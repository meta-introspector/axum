(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module boxed.
  Module  BoxedIntoRoute.
  Section BoxedIntoRoute.
    Context {S E : Set}.
    
    Record t : Set := {
      x0 :
        ltac:(axum.util.mutex.AxumMutex
          (alloc.boxed.Box.t
            (dyn [axum.boxed.ErasedIntoRoute.Trait])
            alloc.boxed.Box.Default.A));
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End BoxedIntoRoute.
  End BoxedIntoRoute.
  
  Module  Impl_axum_boxed_BoxedIntoRoute_t_S_core_convert_Infallible_t.
  Section Impl_axum_boxed_BoxedIntoRoute_t_S_core_convert_Infallible_t.
    Context {S : Set}.
    
    Definition Self : Set :=
      axum.boxed.BoxedIntoRoute.t S core.convert.Infallible.t.
    
    (*
        pub(crate) fn from_handler<H, T>(handler: H) -> Self
        where
            H: Handler<T, S>,
            T: 'static,
        {
            Self(AxumMutex::new(Box::new(MakeErasedHandler {
                handler,
                into_route: |handler, state| Route::new(Handler::with_state(handler, state)),
            })))
        }
    *)
    Definition from_handler
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        (handler : H)
        : M Self :=
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_from_handler
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
      Notations.DoubleColon Self "from_handler" := {
      Notations.double_colon := from_handler (H := H) (T := T);
    }.
  End Impl_axum_boxed_BoxedIntoRoute_t_S_core_convert_Infallible_t.
  End Impl_axum_boxed_BoxedIntoRoute_t_S_core_convert_Infallible_t.
  
  Module  Impl_axum_boxed_BoxedIntoRoute_t_S_E.
  Section Impl_axum_boxed_BoxedIntoRoute_t_S_E.
    Context {S E : Set}.
    
    Definition Self : Set := axum.boxed.BoxedIntoRoute.t S E.
    
    (*
        pub(crate) fn map<F, E2>(self, f: F) -> BoxedIntoRoute<S, E2>
        where
            S: 'static,
            E: 'static,
            F: FnOnce(Route<E>) -> Route<E2> + Clone + Send + 'static,
            E2: 'static,
        {
            BoxedIntoRoute(AxumMutex::new(Box::new(Map {
                inner: self.0.into_inner().unwrap(),
                layer: Box::new(f),
            })))
        }
    *)
    Definition map
        {F E2 : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        (self : Self)
        (f : F)
        : M (axum.boxed.BoxedIntoRoute.t S E2) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_map
        {F E2 : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F} :
      Notations.DoubleColon Self "map" := {
      Notations.double_colon := map (F := F) (E2 := E2);
    }.
    
    (*
        pub(crate) fn into_route(self, state: S) -> Route<E> {
            self.0.into_inner().unwrap().into_route(state)
        }
    *)
    Definition into_route
        (self : Self)
        (state : S)
        : M (axum.routing.route.Route.t E) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_into_route :
      Notations.DoubleColon Self "into_route" := {
      Notations.double_colon := into_route;
    }.
  End Impl_axum_boxed_BoxedIntoRoute_t_S_E.
  End Impl_axum_boxed_BoxedIntoRoute_t_S_E.
  
  Module  Impl_core_clone_Clone_for_axum_boxed_BoxedIntoRoute_t_S_E.
  Section Impl_core_clone_Clone_for_axum_boxed_BoxedIntoRoute_t_S_E.
    Context {S E : Set}.
    
    Definition Self : Set := axum.boxed.BoxedIntoRoute.t S E.
    
    (*
        fn clone(&self) -> Self {
            Self(AxumMutex::new(self.0.lock().unwrap().clone_box()))
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_boxed_BoxedIntoRoute_t_S_E.
  End Impl_core_clone_Clone_for_axum_boxed_BoxedIntoRoute_t_S_E.
  
  Module  Impl_core_fmt_Debug_for_axum_boxed_BoxedIntoRoute_t_S_E.
  Section Impl_core_fmt_Debug_for_axum_boxed_BoxedIntoRoute_t_S_E.
    Context {S E : Set}.
    
    Definition Self : Set := axum.boxed.BoxedIntoRoute.t S E.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_tuple("BoxedIntoRoute").finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_boxed_BoxedIntoRoute_t_S_E.
  End Impl_core_fmt_Debug_for_axum_boxed_BoxedIntoRoute_t_S_E.
  
  Module  ErasedIntoRoute.
  Section ErasedIntoRoute.
    Class Trait (Self : Set) {S E : Set} : Type := {
      ℒ_0 :: core.marker.Send.Trait Self;
      clone_box :
        (ref Self) ->
          M
            (alloc.boxed.Box.t
              (dyn [axum.boxed.ErasedIntoRoute.Trait])
              alloc.boxed.Box.Default.A);
      into_route :
        (alloc.boxed.Box.t Self alloc.boxed.Box.Default.A) ->
          S ->
          M (axum.routing.route.Route.t E);
      call_with_state :
        (alloc.boxed.Box.t Self alloc.boxed.Box.Default.A) ->
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T)
          ->
          S ->
          M (axum.routing.route.RouteFuture.t E);
    }.
    
  End ErasedIntoRoute.
  End ErasedIntoRoute.
  
  Module  MakeErasedHandler.
  Section MakeErasedHandler.
    Context (H S : Set).
    
    Record t : Set := {
      handler : H;
      into_route :
        H -> S -> axum.routing.route.Route.t axum.routing.route.Route.Default.E;
    }.
    
    Definition Get_handler :=
      Ref.map
        (fun α => Some α.(handler))
        (fun β α => Some (α <| handler := β |>)).
    Definition Get_into_route :=
      Ref.map
        (fun α => Some α.(into_route))
        (fun β α => Some (α <| into_route := β |>)).
  End MakeErasedHandler.
  End MakeErasedHandler.
  
  Module  Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedHandler_t_H_S.
  Section Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedHandler_t_H_S.
    Context {H S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait H} {ℋ_1 : core.marker.Send.Trait H}.
    
    Definition Self : Set := axum.boxed.MakeErasedHandler.t H S.
    
    (*
        fn clone_box(&self) -> Box<dyn ErasedIntoRoute<S, Infallible>> {
            Box::new(self.clone())
        }
    *)
    Definition clone_box
        (self : ref Self)
        :
          M
            (alloc.boxed.Box.t
              (dyn [axum.boxed.ErasedIntoRoute.Trait])
              alloc.boxed.Box.Default.A) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone_box :
      Notations.DoubleColon Self "clone_box" := {
      Notations.double_colon := clone_box;
    }.
    
    (*
        fn into_route(self: Box<Self>, state: S) -> Route {
            (self.into_route)(self.handler, state)
        }
    *)
    Definition into_route
        (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
        (state : S)
        : M (axum.routing.route.Route.t axum.routing.route.Route.Default.E) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_into_route :
      Notations.DoubleColon Self "into_route" := {
      Notations.double_colon := into_route;
    }.
    
    (*
        fn call_with_state(self: Box<Self>, request: Request, state: S) -> RouteFuture<Infallible> {
            self.into_route(state).call(request)
        }
    *)
    Definition call_with_state
        (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
        (request
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M (axum.routing.route.RouteFuture.t core.convert.Infallible.t) :=
      let* self := M.alloc self in
      let* request := M.alloc request in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call_with_state :
      Notations.DoubleColon Self "call_with_state" := {
      Notations.double_colon := call_with_state;
    }.
    
    Global Instance ℐ :
      axum.boxed.ErasedIntoRoute.Trait Self
        (S := S)
        (E := core.convert.Infallible.t) := {
      axum.boxed.ErasedIntoRoute.clone_box := clone_box;
      axum.boxed.ErasedIntoRoute.into_route := into_route;
      axum.boxed.ErasedIntoRoute.call_with_state := call_with_state;
    }.
  End Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedHandler_t_H_S.
  End Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedHandler_t_H_S.
  
  Module  Impl_core_clone_Clone_for_axum_boxed_MakeErasedHandler_t_H_S.
  Section Impl_core_clone_Clone_for_axum_boxed_MakeErasedHandler_t_H_S.
    Context {H S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait H}.
    
    Definition Self : Set := axum.boxed.MakeErasedHandler.t H S.
    
    (*
        fn clone(&self) -> Self {
            Self {
                handler: self.handler.clone(),
                into_route: self.into_route,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_boxed_MakeErasedHandler_t_H_S.
  End Impl_core_clone_Clone_for_axum_boxed_MakeErasedHandler_t_H_S.
  
  Module  MakeErasedRouter.
  Section MakeErasedRouter.
    Context (S : Set).
    
    Record t : Set := {
      router : axum.routing.Router.t S;
      into_route :
        (axum.routing.Router.t S) ->
          S ->
          axum.routing.route.Route.t axum.routing.route.Route.Default.E;
    }.
    
    Definition Get_router :=
      Ref.map
        (fun α => Some α.(router))
        (fun β α => Some (α <| router := β |>)).
    Definition Get_into_route :=
      Ref.map
        (fun α => Some α.(into_route))
        (fun β α => Some (α <| into_route := β |>)).
  End MakeErasedRouter.
  End MakeErasedRouter.
  
  Module  Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedRouter_t_S.
  Section Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedRouter_t_S.
    Context {S : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait S}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.boxed.MakeErasedRouter.t S.
    
    (*
        fn clone_box(&self) -> Box<dyn ErasedIntoRoute<S, Infallible>> {
            Box::new(self.clone())
        }
    *)
    Definition clone_box
        (self : ref Self)
        :
          M
            (alloc.boxed.Box.t
              (dyn [axum.boxed.ErasedIntoRoute.Trait])
              alloc.boxed.Box.Default.A) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone_box :
      Notations.DoubleColon Self "clone_box" := {
      Notations.double_colon := clone_box;
    }.
    
    (*
        fn into_route(self: Box<Self>, state: S) -> Route {
            (self.into_route)(self.router, state)
        }
    *)
    Definition into_route
        (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
        (state : S)
        : M (axum.routing.route.Route.t axum.routing.route.Route.Default.E) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_into_route :
      Notations.DoubleColon Self "into_route" := {
      Notations.double_colon := into_route;
    }.
    
    (*
        fn call_with_state(self: Box<Self>, request: Request, state: S) -> RouteFuture<Infallible> {
            self.router.call_with_state(request, state)
        }
    *)
    Definition call_with_state
        (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
        (request
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M (axum.routing.route.RouteFuture.t core.convert.Infallible.t) :=
      let* self := M.alloc self in
      let* request := M.alloc request in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call_with_state :
      Notations.DoubleColon Self "call_with_state" := {
      Notations.double_colon := call_with_state;
    }.
    
    Global Instance ℐ :
      axum.boxed.ErasedIntoRoute.Trait Self
        (S := S)
        (E := core.convert.Infallible.t) := {
      axum.boxed.ErasedIntoRoute.clone_box := clone_box;
      axum.boxed.ErasedIntoRoute.into_route := into_route;
      axum.boxed.ErasedIntoRoute.call_with_state := call_with_state;
    }.
  End Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedRouter_t_S.
  End Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedRouter_t_S.
  
  Module  Impl_core_clone_Clone_for_axum_boxed_MakeErasedRouter_t_S.
  Section Impl_core_clone_Clone_for_axum_boxed_MakeErasedRouter_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.boxed.MakeErasedRouter.t S.
    
    (*
        fn clone(&self) -> Self {
            Self {
                router: self.router.clone(),
                into_route: self.into_route,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_boxed_MakeErasedRouter_t_S.
  End Impl_core_clone_Clone_for_axum_boxed_MakeErasedRouter_t_S.
  
  Module  Map.
  Section Map.
    Context (S E E2 : Set).
    
    Record t : Set := {
      inner :
        alloc.boxed.Box.t
          (dyn [axum.boxed.ErasedIntoRoute.Trait])
          alloc.boxed.Box.Default.A;
      layer :
        alloc.boxed.Box.t
          (dyn [axum.boxed.LayerFn.Trait])
          alloc.boxed.Box.Default.A;
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Definition Get_layer :=
      Ref.map (fun α => Some α.(layer)) (fun β α => Some (α <| layer := β |>)).
  End Map.
  End Map.
  
  Module  Impl_axum_boxed_ErasedIntoRoute_S_E2_for_axum_boxed_Map_t_S_E_E2.
  Section Impl_axum_boxed_ErasedIntoRoute_S_E2_for_axum_boxed_Map_t_S_E_E2.
    Context {S E E2 : Set}.
    
    Definition Self : Set := axum.boxed.Map.t S E E2.
    
    (*
        fn clone_box(&self) -> Box<dyn ErasedIntoRoute<S, E2>> {
            Box::new(Self {
                inner: self.inner.clone_box(),
                layer: self.layer.clone_box(),
            })
        }
    *)
    Definition clone_box
        (self : ref Self)
        :
          M
            (alloc.boxed.Box.t
              (dyn [axum.boxed.ErasedIntoRoute.Trait])
              alloc.boxed.Box.Default.A) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone_box :
      Notations.DoubleColon Self "clone_box" := {
      Notations.double_colon := clone_box;
    }.
    
    (*
        fn into_route(self: Box<Self>, state: S) -> Route<E2> {
            (self.layer)(self.inner.into_route(state))
        }
    *)
    Definition into_route
        (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
        (state : S)
        : M (axum.routing.route.Route.t E2) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_into_route :
      Notations.DoubleColon Self "into_route" := {
      Notations.double_colon := into_route;
    }.
    
    (*
        fn call_with_state(self: Box<Self>, request: Request, state: S) -> RouteFuture<E2> {
            (self.layer)(self.inner.into_route(state)).call(request)
        }
    *)
    Definition call_with_state
        (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
        (request
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M (axum.routing.route.RouteFuture.t E2) :=
      let* self := M.alloc self in
      let* request := M.alloc request in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call_with_state :
      Notations.DoubleColon Self "call_with_state" := {
      Notations.double_colon := call_with_state;
    }.
    
    Global Instance ℐ :
      axum.boxed.ErasedIntoRoute.Trait Self (S := S) (E := E2) := {
      axum.boxed.ErasedIntoRoute.clone_box := clone_box;
      axum.boxed.ErasedIntoRoute.into_route := into_route;
      axum.boxed.ErasedIntoRoute.call_with_state := call_with_state;
    }.
  End Impl_axum_boxed_ErasedIntoRoute_S_E2_for_axum_boxed_Map_t_S_E_E2.
  End Impl_axum_boxed_ErasedIntoRoute_S_E2_for_axum_boxed_Map_t_S_E_E2.
  
  Module  LayerFn.
  Section LayerFn.
    Class Trait (Self : Set) {E E2 : Set} : Type := {
      ℒ_0 ::
        core.ops.function.FnOnce.Trait Self
          (Args := axum.routing.route.Route.t E);
      ℒ_1 :: core.marker.Send.Trait Self;
      clone_box :
        (ref Self) ->
          M
            (alloc.boxed.Box.t
              (dyn [axum.boxed.LayerFn.Trait])
              alloc.boxed.Box.Default.A);
    }.
    
  End LayerFn.
  End LayerFn.
  
  Module  Impl_axum_boxed_LayerFn_E_E2_for_F.
  Section Impl_axum_boxed_LayerFn_E_E2_for_F.
    Context {F E E2 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F (Args := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}.
    
    Definition Self : Set := F.
    
    (*
        fn clone_box(&self) -> Box<dyn LayerFn<E, E2>> {
            Box::new(self.clone())
        }
    *)
    Definition clone_box
        (self : ref Self)
        :
          M
            (alloc.boxed.Box.t
              (dyn [axum.boxed.LayerFn.Trait])
              alloc.boxed.Box.Default.A) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone_box :
      Notations.DoubleColon Self "clone_box" := {
      Notations.double_colon := clone_box;
    }.
    
    Global Instance ℐ : axum.boxed.LayerFn.Trait Self (E := E) (E2 := E2) := {
      axum.boxed.LayerFn.clone_box := clone_box;
    }.
  End Impl_axum_boxed_LayerFn_E_E2_for_F.
  End Impl_axum_boxed_LayerFn_E_E2_for_F.
End boxed.

Module  BoxedIntoRoute.
Section BoxedIntoRoute.
  Context {S E : Set}.
  
  Record t : Set := {
    x0 :
      ltac:(axum.util.mutex.AxumMutex
        (alloc.boxed.Box.t
          (dyn [axum.boxed.ErasedIntoRoute.Trait])
          alloc.boxed.Box.Default.A));
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End BoxedIntoRoute.
End BoxedIntoRoute.

Module  Impl_axum_boxed_BoxedIntoRoute_t_S_core_convert_Infallible_t_2.
Section Impl_axum_boxed_BoxedIntoRoute_t_S_core_convert_Infallible_t_2.
  Context {S : Set}.
  
  Definition Self : Set :=
    axum.boxed.BoxedIntoRoute.t S core.convert.Infallible.t.
  
  (*
      pub(crate) fn from_handler<H, T>(handler: H) -> Self
      where
          H: Handler<T, S>,
          T: 'static,
      {
          Self(AxumMutex::new(Box::new(MakeErasedHandler {
              handler,
              into_route: |handler, state| Route::new(Handler::with_state(handler, state)),
          })))
      }
  *)
  Definition from_handler
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      (handler : H)
      : M Self :=
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_from_handler
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
    Notations.DoubleColon Self "from_handler" := {
    Notations.double_colon := from_handler (H := H) (T := T);
  }.
End Impl_axum_boxed_BoxedIntoRoute_t_S_core_convert_Infallible_t_2.
End Impl_axum_boxed_BoxedIntoRoute_t_S_core_convert_Infallible_t_2.

Module  Impl_axum_boxed_BoxedIntoRoute_t_S_E_2.
Section Impl_axum_boxed_BoxedIntoRoute_t_S_E_2.
  Context {S E : Set}.
  
  Definition Self : Set := axum.boxed.BoxedIntoRoute.t S E.
  
  (*
      pub(crate) fn map<F, E2>(self, f: F) -> BoxedIntoRoute<S, E2>
      where
          S: 'static,
          E: 'static,
          F: FnOnce(Route<E>) -> Route<E2> + Clone + Send + 'static,
          E2: 'static,
      {
          BoxedIntoRoute(AxumMutex::new(Box::new(Map {
              inner: self.0.into_inner().unwrap(),
              layer: Box::new(f),
          })))
      }
  *)
  Definition map
      {F E2 : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F (Args := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      (self : Self)
      (f : F)
      : M (axum.boxed.BoxedIntoRoute.t S E2) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_map
      {F E2 : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F (Args := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F} :
    Notations.DoubleColon Self "map" := {
    Notations.double_colon := map (F := F) (E2 := E2);
  }.
  
  (*
      pub(crate) fn into_route(self, state: S) -> Route<E> {
          self.0.into_inner().unwrap().into_route(state)
      }
  *)
  Definition into_route
      (self : Self)
      (state : S)
      : M (axum.routing.route.Route.t E) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_into_route :
    Notations.DoubleColon Self "into_route" := {
    Notations.double_colon := into_route;
  }.
End Impl_axum_boxed_BoxedIntoRoute_t_S_E_2.
End Impl_axum_boxed_BoxedIntoRoute_t_S_E_2.

Module  Impl_core_clone_Clone_for_axum_boxed_BoxedIntoRoute_t_S_E.
Section Impl_core_clone_Clone_for_axum_boxed_BoxedIntoRoute_t_S_E.
  Context {S E : Set}.
  
  Definition Self : Set := axum.boxed.BoxedIntoRoute.t S E.
  
  (*
      fn clone(&self) -> Self {
          Self(AxumMutex::new(self.0.lock().unwrap().clone_box()))
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_boxed_BoxedIntoRoute_t_S_E.
End Impl_core_clone_Clone_for_axum_boxed_BoxedIntoRoute_t_S_E.

Module  Impl_core_fmt_Debug_for_axum_boxed_BoxedIntoRoute_t_S_E.
Section Impl_core_fmt_Debug_for_axum_boxed_BoxedIntoRoute_t_S_E.
  Context {S E : Set}.
  
  Definition Self : Set := axum.boxed.BoxedIntoRoute.t S E.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_tuple("BoxedIntoRoute").finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_boxed_BoxedIntoRoute_t_S_E.
End Impl_core_fmt_Debug_for_axum_boxed_BoxedIntoRoute_t_S_E.

Module  ErasedIntoRoute.
Section ErasedIntoRoute.
  Class Trait (Self : Set) {S E : Set} : Type := {
    ℒ_0 :: core.marker.Send.Trait Self;
    clone_box :
      (ref Self) ->
        M
          (alloc.boxed.Box.t
            (dyn [axum.boxed.ErasedIntoRoute.Trait])
            alloc.boxed.Box.Default.A);
    into_route :
      (alloc.boxed.Box.t Self alloc.boxed.Box.Default.A) ->
        S ->
        M (axum.routing.route.Route.t E);
    call_with_state :
      (alloc.boxed.Box.t Self alloc.boxed.Box.Default.A) ->
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T) ->
        S ->
        M (axum.routing.route.RouteFuture.t E);
  }.
  
End ErasedIntoRoute.
End ErasedIntoRoute.

Module  MakeErasedHandler.
Section MakeErasedHandler.
  Context (H S : Set).
  
  Record t : Set := {
    handler : H;
    into_route :
      H -> S -> axum.routing.route.Route.t axum.routing.route.Route.Default.E;
  }.
  
  Definition Get_handler :=
    Ref.map
      (fun α => Some α.(handler))
      (fun β α => Some (α <| handler := β |>)).
  Definition Get_into_route :=
    Ref.map
      (fun α => Some α.(into_route))
      (fun β α => Some (α <| into_route := β |>)).
End MakeErasedHandler.
End MakeErasedHandler.

Module  Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedHandler_t_H_S.
Section Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedHandler_t_H_S.
  Context {H S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait H} {ℋ_1 : core.marker.Send.Trait H}.
  
  Definition Self : Set := axum.boxed.MakeErasedHandler.t H S.
  
  (*
      fn clone_box(&self) -> Box<dyn ErasedIntoRoute<S, Infallible>> {
          Box::new(self.clone())
      }
  *)
  Definition clone_box
      (self : ref Self)
      :
        M
          (alloc.boxed.Box.t
            (dyn [axum.boxed.ErasedIntoRoute.Trait])
            alloc.boxed.Box.Default.A) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone_box :
    Notations.DoubleColon Self "clone_box" := {
    Notations.double_colon := clone_box;
  }.
  
  (*
      fn into_route(self: Box<Self>, state: S) -> Route {
          (self.into_route)(self.handler, state)
      }
  *)
  Definition into_route
      (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
      (state : S)
      : M (axum.routing.route.Route.t axum.routing.route.Route.Default.E) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_into_route :
    Notations.DoubleColon Self "into_route" := {
    Notations.double_colon := into_route;
  }.
  
  (*
      fn call_with_state(self: Box<Self>, request: Request, state: S) -> RouteFuture<Infallible> {
          self.into_route(state).call(request)
      }
  *)
  Definition call_with_state
      (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
      (request
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M (axum.routing.route.RouteFuture.t core.convert.Infallible.t) :=
    let* self := M.alloc self in
    let* request := M.alloc request in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call_with_state :
    Notations.DoubleColon Self "call_with_state" := {
    Notations.double_colon := call_with_state;
  }.
  
  Global Instance ℐ :
    axum.boxed.ErasedIntoRoute.Trait Self
      (S := S)
      (E := core.convert.Infallible.t) := {
    axum.boxed.ErasedIntoRoute.clone_box := clone_box;
    axum.boxed.ErasedIntoRoute.into_route := into_route;
    axum.boxed.ErasedIntoRoute.call_with_state := call_with_state;
  }.
End Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedHandler_t_H_S.
End Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedHandler_t_H_S.

Module  Impl_core_clone_Clone_for_axum_boxed_MakeErasedHandler_t_H_S.
Section Impl_core_clone_Clone_for_axum_boxed_MakeErasedHandler_t_H_S.
  Context {H S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait H}.
  
  Definition Self : Set := axum.boxed.MakeErasedHandler.t H S.
  
  (*
      fn clone(&self) -> Self {
          Self {
              handler: self.handler.clone(),
              into_route: self.into_route,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_boxed_MakeErasedHandler_t_H_S.
End Impl_core_clone_Clone_for_axum_boxed_MakeErasedHandler_t_H_S.

Module  MakeErasedRouter.
Section MakeErasedRouter.
  Context (S : Set).
  
  Record t : Set := {
    router : axum.routing.Router.t S;
    into_route :
      (axum.routing.Router.t S) ->
        S ->
        axum.routing.route.Route.t axum.routing.route.Route.Default.E;
  }.
  
  Definition Get_router :=
    Ref.map (fun α => Some α.(router)) (fun β α => Some (α <| router := β |>)).
  Definition Get_into_route :=
    Ref.map
      (fun α => Some α.(into_route))
      (fun β α => Some (α <| into_route := β |>)).
End MakeErasedRouter.
End MakeErasedRouter.

Module  Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedRouter_t_S.
Section Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedRouter_t_S.
  Context {S : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait S}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.boxed.MakeErasedRouter.t S.
  
  (*
      fn clone_box(&self) -> Box<dyn ErasedIntoRoute<S, Infallible>> {
          Box::new(self.clone())
      }
  *)
  Definition clone_box
      (self : ref Self)
      :
        M
          (alloc.boxed.Box.t
            (dyn [axum.boxed.ErasedIntoRoute.Trait])
            alloc.boxed.Box.Default.A) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone_box :
    Notations.DoubleColon Self "clone_box" := {
    Notations.double_colon := clone_box;
  }.
  
  (*
      fn into_route(self: Box<Self>, state: S) -> Route {
          (self.into_route)(self.router, state)
      }
  *)
  Definition into_route
      (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
      (state : S)
      : M (axum.routing.route.Route.t axum.routing.route.Route.Default.E) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_into_route :
    Notations.DoubleColon Self "into_route" := {
    Notations.double_colon := into_route;
  }.
  
  (*
      fn call_with_state(self: Box<Self>, request: Request, state: S) -> RouteFuture<Infallible> {
          self.router.call_with_state(request, state)
      }
  *)
  Definition call_with_state
      (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
      (request
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M (axum.routing.route.RouteFuture.t core.convert.Infallible.t) :=
    let* self := M.alloc self in
    let* request := M.alloc request in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call_with_state :
    Notations.DoubleColon Self "call_with_state" := {
    Notations.double_colon := call_with_state;
  }.
  
  Global Instance ℐ :
    axum.boxed.ErasedIntoRoute.Trait Self
      (S := S)
      (E := core.convert.Infallible.t) := {
    axum.boxed.ErasedIntoRoute.clone_box := clone_box;
    axum.boxed.ErasedIntoRoute.into_route := into_route;
    axum.boxed.ErasedIntoRoute.call_with_state := call_with_state;
  }.
End Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedRouter_t_S.
End Impl_axum_boxed_ErasedIntoRoute_S_core_convert_Infallible_t_for_axum_boxed_MakeErasedRouter_t_S.

Module  Impl_core_clone_Clone_for_axum_boxed_MakeErasedRouter_t_S.
Section Impl_core_clone_Clone_for_axum_boxed_MakeErasedRouter_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.boxed.MakeErasedRouter.t S.
  
  (*
      fn clone(&self) -> Self {
          Self {
              router: self.router.clone(),
              into_route: self.into_route,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_boxed_MakeErasedRouter_t_S.
End Impl_core_clone_Clone_for_axum_boxed_MakeErasedRouter_t_S.

Module  Map.
Section Map.
  Context (S E E2 : Set).
  
  Record t : Set := {
    inner :
      alloc.boxed.Box.t
        (dyn [axum.boxed.ErasedIntoRoute.Trait])
        alloc.boxed.Box.Default.A;
    layer :
      alloc.boxed.Box.t
        (dyn [axum.boxed.LayerFn.Trait])
        alloc.boxed.Box.Default.A;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Definition Get_layer :=
    Ref.map (fun α => Some α.(layer)) (fun β α => Some (α <| layer := β |>)).
End Map.
End Map.

Module  Impl_axum_boxed_ErasedIntoRoute_S_E2_for_axum_boxed_Map_t_S_E_E2.
Section Impl_axum_boxed_ErasedIntoRoute_S_E2_for_axum_boxed_Map_t_S_E_E2.
  Context {S E E2 : Set}.
  
  Definition Self : Set := axum.boxed.Map.t S E E2.
  
  (*
      fn clone_box(&self) -> Box<dyn ErasedIntoRoute<S, E2>> {
          Box::new(Self {
              inner: self.inner.clone_box(),
              layer: self.layer.clone_box(),
          })
      }
  *)
  Definition clone_box
      (self : ref Self)
      :
        M
          (alloc.boxed.Box.t
            (dyn [axum.boxed.ErasedIntoRoute.Trait])
            alloc.boxed.Box.Default.A) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone_box :
    Notations.DoubleColon Self "clone_box" := {
    Notations.double_colon := clone_box;
  }.
  
  (*
      fn into_route(self: Box<Self>, state: S) -> Route<E2> {
          (self.layer)(self.inner.into_route(state))
      }
  *)
  Definition into_route
      (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
      (state : S)
      : M (axum.routing.route.Route.t E2) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_into_route :
    Notations.DoubleColon Self "into_route" := {
    Notations.double_colon := into_route;
  }.
  
  (*
      fn call_with_state(self: Box<Self>, request: Request, state: S) -> RouteFuture<E2> {
          (self.layer)(self.inner.into_route(state)).call(request)
      }
  *)
  Definition call_with_state
      (self : alloc.boxed.Box.t Self alloc.boxed.Box.Default.A)
      (request
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M (axum.routing.route.RouteFuture.t E2) :=
    let* self := M.alloc self in
    let* request := M.alloc request in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call_with_state :
    Notations.DoubleColon Self "call_with_state" := {
    Notations.double_colon := call_with_state;
  }.
  
  Global Instance ℐ :
    axum.boxed.ErasedIntoRoute.Trait Self (S := S) (E := E2) := {
    axum.boxed.ErasedIntoRoute.clone_box := clone_box;
    axum.boxed.ErasedIntoRoute.into_route := into_route;
    axum.boxed.ErasedIntoRoute.call_with_state := call_with_state;
  }.
End Impl_axum_boxed_ErasedIntoRoute_S_E2_for_axum_boxed_Map_t_S_E_E2.
End Impl_axum_boxed_ErasedIntoRoute_S_E2_for_axum_boxed_Map_t_S_E_E2.

Module  LayerFn.
Section LayerFn.
  Class Trait (Self : Set) {E E2 : Set} : Type := {
    ℒ_0 ::
      core.ops.function.FnOnce.Trait Self
        (Args := axum.routing.route.Route.t E);
    ℒ_1 :: core.marker.Send.Trait Self;
    clone_box :
      (ref Self) ->
        M
          (alloc.boxed.Box.t
            (dyn [axum.boxed.LayerFn.Trait])
            alloc.boxed.Box.Default.A);
  }.
  
End LayerFn.
End LayerFn.

Module  Impl_axum_boxed_LayerFn_E_E2_for_F.
Section Impl_axum_boxed_LayerFn_E_E2_for_F.
  Context {F E E2 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F (Args := axum.routing.route.Route.t E)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}.
  
  Definition Self : Set := F.
  
  (*
      fn clone_box(&self) -> Box<dyn LayerFn<E, E2>> {
          Box::new(self.clone())
      }
  *)
  Definition clone_box
      (self : ref Self)
      :
        M
          (alloc.boxed.Box.t
            (dyn [axum.boxed.LayerFn.Trait])
            alloc.boxed.Box.Default.A) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone_box :
    Notations.DoubleColon Self "clone_box" := {
    Notations.double_colon := clone_box;
  }.
  
  Global Instance ℐ : axum.boxed.LayerFn.Trait Self (E := E) (E2 := E2) := {
    axum.boxed.LayerFn.clone_box := clone_box;
  }.
End Impl_axum_boxed_LayerFn_E_E2_for_F.
End Impl_axum_boxed_LayerFn_E_E2_for_F.

Module extension.
  Module  Extension.
  Section Extension.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Extension.
  End Extension.
  
  Module  Impl_core_fmt_Debug_for_axum_extension_Extension_t_T.
  Section Impl_core_fmt_Debug_for_axum_extension_Extension_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum.extension.Extension.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extension_Extension_t_T.
  End Impl_core_fmt_Debug_for_axum_extension_Extension_t_T.
  
  Module  Impl_core_clone_Clone_for_axum_extension_Extension_t_T.
  Section Impl_core_clone_Clone_for_axum_extension_Extension_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum.extension.Extension.t T.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M (axum.extension.Extension.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extension_Extension_t_T.
  End Impl_core_clone_Clone_for_axum_extension_Extension_t_T.
  
  Module  Impl_core_marker_Copy_for_axum_extension_Extension_t_T.
  Section Impl_core_marker_Copy_for_axum_extension_Extension_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum.extension.Extension.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extension_Extension_t_T.
  End Impl_core_marker_Copy_for_axum_extension_Extension_t_T.
  
  Module  Impl_core_default_Default_for_axum_extension_Extension_t_T.
  Section Impl_core_default_Default_for_axum_extension_Extension_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.default.Default.Trait T}.
    
    Definition Self : Set := axum.extension.Extension.t T.
    
    (*
    Default
    *)
    Definition default : M (axum.extension.Extension.t T) := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_extension_Extension_t_T.
  End Impl_core_default_Default_for_axum_extension_Extension_t_T.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extension_Extension_t_T.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extension_Extension_t_T.
    Context {T S : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait T}
      {ℋ_1 : core.marker.Send.Trait T}
      {ℋ_2 : core.marker.Sync.Trait T}
      {ℋ_3 : core.marker.Send.Trait S}
      {ℋ_4 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.extension.Extension.t T.
    
    (*
        type Rejection = ExtensionRejection;
    *)
    Definition Rejection : Set := axum.extract.rejection.ExtensionRejection.t.
    
    (*
        async fn from_request_parts(req: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
            let value = req
                .extensions
                .get::<T>()
                .ok_or_else(|| {
                    MissingExtension::from_err(format!(
                        "Extension of type `{}` was not found. Perhaps you forgot to add it? See `axum::Extension`.",
                        std::any::type_name::<T>()
                    ))
                })
                .map(|x| x.clone())?;
    
            Ok(Extension(value))
        }
    *)
    Definition from_request_parts
        (req : mut_ref http.request.Parts.t)
        (_state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extension_Extension_t_T.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extension_Extension_t_T.
  
  Module  Impl_core_ops_deref_Deref_for_axum_extension_Extension_t_T.
  Section Impl_core_ops_deref_Deref_for_axum_extension_Extension_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.extension.Extension.t T.
    
    (*
                type Target = T;
    *)
    Definition Target : Set := T.
    
    (*
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_axum_extension_Extension_t_T.
  End Impl_core_ops_deref_Deref_for_axum_extension_Extension_t_T.
  
  Module  Impl_core_ops_deref_DerefMut_for_axum_extension_Extension_t_T.
  Section Impl_core_ops_deref_DerefMut_for_axum_extension_Extension_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.extension.Extension.t T.
    
    (*
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
    *)
    Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref_mut :
      Notations.DoubleColon Self "deref_mut" := {
      Notations.double_colon := deref_mut;
    }.
    
    Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
      core.ops.deref.DerefMut.deref_mut := deref_mut;
    }.
  End Impl_core_ops_deref_DerefMut_for_axum_extension_Extension_t_T.
  End Impl_core_ops_deref_DerefMut_for_axum_extension_Extension_t_T.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_extension_Extension_t_T.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_extension_Extension_t_T.
    Context {T : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait T}
      {ℋ_1 : core.marker.Send.Trait T}
      {ℋ_2 : core.marker.Sync.Trait T}.
    
    Definition Self : Set := axum.extension.Extension.t T.
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
            res.extensions_mut().insert(self.0);
            Ok(res)
        }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_extension_Extension_t_T.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_extension_Extension_t_T.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extension_Extension_t_T.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extension_Extension_t_T.
    Context {T : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait T}
      {ℋ_1 : core.marker.Send.Trait T}
      {ℋ_2 : core.marker.Sync.Trait T}.
    
    Definition Self : Set := axum.extension.Extension.t T.
    
    (*
        fn into_response(self) -> Response {
            let mut res = ().into_response();
            res.extensions_mut().insert(self.0);
            res
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extension_Extension_t_T.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extension_Extension_t_T.
  
  Module  Impl_tower_layer_Layer_S_for_axum_extension_Extension_t_T.
  Section Impl_tower_layer_Layer_S_for_axum_extension_Extension_t_T.
    Context {S T : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait T}
      {ℋ_1 : core.marker.Send.Trait T}
      {ℋ_2 : core.marker.Sync.Trait T}.
    
    Definition Self : Set := axum.extension.Extension.t T.
    
    (*
        type Service = AddExtension<S, T>;
    *)
    Definition Service : Set := axum.extension.AddExtension.t S T.
    
    (*
        fn layer(&self, inner: S) -> Self::Service {
            AddExtension {
                inner,
                value: self.0.clone(),
            }
        }
    *)
    Definition layer (self : ref Self) (inner : S) : M Service :=
      let* self := M.alloc self in
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_layer :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer;
    }.
    
    Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
      tower_layer.Layer.Service := Service;
      tower_layer.Layer.layer := layer;
    }.
  End Impl_tower_layer_Layer_S_for_axum_extension_Extension_t_T.
  End Impl_tower_layer_Layer_S_for_axum_extension_Extension_t_T.
  
  Module  AddExtension.
  Section AddExtension.
    Context (S T : Set).
    
    Record t : Set := {
      inner : S;
      value : T;
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Definition Get_value :=
      Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  End AddExtension.
  End AddExtension.
  
  Module  Impl_core_clone_Clone_for_axum_extension_AddExtension_t_S_T.
  Section Impl_core_clone_Clone_for_axum_extension_AddExtension_t_S_T.
    Context {S T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S} {ℋ_1 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum.extension.AddExtension.t S T.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum.extension.AddExtension.t S T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extension_AddExtension_t_S_T.
  End Impl_core_clone_Clone_for_axum_extension_AddExtension_t_S_T.
  
  Module  Impl_core_marker_Copy_for_axum_extension_AddExtension_t_S_T.
  Section Impl_core_marker_Copy_for_axum_extension_AddExtension_t_S_T.
    Context {S T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait S} {ℋ_1 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum.extension.AddExtension.t S T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extension_AddExtension_t_S_T.
  End Impl_core_marker_Copy_for_axum_extension_AddExtension_t_S_T.
  
  Module  Impl_core_fmt_Debug_for_axum_extension_AddExtension_t_S_T.
  Section Impl_core_fmt_Debug_for_axum_extension_AddExtension_t_S_T.
    Context {S T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S} {ℋ_1 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum.extension.AddExtension.t S T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extension_AddExtension_t_S_T.
  End Impl_core_fmt_Debug_for_axum_extension_AddExtension_t_S_T.
  
  Module  Impl_tower_service_Service_http_request_Request_t_ResBody_for_axum_extension_AddExtension_t_S_T.
  Section Impl_tower_service_Service_http_request_Request_t_ResBody_for_axum_extension_AddExtension_t_S_T.
    Context {ResBody S T : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S
          (Request := http.request.Request.t ResBody)}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 : core.marker.Sync.Trait T}.
    
    Definition Self : Set := axum.extension.AddExtension.t S T.
    
    (*
        type Response = S::Response;
    *)
    Definition Response : Set := S::type["Response"].t.
    
    (*
        type Error = S::Error;
    *)
    Definition Error : Set := S::type["Error"].t.
    
    (*
        type Future = S::Future;
    *)
    Definition Future : Set := S::type["Future"].t.
    
    (*
        fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            self.inner.poll_ready(cx)
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, mut req: Request<ResBody>) -> Self::Future {
            req.extensions_mut().insert(self.value.clone());
            self.inner.call(req)
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t ResBody)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t ResBody) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_ResBody_for_axum_extension_AddExtension_t_S_T.
  End Impl_tower_service_Service_http_request_Request_t_ResBody_for_axum_extension_AddExtension_t_S_T.
End extension.

Module  Extension.
Section Extension.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Extension.
End Extension.

Module  Impl_core_fmt_Debug_for_axum_extension_Extension_t_T.
Section Impl_core_fmt_Debug_for_axum_extension_Extension_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum.extension.Extension.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extension_Extension_t_T.
End Impl_core_fmt_Debug_for_axum_extension_Extension_t_T.

Module  Impl_core_clone_Clone_for_axum_extension_Extension_t_T.
Section Impl_core_clone_Clone_for_axum_extension_Extension_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum.extension.Extension.t T.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M (axum.extension.Extension.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extension_Extension_t_T.
End Impl_core_clone_Clone_for_axum_extension_Extension_t_T.

Module  Impl_core_marker_Copy_for_axum_extension_Extension_t_T.
Section Impl_core_marker_Copy_for_axum_extension_Extension_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum.extension.Extension.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extension_Extension_t_T.
End Impl_core_marker_Copy_for_axum_extension_Extension_t_T.

Module  Impl_core_default_Default_for_axum_extension_Extension_t_T.
Section Impl_core_default_Default_for_axum_extension_Extension_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.default.Default.Trait T}.
  
  Definition Self : Set := axum.extension.Extension.t T.
  
  (*
  Default
  *)
  Definition default : M (axum.extension.Extension.t T) := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_extension_Extension_t_T.
End Impl_core_default_Default_for_axum_extension_Extension_t_T.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extension_Extension_t_T.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extension_Extension_t_T.
  Context {T S : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait T}
    {ℋ_1 : core.marker.Send.Trait T}
    {ℋ_2 : core.marker.Sync.Trait T}
    {ℋ_3 : core.marker.Send.Trait S}
    {ℋ_4 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.extension.Extension.t T.
  
  (*
      type Rejection = ExtensionRejection;
  *)
  Definition Rejection : Set := axum.extract.rejection.ExtensionRejection.t.
  
  (*
      async fn from_request_parts(req: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
          let value = req
              .extensions
              .get::<T>()
              .ok_or_else(|| {
                  MissingExtension::from_err(format!(
                      "Extension of type `{}` was not found. Perhaps you forgot to add it? See `axum::Extension`.",
                      std::any::type_name::<T>()
                  ))
              })
              .map(|x| x.clone())?;
  
          Ok(Extension(value))
      }
  *)
  Definition from_request_parts
      (req : mut_ref http.request.Parts.t)
      (_state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extension_Extension_t_T.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extension_Extension_t_T.

Module  Impl_core_ops_deref_Deref_for_axum_extension_Extension_t_T.
Section Impl_core_ops_deref_Deref_for_axum_extension_Extension_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.extension.Extension.t T.
  
  (*
              type Target = T;
  *)
  Definition Target : Set := T.
  
  (*
              fn deref(&self) -> &Self::Target {
                  &self.0
              }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_axum_extension_Extension_t_T.
End Impl_core_ops_deref_Deref_for_axum_extension_Extension_t_T.

Module  Impl_core_ops_deref_DerefMut_for_axum_extension_Extension_t_T.
Section Impl_core_ops_deref_DerefMut_for_axum_extension_Extension_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.extension.Extension.t T.
  
  (*
              fn deref_mut(&mut self) -> &mut Self::Target {
                  &mut self.0
              }
  *)
  Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref_mut :
    Notations.DoubleColon Self "deref_mut" := {
    Notations.double_colon := deref_mut;
  }.
  
  Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
    core.ops.deref.DerefMut.deref_mut := deref_mut;
  }.
End Impl_core_ops_deref_DerefMut_for_axum_extension_Extension_t_T.
End Impl_core_ops_deref_DerefMut_for_axum_extension_Extension_t_T.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_extension_Extension_t_T.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_extension_Extension_t_T.
  Context {T : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait T}
    {ℋ_1 : core.marker.Send.Trait T}
    {ℋ_2 : core.marker.Sync.Trait T}.
  
  Definition Self : Set := axum.extension.Extension.t T.
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
          res.extensions_mut().insert(self.0);
          Ok(res)
      }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_extension_Extension_t_T.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_extension_Extension_t_T.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extension_Extension_t_T.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extension_Extension_t_T.
  Context {T : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait T}
    {ℋ_1 : core.marker.Send.Trait T}
    {ℋ_2 : core.marker.Sync.Trait T}.
  
  Definition Self : Set := axum.extension.Extension.t T.
  
  (*
      fn into_response(self) -> Response {
          let mut res = ().into_response();
          res.extensions_mut().insert(self.0);
          res
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extension_Extension_t_T.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extension_Extension_t_T.

Module  Impl_tower_layer_Layer_S_for_axum_extension_Extension_t_T.
Section Impl_tower_layer_Layer_S_for_axum_extension_Extension_t_T.
  Context {S T : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait T}
    {ℋ_1 : core.marker.Send.Trait T}
    {ℋ_2 : core.marker.Sync.Trait T}.
  
  Definition Self : Set := axum.extension.Extension.t T.
  
  (*
      type Service = AddExtension<S, T>;
  *)
  Definition Service : Set := axum.extension.AddExtension.t S T.
  
  (*
      fn layer(&self, inner: S) -> Self::Service {
          AddExtension {
              inner,
              value: self.0.clone(),
          }
      }
  *)
  Definition layer (self : ref Self) (inner : S) : M Service :=
    let* self := M.alloc self in
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_layer :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer;
  }.
  
  Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
    tower_layer.Layer.Service := Service;
    tower_layer.Layer.layer := layer;
  }.
End Impl_tower_layer_Layer_S_for_axum_extension_Extension_t_T.
End Impl_tower_layer_Layer_S_for_axum_extension_Extension_t_T.

Module  AddExtension.
Section AddExtension.
  Context (S T : Set).
  
  Record t : Set := {
    inner : S;
    value : T;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End AddExtension.
End AddExtension.

Module  Impl_core_clone_Clone_for_axum_extension_AddExtension_t_S_T.
Section Impl_core_clone_Clone_for_axum_extension_AddExtension_t_S_T.
  Context {S T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S} {ℋ_1 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum.extension.AddExtension.t S T.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M (axum.extension.AddExtension.t S T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extension_AddExtension_t_S_T.
End Impl_core_clone_Clone_for_axum_extension_AddExtension_t_S_T.

Module  Impl_core_marker_Copy_for_axum_extension_AddExtension_t_S_T.
Section Impl_core_marker_Copy_for_axum_extension_AddExtension_t_S_T.
  Context {S T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait S} {ℋ_1 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum.extension.AddExtension.t S T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extension_AddExtension_t_S_T.
End Impl_core_marker_Copy_for_axum_extension_AddExtension_t_S_T.

Module  Impl_core_fmt_Debug_for_axum_extension_AddExtension_t_S_T.
Section Impl_core_fmt_Debug_for_axum_extension_AddExtension_t_S_T.
  Context {S T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S} {ℋ_1 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum.extension.AddExtension.t S T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extension_AddExtension_t_S_T.
End Impl_core_fmt_Debug_for_axum_extension_AddExtension_t_S_T.

Module  Impl_tower_service_Service_http_request_Request_t_ResBody_for_axum_extension_AddExtension_t_S_T.
Section Impl_tower_service_Service_http_request_Request_t_ResBody_for_axum_extension_AddExtension_t_S_T.
  Context {ResBody S T : Set}.
  
  Context
    {ℋ_0 :
      tower_service.Service.Trait S (Request := http.request.Request.t ResBody)}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 : core.marker.Sync.Trait T}.
  
  Definition Self : Set := axum.extension.AddExtension.t S T.
  
  (*
      type Response = S::Response;
  *)
  Definition Response : Set := S::type["Response"].t.
  
  (*
      type Error = S::Error;
  *)
  Definition Error : Set := S::type["Error"].t.
  
  (*
      type Future = S::Future;
  *)
  Definition Future : Set := S::type["Future"].t.
  
  (*
      fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          self.inner.poll_ready(cx)
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, mut req: Request<ResBody>) -> Self::Future {
          req.extensions_mut().insert(self.value.clone());
          self.inner.call(req)
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t ResBody)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := http.request.Request.t ResBody) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_ResBody_for_axum_extension_AddExtension_t_S_T.
End Impl_tower_service_Service_http_request_Request_t_ResBody_for_axum_extension_AddExtension_t_S_T.

Module form.
  Module  Form.
  Section Form.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Form.
  End Form.
  
  Module  Impl_core_fmt_Debug_for_axum_form_Form_t_T.
  Section Impl_core_fmt_Debug_for_axum_form_Form_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum.form.Form.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_form_Form_t_T.
  End Impl_core_fmt_Debug_for_axum_form_Form_t_T.
  
  Module  Impl_core_clone_Clone_for_axum_form_Form_t_T.
  Section Impl_core_clone_Clone_for_axum_form_Form_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum.form.Form.t T.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M (axum.form.Form.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_form_Form_t_T.
  End Impl_core_clone_Clone_for_axum_form_Form_t_T.
  
  Module  Impl_core_marker_Copy_for_axum_form_Form_t_T.
  Section Impl_core_marker_Copy_for_axum_form_Form_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum.form.Form.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_form_Form_t_T.
  End Impl_core_marker_Copy_for_axum_form_Form_t_T.
  
  Module  Impl_core_default_Default_for_axum_form_Form_t_T.
  Section Impl_core_default_Default_for_axum_form_Form_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.default.Default.Trait T}.
    
    Definition Self : Set := axum.form.Form.t T.
    
    (*
    Default
    *)
    Definition default : M (axum.form.Form.t T) := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_form_Form_t_T.
  End Impl_core_default_Default_for_axum_form_Form_t_T.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_axum_form_Form_t_T.
  Section Impl_axum_core_extract_FromRequest_S_for_axum_form_Form_t_T.
    Context {T S : Set}.
    
    Context
      {ℋ_0 : serde.de.DeserializeOwned.Trait T}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.form.Form.t T.
    
    (*
        type Rejection = FormRejection;
    *)
    Definition Rejection : Set := axum.extract.rejection.FormRejection.t.
    
    (*
        async fn from_request(req: Request, _state: &S) -> Result<Self, Self::Rejection> {
            let is_get_or_head =
                req.method() == http::Method::GET || req.method() == http::Method::HEAD;
    
            match req.extract().await {
                Ok(RawForm(bytes)) => {
                    let value =
                        serde_urlencoded::from_bytes(&bytes).map_err(|err| -> FormRejection {
                            if is_get_or_head {
                                FailedToDeserializeForm::from_err(err).into()
                            } else {
                                FailedToDeserializeFormBody::from_err(err).into()
                            }
                        })?;
                    Ok(Form(value))
                }
                Err(RawFormRejection::BytesRejection(r)) => Err(FormRejection::BytesRejection(r)),
                Err(RawFormRejection::InvalidFormContentType(r)) => {
                    Err(FormRejection::InvalidFormContentType(r))
                }
            }
        }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (_state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_axum_form_Form_t_T.
  End Impl_axum_core_extract_FromRequest_S_for_axum_form_Form_t_T.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_form_Form_t_T.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_form_Form_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : serde.ser.Serialize.Trait T}.
    
    Definition Self : Set := axum.form.Form.t T.
    
    (*
        fn into_response(self) -> Response {
            match serde_urlencoded::to_string(&self.0) {
                Ok(body) => (
                    [(CONTENT_TYPE, mime::APPLICATION_WWW_FORM_URLENCODED.as_ref())],
                    body,
                )
                    .into_response(),
                Err(err) => (StatusCode::INTERNAL_SERVER_ERROR, err.to_string()).into_response(),
            }
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_form_Form_t_T.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_form_Form_t_T.
  
  Module  Impl_core_ops_deref_Deref_for_axum_form_Form_t_T.
  Section Impl_core_ops_deref_Deref_for_axum_form_Form_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.form.Form.t T.
    
    (*
                type Target = T;
    *)
    Definition Target : Set := T.
    
    (*
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_axum_form_Form_t_T.
  End Impl_core_ops_deref_Deref_for_axum_form_Form_t_T.
  
  Module  Impl_core_ops_deref_DerefMut_for_axum_form_Form_t_T.
  Section Impl_core_ops_deref_DerefMut_for_axum_form_Form_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.form.Form.t T.
    
    (*
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
    *)
    Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref_mut :
      Notations.DoubleColon Self "deref_mut" := {
      Notations.double_colon := deref_mut;
    }.
    
    Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
      core.ops.deref.DerefMut.deref_mut := deref_mut;
    }.
  End Impl_core_ops_deref_DerefMut_for_axum_form_Form_t_T.
  End Impl_core_ops_deref_DerefMut_for_axum_form_Form_t_T.
End form.

Module  Form.
Section Form.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Form.
End Form.

Module  Impl_core_fmt_Debug_for_axum_form_Form_t_T.
Section Impl_core_fmt_Debug_for_axum_form_Form_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum.form.Form.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_form_Form_t_T.
End Impl_core_fmt_Debug_for_axum_form_Form_t_T.

Module  Impl_core_clone_Clone_for_axum_form_Form_t_T.
Section Impl_core_clone_Clone_for_axum_form_Form_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum.form.Form.t T.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M (axum.form.Form.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_form_Form_t_T.
End Impl_core_clone_Clone_for_axum_form_Form_t_T.

Module  Impl_core_marker_Copy_for_axum_form_Form_t_T.
Section Impl_core_marker_Copy_for_axum_form_Form_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum.form.Form.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_form_Form_t_T.
End Impl_core_marker_Copy_for_axum_form_Form_t_T.

Module  Impl_core_default_Default_for_axum_form_Form_t_T.
Section Impl_core_default_Default_for_axum_form_Form_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.default.Default.Trait T}.
  
  Definition Self : Set := axum.form.Form.t T.
  
  (*
  Default
  *)
  Definition default : M (axum.form.Form.t T) := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_form_Form_t_T.
End Impl_core_default_Default_for_axum_form_Form_t_T.

Module  Impl_axum_core_extract_FromRequest_S_for_axum_form_Form_t_T.
Section Impl_axum_core_extract_FromRequest_S_for_axum_form_Form_t_T.
  Context {T S : Set}.
  
  Context
    {ℋ_0 : serde.de.DeserializeOwned.Trait T}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.form.Form.t T.
  
  (*
      type Rejection = FormRejection;
  *)
  Definition Rejection : Set := axum.extract.rejection.FormRejection.t.
  
  (*
      async fn from_request(req: Request, _state: &S) -> Result<Self, Self::Rejection> {
          let is_get_or_head =
              req.method() == http::Method::GET || req.method() == http::Method::HEAD;
  
          match req.extract().await {
              Ok(RawForm(bytes)) => {
                  let value =
                      serde_urlencoded::from_bytes(&bytes).map_err(|err| -> FormRejection {
                          if is_get_or_head {
                              FailedToDeserializeForm::from_err(err).into()
                          } else {
                              FailedToDeserializeFormBody::from_err(err).into()
                          }
                      })?;
                  Ok(Form(value))
              }
              Err(RawFormRejection::BytesRejection(r)) => Err(FormRejection::BytesRejection(r)),
              Err(RawFormRejection::InvalidFormContentType(r)) => {
                  Err(FormRejection::InvalidFormContentType(r))
              }
          }
      }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (_state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_axum_form_Form_t_T.
End Impl_axum_core_extract_FromRequest_S_for_axum_form_Form_t_T.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_form_Form_t_T.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_form_Form_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : serde.ser.Serialize.Trait T}.
  
  Definition Self : Set := axum.form.Form.t T.
  
  (*
      fn into_response(self) -> Response {
          match serde_urlencoded::to_string(&self.0) {
              Ok(body) => (
                  [(CONTENT_TYPE, mime::APPLICATION_WWW_FORM_URLENCODED.as_ref())],
                  body,
              )
                  .into_response(),
              Err(err) => (StatusCode::INTERNAL_SERVER_ERROR, err.to_string()).into_response(),
          }
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_form_Form_t_T.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_form_Form_t_T.

Module  Impl_core_ops_deref_Deref_for_axum_form_Form_t_T.
Section Impl_core_ops_deref_Deref_for_axum_form_Form_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.form.Form.t T.
  
  (*
              type Target = T;
  *)
  Definition Target : Set := T.
  
  (*
              fn deref(&self) -> &Self::Target {
                  &self.0
              }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_axum_form_Form_t_T.
End Impl_core_ops_deref_Deref_for_axum_form_Form_t_T.

Module  Impl_core_ops_deref_DerefMut_for_axum_form_Form_t_T.
Section Impl_core_ops_deref_DerefMut_for_axum_form_Form_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.form.Form.t T.
  
  (*
              fn deref_mut(&mut self) -> &mut Self::Target {
                  &mut self.0
              }
  *)
  Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref_mut :
    Notations.DoubleColon Self "deref_mut" := {
    Notations.double_colon := deref_mut;
  }.
  
  Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
    core.ops.deref.DerefMut.deref_mut := deref_mut;
  }.
End Impl_core_ops_deref_DerefMut_for_axum_form_Form_t_T.
End Impl_core_ops_deref_DerefMut_for_axum_form_Form_t_T.

Module json.
  Module  Json.
  Section Json.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Json.
  End Json.
  
  Module  Impl_core_fmt_Debug_for_axum_json_Json_t_T.
  Section Impl_core_fmt_Debug_for_axum_json_Json_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum.json.Json.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_json_Json_t_T.
  End Impl_core_fmt_Debug_for_axum_json_Json_t_T.
  
  Module  Impl_core_clone_Clone_for_axum_json_Json_t_T.
  Section Impl_core_clone_Clone_for_axum_json_Json_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum.json.Json.t T.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M (axum.json.Json.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_json_Json_t_T.
  End Impl_core_clone_Clone_for_axum_json_Json_t_T.
  
  Module  Impl_core_marker_Copy_for_axum_json_Json_t_T.
  Section Impl_core_marker_Copy_for_axum_json_Json_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum.json.Json.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_json_Json_t_T.
  End Impl_core_marker_Copy_for_axum_json_Json_t_T.
  
  Module  Impl_core_default_Default_for_axum_json_Json_t_T.
  Section Impl_core_default_Default_for_axum_json_Json_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.default.Default.Trait T}.
    
    Definition Self : Set := axum.json.Json.t T.
    
    (*
    Default
    *)
    Definition default : M (axum.json.Json.t T) := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_json_Json_t_T.
  End Impl_core_default_Default_for_axum_json_Json_t_T.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_axum_json_Json_t_T.
  Section Impl_axum_core_extract_FromRequest_S_for_axum_json_Json_t_T.
    Context {T S : Set}.
    
    Context
      {ℋ_0 : serde.de.DeserializeOwned.Trait T}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.json.Json.t T.
    
    (*
        type Rejection = JsonRejection;
    *)
    Definition Rejection : Set := axum.extract.rejection.JsonRejection.t.
    
    (*
        async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
            if json_content_type(req.headers()) {
                let bytes = Bytes::from_request(req, state).await?;
                Self::from_bytes(&bytes)
            } else {
                Err(MissingJsonContentType.into())
            }
        }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_axum_json_Json_t_T.
  End Impl_axum_core_extract_FromRequest_S_for_axum_json_Json_t_T.
  
  (*
  fn json_content_type(headers: &HeaderMap) -> bool {
      let content_type = if let Some(content_type) = headers.get(header::CONTENT_TYPE) {
          content_type
      } else {
          return false;
      };
  
      let content_type = if let Ok(content_type) = content_type.to_str() {
          content_type
      } else {
          return false;
      };
  
      let mime = if let Ok(mime) = content_type.parse::<mime::Mime>() {
          mime
      } else {
          return false;
      };
  
      let is_json_content_type = mime.type_() == "application"
          && (mime.subtype() == "json" || mime.suffix().map_or(false, |name| name == "json"));
  
      is_json_content_type
  }
  *)
  Definition json_content_type
      (headers
        :
        ref (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
      : M bool.t :=
    let* headers := M.alloc headers in
    M.read foo.
  
  Module  Impl_core_ops_deref_Deref_for_axum_json_Json_t_T.
  Section Impl_core_ops_deref_Deref_for_axum_json_Json_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.json.Json.t T.
    
    (*
                type Target = T;
    *)
    Definition Target : Set := T.
    
    (*
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_axum_json_Json_t_T.
  End Impl_core_ops_deref_Deref_for_axum_json_Json_t_T.
  
  Module  Impl_core_ops_deref_DerefMut_for_axum_json_Json_t_T.
  Section Impl_core_ops_deref_DerefMut_for_axum_json_Json_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.json.Json.t T.
    
    (*
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
    *)
    Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref_mut :
      Notations.DoubleColon Self "deref_mut" := {
      Notations.double_colon := deref_mut;
    }.
    
    Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
      core.ops.deref.DerefMut.deref_mut := deref_mut;
    }.
  End Impl_core_ops_deref_DerefMut_for_axum_json_Json_t_T.
  End Impl_core_ops_deref_DerefMut_for_axum_json_Json_t_T.
  
  Module  Impl_core_convert_From_T_for_axum_json_Json_t_T.
  Section Impl_core_convert_From_T_for_axum_json_Json_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.json.Json.t T.
    
    (*
        fn from(inner: T) -> Self {
            Self(inner)
        }
    *)
    Definition from (inner : T) : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_T_for_axum_json_Json_t_T.
  End Impl_core_convert_From_T_for_axum_json_Json_t_T.
  
  Module  Impl_axum_json_Json_t_T.
  Section Impl_axum_json_Json_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.json.Json.t T.
    
    (*
        pub fn from_bytes(bytes: &[u8]) -> Result<Self, JsonRejection> {
            let deserializer = &mut serde_json::Deserializer::from_slice(bytes);
    
            let value = match serde_path_to_error::deserialize(deserializer) {
                Ok(value) => value,
                Err(err) => {
                    let rejection = match err.inner().classify() {
                        serde_json::error::Category::Data => JsonDataError::from_err(err).into(),
                        serde_json::error::Category::Syntax | serde_json::error::Category::Eof => {
                            JsonSyntaxError::from_err(err).into()
                        }
                        serde_json::error::Category::Io => {
                            if cfg!(debug_assertions) {
                                // we don't use `serde_json::from_reader` and instead always buffer
                                // bodies first, so we shouldn't encounter any IO errors
                                unreachable!()
                            } else {
                                JsonSyntaxError::from_err(err).into()
                            }
                        }
                    };
                    return Err(rejection);
                }
            };
    
            Ok(Json(value))
        }
    *)
    Definition from_bytes
        (bytes : ref (slice u8.t))
        :
          M
            (core.result.Result.t
              Self
              axum.extract.rejection.JsonRejection.t) :=
      let* bytes := M.alloc bytes in
      M.read foo.
    
    Global Instance AssociatedFunction_from_bytes :
      Notations.DoubleColon Self "from_bytes" := {
      Notations.double_colon := from_bytes;
    }.
  End Impl_axum_json_Json_t_T.
  End Impl_axum_json_Json_t_T.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_json_Json_t_T.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_json_Json_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : serde.ser.Serialize.Trait T}.
    
    Definition Self : Set := axum.json.Json.t T.
    
    (*
        fn into_response(self) -> Response {
            // Use a small initial capacity of 128 bytes like serde_json::to_vec
            // https://docs.rs/serde_json/1.0.82/src/serde_json/ser.rs.html#2189
            let mut buf = BytesMut::with_capacity(128).writer();
            match serde_json::to_writer(&mut buf, &self.0) {
                Ok(()) => (
                    [(
                        header::CONTENT_TYPE,
                        HeaderValue::from_static(mime::APPLICATION_JSON.as_ref()),
                    )],
                    buf.into_inner().freeze(),
                )
                    .into_response(),
                Err(err) => (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    [(
                        header::CONTENT_TYPE,
                        HeaderValue::from_static(mime::TEXT_PLAIN_UTF_8.as_ref()),
                    )],
                    err.to_string(),
                )
                    .into_response(),
            }
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_json_Json_t_T.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_json_Json_t_T.
End json.

Module  Json.
Section Json.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Json.
End Json.

Module  Impl_core_fmt_Debug_for_axum_json_Json_t_T.
Section Impl_core_fmt_Debug_for_axum_json_Json_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum.json.Json.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_json_Json_t_T.
End Impl_core_fmt_Debug_for_axum_json_Json_t_T.

Module  Impl_core_clone_Clone_for_axum_json_Json_t_T.
Section Impl_core_clone_Clone_for_axum_json_Json_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum.json.Json.t T.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M (axum.json.Json.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_json_Json_t_T.
End Impl_core_clone_Clone_for_axum_json_Json_t_T.

Module  Impl_core_marker_Copy_for_axum_json_Json_t_T.
Section Impl_core_marker_Copy_for_axum_json_Json_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum.json.Json.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_json_Json_t_T.
End Impl_core_marker_Copy_for_axum_json_Json_t_T.

Module  Impl_core_default_Default_for_axum_json_Json_t_T.
Section Impl_core_default_Default_for_axum_json_Json_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.default.Default.Trait T}.
  
  Definition Self : Set := axum.json.Json.t T.
  
  (*
  Default
  *)
  Definition default : M (axum.json.Json.t T) := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_json_Json_t_T.
End Impl_core_default_Default_for_axum_json_Json_t_T.

Module  Impl_axum_core_extract_FromRequest_S_for_axum_json_Json_t_T.
Section Impl_axum_core_extract_FromRequest_S_for_axum_json_Json_t_T.
  Context {T S : Set}.
  
  Context
    {ℋ_0 : serde.de.DeserializeOwned.Trait T}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.json.Json.t T.
  
  (*
      type Rejection = JsonRejection;
  *)
  Definition Rejection : Set := axum.extract.rejection.JsonRejection.t.
  
  (*
      async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
          if json_content_type(req.headers()) {
              let bytes = Bytes::from_request(req, state).await?;
              Self::from_bytes(&bytes)
          } else {
              Err(MissingJsonContentType.into())
          }
      }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_axum_json_Json_t_T.
End Impl_axum_core_extract_FromRequest_S_for_axum_json_Json_t_T.

(*
fn json_content_type(headers: &HeaderMap) -> bool {
    let content_type = if let Some(content_type) = headers.get(header::CONTENT_TYPE) {
        content_type
    } else {
        return false;
    };

    let content_type = if let Ok(content_type) = content_type.to_str() {
        content_type
    } else {
        return false;
    };

    let mime = if let Ok(mime) = content_type.parse::<mime::Mime>() {
        mime
    } else {
        return false;
    };

    let is_json_content_type = mime.type_() == "application"
        && (mime.subtype() == "json" || mime.suffix().map_or(false, |name| name == "json"));

    is_json_content_type
}
*)
Definition json_content_type
    (headers
      :
      ref (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
    : M bool.t :=
  let* headers := M.alloc headers in
  M.read foo.

Module  Impl_core_ops_deref_Deref_for_axum_json_Json_t_T.
Section Impl_core_ops_deref_Deref_for_axum_json_Json_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.json.Json.t T.
  
  (*
              type Target = T;
  *)
  Definition Target : Set := T.
  
  (*
              fn deref(&self) -> &Self::Target {
                  &self.0
              }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_axum_json_Json_t_T.
End Impl_core_ops_deref_Deref_for_axum_json_Json_t_T.

Module  Impl_core_ops_deref_DerefMut_for_axum_json_Json_t_T.
Section Impl_core_ops_deref_DerefMut_for_axum_json_Json_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.json.Json.t T.
  
  (*
              fn deref_mut(&mut self) -> &mut Self::Target {
                  &mut self.0
              }
  *)
  Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref_mut :
    Notations.DoubleColon Self "deref_mut" := {
    Notations.double_colon := deref_mut;
  }.
  
  Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
    core.ops.deref.DerefMut.deref_mut := deref_mut;
  }.
End Impl_core_ops_deref_DerefMut_for_axum_json_Json_t_T.
End Impl_core_ops_deref_DerefMut_for_axum_json_Json_t_T.

Module  Impl_core_convert_From_T_for_axum_json_Json_t_T.
Section Impl_core_convert_From_T_for_axum_json_Json_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.json.Json.t T.
  
  (*
      fn from(inner: T) -> Self {
          Self(inner)
      }
  *)
  Definition from (inner : T) : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_T_for_axum_json_Json_t_T.
End Impl_core_convert_From_T_for_axum_json_Json_t_T.

Module  Impl_axum_json_Json_t_T_2.
Section Impl_axum_json_Json_t_T_2.
  Context {T : Set}.
  
  Definition Self : Set := axum.json.Json.t T.
  
  (*
      pub fn from_bytes(bytes: &[u8]) -> Result<Self, JsonRejection> {
          let deserializer = &mut serde_json::Deserializer::from_slice(bytes);
  
          let value = match serde_path_to_error::deserialize(deserializer) {
              Ok(value) => value,
              Err(err) => {
                  let rejection = match err.inner().classify() {
                      serde_json::error::Category::Data => JsonDataError::from_err(err).into(),
                      serde_json::error::Category::Syntax | serde_json::error::Category::Eof => {
                          JsonSyntaxError::from_err(err).into()
                      }
                      serde_json::error::Category::Io => {
                          if cfg!(debug_assertions) {
                              // we don't use `serde_json::from_reader` and instead always buffer
                              // bodies first, so we shouldn't encounter any IO errors
                              unreachable!()
                          } else {
                              JsonSyntaxError::from_err(err).into()
                          }
                      }
                  };
                  return Err(rejection);
              }
          };
  
          Ok(Json(value))
      }
  *)
  Definition from_bytes
      (bytes : ref (slice u8.t))
      : M (core.result.Result.t Self axum.extract.rejection.JsonRejection.t) :=
    let* bytes := M.alloc bytes in
    M.read foo.
  
  Global Instance AssociatedFunction_from_bytes :
    Notations.DoubleColon Self "from_bytes" := {
    Notations.double_colon := from_bytes;
  }.
End Impl_axum_json_Json_t_T_2.
End Impl_axum_json_Json_t_T_2.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_json_Json_t_T.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_json_Json_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : serde.ser.Serialize.Trait T}.
  
  Definition Self : Set := axum.json.Json.t T.
  
  (*
      fn into_response(self) -> Response {
          // Use a small initial capacity of 128 bytes like serde_json::to_vec
          // https://docs.rs/serde_json/1.0.82/src/serde_json/ser.rs.html#2189
          let mut buf = BytesMut::with_capacity(128).writer();
          match serde_json::to_writer(&mut buf, &self.0) {
              Ok(()) => (
                  [(
                      header::CONTENT_TYPE,
                      HeaderValue::from_static(mime::APPLICATION_JSON.as_ref()),
                  )],
                  buf.into_inner().freeze(),
              )
                  .into_response(),
              Err(err) => (
                  StatusCode::INTERNAL_SERVER_ERROR,
                  [(
                      header::CONTENT_TYPE,
                      HeaderValue::from_static(mime::TEXT_PLAIN_UTF_8.as_ref()),
                  )],
                  err.to_string(),
              )
                  .into_response(),
          }
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_json_Json_t_T.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_json_Json_t_T.

Module service_ext.
  Module  ServiceExt.
  Section ServiceExt.
    Class Trait (Self : Set) {R : Set} : Type := {
      ℒ_0 :: tower_service.Service.Trait Self (Request := R);
      into_make_service :
        Self -> M (axum.routing.into_make_service.IntoMakeService.t Self);
      into_make_service_with_connect_info {C : Set} :
        Self ->
          M (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t Self C);
    }.
    
  End ServiceExt.
  End ServiceExt.
  
  Module  Impl_axum_service_ext_ServiceExt_R_for_S.
  Section Impl_axum_service_ext_ServiceExt_R_for_S.
    Context {S R : Set}.
    
    Context {ℋ_0 : tower_service.Service.Trait S (Request := R)}.
    
    Definition Self : Set := S.
    
    (*
        fn into_make_service(self) -> IntoMakeService<Self> {
            IntoMakeService::new(self)
        }
    *)
    Definition into_make_service
        (self : Self)
        : M (axum.routing.into_make_service.IntoMakeService.t Self) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_make_service :
      Notations.DoubleColon Self "into_make_service" := {
      Notations.double_colon := into_make_service;
    }.
    
    (*
        fn into_make_service_with_connect_info<C>(self) -> IntoMakeServiceWithConnectInfo<Self, C> {
            IntoMakeServiceWithConnectInfo::new(self)
        }
    *)
    Definition into_make_service_with_connect_info
        {C : Set}
        (self : Self)
        :
          M
            (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t
              Self
              C) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_make_service_with_connect_info
        {C : Set} :
      Notations.DoubleColon Self "into_make_service_with_connect_info" := {
      Notations.double_colon := into_make_service_with_connect_info (C := C);
    }.
    
    Global Instance ℐ :
      axum.service_ext.ServiceExt.Required.Trait Self (R := R) := {
      axum.service_ext.ServiceExt.into_make_service := into_make_service;
      axum.service_ext.ServiceExt.into_make_service_with_connect_info
        {C : Set} :=
        into_make_service_with_connect_info (C := C);
      axum.service_ext.ServiceExt.handle_error := Datatypes.None;
    }.
  End Impl_axum_service_ext_ServiceExt_R_for_S.
  End Impl_axum_service_ext_ServiceExt_R_for_S.
End service_ext.

Module  ServiceExt.
Section ServiceExt.
  Class Trait (Self : Set) {R : Set} : Type := {
    ℒ_0 :: tower_service.Service.Trait Self (Request := R);
    into_make_service :
      Self -> M (axum.routing.into_make_service.IntoMakeService.t Self);
    into_make_service_with_connect_info {C : Set} :
      Self ->
        M (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t Self C);
  }.
  
End ServiceExt.
End ServiceExt.

Module  Impl_axum_service_ext_ServiceExt_R_for_S.
Section Impl_axum_service_ext_ServiceExt_R_for_S.
  Context {S R : Set}.
  
  Context {ℋ_0 : tower_service.Service.Trait S (Request := R)}.
  
  Definition Self : Set := S.
  
  (*
      fn into_make_service(self) -> IntoMakeService<Self> {
          IntoMakeService::new(self)
      }
  *)
  Definition into_make_service
      (self : Self)
      : M (axum.routing.into_make_service.IntoMakeService.t Self) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_make_service :
    Notations.DoubleColon Self "into_make_service" := {
    Notations.double_colon := into_make_service;
  }.
  
  (*
      fn into_make_service_with_connect_info<C>(self) -> IntoMakeServiceWithConnectInfo<Self, C> {
          IntoMakeServiceWithConnectInfo::new(self)
      }
  *)
  Definition into_make_service_with_connect_info
      {C : Set}
      (self : Self)
      : M (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t Self C) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_make_service_with_connect_info
      {C : Set} :
    Notations.DoubleColon Self "into_make_service_with_connect_info" := {
    Notations.double_colon := into_make_service_with_connect_info (C := C);
  }.
  
  Global Instance ℐ :
    axum.service_ext.ServiceExt.Required.Trait Self (R := R) := {
    axum.service_ext.ServiceExt.into_make_service := into_make_service;
    axum.service_ext.ServiceExt.into_make_service_with_connect_info {C : Set} :=
      into_make_service_with_connect_info (C := C);
    axum.service_ext.ServiceExt.handle_error := Datatypes.None;
  }.
End Impl_axum_service_ext_ServiceExt_R_for_S.
End Impl_axum_service_ext_ServiceExt_R_for_S.

Module util.
  Module  PercentDecodedStr.
  Section PercentDecodedStr.
    Record t : Set := {
      x0 : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End PercentDecodedStr.
  End PercentDecodedStr.
  
  Module  Impl_core_clone_Clone_for_axum_util_PercentDecodedStr_t.
  Section Impl_core_clone_Clone_for_axum_util_PercentDecodedStr_t.
    Definition Self : Set := axum.util.PercentDecodedStr.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum.util.PercentDecodedStr.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_util_PercentDecodedStr_t.
  End Impl_core_clone_Clone_for_axum_util_PercentDecodedStr_t.
  
  Module  Impl_core_fmt_Debug_for_axum_util_PercentDecodedStr_t.
  Section Impl_core_fmt_Debug_for_axum_util_PercentDecodedStr_t.
    Definition Self : Set := axum.util.PercentDecodedStr.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_util_PercentDecodedStr_t.
  End Impl_core_fmt_Debug_for_axum_util_PercentDecodedStr_t.
  
  Module  Impl_core_marker_StructuralPartialEq_for_axum_util_PercentDecodedStr_t.
  Section Impl_core_marker_StructuralPartialEq_for_axum_util_PercentDecodedStr_t.
    Definition Self : Set := axum.util.PercentDecodedStr.t.
    
    Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralPartialEq_for_axum_util_PercentDecodedStr_t.
  End Impl_core_marker_StructuralPartialEq_for_axum_util_PercentDecodedStr_t.
  
  Module  Impl_core_cmp_PartialEq_for_axum_util_PercentDecodedStr_t.
  Section Impl_core_cmp_PartialEq_for_axum_util_PercentDecodedStr_t.
    Definition Self : Set := axum.util.PercentDecodedStr.t.
    
    (*
    PartialEq
    *)
    Definition eq
        (self : ref Self)
        (other : ref axum.util.PercentDecodedStr.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_axum_util_PercentDecodedStr_t.
  End Impl_core_cmp_PartialEq_for_axum_util_PercentDecodedStr_t.
  
  Module  Impl_core_marker_StructuralEq_for_axum_util_PercentDecodedStr_t.
  Section Impl_core_marker_StructuralEq_for_axum_util_PercentDecodedStr_t.
    Definition Self : Set := axum.util.PercentDecodedStr.t.
    
    Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralEq_for_axum_util_PercentDecodedStr_t.
  End Impl_core_marker_StructuralEq_for_axum_util_PercentDecodedStr_t.
  
  Module  Impl_core_cmp_Eq_for_axum_util_PercentDecodedStr_t.
  Section Impl_core_cmp_Eq_for_axum_util_PercentDecodedStr_t.
    Definition Self : Set := axum.util.PercentDecodedStr.t.
    
    (*
    Eq
    *)
    Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_assert_receiver_is_total_eq :
      Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
      Notations.double_colon := assert_receiver_is_total_eq;
    }.
    
    Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
      core.cmp.Eq.assert_receiver_is_total_eq :=
        Datatypes.Some assert_receiver_is_total_eq;
    }.
  End Impl_core_cmp_Eq_for_axum_util_PercentDecodedStr_t.
  End Impl_core_cmp_Eq_for_axum_util_PercentDecodedStr_t.
  
  Module  Impl_core_hash_Hash_for_axum_util_PercentDecodedStr_t.
  Section Impl_core_hash_Hash_for_axum_util_PercentDecodedStr_t.
    Definition Self : Set := axum.util.PercentDecodedStr.t.
    
    (*
    Hash
    *)
    Definition hash
        {__H : Set}
        {ℋ_0 : core.hash.Hasher.Trait __H}
        (self : ref Self)
        (state : mut_ref __H)
        : M unit :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_hash
        {__H : Set}
        {ℋ_0 : core.hash.Hasher.Trait __H} :
      Notations.DoubleColon Self "hash" := {
      Notations.double_colon := hash (__H := __H);
    }.
    
    Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
      core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
        hash (__H := __H);
      core.hash.Hash.hash_slice := Datatypes.None;
    }.
  End Impl_core_hash_Hash_for_axum_util_PercentDecodedStr_t.
  End Impl_core_hash_Hash_for_axum_util_PercentDecodedStr_t.
  
  Module  Impl_axum_util_PercentDecodedStr_t.
  Section Impl_axum_util_PercentDecodedStr_t.
    Definition Self : Set := axum.util.PercentDecodedStr.t.
    
    (*
        pub(crate) fn new<S>(s: S) -> Option<Self>
        where
            S: AsRef<str>,
        {
            percent_encoding::percent_decode(s.as_ref().as_bytes())
                .decode_utf8()
                .ok()
                .map(|decoded| Self(decoded.as_ref().into()))
        }
    *)
    Definition new
        {S : Set}
        {ℋ_0 : core.convert.AsRef.Trait S (T := str.t)}
        (s : S)
        : M (core.option.Option.t Self) :=
      let* s := M.alloc s in
      M.read foo.
    
    Global Instance AssociatedFunction_new
        {S : Set}
        {ℋ_0 : core.convert.AsRef.Trait S (T := str.t)} :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new (S := S);
    }.
    
    (*
        pub(crate) fn as_str(&self) -> &str {
            &self.0
        }
    *)
    Definition as_str (self : ref Self) : M (ref str.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_str :
      Notations.DoubleColon Self "as_str" := {
      Notations.double_colon := as_str;
    }.
    
    (*
        pub(crate) fn into_inner(self) -> Arc<str> {
            self.0
        }
    *)
    Definition into_inner
        (self : Self)
        : M (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_inner :
      Notations.DoubleColon Self "into_inner" := {
      Notations.double_colon := into_inner;
    }.
  End Impl_axum_util_PercentDecodedStr_t.
  End Impl_axum_util_PercentDecodedStr_t.
  
  Module  Impl_core_ops_deref_Deref_for_axum_util_PercentDecodedStr_t.
  Section Impl_core_ops_deref_Deref_for_axum_util_PercentDecodedStr_t.
    Definition Self : Set := axum.util.PercentDecodedStr.t.
    
    (*
        type Target = str;
    *)
    Definition Target : Set := str.t.
    
    (*
        fn deref(&self) -> &Self::Target {
            self.as_str()
        }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_axum_util_PercentDecodedStr_t.
  End Impl_core_ops_deref_Deref_for_axum_util_PercentDecodedStr_t.
  
  Module Either.
    Module A.
      Record t : Set := {
        inner : A;
      }.
    End A.
    
    Module B.
      Record t : Set := {
        inner : B;
      }.
    End B.
    
    Inductive t (A : Set) (B : Set) : Set :=
    | A (_ : A.t)
    | B (_ : B.t).
    
    Definition Get_A_inner :=
      Ref.map
        (fun α => match α with | A α => Some α.(A.inner) | _ => None end)
        (fun β α =>
          match α with
          | A α => Some (A (α <| A.inner := β |>))
          | _ => None
          end).
    
    Definition Get_B_inner :=
      Ref.map
        (fun α => match α with | B α => Some α.(B.inner) | _ => None end)
        (fun β α =>
          match α with
          | B α => Some (B (α <| B.inner := β |>))
          | _ => None
          end).
  End Either.
  
  Module EitherProj.
    Module A.
      Record t : Set := {
        inner : core.pin.Pin.t (mut_ref A);
      }.
    End A.
    
    Module B.
      Record t : Set := {
        inner : core.pin.Pin.t (mut_ref B);
      }.
    End B.
    
    Inductive t (A : Set) (B : Set) : Set :=
    | A (_ : A.t)
    | B (_ : B.t).
    
    Definition Get_A_inner :=
      Ref.map
        (fun α => match α with | A α => Some α.(A.inner) | _ => None end)
        (fun β α =>
          match α with
          | A α => Some (A (α <| A.inner := β |>))
          | _ => None
          end).
    
    Definition Get_B_inner :=
      Ref.map
        (fun α => match α with | B α => Some α.(B.inner) | _ => None end)
        (fun β α =>
          match α with
          | B α => Some (B (α <| B.inner := β |>))
          | _ => None
          end).
  End EitherProj.
  
  (*
  pub(crate) fn try_downcast<T, K>(k: K) -> Result<T, K>
  where
      T: 'static,
      K: Send + 'static,
  {
      let mut k = Some(k);
      if let Some(k) = <dyn std::any::Any>::downcast_mut::<Option<T>>(&mut k) {
          Ok(k.take().unwrap())
      } else {
          Err(k.unwrap())
      }
  }
  *)
  Definition try_downcast
      {T K : Set}
      {ℋ_0 : core.marker.Send.Trait K}
      (k : K)
      : M (core.result.Result.t T K) :=
    let* k := M.alloc k in
    M.read foo.
  
  Module mutex.
    Ltac AxumMutex T := exact (std.sync.mutex.Mutex.t T).
  End mutex.
End util.

Module  PercentDecodedStr.
Section PercentDecodedStr.
  Record t : Set := {
    x0 : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End PercentDecodedStr.
End PercentDecodedStr.

Module  Impl_core_clone_Clone_for_axum_util_PercentDecodedStr_t.
Section Impl_core_clone_Clone_for_axum_util_PercentDecodedStr_t.
  Definition Self : Set := axum.util.PercentDecodedStr.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.util.PercentDecodedStr.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_util_PercentDecodedStr_t.
End Impl_core_clone_Clone_for_axum_util_PercentDecodedStr_t.

Module  Impl_core_fmt_Debug_for_axum_util_PercentDecodedStr_t.
Section Impl_core_fmt_Debug_for_axum_util_PercentDecodedStr_t.
  Definition Self : Set := axum.util.PercentDecodedStr.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_util_PercentDecodedStr_t.
End Impl_core_fmt_Debug_for_axum_util_PercentDecodedStr_t.

Module  Impl_core_marker_StructuralPartialEq_for_axum_util_PercentDecodedStr_t.
Section Impl_core_marker_StructuralPartialEq_for_axum_util_PercentDecodedStr_t.
  Definition Self : Set := axum.util.PercentDecodedStr.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_axum_util_PercentDecodedStr_t.
End Impl_core_marker_StructuralPartialEq_for_axum_util_PercentDecodedStr_t.

Module  Impl_core_cmp_PartialEq_for_axum_util_PercentDecodedStr_t.
Section Impl_core_cmp_PartialEq_for_axum_util_PercentDecodedStr_t.
  Definition Self : Set := axum.util.PercentDecodedStr.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref axum.util.PercentDecodedStr.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_util_PercentDecodedStr_t.
End Impl_core_cmp_PartialEq_for_axum_util_PercentDecodedStr_t.

Module  Impl_core_marker_StructuralEq_for_axum_util_PercentDecodedStr_t.
Section Impl_core_marker_StructuralEq_for_axum_util_PercentDecodedStr_t.
  Definition Self : Set := axum.util.PercentDecodedStr.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_axum_util_PercentDecodedStr_t.
End Impl_core_marker_StructuralEq_for_axum_util_PercentDecodedStr_t.

Module  Impl_core_cmp_Eq_for_axum_util_PercentDecodedStr_t.
Section Impl_core_cmp_Eq_for_axum_util_PercentDecodedStr_t.
  Definition Self : Set := axum.util.PercentDecodedStr.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_axum_util_PercentDecodedStr_t.
End Impl_core_cmp_Eq_for_axum_util_PercentDecodedStr_t.

Module  Impl_core_hash_Hash_for_axum_util_PercentDecodedStr_t.
Section Impl_core_hash_Hash_for_axum_util_PercentDecodedStr_t.
  Definition Self : Set := axum.util.PercentDecodedStr.t.
  
  (*
  Hash
  *)
  Definition hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H}
      (self : ref Self)
      (state : mut_ref __H)
      : M unit :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
      hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_axum_util_PercentDecodedStr_t.
End Impl_core_hash_Hash_for_axum_util_PercentDecodedStr_t.

Module  Impl_axum_util_PercentDecodedStr_t_2.
Section Impl_axum_util_PercentDecodedStr_t_2.
  Definition Self : Set := axum.util.PercentDecodedStr.t.
  
  (*
      pub(crate) fn new<S>(s: S) -> Option<Self>
      where
          S: AsRef<str>,
      {
          percent_encoding::percent_decode(s.as_ref().as_bytes())
              .decode_utf8()
              .ok()
              .map(|decoded| Self(decoded.as_ref().into()))
      }
  *)
  Definition new
      {S : Set}
      {ℋ_0 : core.convert.AsRef.Trait S (T := str.t)}
      (s : S)
      : M (core.option.Option.t Self) :=
    let* s := M.alloc s in
    M.read foo.
  
  Global Instance AssociatedFunction_new
      {S : Set}
      {ℋ_0 : core.convert.AsRef.Trait S (T := str.t)} :
    Notations.DoubleColon Self "new" := {
    Notations.double_colon := new (S := S);
  }.
  
  (*
      pub(crate) fn as_str(&self) -> &str {
          &self.0
      }
  *)
  Definition as_str (self : ref Self) : M (ref str.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_str :
    Notations.DoubleColon Self "as_str" := {
    Notations.double_colon := as_str;
  }.
  
  (*
      pub(crate) fn into_inner(self) -> Arc<str> {
          self.0
      }
  *)
  Definition into_inner
      (self : Self)
      : M (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_inner :
    Notations.DoubleColon Self "into_inner" := {
    Notations.double_colon := into_inner;
  }.
End Impl_axum_util_PercentDecodedStr_t_2.
End Impl_axum_util_PercentDecodedStr_t_2.

Module  Impl_core_ops_deref_Deref_for_axum_util_PercentDecodedStr_t.
Section Impl_core_ops_deref_Deref_for_axum_util_PercentDecodedStr_t.
  Definition Self : Set := axum.util.PercentDecodedStr.t.
  
  (*
      type Target = str;
  *)
  Definition Target : Set := str.t.
  
  (*
      fn deref(&self) -> &Self::Target {
          self.as_str()
      }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_axum_util_PercentDecodedStr_t.
End Impl_core_ops_deref_Deref_for_axum_util_PercentDecodedStr_t.

Module Either.
  Module A.
    Record t : Set := {
      inner : A;
    }.
  End A.
  
  Module B.
    Record t : Set := {
      inner : B;
    }.
  End B.
  
  Inductive t (A : Set) (B : Set) : Set :=
  | A (_ : A.t)
  | B (_ : B.t).
  
  Definition Get_A_inner :=
    Ref.map
      (fun α => match α with | A α => Some α.(A.inner) | _ => None end)
      (fun β α =>
        match α with | A α => Some (A (α <| A.inner := β |>)) | _ => None end).
  
  Definition Get_B_inner :=
    Ref.map
      (fun α => match α with | B α => Some α.(B.inner) | _ => None end)
      (fun β α =>
        match α with | B α => Some (B (α <| B.inner := β |>)) | _ => None end).
End Either.

Module EitherProj.
  Module A.
    Record t : Set := {
      inner : core.pin.Pin.t (mut_ref A);
    }.
  End A.
  
  Module B.
    Record t : Set := {
      inner : core.pin.Pin.t (mut_ref B);
    }.
  End B.
  
  Inductive t (A : Set) (B : Set) : Set :=
  | A (_ : A.t)
  | B (_ : B.t).
  
  Definition Get_A_inner :=
    Ref.map
      (fun α => match α with | A α => Some α.(A.inner) | _ => None end)
      (fun β α =>
        match α with | A α => Some (A (α <| A.inner := β |>)) | _ => None end).
  
  Definition Get_B_inner :=
    Ref.map
      (fun α => match α with | B α => Some α.(B.inner) | _ => None end)
      (fun β α =>
        match α with | B α => Some (B (α <| B.inner := β |>)) | _ => None end).
End EitherProj.

Module  Impl_axum_util_Either_t_A_B.
Section Impl_axum_util_Either_t_A_B.
  Context {A B : Set}.
  
  Definition Self : Set := axum.util.Either.t A B.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  match self.$get_method() {
                      $(
                          Self::$variant $({
                              $($field),+
                          })? => {
                              $proj_ty_ident::$variant $({
                                  $(
                                      $field: $crate::__pin_project_make_unsafe_field_proj!(
                                          $(#[$pin])? $field
                                      )
                                  ),+
                              })?
                          }
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum.util.EitherProj.t A B) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
End Impl_axum_util_Either_t_A_B.
End Impl_axum_util_Either_t_A_B.

Module  __Origin.
Section __Origin.
  Context (A B : Set).
  
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    A : A;
    B : B;
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_A :=
    Ref.map (fun α => Some α.(A)) (fun β α => Some (α <| A := β |>)).
  Definition Get_B :=
    Ref.map (fun α => Some α.(B)) (fun β α => Some (α <| B := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_util_Either_t_A_B.
Section Impl_core_marker_Unpin_for_axum_util_Either_t_A_B.
  Context {A B : Set}.
  
  Context {ℋ_0 : core.marker.Unpin.Trait (axum.util._.__Origin.t A B)}.
  
  Definition Self : Set := axum.util.Either.t A B.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_util_Either_t_A_B.
End Impl_core_marker_Unpin_for_axum_util_Either_t_A_B.

Module  MustNotImplDrop.
Section MustNotImplDrop.
  Unset Primitive Projections.
  Class Trait (Self : Set) : Type := {
  }.
  Global Set Primitive Projections.
End MustNotImplDrop.
End MustNotImplDrop.

Module  Impl_axum_util___MustNotImplDrop_for_T.
Section Impl_axum_util___MustNotImplDrop_for_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.ops.drop.Drop.Trait T}.
  
  Definition Self : Set := T.
  
  Global Instance ℐ : axum.util._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_util___MustNotImplDrop_for_T.
End Impl_axum_util___MustNotImplDrop_for_T.

Module  Impl_axum_util___MustNotImplDrop_for_axum_util_Either_t_A_B.
Section Impl_axum_util___MustNotImplDrop_for_axum_util_Either_t_A_B.
  Context {A B : Set}.
  
  Definition Self : Set := axum.util.Either.t A B.
  
  Global Instance ℐ : axum.util._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_util___MustNotImplDrop_for_axum_util_Either_t_A_B.
End Impl_axum_util___MustNotImplDrop_for_axum_util_Either_t_A_B.

(*
pub(crate) fn try_downcast<T, K>(k: K) -> Result<T, K>
where
    T: 'static,
    K: Send + 'static,
{
    let mut k = Some(k);
    if let Some(k) = <dyn std::any::Any>::downcast_mut::<Option<T>>(&mut k) {
        Ok(k.take().unwrap())
    } else {
        Err(k.unwrap())
    }
}
*)
Definition try_downcast
    {T K : Set}
    {ℋ_0 : core.marker.Send.Trait K}
    (k : K)
    : M (core.result.Result.t T K) :=
  let* k := M.alloc k in
  M.read foo.

Module mutex.
  Ltac AxumMutex T := exact (std.sync.mutex.Mutex.t T).
End mutex.

Ltac AxumMutex T := exact (std.sync.mutex.Mutex.t T).

Module body.
  (*
  pub async fn to_bytes(body: Body, limit: usize) -> Result<Bytes, axum_core::Error> {
      Limited::new(body, limit)
          .collect()
          .await
          .map(|col| col.to_bytes())
          .map_err(axum_core::Error::new)
  }
  *)
  Definition to_bytes
      (body : axum_core.body.Body.t)
      (limit : usize.t)
      : M OpaqueDef :=
    let* body := M.alloc body in
    let* limit := M.alloc limit in
    M.read foo.
End body.

(*
pub async fn to_bytes(body: Body, limit: usize) -> Result<Bytes, axum_core::Error> {
    Limited::new(body, limit)
        .collect()
        .await
        .map(|col| col.to_bytes())
        .map_err(axum_core::Error::new)
}
*)
Definition to_bytes
    (body : axum_core.body.Body.t)
    (limit : usize.t)
    : M OpaqueDef :=
  let* body := M.alloc body in
  let* limit := M.alloc limit in
  M.read foo.

Error OpaqueTy.

Module error_handling.
  Module  HandleErrorLayer.
  Section HandleErrorLayer.
    Context (F T : Set).
    
    Record t : Set := {
      f : F;
      _extractor : core.marker.PhantomData.t T;
    }.
    
    Definition Get_f :=
      Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
    Definition Get__extractor :=
      Ref.map
        (fun α => Some α.(_extractor))
        (fun β α => Some (α <| _extractor := β |>)).
  End HandleErrorLayer.
  End HandleErrorLayer.
  
  Module  Impl_axum_error_handling_HandleErrorLayer_t_F_T.
  Section Impl_axum_error_handling_HandleErrorLayer_t_F_T.
    Context {F T : Set}.
    
    Definition Self : Set := axum.error_handling.HandleErrorLayer.t F T.
    
    (*
        pub fn new(f: F) -> Self {
            Self {
                f,
                _extractor: PhantomData,
            }
        }
    *)
    Definition new (f : F) : M Self :=
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_axum_error_handling_HandleErrorLayer_t_F_T.
  End Impl_axum_error_handling_HandleErrorLayer_t_F_T.
  
  Module  Impl_core_clone_Clone_for_axum_error_handling_HandleErrorLayer_t_F_T.
  Section Impl_core_clone_Clone_for_axum_error_handling_HandleErrorLayer_t_F_T.
    Context {F T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait F}.
    
    Definition Self : Set := axum.error_handling.HandleErrorLayer.t F T.
    
    (*
        fn clone(&self) -> Self {
            Self {
                f: self.f.clone(),
                _extractor: PhantomData,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_error_handling_HandleErrorLayer_t_F_T.
  End Impl_core_clone_Clone_for_axum_error_handling_HandleErrorLayer_t_F_T.
  
  Module  Impl_core_fmt_Debug_for_axum_error_handling_HandleErrorLayer_t_F_E.
  Section Impl_core_fmt_Debug_for_axum_error_handling_HandleErrorLayer_t_F_E.
    Context {F E : Set}.
    
    Definition Self : Set := axum.error_handling.HandleErrorLayer.t F E.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("HandleErrorLayer")
                .field("f", &format_args!("{}", std::any::type_name::<F>()))
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_error_handling_HandleErrorLayer_t_F_E.
  End Impl_core_fmt_Debug_for_axum_error_handling_HandleErrorLayer_t_F_E.
  
  Module  Impl_tower_layer_Layer_S_for_axum_error_handling_HandleErrorLayer_t_F_T.
  Section Impl_tower_layer_Layer_S_for_axum_error_handling_HandleErrorLayer_t_F_T.
    Context {S F T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait F}.
    
    Definition Self : Set := axum.error_handling.HandleErrorLayer.t F T.
    
    (*
        type Service = HandleError<S, F, T>;
    *)
    Definition Service : Set := axum.error_handling.HandleError.t S F T.
    
    (*
        fn layer(&self, inner: S) -> Self::Service {
            HandleError::new(inner, self.f.clone())
        }
    *)
    Definition layer (self : ref Self) (inner : S) : M Service :=
      let* self := M.alloc self in
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_layer :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer;
    }.
    
    Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
      tower_layer.Layer.Service := Service;
      tower_layer.Layer.layer := layer;
    }.
  End Impl_tower_layer_Layer_S_for_axum_error_handling_HandleErrorLayer_t_F_T.
  End Impl_tower_layer_Layer_S_for_axum_error_handling_HandleErrorLayer_t_F_T.
  
  Module  HandleError.
  Section HandleError.
    Context (S F T : Set).
    
    Record t : Set := {
      inner : S;
      f : F;
      _extractor : core.marker.PhantomData.t T;
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Definition Get_f :=
      Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
    Definition Get__extractor :=
      Ref.map
        (fun α => Some α.(_extractor))
        (fun β α => Some (α <| _extractor := β |>)).
  End HandleError.
  End HandleError.
  
  Module  Impl_axum_error_handling_HandleError_t_S_F_T.
  Section Impl_axum_error_handling_HandleError_t_S_F_T.
    Context {S F T : Set}.
    
    Definition Self : Set := axum.error_handling.HandleError.t S F T.
    
    (*
        pub fn new(inner: S, f: F) -> Self {
            Self {
                inner,
                f,
                _extractor: PhantomData,
            }
        }
    *)
    Definition new (inner : S) (f : F) : M Self :=
      let* inner := M.alloc inner in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_axum_error_handling_HandleError_t_S_F_T.
  End Impl_axum_error_handling_HandleError_t_S_F_T.
  
  Module  Impl_core_clone_Clone_for_axum_error_handling_HandleError_t_S_F_T.
  Section Impl_core_clone_Clone_for_axum_error_handling_HandleError_t_S_F_T.
    Context {S F T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S} {ℋ_1 : core.clone.Clone.Trait F}.
    
    Definition Self : Set := axum.error_handling.HandleError.t S F T.
    
    (*
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
                f: self.f.clone(),
                _extractor: PhantomData,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_error_handling_HandleError_t_S_F_T.
  End Impl_core_clone_Clone_for_axum_error_handling_HandleError_t_S_F_T.
  
  Module  Impl_core_fmt_Debug_for_axum_error_handling_HandleError_t_S_F_E.
  Section Impl_core_fmt_Debug_for_axum_error_handling_HandleError_t_S_F_E.
    Context {S F E : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set := axum.error_handling.HandleError.t S F E.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("HandleError")
                .field("inner", &self.inner)
                .field("f", &format_args!("{}", std::any::type_name::<F>()))
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_error_handling_HandleError_t_S_F_E.
  End Impl_core_fmt_Debug_for_axum_error_handling_HandleError_t_S_F_E.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_.
    Context {S F B Fut Res : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 : core.ops.function.FnOnce.Trait F (Args := S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : core.marker.Send.Trait B}.
    
    Definition Self : Set := axum.error_handling.HandleError.t S F unit.
    
    (*
        type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
        fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, req: Request<B>) -> Self::Future {
            let f = self.f.clone();
    
            let clone = self.inner.clone();
            let inner = std::mem::replace(&mut self.inner, clone);
    
            let future = Box::pin(async move {
                match inner.oneshot(req).await {
                    Ok(res) => Ok(res.into_response()),
                    Err(err) => Ok(f(err).await.into_response()),
                }
            });
    
            future::HandleErrorFuture { future }
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_.
    Context {S F B Res Fut T1 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 : core.ops.function.FnOnce.Trait F (Args := T1 * S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : core.marker.Send.Trait B}.
    
    Definition Self : Set := axum.error_handling.HandleError.t S F T1.
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_.
    Context {S F B Res Fut T1 T2 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := (T1 * T2) * S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : core.marker.Send.Trait B}.
    
    Definition Self : Set := axum.error_handling.HandleError.t S F (T1 * T2).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_.
    Context {S F B Res Fut T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := ((T1 * T2) * T3) * S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t S F ((T1 * T2) * T3).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_.
    Context {S F B Res Fut T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := (((T1 * T2) * T3) * T4) * S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t S F (((T1 * T2) * T3) * T4).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_.
    Context {S F B Res Fut T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((T1 * T2) * T3) * T4) * T5) * S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t S F ((((T1 * T2) * T3) * T4) * T5).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_.
    Context {S F B Res Fut T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((T1 * T2) * T3) * T4) * T5) * T6) * S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
      {ℋ_24 : core.marker.Send.Trait T6}
      {ℋ_25 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t
        S
        F
        (((((T1 * T2) * T3) * T4) * T5) * T6).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
          *
          S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
      {ℋ_24 : core.marker.Send.Trait T6}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
      {ℋ_26 : core.marker.Send.Trait T7}
      {ℋ_27 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t
        S
        F
        ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
      {ℋ_24 : core.marker.Send.Trait T6}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
      {ℋ_26 : core.marker.Send.Trait T7}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
      {ℋ_28 : core.marker.Send.Trait T8}
      {ℋ_29 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t
        S
        F
        (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
      {ℋ_24 : core.marker.Send.Trait T6}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
      {ℋ_26 : core.marker.Send.Trait T7}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
      {ℋ_28 : core.marker.Send.Trait T8}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
      {ℋ_30 : core.marker.Send.Trait T9}
      {ℋ_31 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t
        S
        F
        ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
      {ℋ_24 : core.marker.Send.Trait T6}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
      {ℋ_26 : core.marker.Send.Trait T7}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
      {ℋ_28 : core.marker.Send.Trait T8}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
      {ℋ_30 : core.marker.Send.Trait T9}
      {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
      {ℋ_32 : core.marker.Send.Trait T10}
      {ℋ_33 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t
        S
        F
        (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
      {ℋ_24 : core.marker.Send.Trait T6}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
      {ℋ_26 : core.marker.Send.Trait T7}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
      {ℋ_28 : core.marker.Send.Trait T8}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
      {ℋ_30 : core.marker.Send.Trait T9}
      {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
      {ℋ_32 : core.marker.Send.Trait T10}
      {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
      {ℋ_34 : core.marker.Send.Trait T11}
      {ℋ_35 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t
        S
        F
        ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
      {ℋ_24 : core.marker.Send.Trait T6}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
      {ℋ_26 : core.marker.Send.Trait T7}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
      {ℋ_28 : core.marker.Send.Trait T8}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
      {ℋ_30 : core.marker.Send.Trait T9}
      {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
      {ℋ_32 : core.marker.Send.Trait T10}
      {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
      {ℋ_34 : core.marker.Send.Trait T11}
      {ℋ_35 : axum_core.extract.FromRequestParts.Trait T12 (S := unit)}
      {ℋ_36 : core.marker.Send.Trait T12}
      {ℋ_37 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t
        S
        F
        (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
      {ℋ_24 : core.marker.Send.Trait T6}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
      {ℋ_26 : core.marker.Send.Trait T7}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
      {ℋ_28 : core.marker.Send.Trait T8}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
      {ℋ_30 : core.marker.Send.Trait T9}
      {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
      {ℋ_32 : core.marker.Send.Trait T10}
      {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
      {ℋ_34 : core.marker.Send.Trait T11}
      {ℋ_35 : axum_core.extract.FromRequestParts.Trait T12 (S := unit)}
      {ℋ_36 : core.marker.Send.Trait T12}
      {ℋ_37 : axum_core.extract.FromRequestParts.Trait T13 (S := unit)}
      {ℋ_38 : core.marker.Send.Trait T13}
      {ℋ_39 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t
        S
        F
        ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Context
      {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
      {ℋ_24 : core.marker.Send.Trait T6}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
      {ℋ_26 : core.marker.Send.Trait T7}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
      {ℋ_28 : core.marker.Send.Trait T8}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
      {ℋ_30 : core.marker.Send.Trait T9}
      {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
      {ℋ_32 : core.marker.Send.Trait T10}
      {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
      {ℋ_34 : core.marker.Send.Trait T11}
      {ℋ_35 : axum_core.extract.FromRequestParts.Trait T12 (S := unit)}
      {ℋ_36 : core.marker.Send.Trait T12}
      {ℋ_37 : axum_core.extract.FromRequestParts.Trait T13 (S := unit)}
      {ℋ_38 : core.marker.Send.Trait T13}
      {ℋ_39 : axum_core.extract.FromRequestParts.Trait T14 (S := unit)}
      {ℋ_40 : core.marker.Send.Trait T14}
      {ℋ_41 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t
        S
        F
        (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Context
      {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
      {ℋ_24 : core.marker.Send.Trait T6}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
      {ℋ_26 : core.marker.Send.Trait T7}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
      {ℋ_28 : core.marker.Send.Trait T8}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
      {ℋ_30 : core.marker.Send.Trait T9}
      {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
      {ℋ_32 : core.marker.Send.Trait T10}
      {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
      {ℋ_34 : core.marker.Send.Trait T11}
      {ℋ_35 : axum_core.extract.FromRequestParts.Trait T12 (S := unit)}
      {ℋ_36 : core.marker.Send.Trait T12}
      {ℋ_37 : axum_core.extract.FromRequestParts.Trait T13 (S := unit)}
      {ℋ_38 : core.marker.Send.Trait T13}
      {ℋ_39 : axum_core.extract.FromRequestParts.Trait T14 (S := unit)}
      {ℋ_40 : core.marker.Send.Trait T14}
      {ℋ_41 : axum_core.extract.FromRequestParts.Trait T15 (S := unit)}
      {ℋ_42 : core.marker.Send.Trait T15}
      {ℋ_43 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t
        S
        F
        ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Context
      {S
        F
        B
        Res
        Fut
        T1
        T2
        T3
        T4
        T5
        T6
        T7
        T8
        T9
        T10
        T11
        T12
        T13
        T14
        T15
        T16
        :
        Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            S::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
      {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          T16)
          *
          S::type["Error"].t)}
      {ℋ_8 : core.clone.Clone.Trait F}
      {ℋ_9 : core.marker.Send.Trait F}
      {ℋ_10 : core.future.future.Future.Trait Fut}
      {ℋ_11 : core.marker.Send.Trait Fut}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
      {ℋ_14 : core.marker.Send.Trait T1}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
      {ℋ_16 : core.marker.Send.Trait T2}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
      {ℋ_18 : core.marker.Send.Trait T3}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
      {ℋ_20 : core.marker.Send.Trait T4}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
      {ℋ_22 : core.marker.Send.Trait T5}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
      {ℋ_24 : core.marker.Send.Trait T6}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
      {ℋ_26 : core.marker.Send.Trait T7}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
      {ℋ_28 : core.marker.Send.Trait T8}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
      {ℋ_30 : core.marker.Send.Trait T9}
      {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
      {ℋ_32 : core.marker.Send.Trait T10}
      {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
      {ℋ_34 : core.marker.Send.Trait T11}
      {ℋ_35 : axum_core.extract.FromRequestParts.Trait T12 (S := unit)}
      {ℋ_36 : core.marker.Send.Trait T12}
      {ℋ_37 : axum_core.extract.FromRequestParts.Trait T13 (S := unit)}
      {ℋ_38 : core.marker.Send.Trait T13}
      {ℋ_39 : axum_core.extract.FromRequestParts.Trait T14 (S := unit)}
      {ℋ_40 : core.marker.Send.Trait T14}
      {ℋ_41 : axum_core.extract.FromRequestParts.Trait T15 (S := unit)}
      {ℋ_42 : core.marker.Send.Trait T15}
      {ℋ_43 : axum_core.extract.FromRequestParts.Trait T16 (S := unit)}
      {ℋ_44 : core.marker.Send.Trait T16}
      {ℋ_45 : core.marker.Send.Trait B}.
    
    Definition Self : Set :=
      axum.error_handling.HandleError.t
        S
        F
        (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = future::HandleErrorFuture;
    *)
    Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
                fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let f = self.f.clone();
    
                    let clone = self.inner.clone();
                    let inner = std::mem::replace(&mut self.inner, clone);
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                                Ok(value) => value,
                                Err(rejection) => return Ok(rejection.into_response()),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match inner.oneshot(req).await {
                            Ok(res) => Ok(res.into_response()),
                            Err(err) => Ok(f($($ty),*, err).await.into_response()),
                        }
                    });
    
                    future::HandleErrorFuture { future }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  
  Module future.
    Module  HandleErrorFuture.
    Section HandleErrorFuture.
      Record t : Set := {
        future :
          core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A);
      }.
      
      Definition Get_future :=
        Ref.map
          (fun α => Some α.(future))
          (fun β α => Some (α <| future := β |>)).
    End HandleErrorFuture.
    End HandleErrorFuture.
    
    Module  Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.
    Section Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.
      Definition Self : Set := axum.error_handling.future.HandleErrorFuture.t.
      
      (*
              type Output = Result<Response, Infallible>;
      *)
      Definition Output : Set :=
        core.result.Result.t
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            core.convert.Infallible.t.
      
      (*
              fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
                  self.project().future.poll(cx)
              }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.
    End Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.
  End future.
End error_handling.

Module  HandleErrorLayer.
Section HandleErrorLayer.
  Context (F T : Set).
  
  Record t : Set := {
    f : F;
    _extractor : core.marker.PhantomData.t T;
  }.
  
  Definition Get_f :=
    Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
  Definition Get__extractor :=
    Ref.map
      (fun α => Some α.(_extractor))
      (fun β α => Some (α <| _extractor := β |>)).
End HandleErrorLayer.
End HandleErrorLayer.

Module  Impl_axum_error_handling_HandleErrorLayer_t_F_T_2.
Section Impl_axum_error_handling_HandleErrorLayer_t_F_T_2.
  Context {F T : Set}.
  
  Definition Self : Set := axum.error_handling.HandleErrorLayer.t F T.
  
  (*
      pub fn new(f: F) -> Self {
          Self {
              f,
              _extractor: PhantomData,
          }
      }
  *)
  Definition new (f : F) : M Self :=
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_axum_error_handling_HandleErrorLayer_t_F_T_2.
End Impl_axum_error_handling_HandleErrorLayer_t_F_T_2.

Module  Impl_core_clone_Clone_for_axum_error_handling_HandleErrorLayer_t_F_T.
Section Impl_core_clone_Clone_for_axum_error_handling_HandleErrorLayer_t_F_T.
  Context {F T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait F}.
  
  Definition Self : Set := axum.error_handling.HandleErrorLayer.t F T.
  
  (*
      fn clone(&self) -> Self {
          Self {
              f: self.f.clone(),
              _extractor: PhantomData,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_error_handling_HandleErrorLayer_t_F_T.
End Impl_core_clone_Clone_for_axum_error_handling_HandleErrorLayer_t_F_T.

Module  Impl_core_fmt_Debug_for_axum_error_handling_HandleErrorLayer_t_F_E.
Section Impl_core_fmt_Debug_for_axum_error_handling_HandleErrorLayer_t_F_E.
  Context {F E : Set}.
  
  Definition Self : Set := axum.error_handling.HandleErrorLayer.t F E.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("HandleErrorLayer")
              .field("f", &format_args!("{}", std::any::type_name::<F>()))
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_error_handling_HandleErrorLayer_t_F_E.
End Impl_core_fmt_Debug_for_axum_error_handling_HandleErrorLayer_t_F_E.

Module  Impl_tower_layer_Layer_S_for_axum_error_handling_HandleErrorLayer_t_F_T.
Section Impl_tower_layer_Layer_S_for_axum_error_handling_HandleErrorLayer_t_F_T.
  Context {S F T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait F}.
  
  Definition Self : Set := axum.error_handling.HandleErrorLayer.t F T.
  
  (*
      type Service = HandleError<S, F, T>;
  *)
  Definition Service : Set := axum.error_handling.HandleError.t S F T.
  
  (*
      fn layer(&self, inner: S) -> Self::Service {
          HandleError::new(inner, self.f.clone())
      }
  *)
  Definition layer (self : ref Self) (inner : S) : M Service :=
    let* self := M.alloc self in
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_layer :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer;
  }.
  
  Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
    tower_layer.Layer.Service := Service;
    tower_layer.Layer.layer := layer;
  }.
End Impl_tower_layer_Layer_S_for_axum_error_handling_HandleErrorLayer_t_F_T.
End Impl_tower_layer_Layer_S_for_axum_error_handling_HandleErrorLayer_t_F_T.

Module  HandleError.
Section HandleError.
  Context (S F T : Set).
  
  Record t : Set := {
    inner : S;
    f : F;
    _extractor : core.marker.PhantomData.t T;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Definition Get_f :=
    Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
  Definition Get__extractor :=
    Ref.map
      (fun α => Some α.(_extractor))
      (fun β α => Some (α <| _extractor := β |>)).
End HandleError.
End HandleError.

Module  Impl_axum_error_handling_HandleError_t_S_F_T_2.
Section Impl_axum_error_handling_HandleError_t_S_F_T_2.
  Context {S F T : Set}.
  
  Definition Self : Set := axum.error_handling.HandleError.t S F T.
  
  (*
      pub fn new(inner: S, f: F) -> Self {
          Self {
              inner,
              f,
              _extractor: PhantomData,
          }
      }
  *)
  Definition new (inner : S) (f : F) : M Self :=
    let* inner := M.alloc inner in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_axum_error_handling_HandleError_t_S_F_T_2.
End Impl_axum_error_handling_HandleError_t_S_F_T_2.

Module  Impl_core_clone_Clone_for_axum_error_handling_HandleError_t_S_F_T.
Section Impl_core_clone_Clone_for_axum_error_handling_HandleError_t_S_F_T.
  Context {S F T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S} {ℋ_1 : core.clone.Clone.Trait F}.
  
  Definition Self : Set := axum.error_handling.HandleError.t S F T.
  
  (*
      fn clone(&self) -> Self {
          Self {
              inner: self.inner.clone(),
              f: self.f.clone(),
              _extractor: PhantomData,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_error_handling_HandleError_t_S_F_T.
End Impl_core_clone_Clone_for_axum_error_handling_HandleError_t_S_F_T.

Module  Impl_core_fmt_Debug_for_axum_error_handling_HandleError_t_S_F_E.
Section Impl_core_fmt_Debug_for_axum_error_handling_HandleError_t_S_F_E.
  Context {S F E : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set := axum.error_handling.HandleError.t S F E.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("HandleError")
              .field("inner", &self.inner)
              .field("f", &format_args!("{}", std::any::type_name::<F>()))
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_error_handling_HandleError_t_S_F_E.
End Impl_core_fmt_Debug_for_axum_error_handling_HandleError_t_S_F_E.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_.
  Context {S F B Fut Res : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 : core.ops.function.FnOnce.Trait F (Args := S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : core.marker.Send.Trait B}.
  
  Definition Self : Set := axum.error_handling.HandleError.t S F unit.
  
  (*
      type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
      fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          Poll::Ready(Ok(()))
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, req: Request<B>) -> Self::Future {
          let f = self.f.clone();
  
          let clone = self.inner.clone();
          let inner = std::mem::replace(&mut self.inner, clone);
  
          let future = Box::pin(async move {
              match inner.oneshot(req).await {
                  Ok(res) => Ok(res.into_response()),
                  Err(err) => Ok(f(err).await.into_response()),
              }
          });
  
          future::HandleErrorFuture { future }
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_.
  Context {S F B Res Fut T1 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 : core.ops.function.FnOnce.Trait F (Args := T1 * S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : core.marker.Send.Trait B}.
  
  Definition Self : Set := axum.error_handling.HandleError.t S F T1.
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_.
  Context {S F B Res Fut T1 T2 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F (Args := (T1 * T2) * S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : core.marker.Send.Trait B}.
  
  Definition Self : Set := axum.error_handling.HandleError.t S F (T1 * T2).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_.
  Context {S F B Res Fut T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := ((T1 * T2) * T3) * S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t S F ((T1 * T2) * T3).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_.
  Context {S F B Res Fut T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := (((T1 * T2) * T3) * T4) * S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t S F (((T1 * T2) * T3) * T4).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_.
  Context {S F B Res Fut T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((T1 * T2) * T3) * T4) * T5) * S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t S F ((((T1 * T2) * T3) * T4) * T5).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_.
  Context {S F B Res Fut T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((T1 * T2) * T3) * T4) * T5) * T6) * S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
    {ℋ_24 : core.marker.Send.Trait T6}
    {ℋ_25 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t S F (((((T1 * T2) * T3) * T4) * T5) * T6).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
        *
        S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
    {ℋ_24 : core.marker.Send.Trait T6}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
    {ℋ_26 : core.marker.Send.Trait T7}
    {ℋ_27 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t
      S
      F
      ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
    {ℋ_24 : core.marker.Send.Trait T6}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
    {ℋ_26 : core.marker.Send.Trait T7}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
    {ℋ_28 : core.marker.Send.Trait T8}
    {ℋ_29 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t
      S
      F
      (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
    {ℋ_24 : core.marker.Send.Trait T6}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
    {ℋ_26 : core.marker.Send.Trait T7}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
    {ℋ_28 : core.marker.Send.Trait T8}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
    {ℋ_30 : core.marker.Send.Trait T9}
    {ℋ_31 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t
      S
      F
      ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
    {ℋ_24 : core.marker.Send.Trait T6}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
    {ℋ_26 : core.marker.Send.Trait T7}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
    {ℋ_28 : core.marker.Send.Trait T8}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
    {ℋ_30 : core.marker.Send.Trait T9}
    {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
    {ℋ_32 : core.marker.Send.Trait T10}
    {ℋ_33 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t
      S
      F
      (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
    {ℋ_24 : core.marker.Send.Trait T6}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
    {ℋ_26 : core.marker.Send.Trait T7}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
    {ℋ_28 : core.marker.Send.Trait T8}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
    {ℋ_30 : core.marker.Send.Trait T9}
    {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
    {ℋ_32 : core.marker.Send.Trait T10}
    {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
    {ℋ_34 : core.marker.Send.Trait T11}
    {ℋ_35 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t
      S
      F
      ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
    {ℋ_24 : core.marker.Send.Trait T6}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
    {ℋ_26 : core.marker.Send.Trait T7}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
    {ℋ_28 : core.marker.Send.Trait T8}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
    {ℋ_30 : core.marker.Send.Trait T9}
    {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
    {ℋ_32 : core.marker.Send.Trait T10}
    {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
    {ℋ_34 : core.marker.Send.Trait T11}
    {ℋ_35 : axum_core.extract.FromRequestParts.Trait T12 (S := unit)}
    {ℋ_36 : core.marker.Send.Trait T12}
    {ℋ_37 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t
      S
      F
      (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
    {ℋ_24 : core.marker.Send.Trait T6}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
    {ℋ_26 : core.marker.Send.Trait T7}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
    {ℋ_28 : core.marker.Send.Trait T8}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
    {ℋ_30 : core.marker.Send.Trait T9}
    {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
    {ℋ_32 : core.marker.Send.Trait T10}
    {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
    {ℋ_34 : core.marker.Send.Trait T11}
    {ℋ_35 : axum_core.extract.FromRequestParts.Trait T12 (S := unit)}
    {ℋ_36 : core.marker.Send.Trait T12}
    {ℋ_37 : axum_core.extract.FromRequestParts.Trait T13 (S := unit)}
    {ℋ_38 : core.marker.Send.Trait T13}
    {ℋ_39 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t
      S
      F
      ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Context {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
    {ℋ_24 : core.marker.Send.Trait T6}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
    {ℋ_26 : core.marker.Send.Trait T7}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
    {ℋ_28 : core.marker.Send.Trait T8}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
    {ℋ_30 : core.marker.Send.Trait T9}
    {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
    {ℋ_32 : core.marker.Send.Trait T10}
    {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
    {ℋ_34 : core.marker.Send.Trait T11}
    {ℋ_35 : axum_core.extract.FromRequestParts.Trait T12 (S := unit)}
    {ℋ_36 : core.marker.Send.Trait T12}
    {ℋ_37 : axum_core.extract.FromRequestParts.Trait T13 (S := unit)}
    {ℋ_38 : core.marker.Send.Trait T13}
    {ℋ_39 : axum_core.extract.FromRequestParts.Trait T14 (S := unit)}
    {ℋ_40 : core.marker.Send.Trait T14}
    {ℋ_41 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t
      S
      F
      (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Context
    {S F B Res Fut T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
    {ℋ_24 : core.marker.Send.Trait T6}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
    {ℋ_26 : core.marker.Send.Trait T7}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
    {ℋ_28 : core.marker.Send.Trait T8}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
    {ℋ_30 : core.marker.Send.Trait T9}
    {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
    {ℋ_32 : core.marker.Send.Trait T10}
    {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
    {ℋ_34 : core.marker.Send.Trait T11}
    {ℋ_35 : axum_core.extract.FromRequestParts.Trait T12 (S := unit)}
    {ℋ_36 : core.marker.Send.Trait T12}
    {ℋ_37 : axum_core.extract.FromRequestParts.Trait T13 (S := unit)}
    {ℋ_38 : core.marker.Send.Trait T13}
    {ℋ_39 : axum_core.extract.FromRequestParts.Trait T14 (S := unit)}
    {ℋ_40 : core.marker.Send.Trait T14}
    {ℋ_41 : axum_core.extract.FromRequestParts.Trait T15 (S := unit)}
    {ℋ_42 : core.marker.Send.Trait T15}
    {ℋ_43 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t
      S
      F
      ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Context
    {S
      F
      B
      Res
      Fut
      T1
      T2
      T3
      T4
      T5
      T6
      T7
      T8
      T9
      T10
      T11
      T12
      T13
      T14
      T15
      T16
      :
      Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait S::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait S::type["Response"].t}
    {ℋ_5 : core.marker.Send.Trait S::type["Error"].t}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)
        *
        S::type["Error"].t)}
    {ℋ_8 : core.clone.Clone.Trait F}
    {ℋ_9 : core.marker.Send.Trait F}
    {ℋ_10 : core.future.future.Future.Trait Fut}
    {ℋ_11 : core.marker.Send.Trait Fut}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T1 (S := unit)}
    {ℋ_14 : core.marker.Send.Trait T1}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T2 (S := unit)}
    {ℋ_16 : core.marker.Send.Trait T2}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T3 (S := unit)}
    {ℋ_18 : core.marker.Send.Trait T3}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T4 (S := unit)}
    {ℋ_20 : core.marker.Send.Trait T4}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T5 (S := unit)}
    {ℋ_22 : core.marker.Send.Trait T5}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T6 (S := unit)}
    {ℋ_24 : core.marker.Send.Trait T6}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T7 (S := unit)}
    {ℋ_26 : core.marker.Send.Trait T7}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T8 (S := unit)}
    {ℋ_28 : core.marker.Send.Trait T8}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T9 (S := unit)}
    {ℋ_30 : core.marker.Send.Trait T9}
    {ℋ_31 : axum_core.extract.FromRequestParts.Trait T10 (S := unit)}
    {ℋ_32 : core.marker.Send.Trait T10}
    {ℋ_33 : axum_core.extract.FromRequestParts.Trait T11 (S := unit)}
    {ℋ_34 : core.marker.Send.Trait T11}
    {ℋ_35 : axum_core.extract.FromRequestParts.Trait T12 (S := unit)}
    {ℋ_36 : core.marker.Send.Trait T12}
    {ℋ_37 : axum_core.extract.FromRequestParts.Trait T13 (S := unit)}
    {ℋ_38 : core.marker.Send.Trait T13}
    {ℋ_39 : axum_core.extract.FromRequestParts.Trait T14 (S := unit)}
    {ℋ_40 : core.marker.Send.Trait T14}
    {ℋ_41 : axum_core.extract.FromRequestParts.Trait T15 (S := unit)}
    {ℋ_42 : core.marker.Send.Trait T15}
    {ℋ_43 : axum_core.extract.FromRequestParts.Trait T16 (S := unit)}
    {ℋ_44 : core.marker.Send.Trait T16}
    {ℋ_45 : core.marker.Send.Trait B}.
  
  Definition Self : Set :=
    axum.error_handling.HandleError.t
      S
      F
      (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = future::HandleErrorFuture;
  *)
  Definition Future : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
              fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  Poll::Ready(Ok(()))
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let f = self.f.clone();
  
                  let clone = self.inner.clone();
                  let inner = std::mem::replace(&mut self.inner, clone);
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &()).await {
                              Ok(value) => value,
                              Err(rejection) => return Ok(rejection.into_response()),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match inner.oneshot(req).await {
                          Ok(res) => Ok(res.into_response()),
                          Err(err) => Ok(f($($ty),*, err).await.into_response()),
                      }
                  });
  
                  future::HandleErrorFuture { future }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_error_handling_HandleError_t_S_F_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.

Module future.
  Module  HandleErrorFuture.
  Section HandleErrorFuture.
    Record t : Set := {
      future :
        core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A);
    }.
    
    Definition Get_future :=
      Ref.map
        (fun α => Some α.(future))
        (fun β α => Some (α <| future := β |>)).
  End HandleErrorFuture.
  End HandleErrorFuture.
  
  Module  Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.
  Section Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.
    Definition Self : Set := axum.error_handling.future.HandleErrorFuture.t.
    
    (*
            type Output = Result<Response, Infallible>;
    *)
    Definition Output : Set :=
      core.result.Result.t
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          core.convert.Infallible.t.
    
    (*
            fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
                self.project().future.poll(cx)
            }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.
  End Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.
End future.

Module  HandleErrorFuture.
Section HandleErrorFuture.
  Record t : Set := {
    future :
      core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A);
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End HandleErrorFuture.
End HandleErrorFuture.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Record t : Set := {
    future :
      core.pin.Pin.t
        (mut_ref
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Record t : Set := {
    future :
      core.pin.Pin.t
        (ref
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_error_handling_future_HandleErrorFuture_t.
Section Impl_axum_error_handling_future_HandleErrorFuture_t.
  Definition Self : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M axum.error_handling.future._.Projection.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M axum.error_handling.future._.ProjectionRef.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_error_handling_future_HandleErrorFuture_t.
End Impl_axum_error_handling_future_HandleErrorFuture_t.

Module  __Origin.
Section __Origin.
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    future :
      core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A);
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_error_handling_future_HandleErrorFuture_t.
Section Impl_core_marker_Unpin_for_axum_error_handling_future_HandleErrorFuture_t.
  Context
    {ℋ_0 : core.marker.Unpin.Trait axum.error_handling.future._.__Origin.t}.
  
  Definition Self : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_error_handling_future_HandleErrorFuture_t.
End Impl_core_marker_Unpin_for_axum_error_handling_future_HandleErrorFuture_t.

Module  Impl_axum_error_handling_future___MustNotImplDrop_for_T.
Section Impl_axum_error_handling_future___MustNotImplDrop_for_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.ops.drop.Drop.Trait T}.
  
  Definition Self : Set := T.
  
  Global Instance ℐ :
    axum.error_handling.future._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_error_handling_future___MustNotImplDrop_for_T.
End Impl_axum_error_handling_future___MustNotImplDrop_for_T.

Module  Impl_axum_error_handling_future___MustNotImplDrop_for_axum_error_handling_future_HandleErrorFuture_t.
Section Impl_axum_error_handling_future___MustNotImplDrop_for_axum_error_handling_future_HandleErrorFuture_t.
  Definition Self : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  Global Instance ℐ :
    axum.error_handling.future._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_error_handling_future___MustNotImplDrop_for_axum_error_handling_future_HandleErrorFuture_t.
End Impl_axum_error_handling_future___MustNotImplDrop_for_axum_error_handling_future_HandleErrorFuture_t.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    (this : ref axum.error_handling.future.HandleErrorFuture.t)
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module  Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.
Section Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.
  Definition Self : Set := axum.error_handling.future.HandleErrorFuture.t.
  
  (*
          type Output = Result<Response, Infallible>;
  *)
  Definition Output : Set :=
    core.result.Result.t
        ltac:(axum_core.response.Response axum_core.response.Response.Default.T)
        core.convert.Infallible.t.
  
  (*
          fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
              self.project().future.poll(cx)
          }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.
End Impl_core_future_future_Future_for_axum_error_handling_future_HandleErrorFuture_t.

Module extract.
  Module connect_info.
    Module  IntoMakeServiceWithConnectInfo.
    Section IntoMakeServiceWithConnectInfo.
      Context (S C : Set).
      
      Record t : Set := {
        svc : S;
        _connect_info : core.marker.PhantomData.t C;
      }.
      
      Definition Get_svc :=
        Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
      Definition Get__connect_info :=
        Ref.map
          (fun α => Some α.(_connect_info))
          (fun β α => Some (α <| _connect_info := β |>)).
    End IntoMakeServiceWithConnectInfo.
    End IntoMakeServiceWithConnectInfo.
    
    Module  Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    Section Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
      Context {S C : Set}.
      
      Definition Self : Set :=
        axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
      
      (*
          pub(crate) fn new(svc: S) -> Self {
              Self {
                  svc,
                  _connect_info: PhantomData,
              }
          }
      *)
      Definition new (svc : S) : M Self :=
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    End Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    Section Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
      Context {S C : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S}.
      
      Definition Self : Set :=
        axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("IntoMakeServiceWithConnectInfo")
                  .field("svc", &self.svc)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    End Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    
    Module  Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    Section Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
      Context {S C : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  svc: self.svc.clone(),
                  _connect_info: PhantomData,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    End Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    
    Module  Connected.
    Section Connected.
      Class Trait (Self : Set) {T : Set} : Type := {
        ℒ_0 :: core.clone.Clone.Trait Self;
        ℒ_1 :: core.marker.Send.Trait Self;
        ℒ_2 :: core.marker.Sync.Trait Self;
        connect_info : T -> M Self;
      }.
      
    End Connected.
    End Connected.
    
    Module  Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.
    Section Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.
      Definition Self : Set := core.net.socket_addr.SocketAddr.t.
      
      (*
          fn connect_info(remote_addr: SocketAddr) -> Self {
              remote_addr
          }
      *)
      Definition connect_info
          (remote_addr : core.net.socket_addr.SocketAddr.t)
          : M Self :=
        let* remote_addr := M.alloc remote_addr in
        M.read foo.
      
      Global Instance AssociatedFunction_connect_info :
        Notations.DoubleColon Self "connect_info" := {
        Notations.double_colon := connect_info;
      }.
      
      Global Instance ℐ :
        axum.extract.connect_info.Connected.Trait Self
          (T := core.net.socket_addr.SocketAddr.t) := {
        axum.extract.connect_info.Connected.connect_info := connect_info;
      }.
    End Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.
    End Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.
    
    Module  Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    Section Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
      Context {S C T : Set}.
      
      Context
        {ℋ_0 : core.clone.Clone.Trait S}
        {ℋ_1 : axum.extract.connect_info.Connected.Trait C (T := T)}.
      
      Definition Self : Set :=
        axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
      
      (*
          type Response = AddExtension<S, ConnectInfo<C>>;
      *)
      Definition Response : Set :=
        axum.extension.AddExtension.t
            S
            (axum.extract.connect_info.ConnectInfo.t C).
      
      (*
          type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
          type Future = ResponseFuture<S, C>;
      *)
      Definition Future : Set := axum.extract.connect_info.ResponseFuture.t S C.
      
      (*
          fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              Poll::Ready(Ok(()))
          }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (_cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* _cx := M.alloc _cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
          fn call(&mut self, target: T) -> Self::Future {
              let connect_info = ConnectInfo(C::connect_info(target));
              let svc = Extension(connect_info).layer(self.svc.clone());
              ResponseFuture::new(ready(Ok(svc)))
          }
      *)
      Definition call (self : mut_ref Self) (target : T) : M Future :=
        let* self := M.alloc self in
        let* target := M.alloc target in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ : tower_service.Service.Trait Self (Request := T) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    End Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    
    Module  ResponseFuture.
    Section ResponseFuture.
      Context (S C : Set).
      
      Record t : Set := {
        future :
          core.future.ready.Ready.t
            (core.result.Result.t
              (axum.extension.AddExtension.t
                S
                (axum.extract.connect_info.ConnectInfo.t C))
              core.convert.Infallible.t);
      }.
      
      Definition Get_future :=
        Ref.map
          (fun α => Some α.(future))
          (fun β α => Some (α <| future := β |>)).
    End ResponseFuture.
    End ResponseFuture.
    
    Module  Impl_axum_extract_connect_info_ResponseFuture_t_S_C.
    Section Impl_axum_extract_connect_info_ResponseFuture_t_S_C.
      Context {S C : Set}.
      
      Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
      
      (*
                  pub(crate) fn new(future: $actual) -> Self {
                      Self { future }
                  }
      *)
      Definition new
          (future
            :
            core.future.ready.Ready.t
              (core.result.Result.t
                (axum.extension.AddExtension.t
                  S
                  (axum.extract.connect_info.ConnectInfo.t C))
                core.convert.Infallible.t))
          : M Self :=
        let* future := M.alloc future in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_axum_extract_connect_info_ResponseFuture_t_S_C.
    End Impl_axum_extract_connect_info_ResponseFuture_t_S_C.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.
    Section Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.
      Context {S C : Set}.
      
      Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      f.debug_struct(stringify!($name)).finish_non_exhaustive()
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.
    End Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.
    
    Module  Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.
    Section Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.
      Context {S C : Set}.
      
      Context
        {ℋ_0 :
          core.future.future.Future.Trait
              (core.future.ready.Ready.t
                (core.result.Result.t
                  (axum.extension.AddExtension.t
                    S
                    (axum.extract.connect_info.ConnectInfo.t C))
                  core.convert.Infallible.t))}.
      
      Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
      
      (*
                  type Output = <$actual as std::future::Future>::Output;
      *)
      Definition Output : Set :=
        core.future.future.Future.Output
            (Self := core.future.ready.Ready.t
              (core.result.Result.t
                (axum.extension.AddExtension.t
                  S
                  (axum.extract.connect_info.ConnectInfo.t C))
                core.convert.Infallible.t))
            (Trait := ltac:(refine _)).
      
      (*
                  fn poll(
                      self: std::pin::Pin<&mut Self>,
                      cx: &mut std::task::Context<'_>,
                  ) -> std::task::Poll<Self::Output> {
                      self.project().future.poll(cx)
                  }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.
    End Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.
    
    Module  ConnectInfo.
    Section ConnectInfo.
      Context {T : Set}.
      
      Record t : Set := {
        x0 : T;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End ConnectInfo.
    End ConnectInfo.
    
    Module  Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.
    Section Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait T}.
      
      Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M (axum.extract.connect_info.ConnectInfo.t T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.
    End Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.
    
    Module  Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.
    Section Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.marker.Copy.Trait T}.
      
      Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.
    End Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.
    Section Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait T}.
      
      Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.
    End Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.
      Context {S T : Set}.
      
      Context
        {ℋ_0 : core.marker.Send.Trait S}
        {ℋ_1 : core.marker.Sync.Trait S}
        {ℋ_2 : core.clone.Clone.Trait T}
        {ℋ_3 : core.marker.Send.Trait T}
        {ℋ_4 : core.marker.Sync.Trait T}.
      
      Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
      
      (*
          type Rejection = <Extension<Self> as FromRequestParts<S>>::Rejection;
      *)
      Definition Rejection : Set :=
        axum_core.extract.FromRequestParts.Rejection
            (Self := axum.extension.Extension.t Self)
            (Trait := ltac:(refine _)).
      
      (*
          async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
              match Extension::<Self>::from_request_parts(parts, state).await {
                  Ok(Extension(connect_info)) => Ok(connect_info),
                  Err(err) => match parts.extensions.get::<MockConnectInfo<T>>() {
                      Some(MockConnectInfo(connect_info)) => Ok(Self(connect_info.clone())),
                      None => Err(err),
                  },
              }
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.
    
    Module  Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.
    Section Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.
      Context {T : Set}.
      
      Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
      
      (*
                  type Target = T;
      *)
      Definition Target : Set := T.
      
      (*
                  fn deref(&self) -> &Self::Target {
                      &self.0
                  }
      *)
      Definition deref (self : ref Self) : M (ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref :
        Notations.DoubleColon Self "deref" := {
        Notations.double_colon := deref;
      }.
      
      Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
        core.ops.deref.Deref.Target := Target;
        core.ops.deref.Deref.deref := deref;
      }.
    End Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.
    End Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.
    
    Module  Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.
    Section Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.
      Context {T : Set}.
      
      Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
      
      (*
                  fn deref_mut(&mut self) -> &mut Self::Target {
                      &mut self.0
                  }
      *)
      Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref_mut :
        Notations.DoubleColon Self "deref_mut" := {
        Notations.double_colon := deref_mut;
      }.
      
      Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
        core.ops.deref.DerefMut.deref_mut := deref_mut;
      }.
    End Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.
    End Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.
    
    Module  MockConnectInfo.
    Section MockConnectInfo.
      Context {T : Set}.
      
      Record t : Set := {
        x0 : T;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End MockConnectInfo.
    End MockConnectInfo.
    
    Module  Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.
    Section Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait T}.
      
      Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M (axum.extract.connect_info.MockConnectInfo.t T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.
    End Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.
    
    Module  Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.
    Section Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.marker.Copy.Trait T}.
      
      Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.
    End Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.
    Section Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait T}.
      
      Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.
    End Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.
    
    Module  Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.
    Section Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.
      Context {S T : Set}.
      
      Context
        {ℋ_0 : core.clone.Clone.Trait T}
        {ℋ_1 : core.marker.Send.Trait T}
        {ℋ_2 : core.marker.Sync.Trait T}.
      
      Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
      
      (*
          type Service = <Extension<Self> as Layer<S>>::Service;
      *)
      Definition Service : Set :=
        tower_layer.Layer.Service
            (Self := axum.extension.Extension.t Self)
            (Trait := ltac:(refine _)).
      
      (*
          fn layer(&self, inner: S) -> Self::Service {
              Extension(self.clone()).layer(inner)
          }
      *)
      Definition layer (self : ref Self) (inner : S) : M Service :=
        let* self := M.alloc self in
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_layer :
        Notations.DoubleColon Self "layer" := {
        Notations.double_colon := layer;
      }.
      
      Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
        tower_layer.Layer.Service := Service;
        tower_layer.Layer.layer := layer;
      }.
    End Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.
    End Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.
  End connect_info.
  
  Module path.
    Module de.
      Module  PathDeserializer.
      Section PathDeserializer.
        Record t : Set := {
          url_params :
            ref
              (slice
                ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
                *
                axum.util.PercentDecodedStr.t));
        }.
        
        Definition Get_url_params :=
          Ref.map
            (fun α => Some α.(url_params))
            (fun β α => Some (α <| url_params := β |>)).
      End PathDeserializer.
      End PathDeserializer.
      
      Module  Impl_axum_extract_path_de_PathDeserializer_t.
      Section Impl_axum_extract_path_de_PathDeserializer_t.
        Definition Self : Set := axum.extract.path.de.PathDeserializer.t.
        
        (*
            pub(crate) fn new(url_params: &'de [(Arc<str>, PercentDecodedStr)]) -> Self {
                PathDeserializer { url_params }
            }
        *)
        Definition new
            (url_params
              :
              ref
                (slice
                  ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
                  *
                  axum.util.PercentDecodedStr.t)))
            : M Self :=
          let* url_params := M.alloc url_params in
          M.read foo.
        
        Global Instance AssociatedFunction_new :
          Notations.DoubleColon Self "new" := {
          Notations.double_colon := new;
        }.
      End Impl_axum_extract_path_de_PathDeserializer_t.
      End Impl_axum_extract_path_de_PathDeserializer_t.
      
      Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
      Section Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
        Definition Self : Set := axum.extract.path.de.PathDeserializer.t.
        
        (*
            type Error = PathDeserializationError;
        *)
        Definition Error : Set := axum.extract.path.PathDeserializationError.t.
        
        (*
                fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    Err(PathDeserializationError::unsupported_type(type_name::<
                        V::Value,
                    >()))
                }
        *)
        Definition deserialize_bytes
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (Pattern : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* Pattern := M.alloc Pattern in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_bytes
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_bytes" := {
          Notations.double_colon := deserialize_bytes (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    Err(PathDeserializationError::unsupported_type(type_name::<
                        V::Value,
                    >()))
                }
        *)
        Definition deserialize_option
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (Pattern : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* Pattern := M.alloc Pattern in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_option
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_option" := {
          Notations.double_colon := deserialize_option (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    Err(PathDeserializationError::unsupported_type(type_name::<
                        V::Value,
                    >()))
                }
        *)
        Definition deserialize_identifier
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (Pattern : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* Pattern := M.alloc Pattern in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_identifier
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_identifier" := {
          Notations.double_colon := deserialize_identifier (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    Err(PathDeserializationError::unsupported_type(type_name::<
                        V::Value,
                    >()))
                }
        *)
        Definition deserialize_ignored_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (Pattern : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* Pattern := M.alloc Pattern in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_ignored_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_ignored_any" := {
          Notations.double_colon := deserialize_ignored_any (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_bool
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_bool
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_bool" := {
          Notations.double_colon := deserialize_bool (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_i8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i8" := {
          Notations.double_colon := deserialize_i8 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_i16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i16" := {
          Notations.double_colon := deserialize_i16 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_i32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i32" := {
          Notations.double_colon := deserialize_i32 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_i64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i64" := {
          Notations.double_colon := deserialize_i64 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_i128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i128" := {
          Notations.double_colon := deserialize_i128 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_u8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u8" := {
          Notations.double_colon := deserialize_u8 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_u16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u16" := {
          Notations.double_colon := deserialize_u16 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_u32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u32" := {
          Notations.double_colon := deserialize_u32 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_u64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u64" := {
          Notations.double_colon := deserialize_u64 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_u128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u128" := {
          Notations.double_colon := deserialize_u128 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_f32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_f32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_f32" := {
          Notations.double_colon := deserialize_f32 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_f64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_f64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_f64" := {
          Notations.double_colon := deserialize_f64 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_string
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_string
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_string" := {
          Notations.double_colon := deserialize_string (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_byte_buf
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_byte_buf
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_byte_buf" := {
          Notations.double_colon := deserialize_byte_buf (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    if self.url_params.len() != 1 {
                        return Err(PathDeserializationError::wrong_number_of_parameters()
                            .got(self.url_params.len())
                            .expected(1));
                    }
        
                    let value = self.url_params[0].1.parse().map_err(|_| {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.url_params[0].1.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    })?;
                    visitor.$visit_fn(value)
                }
        *)
        Definition deserialize_char
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_char
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_char" := {
          Notations.double_colon := deserialize_char (V := V);
        }.
        
        (*
            fn deserialize_any<V>(self, v: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_str(v)
            }
        *)
        Definition deserialize_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (v : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* v := M.alloc v in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_any" := {
          Notations.double_colon := deserialize_any (V := V);
        }.
        
        (*
            fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
                visitor.visit_borrowed_str(&self.url_params[0].1)
            }
        *)
        Definition deserialize_str
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_str
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_str" := {
          Notations.double_colon := deserialize_str (V := V);
        }.
        
        (*
            fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_unit()
            }
        *)
        Definition deserialize_unit
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_unit
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_unit" := {
          Notations.double_colon := deserialize_unit (V := V);
        }.
        
        (*
            fn deserialize_unit_struct<V>(
                self,
                _name: &'static str,
                visitor: V,
            ) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_unit()
            }
        *)
        Definition deserialize_unit_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_name : ref str.t)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _name := M.alloc _name in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_unit_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_unit_struct" := {
          Notations.double_colon := deserialize_unit_struct (V := V);
        }.
        
        (*
            fn deserialize_newtype_struct<V>(
                self,
                _name: &'static str,
                visitor: V,
            ) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_newtype_struct(self)
            }
        *)
        Definition deserialize_newtype_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_name : ref str.t)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _name := M.alloc _name in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_newtype_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_newtype_struct" := {
          Notations.double_colon := deserialize_newtype_struct (V := V);
        }.
        
        (*
            fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_seq(SeqDeserializer {
                    params: self.url_params,
                    idx: 0,
                })
            }
        *)
        Definition deserialize_seq
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_seq
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_seq" := {
          Notations.double_colon := deserialize_seq (V := V);
        }.
        
        (*
            fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() < len {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(len));
                }
                visitor.visit_seq(SeqDeserializer {
                    params: self.url_params,
                    idx: 0,
                })
            }
        *)
        Definition deserialize_tuple
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (len : usize.t)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* len := M.alloc len in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_tuple
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_tuple" := {
          Notations.double_colon := deserialize_tuple (V := V);
        }.
        
        (*
            fn deserialize_tuple_struct<V>(
                self,
                _name: &'static str,
                len: usize,
                visitor: V,
            ) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() < len {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(len));
                }
                visitor.visit_seq(SeqDeserializer {
                    params: self.url_params,
                    idx: 0,
                })
            }
        *)
        Definition deserialize_tuple_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_name : ref str.t)
            (len : usize.t)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _name := M.alloc _name in
          let* len := M.alloc len in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_tuple_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_tuple_struct" := {
          Notations.double_colon := deserialize_tuple_struct (V := V);
        }.
        
        (*
            fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_map(MapDeserializer {
                    params: self.url_params,
                    value: None,
                    key: None,
                })
            }
        *)
        Definition deserialize_map
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_map
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_map" := {
          Notations.double_colon := deserialize_map (V := V);
        }.
        
        (*
            fn deserialize_struct<V>(
                self,
                _name: &'static str,
                _fields: &'static [&'static str],
                visitor: V,
            ) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_map(visitor)
            }
        *)
        Definition deserialize_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_name : ref str.t)
            (_fields : ref (slice (ref str.t)))
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _name := M.alloc _name in
          let* _fields := M.alloc _fields in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_struct" := {
          Notations.double_colon := deserialize_struct (V := V);
        }.
        
        (*
            fn deserialize_enum<V>(
                self,
                _name: &'static str,
                _variants: &'static [&'static str],
                visitor: V,
            ) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
        
                visitor.visit_enum(EnumDeserializer {
                    value: self.url_params[0].1.clone().into_inner(),
                })
            }
        *)
        Definition deserialize_enum
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_name : ref str.t)
            (_variants : ref (slice (ref str.t)))
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _name := M.alloc _name in
          let* _variants := M.alloc _variants in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_enum
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_enum" := {
          Notations.double_colon := deserialize_enum (V := V);
        }.
        
        Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
          serde.de.Deserializer.Error := Error;
          serde.de.Deserializer.deserialize_bytes
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_bytes (V := V);
          serde.de.Deserializer.deserialize_option
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_option (V := V);
          serde.de.Deserializer.deserialize_identifier
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_identifier (V := V);
          serde.de.Deserializer.deserialize_ignored_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_ignored_any (V := V);
          serde.de.Deserializer.deserialize_bool
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_bool (V := V);
          serde.de.Deserializer.deserialize_i8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i8 (V := V);
          serde.de.Deserializer.deserialize_i16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i16 (V := V);
          serde.de.Deserializer.deserialize_i32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i32 (V := V);
          serde.de.Deserializer.deserialize_i64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i64 (V := V);
          serde.de.Deserializer.deserialize_i128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            Datatypes.Some (deserialize_i128 (V := V));
          serde.de.Deserializer.deserialize_u8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u8 (V := V);
          serde.de.Deserializer.deserialize_u16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u16 (V := V);
          serde.de.Deserializer.deserialize_u32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u32 (V := V);
          serde.de.Deserializer.deserialize_u64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u64 (V := V);
          serde.de.Deserializer.deserialize_u128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            Datatypes.Some (deserialize_u128 (V := V));
          serde.de.Deserializer.deserialize_f32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_f32 (V := V);
          serde.de.Deserializer.deserialize_f64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_f64 (V := V);
          serde.de.Deserializer.deserialize_string
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_string (V := V);
          serde.de.Deserializer.deserialize_byte_buf
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_byte_buf (V := V);
          serde.de.Deserializer.deserialize_char
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_char (V := V);
          serde.de.Deserializer.deserialize_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_any (V := V);
          serde.de.Deserializer.deserialize_str
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_str (V := V);
          serde.de.Deserializer.deserialize_unit
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_unit (V := V);
          serde.de.Deserializer.deserialize_unit_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_unit_struct (V := V);
          serde.de.Deserializer.deserialize_newtype_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_newtype_struct (V := V);
          serde.de.Deserializer.deserialize_seq
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_seq (V := V);
          serde.de.Deserializer.deserialize_tuple
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_tuple (V := V);
          serde.de.Deserializer.deserialize_tuple_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_tuple_struct (V := V);
          serde.de.Deserializer.deserialize_map
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_map (V := V);
          serde.de.Deserializer.deserialize_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_struct (V := V);
          serde.de.Deserializer.deserialize_enum
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_enum (V := V);
          serde.de.Deserializer.is_human_readable := Datatypes.None;
          serde.de.Deserializer.__deserialize_content := Datatypes.None;
        }.
      End Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
      End Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
      
      Module  MapDeserializer.
      Section MapDeserializer.
        Record t : Set := {
          params :
            ref
              (slice
                ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
                *
                axum.util.PercentDecodedStr.t));
          key : core.option.Option.t axum.extract.path.de.KeyOrIdx.t;
          value : core.option.Option.t (ref axum.util.PercentDecodedStr.t);
        }.
        
        Definition Get_params :=
          Ref.map
            (fun α => Some α.(params))
            (fun β α => Some (α <| params := β |>)).
        Definition Get_key :=
          Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
        Definition Get_value :=
          Ref.map
            (fun α => Some α.(value))
            (fun β α => Some (α <| value := β |>)).
      End MapDeserializer.
      End MapDeserializer.
      
      Module  Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
      Section Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
        Definition Self : Set := axum.extract.path.de.MapDeserializer.t.
        
        (*
            type Error = PathDeserializationError;
        *)
        Definition Error : Set := axum.extract.path.PathDeserializationError.t.
        
        (*
            fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>
            where
                K: DeserializeSeed<'de>,
            {
                match self.params.split_first() {
                    Some(((key, value), tail)) => {
                        self.value = Some(value);
                        self.params = tail;
                        self.key = Some(KeyOrIdx::Key(key.clone()));
                        seed.deserialize(KeyDeserializer {
                            key: Arc::clone(key),
                        })
                        .map(Some)
                    }
                    None => Ok(None),
                }
            }
        *)
        Definition next_key_seed
            {K : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait K}
            (self : mut_ref Self)
            (seed : K)
            :
              M
                (core.result.Result.t
                  (core.option.Option.t K::type["Value"].t)
                  Error) :=
          let* self := M.alloc self in
          let* seed := M.alloc seed in
          M.read foo.
        
        Global Instance AssociatedFunction_next_key_seed
            {K : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait K} :
          Notations.DoubleColon Self "next_key_seed" := {
          Notations.double_colon := next_key_seed (K := K);
        }.
        
        (*
            fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>
            where
                V: DeserializeSeed<'de>,
            {
                match self.value.take() {
                    Some(value) => seed.deserialize(ValueDeserializer {
                        key: self.key.take(),
                        value,
                    }),
                    None => Err(PathDeserializationError::custom("value is missing")),
                }
            }
        *)
        Definition next_value_seed
            {V : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait V}
            (self : mut_ref Self)
            (seed : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* seed := M.alloc seed in
          M.read foo.
        
        Global Instance AssociatedFunction_next_value_seed
            {V : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
          Notations.DoubleColon Self "next_value_seed" := {
          Notations.double_colon := next_value_seed (V := V);
        }.
        
        Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
          serde.de.MapAccess.Error := Error;
          serde.de.MapAccess.next_key_seed
            {K : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait K} :=
            next_key_seed (K := K);
          serde.de.MapAccess.next_value_seed
            {V : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
            next_value_seed (V := V);
          serde.de.MapAccess.next_entry_seed := Datatypes.None;
          serde.de.MapAccess.next_key := Datatypes.None;
          serde.de.MapAccess.next_value := Datatypes.None;
          serde.de.MapAccess.next_entry := Datatypes.None;
          serde.de.MapAccess.size_hint := Datatypes.None;
        }.
      End Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
      End Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
      
      Module  KeyDeserializer.
      Section KeyDeserializer.
        Record t : Set := {
          key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
        }.
        
        Definition Get_key :=
          Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
      End KeyDeserializer.
      End KeyDeserializer.
      
      Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
      Section Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
        Definition Self : Set := axum.extract.path.de.KeyDeserializer.t.
        
        (*
            type Error = PathDeserializationError;
        *)
        Definition Error : Set := axum.extract.path.PathDeserializationError.t.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    visitor.visit_str(&self.key)
                }
        *)
        Definition deserialize_identifier
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_identifier
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_identifier" := {
          Notations.double_colon := deserialize_identifier (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    visitor.visit_str(&self.key)
                }
        *)
        Definition deserialize_str
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_str
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_str" := {
          Notations.double_colon := deserialize_str (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    visitor.visit_str(&self.key)
                }
        *)
        Definition deserialize_string
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_string
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_string" := {
          Notations.double_colon := deserialize_string (V := V);
        }.
        
        (*
            fn deserialize_any<V>(self, _visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::custom("Unexpected key type"))
            }
        *)
        Definition deserialize_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _visitor := M.alloc _visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_any" := {
          Notations.double_colon := deserialize_any (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_bool
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_bool
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_bool" := {
          Notations.double_colon := deserialize_bool (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_i8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i8" := {
          Notations.double_colon := deserialize_i8 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_i16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i16" := {
          Notations.double_colon := deserialize_i16 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_i32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i32" := {
          Notations.double_colon := deserialize_i32 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_i64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i64" := {
          Notations.double_colon := deserialize_i64 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_i128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i128" := {
          Notations.double_colon := deserialize_i128 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_u8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u8" := {
          Notations.double_colon := deserialize_u8 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_u16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u16" := {
          Notations.double_colon := deserialize_u16 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_u32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u32" := {
          Notations.double_colon := deserialize_u32 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_u64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u64" := {
          Notations.double_colon := deserialize_u64 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_u128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u128" := {
          Notations.double_colon := deserialize_u128 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_f32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_f32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_f32" := {
          Notations.double_colon := deserialize_f32 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_f64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_f64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_f64" := {
          Notations.double_colon := deserialize_f64 (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_char
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_char
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_char" := {
          Notations.double_colon := deserialize_char (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_bytes
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_bytes
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_bytes" := {
          Notations.double_colon := deserialize_bytes (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_byte_buf
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_byte_buf
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_byte_buf" := {
          Notations.double_colon := deserialize_byte_buf (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_option
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_option
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_option" := {
          Notations.double_colon := deserialize_option (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_unit
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_unit
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_unit" := {
          Notations.double_colon := deserialize_unit (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_unit_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (name : ref str.t)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* name := M.alloc name in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_unit_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_unit_struct" := {
          Notations.double_colon := deserialize_unit_struct (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_seq
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_seq
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_seq" := {
          Notations.double_colon := deserialize_seq (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_tuple
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (len : usize.t)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* len := M.alloc len in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_tuple
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_tuple" := {
          Notations.double_colon := deserialize_tuple (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_tuple_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (name : ref str.t)
            (len : usize.t)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* name := M.alloc name in
          let* len := M.alloc len in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_tuple_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_tuple_struct" := {
          Notations.double_colon := deserialize_tuple_struct (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_map
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_map
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_map" := {
          Notations.double_colon := deserialize_map (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_newtype_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (name : ref str.t)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* name := M.alloc name in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_newtype_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_newtype_struct" := {
          Notations.double_colon := deserialize_newtype_struct (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (name : ref str.t)
            (fields : ref (slice (ref str.t)))
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* name := M.alloc name in
          let* fields := M.alloc fields in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_struct" := {
          Notations.double_colon := deserialize_struct (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_enum
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (name : ref str.t)
            (variants : ref (slice (ref str.t)))
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* name := M.alloc name in
          let* variants := M.alloc variants in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_enum
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_enum" := {
          Notations.double_colon := deserialize_enum (V := V);
        }.
        
        (*
                fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
                where
                    $v: $crate::de::Visitor<$l>,
                {
                    $(
                        let _ = $arg;
                    )*
                    self.deserialize_any(visitor)
                }
        *)
        Definition deserialize_ignored_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_ignored_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_ignored_any" := {
          Notations.double_colon := deserialize_ignored_any (V := V);
        }.
        
        Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
          serde.de.Deserializer.Error := Error;
          serde.de.Deserializer.deserialize_identifier
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_identifier (V := V);
          serde.de.Deserializer.deserialize_str
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_str (V := V);
          serde.de.Deserializer.deserialize_string
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_string (V := V);
          serde.de.Deserializer.deserialize_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_any (V := V);
          serde.de.Deserializer.deserialize_bool
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_bool (V := V);
          serde.de.Deserializer.deserialize_i8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i8 (V := V);
          serde.de.Deserializer.deserialize_i16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i16 (V := V);
          serde.de.Deserializer.deserialize_i32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i32 (V := V);
          serde.de.Deserializer.deserialize_i64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i64 (V := V);
          serde.de.Deserializer.deserialize_i128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            Datatypes.Some (deserialize_i128 (V := V));
          serde.de.Deserializer.deserialize_u8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u8 (V := V);
          serde.de.Deserializer.deserialize_u16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u16 (V := V);
          serde.de.Deserializer.deserialize_u32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u32 (V := V);
          serde.de.Deserializer.deserialize_u64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u64 (V := V);
          serde.de.Deserializer.deserialize_u128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            Datatypes.Some (deserialize_u128 (V := V));
          serde.de.Deserializer.deserialize_f32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_f32 (V := V);
          serde.de.Deserializer.deserialize_f64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_f64 (V := V);
          serde.de.Deserializer.deserialize_char
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_char (V := V);
          serde.de.Deserializer.deserialize_bytes
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_bytes (V := V);
          serde.de.Deserializer.deserialize_byte_buf
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_byte_buf (V := V);
          serde.de.Deserializer.deserialize_option
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_option (V := V);
          serde.de.Deserializer.deserialize_unit
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_unit (V := V);
          serde.de.Deserializer.deserialize_unit_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_unit_struct (V := V);
          serde.de.Deserializer.deserialize_seq
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_seq (V := V);
          serde.de.Deserializer.deserialize_tuple
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_tuple (V := V);
          serde.de.Deserializer.deserialize_tuple_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_tuple_struct (V := V);
          serde.de.Deserializer.deserialize_map
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_map (V := V);
          serde.de.Deserializer.deserialize_newtype_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_newtype_struct (V := V);
          serde.de.Deserializer.deserialize_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_struct (V := V);
          serde.de.Deserializer.deserialize_enum
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_enum (V := V);
          serde.de.Deserializer.deserialize_ignored_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_ignored_any (V := V);
          serde.de.Deserializer.is_human_readable := Datatypes.None;
          serde.de.Deserializer.__deserialize_content := Datatypes.None;
        }.
      End Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
      End Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
      
      Module  ValueDeserializer.
      Section ValueDeserializer.
        Record t : Set := {
          key : core.option.Option.t axum.extract.path.de.KeyOrIdx.t;
          value : ref axum.util.PercentDecodedStr.t;
        }.
        
        Definition Get_key :=
          Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
        Definition Get_value :=
          Ref.map
            (fun α => Some α.(value))
            (fun β α => Some (α <| value := β |>)).
      End ValueDeserializer.
      End ValueDeserializer.
      
      Module  Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
      Section Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
        Definition Self : Set := axum.extract.path.de.ValueDeserializer.t.
        
        (*
        Debug
        *)
        Definition fmt
            (self : ref Self)
            (f : mut_ref core.fmt.Formatter.t)
            : M ltac:(core.fmt.Result) :=
          let* self := M.alloc self in
          let* f := M.alloc f in
          M.read foo.
        
        Global Instance AssociatedFunction_fmt :
          Notations.DoubleColon Self "fmt" := {
          Notations.double_colon := fmt;
        }.
        
        Global Instance ℐ : core.fmt.Debug.Trait Self := {
          core.fmt.Debug.fmt := fmt;
        }.
      End Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
      End Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
      
      Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
      Section Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
        Definition Self : Set := axum.extract.path.de.ValueDeserializer.t.
        
        (*
            type Error = PathDeserializationError;
        *)
        Definition Error : Set := axum.extract.path.PathDeserializationError.t.
        
        (*
                fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    Err(PathDeserializationError::unsupported_type(type_name::<
                        V::Value,
                    >()))
                }
        *)
        Definition deserialize_map
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (Pattern : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* Pattern := M.alloc Pattern in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_map
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_map" := {
          Notations.double_colon := deserialize_map (V := V);
        }.
        
        (*
                fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    Err(PathDeserializationError::unsupported_type(type_name::<
                        V::Value,
                    >()))
                }
        *)
        Definition deserialize_identifier
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (Pattern : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* Pattern := M.alloc Pattern in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_identifier
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_identifier" := {
          Notations.double_colon := deserialize_identifier (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_bool
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_bool
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_bool" := {
          Notations.double_colon := deserialize_bool (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_i8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i8" := {
          Notations.double_colon := deserialize_i8 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_i16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i16" := {
          Notations.double_colon := deserialize_i16 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_i32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i32" := {
          Notations.double_colon := deserialize_i32 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_i64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i64" := {
          Notations.double_colon := deserialize_i64 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_i128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_i128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_i128" := {
          Notations.double_colon := deserialize_i128 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_u8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u8" := {
          Notations.double_colon := deserialize_u8 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_u16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u16" := {
          Notations.double_colon := deserialize_u16 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_u32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u32" := {
          Notations.double_colon := deserialize_u32 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_u64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u64" := {
          Notations.double_colon := deserialize_u64 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_u128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_u128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_u128" := {
          Notations.double_colon := deserialize_u128 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_f32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_f32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_f32" := {
          Notations.double_colon := deserialize_f32 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_f64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_f64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_f64" := {
          Notations.double_colon := deserialize_f64 (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_string
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_string
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_string" := {
          Notations.double_colon := deserialize_string (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_byte_buf
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_byte_buf
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_byte_buf" := {
          Notations.double_colon := deserialize_byte_buf (V := V);
        }.
        
        (*
                fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
                where
                    V: Visitor<'de>,
                {
                    let v = self.value.parse().map_err(|_| {
                        if let Some(key) = self.key.take() {
                            let kind = match key {
                                KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                    key: key.to_string(),
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                                KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                    index,
                                    value: self.value.as_str().to_owned(),
                                    expected_type: $ty,
                                },
                            };
                            PathDeserializationError::new(kind)
                        } else {
                            PathDeserializationError::new(ErrorKind::ParseError {
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            })
                        }
                    })?;
                    visitor.$visit_fn(v)
                }
        *)
        Definition deserialize_char
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_char
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_char" := {
          Notations.double_colon := deserialize_char (V := V);
        }.
        
        (*
            fn deserialize_any<V>(self, v: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                self.deserialize_str(v)
            }
        *)
        Definition deserialize_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (v : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* v := M.alloc v in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_any" := {
          Notations.double_colon := deserialize_any (V := V);
        }.
        
        (*
            fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_borrowed_str(self.value)
            }
        *)
        Definition deserialize_str
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_str
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_str" := {
          Notations.double_colon := deserialize_str (V := V);
        }.
        
        (*
            fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_borrowed_bytes(self.value.as_bytes())
            }
        *)
        Definition deserialize_bytes
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_bytes
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_bytes" := {
          Notations.double_colon := deserialize_bytes (V := V);
        }.
        
        (*
            fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_some(self)
            }
        *)
        Definition deserialize_option
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_option
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_option" := {
          Notations.double_colon := deserialize_option (V := V);
        }.
        
        (*
            fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_unit()
            }
        *)
        Definition deserialize_unit
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_unit
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_unit" := {
          Notations.double_colon := deserialize_unit (V := V);
        }.
        
        (*
            fn deserialize_unit_struct<V>(
                self,
                _name: &'static str,
                visitor: V,
            ) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_unit()
            }
        *)
        Definition deserialize_unit_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_name : ref str.t)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _name := M.alloc _name in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_unit_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_unit_struct" := {
          Notations.double_colon := deserialize_unit_struct (V := V);
        }.
        
        (*
            fn deserialize_newtype_struct<V>(
                self,
                _name: &'static str,
                visitor: V,
            ) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_newtype_struct(self)
            }
        *)
        Definition deserialize_newtype_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_name : ref str.t)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _name := M.alloc _name in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_newtype_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_newtype_struct" := {
          Notations.double_colon := deserialize_newtype_struct (V := V);
        }.
        
        (*
            fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                struct PairDeserializer<'de> {
                    key: Option<KeyOrIdx>,
                    value: Option<&'de PercentDecodedStr>,
                }
        
                impl<'de> SeqAccess<'de> for PairDeserializer<'de> {
                    type Error = PathDeserializationError;
        
                    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
                    where
                        T: DeserializeSeed<'de>,
                    {
                        match self.key.take() {
                            Some(KeyOrIdx::Idx { idx: _, key }) => {
                                return seed.deserialize(KeyDeserializer { key }).map(Some);
                            }
                            // `KeyOrIdx::Key` is only used when deserializing maps so `deserialize_seq`
                            // wouldn't be called for that
                            Some(KeyOrIdx::Key(_)) => unreachable!(),
                            None => {}
                        };
        
                        self.value
                            .take()
                            .map(|value| seed.deserialize(ValueDeserializer { key: None, value }))
                            .transpose()
                    }
                }
        
                if len == 2 {
                    match self.key {
                        Some(key) => visitor.visit_seq(PairDeserializer {
                            key: Some(key),
                            value: Some(self.value),
                        }),
                        // `self.key` is only `None` when deserializing maps so `deserialize_seq`
                        // wouldn't be called for that
                        None => unreachable!(),
                    }
                } else {
                    Err(PathDeserializationError::unsupported_type(type_name::<
                        V::Value,
                    >()))
                }
            }
        *)
        Definition deserialize_tuple
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (len : usize.t)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* len := M.alloc len in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_tuple
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_tuple" := {
          Notations.double_colon := deserialize_tuple (V := V);
        }.
        
        (*
            fn deserialize_seq<V>(self, _visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::unsupported_type(type_name::<
                    V::Value,
                >()))
            }
        *)
        Definition deserialize_seq
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _visitor := M.alloc _visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_seq
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_seq" := {
          Notations.double_colon := deserialize_seq (V := V);
        }.
        
        (*
            fn deserialize_tuple_struct<V>(
                self,
                _name: &'static str,
                _len: usize,
                _visitor: V,
            ) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::unsupported_type(type_name::<
                    V::Value,
                >()))
            }
        *)
        Definition deserialize_tuple_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_name : ref str.t)
            (_len : usize.t)
            (_visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _name := M.alloc _name in
          let* _len := M.alloc _len in
          let* _visitor := M.alloc _visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_tuple_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_tuple_struct" := {
          Notations.double_colon := deserialize_tuple_struct (V := V);
        }.
        
        (*
            fn deserialize_struct<V>(
                self,
                _name: &'static str,
                _fields: &'static [&'static str],
                _visitor: V,
            ) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::unsupported_type(type_name::<
                    V::Value,
                >()))
            }
        *)
        Definition deserialize_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_name : ref str.t)
            (_fields : ref (slice (ref str.t)))
            (_visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _name := M.alloc _name in
          let* _fields := M.alloc _fields in
          let* _visitor := M.alloc _visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_struct" := {
          Notations.double_colon := deserialize_struct (V := V);
        }.
        
        (*
            fn deserialize_enum<V>(
                self,
                _name: &'static str,
                _variants: &'static [&'static str],
                visitor: V,
            ) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_enum(EnumDeserializer {
                    value: self.value.clone().into_inner(),
                })
            }
        *)
        Definition deserialize_enum
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_name : ref str.t)
            (_variants : ref (slice (ref str.t)))
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _name := M.alloc _name in
          let* _variants := M.alloc _variants in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_enum
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_enum" := {
          Notations.double_colon := deserialize_enum (V := V);
        }.
        
        (*
            fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_unit()
            }
        *)
        Definition deserialize_ignored_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* visitor := M.alloc visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_deserialize_ignored_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "deserialize_ignored_any" := {
          Notations.double_colon := deserialize_ignored_any (V := V);
        }.
        
        Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
          serde.de.Deserializer.Error := Error;
          serde.de.Deserializer.deserialize_map
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_map (V := V);
          serde.de.Deserializer.deserialize_identifier
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_identifier (V := V);
          serde.de.Deserializer.deserialize_bool
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_bool (V := V);
          serde.de.Deserializer.deserialize_i8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i8 (V := V);
          serde.de.Deserializer.deserialize_i16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i16 (V := V);
          serde.de.Deserializer.deserialize_i32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i32 (V := V);
          serde.de.Deserializer.deserialize_i64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_i64 (V := V);
          serde.de.Deserializer.deserialize_i128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            Datatypes.Some (deserialize_i128 (V := V));
          serde.de.Deserializer.deserialize_u8
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u8 (V := V);
          serde.de.Deserializer.deserialize_u16
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u16 (V := V);
          serde.de.Deserializer.deserialize_u32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u32 (V := V);
          serde.de.Deserializer.deserialize_u64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_u64 (V := V);
          serde.de.Deserializer.deserialize_u128
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            Datatypes.Some (deserialize_u128 (V := V));
          serde.de.Deserializer.deserialize_f32
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_f32 (V := V);
          serde.de.Deserializer.deserialize_f64
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_f64 (V := V);
          serde.de.Deserializer.deserialize_string
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_string (V := V);
          serde.de.Deserializer.deserialize_byte_buf
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_byte_buf (V := V);
          serde.de.Deserializer.deserialize_char
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_char (V := V);
          serde.de.Deserializer.deserialize_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_any (V := V);
          serde.de.Deserializer.deserialize_str
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_str (V := V);
          serde.de.Deserializer.deserialize_bytes
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_bytes (V := V);
          serde.de.Deserializer.deserialize_option
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_option (V := V);
          serde.de.Deserializer.deserialize_unit
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_unit (V := V);
          serde.de.Deserializer.deserialize_unit_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_unit_struct (V := V);
          serde.de.Deserializer.deserialize_newtype_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_newtype_struct (V := V);
          serde.de.Deserializer.deserialize_tuple
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_tuple (V := V);
          serde.de.Deserializer.deserialize_seq
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_seq (V := V);
          serde.de.Deserializer.deserialize_tuple_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_tuple_struct (V := V);
          serde.de.Deserializer.deserialize_struct
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_struct (V := V);
          serde.de.Deserializer.deserialize_enum
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_enum (V := V);
          serde.de.Deserializer.deserialize_ignored_any
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            deserialize_ignored_any (V := V);
          serde.de.Deserializer.is_human_readable := Datatypes.None;
          serde.de.Deserializer.__deserialize_content := Datatypes.None;
        }.
      End Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
      End Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
      
      Module  EnumDeserializer.
      Section EnumDeserializer.
        Record t : Set := {
          value : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
        }.
        
        Definition Get_value :=
          Ref.map
            (fun α => Some α.(value))
            (fun β α => Some (α <| value := β |>)).
      End EnumDeserializer.
      End EnumDeserializer.
      
      Module  Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
      Section Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
        Definition Self : Set := axum.extract.path.de.EnumDeserializer.t.
        
        (*
            type Error = PathDeserializationError;
        *)
        Definition Error : Set := axum.extract.path.PathDeserializationError.t.
        
        (*
            type Variant = UnitVariant;
        *)
        Definition Variant : Set := axum.extract.path.de.UnitVariant.t.
        
        (*
            fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>
            where
                V: de::DeserializeSeed<'de>,
            {
                Ok((
                    seed.deserialize(KeyDeserializer { key: self.value })?,
                    UnitVariant,
                ))
            }
        *)
        Definition variant_seed
            {V : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait V}
            (self : Self)
            (seed : V)
            : M (core.result.Result.t (V::type["Value"].t * Variant) Error) :=
          let* self := M.alloc self in
          let* seed := M.alloc seed in
          M.read foo.
        
        Global Instance AssociatedFunction_variant_seed
            {V : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
          Notations.DoubleColon Self "variant_seed" := {
          Notations.double_colon := variant_seed (V := V);
        }.
        
        Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
          serde.de.EnumAccess.Error := Error;
          serde.de.EnumAccess.Variant := Variant;
          serde.de.EnumAccess.variant_seed
            {V : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
            variant_seed (V := V);
          serde.de.EnumAccess.variant := Datatypes.None;
        }.
      End Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
      End Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
      
      Module  UnitVariant.
      Section UnitVariant.
        Inductive t : Set := Build.
      End UnitVariant.
      End UnitVariant.
      
      Module  Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
      Section Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
        Definition Self : Set := axum.extract.path.de.UnitVariant.t.
        
        (*
            type Error = PathDeserializationError;
        *)
        Definition Error : Set := axum.extract.path.PathDeserializationError.t.
        
        (*
            fn unit_variant(self) -> Result<(), Self::Error> {
                Ok(())
            }
        *)
        Definition unit_variant
            (self : Self)
            : M (core.result.Result.t unit Error) :=
          let* self := M.alloc self in
          M.read foo.
        
        Global Instance AssociatedFunction_unit_variant :
          Notations.DoubleColon Self "unit_variant" := {
          Notations.double_colon := unit_variant;
        }.
        
        (*
            fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>
            where
                T: DeserializeSeed<'de>,
            {
                Err(PathDeserializationError::unsupported_type(
                    "newtype enum variant",
                ))
            }
        *)
        Definition newtype_variant_seed
            {T : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait T}
            (self : Self)
            (_seed : T)
            : M (core.result.Result.t T::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _seed := M.alloc _seed in
          M.read foo.
        
        Global Instance AssociatedFunction_newtype_variant_seed
            {T : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
          Notations.DoubleColon Self "newtype_variant_seed" := {
          Notations.double_colon := newtype_variant_seed (T := T);
        }.
        
        (*
            fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::unsupported_type(
                    "tuple enum variant",
                ))
            }
        *)
        Definition tuple_variant
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_len : usize.t)
            (_visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _len := M.alloc _len in
          let* _visitor := M.alloc _visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_tuple_variant
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "tuple_variant" := {
          Notations.double_colon := tuple_variant (V := V);
        }.
        
        (*
            fn struct_variant<V>(
                self,
                _fields: &'static [&'static str],
                _visitor: V,
            ) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::unsupported_type(
                    "struct enum variant",
                ))
            }
        *)
        Definition struct_variant
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V}
            (self : Self)
            (_fields : ref (slice (ref str.t)))
            (_visitor : V)
            : M (core.result.Result.t V::type["Value"].t Error) :=
          let* self := M.alloc self in
          let* _fields := M.alloc _fields in
          let* _visitor := M.alloc _visitor in
          M.read foo.
        
        Global Instance AssociatedFunction_struct_variant
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :
          Notations.DoubleColon Self "struct_variant" := {
          Notations.double_colon := struct_variant (V := V);
        }.
        
        Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
          serde.de.VariantAccess.Error := Error;
          serde.de.VariantAccess.unit_variant := unit_variant;
          serde.de.VariantAccess.newtype_variant_seed
            {T : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
            newtype_variant_seed (T := T);
          serde.de.VariantAccess.tuple_variant
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            tuple_variant (V := V);
          serde.de.VariantAccess.struct_variant
            {V : Set}
            {ℋ_0 : serde.de.Visitor.Trait V} :=
            struct_variant (V := V);
          serde.de.VariantAccess.newtype_variant := Datatypes.None;
        }.
      End Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
      End Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
      
      Module  SeqDeserializer.
      Section SeqDeserializer.
        Record t : Set := {
          params :
            ref
              (slice
                ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
                *
                axum.util.PercentDecodedStr.t));
          idx : usize.t;
        }.
        
        Definition Get_params :=
          Ref.map
            (fun α => Some α.(params))
            (fun β α => Some (α <| params := β |>)).
        Definition Get_idx :=
          Ref.map (fun α => Some α.(idx)) (fun β α => Some (α <| idx := β |>)).
      End SeqDeserializer.
      End SeqDeserializer.
      
      Module  Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
      Section Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
        Definition Self : Set := axum.extract.path.de.SeqDeserializer.t.
        
        (*
            type Error = PathDeserializationError;
        *)
        Definition Error : Set := axum.extract.path.PathDeserializationError.t.
        
        (*
            fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
            where
                T: DeserializeSeed<'de>,
            {
                match self.params.split_first() {
                    Some(((key, value), tail)) => {
                        self.params = tail;
                        let idx = self.idx;
                        self.idx += 1;
                        Ok(Some(seed.deserialize(ValueDeserializer {
                            key: Some(KeyOrIdx::Idx {
                                idx,
                                key: key.clone(),
                            }),
                            value,
                        })?))
                    }
                    None => Ok(None),
                }
            }
        *)
        Definition next_element_seed
            {T : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait T}
            (self : mut_ref Self)
            (seed : T)
            :
              M
                (core.result.Result.t
                  (core.option.Option.t T::type["Value"].t)
                  Error) :=
          let* self := M.alloc self in
          let* seed := M.alloc seed in
          M.read foo.
        
        Global Instance AssociatedFunction_next_element_seed
            {T : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
          Notations.DoubleColon Self "next_element_seed" := {
          Notations.double_colon := next_element_seed (T := T);
        }.
        
        Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
          serde.de.SeqAccess.Error := Error;
          serde.de.SeqAccess.next_element_seed
            {T : Set}
            {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
            next_element_seed (T := T);
          serde.de.SeqAccess.next_element := Datatypes.None;
          serde.de.SeqAccess.size_hint := Datatypes.None;
        }.
      End Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
      End Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
      
      Module KeyOrIdx.
        Module Idx.
          Record t : Set := {
            idx : usize.t;
            key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
          }.
        End Idx.
        
        Inductive t : Set :=
        | Key (_ : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
        | Idx (_ : Idx.t).
        
        Definition Get_Key_0 :=
          Ref.map
            (fun α => match α with | Key α0 => Some α0 | _ => None end)
            (fun β α => match α with | Key _ => Some (Key β) | _ => None end).
        
        Definition Get_Idx_idx :=
          Ref.map
            (fun α => match α with | Idx α => Some α.(Idx.idx) | _ => None end)
            (fun β α =>
              match α with
              | Idx α => Some (Idx (α <| Idx.idx := β |>))
              | _ => None
              end).
        
        Definition Get_Idx_key :=
          Ref.map
            (fun α => match α with | Idx α => Some α.(Idx.key) | _ => None end)
            (fun β α =>
              match α with
              | Idx α => Some (Idx (α <| Idx.key := β |>))
              | _ => None
              end).
      End KeyOrIdx.
      
      Module  Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
      Section Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
        Definition Self : Set := axum.extract.path.de.KeyOrIdx.t.
        
        (*
        Debug
        *)
        Definition fmt
            (self : ref Self)
            (f : mut_ref core.fmt.Formatter.t)
            : M ltac:(core.fmt.Result) :=
          let* self := M.alloc self in
          let* f := M.alloc f in
          M.read foo.
        
        Global Instance AssociatedFunction_fmt :
          Notations.DoubleColon Self "fmt" := {
          Notations.double_colon := fmt;
        }.
        
        Global Instance ℐ : core.fmt.Debug.Trait Self := {
          core.fmt.Debug.fmt := fmt;
        }.
      End Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
      End Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
      
      Module  Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
      Section Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
        Definition Self : Set := axum.extract.path.de.KeyOrIdx.t.
        
        (*
        Clone
        *)
        Definition clone
            (self : ref Self)
            : M axum.extract.path.de.KeyOrIdx.t :=
          let* self := M.alloc self in
          M.read foo.
        
        Global Instance AssociatedFunction_clone :
          Notations.DoubleColon Self "clone" := {
          Notations.double_colon := clone;
        }.
        
        Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
          core.clone.Clone.clone := clone;
          core.clone.Clone.clone_from := Datatypes.None;
        }.
      End Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
      End Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
    End de.
    
    Module  Path.
    Section Path.
      Context {T : Set}.
      
      Record t : Set := {
        x0 : T;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End Path.
    End Path.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.
    Section Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait T}.
      
      Definition Self : Set := axum.extract.path.Path.t T.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.
    End Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.
    
    Module  Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.
    Section Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.
      Context {T : Set}.
      
      Definition Self : Set := axum.extract.path.Path.t T.
      
      (*
                  type Target = T;
      *)
      Definition Target : Set := T.
      
      (*
                  fn deref(&self) -> &Self::Target {
                      &self.0
                  }
      *)
      Definition deref (self : ref Self) : M (ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref :
        Notations.DoubleColon Self "deref" := {
        Notations.double_colon := deref;
      }.
      
      Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
        core.ops.deref.Deref.Target := Target;
        core.ops.deref.Deref.deref := deref;
      }.
    End Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.
    End Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.
    
    Module  Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.
    Section Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.
      Context {T : Set}.
      
      Definition Self : Set := axum.extract.path.Path.t T.
      
      (*
                  fn deref_mut(&mut self) -> &mut Self::Target {
                      &mut self.0
                  }
      *)
      Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref_mut :
        Notations.DoubleColon Self "deref_mut" := {
        Notations.double_colon := deref_mut;
      }.
      
      Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
        core.ops.deref.DerefMut.deref_mut := deref_mut;
      }.
    End Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.
    End Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.
      Context {T S : Set}.
      
      Context
        {ℋ_0 : serde.de.DeserializeOwned.Trait T}
        {ℋ_1 : core.marker.Send.Trait T}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.extract.path.Path.t T.
      
      (*
          type Rejection = PathRejection;
      *)
      Definition Rejection : Set := axum.extract.rejection.PathRejection.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
              let params = match parts.extensions.get::<UrlParams>() {
                  Some(UrlParams::Params(params)) => params,
                  Some(UrlParams::InvalidUtf8InPathParam { key }) => {
                      let err = PathDeserializationError {
                          kind: ErrorKind::InvalidUtf8InPathParam {
                              key: key.to_string(),
                          },
                      };
                      let err = FailedToDeserializePathParams(err);
                      return Err(err.into());
                  }
                  None => {
                      return Err(MissingPathParams.into());
                  }
              };
      
              T::deserialize(de::PathDeserializer::new(params))
                  .map_err(|err| {
                      PathRejection::FailedToDeserializePathParams(FailedToDeserializePathParams(err))
                  })
                  .map(Path)
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (_state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* _state := M.alloc _state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.
    
    Module  PathDeserializationError.
    Section PathDeserializationError.
      Record t : Set := {
        kind : axum.extract.path.ErrorKind.t;
      }.
      
      Definition Get_kind :=
        Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
    End PathDeserializationError.
    End PathDeserializationError.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.
    Section Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.
      Definition Self : Set := axum.extract.path.PathDeserializationError.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.
    End Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.
    
    Module  Impl_axum_extract_path_PathDeserializationError_t.
    Section Impl_axum_extract_path_PathDeserializationError_t.
      Definition Self : Set := axum.extract.path.PathDeserializationError.t.
      
      (*
          pub(super) fn new(kind: ErrorKind) -> Self {
              Self { kind }
          }
      *)
      Definition new (kind : axum.extract.path.ErrorKind.t) : M Self :=
        let* kind := M.alloc kind in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
      
      (*
          pub(super) fn wrong_number_of_parameters() -> WrongNumberOfParameters<()> {
              WrongNumberOfParameters { got: () }
          }
      *)
      Definition wrong_number_of_parameters
          : M (axum.extract.path.WrongNumberOfParameters.t unit) :=
        M.read foo.
      
      Global Instance AssociatedFunction_wrong_number_of_parameters :
        Notations.DoubleColon Self "wrong_number_of_parameters" := {
        Notations.double_colon := wrong_number_of_parameters;
      }.
      
      (*
          pub(super) fn unsupported_type(name: &'static str) -> Self {
              Self::new(ErrorKind::UnsupportedType { name })
          }
      *)
      Definition unsupported_type (name : ref str.t) : M Self :=
        let* name := M.alloc name in
        M.read foo.
      
      Global Instance AssociatedFunction_unsupported_type :
        Notations.DoubleColon Self "unsupported_type" := {
        Notations.double_colon := unsupported_type;
      }.
    End Impl_axum_extract_path_PathDeserializationError_t.
    End Impl_axum_extract_path_PathDeserializationError_t.
    
    Module  WrongNumberOfParameters.
    Section WrongNumberOfParameters.
      Context (G : Set).
      
      Record t : Set := {
        got : G;
      }.
      
      Definition Get_got :=
        Ref.map (fun α => Some α.(got)) (fun β α => Some (α <| got := β |>)).
    End WrongNumberOfParameters.
    End WrongNumberOfParameters.
    
    Module  Impl_axum_extract_path_WrongNumberOfParameters_t_G.
    Section Impl_axum_extract_path_WrongNumberOfParameters_t_G.
      Context {G : Set}.
      
      Definition Self : Set := axum.extract.path.WrongNumberOfParameters.t G.
      
      (*
          pub(super) fn got<G2>(self, got: G2) -> WrongNumberOfParameters<G2> {
              WrongNumberOfParameters { got }
          }
      *)
      Definition got
          {G2 : Set}
          (self : Self)
          (got : G2)
          : M (axum.extract.path.WrongNumberOfParameters.t G2) :=
        let* self := M.alloc self in
        let* got := M.alloc got in
        M.read foo.
      
      Global Instance AssociatedFunction_got {G2 : Set} :
        Notations.DoubleColon Self "got" := {
        Notations.double_colon := got (G2 := G2);
      }.
    End Impl_axum_extract_path_WrongNumberOfParameters_t_G.
    End Impl_axum_extract_path_WrongNumberOfParameters_t_G.
    
    Module  Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t.
    Section Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t.
      Definition Self : Set :=
        axum.extract.path.WrongNumberOfParameters.t usize.t.
      
      (*
          pub(super) fn expected(self, expected: usize) -> PathDeserializationError {
              PathDeserializationError::new(ErrorKind::WrongNumberOfParameters {
                  got: self.got,
                  expected,
              })
          }
      *)
      Definition expected
          (self : Self)
          (expected : usize.t)
          : M axum.extract.path.PathDeserializationError.t :=
        let* self := M.alloc self in
        let* expected := M.alloc expected in
        M.read foo.
      
      Global Instance AssociatedFunction_expected :
        Notations.DoubleColon Self "expected" := {
        Notations.double_colon := expected;
      }.
    End Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t.
    End Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t.
    
    Module  Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.
    Section Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.
      Definition Self : Set := axum.extract.path.PathDeserializationError.t.
      
      (*
          fn custom<T>(msg: T) -> Self
          where
              T: fmt::Display,
          {
              Self {
                  kind: ErrorKind::Message(msg.to_string()),
              }
          }
      *)
      Definition custom
          {T : Set}
          {ℋ_0 : core.fmt.Display.Trait T}
          (msg : T)
          : M Self :=
        let* msg := M.alloc msg in
        M.read foo.
      
      Global Instance AssociatedFunction_custom
          {T : Set}
          {ℋ_0 : core.fmt.Display.Trait T} :
        Notations.DoubleColon Self "custom" := {
        Notations.double_colon := custom (T := T);
      }.
      
      Global Instance ℐ : serde.de.Error.Required.Trait Self := {
        serde.de.Error.custom {T : Set} {ℋ_0 : core.fmt.Display.Trait T} :=
          custom (T := T);
        serde.de.Error.invalid_type := Datatypes.None;
        serde.de.Error.invalid_value := Datatypes.None;
        serde.de.Error.invalid_length := Datatypes.None;
        serde.de.Error.unknown_variant := Datatypes.None;
        serde.de.Error.unknown_field := Datatypes.None;
        serde.de.Error.missing_field := Datatypes.None;
        serde.de.Error.duplicate_field := Datatypes.None;
      }.
    End Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.
    End Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.
    Section Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.
      Definition Self : Set := axum.extract.path.PathDeserializationError.t.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.kind.fmt(f)
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.
    End Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.
    
    Module  Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.
    Section Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.
      Definition Self : Set := axum.extract.path.PathDeserializationError.t.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.None;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.
    End Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.
    
    Module ErrorKind.
      Module WrongNumberOfParameters.
        Record t : Set := {
          got : usize.t;
          expected : usize.t;
        }.
      End WrongNumberOfParameters.
      
      Module ParseErrorAtKey.
        Record t : Set := {
          key : alloc.string.String.t;
          value : alloc.string.String.t;
          expected_type : ref str.t;
        }.
      End ParseErrorAtKey.
      
      Module ParseErrorAtIndex.
        Record t : Set := {
          index : usize.t;
          value : alloc.string.String.t;
          expected_type : ref str.t;
        }.
      End ParseErrorAtIndex.
      
      Module ParseError.
        Record t : Set := {
          value : alloc.string.String.t;
          expected_type : ref str.t;
        }.
      End ParseError.
      
      Module InvalidUtf8InPathParam.
        Record t : Set := {
          key : alloc.string.String.t;
        }.
      End InvalidUtf8InPathParam.
      
      Module UnsupportedType.
        Record t : Set := {
          name : ref str.t;
        }.
      End UnsupportedType.
      
      Inductive t : Set :=
      | WrongNumberOfParameters (_ : WrongNumberOfParameters.t)
      | ParseErrorAtKey (_ : ParseErrorAtKey.t)
      | ParseErrorAtIndex (_ : ParseErrorAtIndex.t)
      | ParseError (_ : ParseError.t)
      | InvalidUtf8InPathParam (_ : InvalidUtf8InPathParam.t)
      | UnsupportedType (_ : UnsupportedType.t)
      | Message (_ : alloc.string.String.t).
      
      Definition Get_WrongNumberOfParameters_got :=
        Ref.map
          (fun α =>
            match α with
            | WrongNumberOfParameters α => Some α.(WrongNumberOfParameters.got)
            | _ => None
            end)
          (fun β α =>
            match α with
            | WrongNumberOfParameters α =>
              Some
                (WrongNumberOfParameters
                  (α <| WrongNumberOfParameters.got := β |>))
            | _ => None
            end).
      
      Definition Get_WrongNumberOfParameters_expected :=
        Ref.map
          (fun α =>
            match α with
            | WrongNumberOfParameters α =>
              Some α.(WrongNumberOfParameters.expected)
            | _ => None
            end)
          (fun β α =>
            match α with
            | WrongNumberOfParameters α =>
              Some
                (WrongNumberOfParameters
                  (α <| WrongNumberOfParameters.expected := β |>))
            | _ => None
            end).
      
      Definition Get_ParseErrorAtKey_key :=
        Ref.map
          (fun α =>
            match α with
            | ParseErrorAtKey α => Some α.(ParseErrorAtKey.key)
            | _ => None
            end)
          (fun β α =>
            match α with
            | ParseErrorAtKey α =>
              Some (ParseErrorAtKey (α <| ParseErrorAtKey.key := β |>))
            | _ => None
            end).
      
      Definition Get_ParseErrorAtKey_value :=
        Ref.map
          (fun α =>
            match α with
            | ParseErrorAtKey α => Some α.(ParseErrorAtKey.value)
            | _ => None
            end)
          (fun β α =>
            match α with
            | ParseErrorAtKey α =>
              Some (ParseErrorAtKey (α <| ParseErrorAtKey.value := β |>))
            | _ => None
            end).
      
      Definition Get_ParseErrorAtKey_expected_type :=
        Ref.map
          (fun α =>
            match α with
            | ParseErrorAtKey α => Some α.(ParseErrorAtKey.expected_type)
            | _ => None
            end)
          (fun β α =>
            match α with
            | ParseErrorAtKey α =>
              Some
                (ParseErrorAtKey (α <| ParseErrorAtKey.expected_type := β |>))
            | _ => None
            end).
      
      Definition Get_ParseErrorAtIndex_index :=
        Ref.map
          (fun α =>
            match α with
            | ParseErrorAtIndex α => Some α.(ParseErrorAtIndex.index)
            | _ => None
            end)
          (fun β α =>
            match α with
            | ParseErrorAtIndex α =>
              Some (ParseErrorAtIndex (α <| ParseErrorAtIndex.index := β |>))
            | _ => None
            end).
      
      Definition Get_ParseErrorAtIndex_value :=
        Ref.map
          (fun α =>
            match α with
            | ParseErrorAtIndex α => Some α.(ParseErrorAtIndex.value)
            | _ => None
            end)
          (fun β α =>
            match α with
            | ParseErrorAtIndex α =>
              Some (ParseErrorAtIndex (α <| ParseErrorAtIndex.value := β |>))
            | _ => None
            end).
      
      Definition Get_ParseErrorAtIndex_expected_type :=
        Ref.map
          (fun α =>
            match α with
            | ParseErrorAtIndex α => Some α.(ParseErrorAtIndex.expected_type)
            | _ => None
            end)
          (fun β α =>
            match α with
            | ParseErrorAtIndex α =>
              Some
                (ParseErrorAtIndex
                  (α <| ParseErrorAtIndex.expected_type := β |>))
            | _ => None
            end).
      
      Definition Get_ParseError_value :=
        Ref.map
          (fun α =>
            match α with
            | ParseError α => Some α.(ParseError.value)
            | _ => None
            end)
          (fun β α =>
            match α with
            | ParseError α => Some (ParseError (α <| ParseError.value := β |>))
            | _ => None
            end).
      
      Definition Get_ParseError_expected_type :=
        Ref.map
          (fun α =>
            match α with
            | ParseError α => Some α.(ParseError.expected_type)
            | _ => None
            end)
          (fun β α =>
            match α with
            | ParseError α =>
              Some (ParseError (α <| ParseError.expected_type := β |>))
            | _ => None
            end).
      
      Definition Get_InvalidUtf8InPathParam_key :=
        Ref.map
          (fun α =>
            match α with
            | InvalidUtf8InPathParam α => Some α.(InvalidUtf8InPathParam.key)
            | _ => None
            end)
          (fun β α =>
            match α with
            | InvalidUtf8InPathParam α =>
              Some
                (InvalidUtf8InPathParam
                  (α <| InvalidUtf8InPathParam.key := β |>))
            | _ => None
            end).
      
      Definition Get_UnsupportedType_name :=
        Ref.map
          (fun α =>
            match α with
            | UnsupportedType α => Some α.(UnsupportedType.name)
            | _ => None
            end)
          (fun β α =>
            match α with
            | UnsupportedType α =>
              Some (UnsupportedType (α <| UnsupportedType.name := β |>))
            | _ => None
            end).
      
      Definition Get_Message_0 :=
        Ref.map
          (fun α => match α with | Message α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with | Message _ => Some (Message β) | _ => None end).
    End ErrorKind.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.
    Section Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.
      Definition Self : Set := axum.extract.path.ErrorKind.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.
    End Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.
    
    Module  Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.
    Section Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.
      Definition Self : Set := axum.extract.path.ErrorKind.t.
      
      Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.
    End Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.
    
    Module  Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.
    Section Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.
      Definition Self : Set := axum.extract.path.ErrorKind.t.
      
      (*
      PartialEq
      *)
      Definition eq
          (self : ref Self)
          (other : ref axum.extract.path.ErrorKind.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.
    End Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.
    
    Module  Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.
    Section Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.
      Definition Self : Set := axum.extract.path.ErrorKind.t.
      
      Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.
    End Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.
    
    Module  Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.
    Section Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.
      Definition Self : Set := axum.extract.path.ErrorKind.t.
      
      (*
      Eq
      *)
      Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_assert_receiver_is_total_eq :
        Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
        Notations.double_colon := assert_receiver_is_total_eq;
      }.
      
      Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
        core.cmp.Eq.assert_receiver_is_total_eq :=
          Datatypes.Some assert_receiver_is_total_eq;
      }.
    End Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.
    End Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.
    Section Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.
      Definition Self : Set := axum.extract.path.ErrorKind.t.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              match self {
                  ErrorKind::Message(error) => error.fmt(f),
                  ErrorKind::InvalidUtf8InPathParam { key } => write!(f, "Invalid UTF-8 in `{key}`"),
                  ErrorKind::WrongNumberOfParameters { got, expected } => {
                      write!(
                          f,
                          "Wrong number of path arguments for `Path`. Expected {expected} but got {got}"
                      )?;
      
                      if *expected == 1 {
                          write!(f, ". Note that multiple parameters must be extracted with a tuple `Path<(_, _)>` or a struct `Path<YourParams>`")?;
                      }
      
                      Ok(())
                  }
                  ErrorKind::UnsupportedType { name } => write!(f, "Unsupported type `{name}`"),
                  ErrorKind::ParseErrorAtKey {
                      key,
                      value,
                      expected_type,
                  } => write!(
                      f,
                      "Cannot parse `{key}` with value `{value:?}` to a `{expected_type}`"
                  ),
                  ErrorKind::ParseError {
                      value,
                      expected_type,
                  } => write!(f, "Cannot parse `{value:?}` to a `{expected_type}`"),
                  ErrorKind::ParseErrorAtIndex {
                      index,
                      value,
                      expected_type,
                  } => write!(
                      f,
                      "Cannot parse value at index {index} with value `{value:?}` to a `{expected_type}`"
                  ),
              }
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.
    End Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.
    
    Module  FailedToDeserializePathParams.
    Section FailedToDeserializePathParams.
      Record t : Set := {
        x0 : axum.extract.path.PathDeserializationError.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End FailedToDeserializePathParams.
    End FailedToDeserializePathParams.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.
    Section Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.
      Definition Self : Set :=
        axum.extract.path.FailedToDeserializePathParams.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.
    End Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.
    
    Module  Impl_axum_extract_path_FailedToDeserializePathParams_t.
    Section Impl_axum_extract_path_FailedToDeserializePathParams_t.
      Definition Self : Set :=
        axum.extract.path.FailedToDeserializePathParams.t.
      
      (*
          pub fn kind(&self) -> &ErrorKind {
              &self.0.kind
          }
      *)
      Definition kind
          (self : ref Self)
          : M (ref axum.extract.path.ErrorKind.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_kind :
        Notations.DoubleColon Self "kind" := {
        Notations.double_colon := kind;
      }.
      
      (*
          pub fn into_kind(self) -> ErrorKind {
              self.0.kind
          }
      *)
      Definition into_kind (self : Self) : M axum.extract.path.ErrorKind.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_kind :
        Notations.DoubleColon Self "into_kind" := {
        Notations.double_colon := into_kind;
      }.
      
      (*
          pub fn body_text(&self) -> String {
              match self.0.kind {
                  ErrorKind::Message(_)
                  | ErrorKind::InvalidUtf8InPathParam { .. }
                  | ErrorKind::ParseError { .. }
                  | ErrorKind::ParseErrorAtIndex { .. }
                  | ErrorKind::ParseErrorAtKey { .. } => format!("Invalid URL: {}", self.0.kind),
                  ErrorKind::WrongNumberOfParameters { .. } | ErrorKind::UnsupportedType { .. } => {
                      self.0.kind.to_string()
                  }
              }
          }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
          pub fn status(&self) -> StatusCode {
              match self.0.kind {
                  ErrorKind::Message(_)
                  | ErrorKind::InvalidUtf8InPathParam { .. }
                  | ErrorKind::ParseError { .. }
                  | ErrorKind::ParseErrorAtIndex { .. }
                  | ErrorKind::ParseErrorAtKey { .. } => StatusCode::BAD_REQUEST,
                  ErrorKind::WrongNumberOfParameters { .. } | ErrorKind::UnsupportedType { .. } => {
                      StatusCode::INTERNAL_SERVER_ERROR
                  }
              }
          }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_path_FailedToDeserializePathParams_t.
    End Impl_axum_extract_path_FailedToDeserializePathParams_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.
      Definition Self : Set :=
        axum.extract.path.FailedToDeserializePathParams.t.
      
      (*
          fn into_response(self) -> Response {
              axum_core::__log_rejection!(
                  rejection_type = Self,
                  body_text = self.body_text(),
                  status = self.status(),
              );
              (self.status(), self.body_text()).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.
    Section Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.
      Definition Self : Set :=
        axum.extract.path.FailedToDeserializePathParams.t.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.0.fmt(f)
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.
    End Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.
    
    Module  Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.
    Section Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.
      Definition Self : Set :=
        axum.extract.path.FailedToDeserializePathParams.t.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.None;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.
    End Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.
    
    Module  RawPathParams.
    Section RawPathParams.
      Record t : Set := {
        x0 :
          alloc.vec.Vec.t
            ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
            *
            axum.util.PercentDecodedStr.t)
            alloc.vec.Vec.Default.A;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End RawPathParams.
    End RawPathParams.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.
    Section Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.
      Definition Self : Set := axum.extract.path.RawPathParams.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.
    End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.extract.path.RawPathParams.t.
      
      (*
          type Rejection = RawPathParamsRejection;
      *)
      Definition Rejection : Set :=
        axum.extract.rejection.RawPathParamsRejection.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
              let params = match parts.extensions.get::<UrlParams>() {
                  Some(UrlParams::Params(params)) => params,
                  Some(UrlParams::InvalidUtf8InPathParam { key }) => {
                      return Err(InvalidUtf8InPathParam {
                          key: Arc::clone(key),
                      }
                      .into());
                  }
                  None => {
                      return Err(MissingPathParams.into());
                  }
              };
      
              Ok(Self(params.clone()))
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (_state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* _state := M.alloc _state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.
    
    Module  Impl_axum_extract_path_RawPathParams_t.
    Section Impl_axum_extract_path_RawPathParams_t.
      Definition Self : Set := axum.extract.path.RawPathParams.t.
      
      (*
          pub fn iter(&self) -> RawPathParamsIter<'_> {
              self.into_iter()
          }
      *)
      Definition iter
          (self : ref Self)
          : M axum.extract.path.RawPathParamsIter.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_iter :
        Notations.DoubleColon Self "iter" := {
        Notations.double_colon := iter;
      }.
    End Impl_axum_extract_path_RawPathParams_t.
    End Impl_axum_extract_path_RawPathParams_t.
    
    Module  Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.
    Section Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.
      Definition Self : Set := ref axum.extract.path.RawPathParams.t.
      
      (*
          type Item = (&'a str, &'a str);
      *)
      Definition Item : Set := (ref str.t) * (ref str.t).
      
      (*
          type IntoIter = RawPathParamsIter<'a>;
      *)
      Definition IntoIter : Set := axum.extract.path.RawPathParamsIter.t.
      
      (*
          fn into_iter(self) -> Self::IntoIter {
              RawPathParamsIter(self.0.iter())
          }
      *)
      Definition into_iter (self : Self) : M IntoIter :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_iter :
        Notations.DoubleColon Self "into_iter" := {
        Notations.double_colon := into_iter;
      }.
      
      Global Instance ℐ : core.iter.traits.collect.IntoIterator.Trait Self := {
        core.iter.traits.collect.IntoIterator.Item := Item;
        core.iter.traits.collect.IntoIterator.IntoIter := IntoIter;
        core.iter.traits.collect.IntoIterator.into_iter := into_iter;
      }.
    End Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.
    End Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.
    
    Module  RawPathParamsIter.
    Section RawPathParamsIter.
      Record t : Set := {
        x0 :
          core.slice.iter.Iter.t
            ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
            *
            axum.util.PercentDecodedStr.t);
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End RawPathParamsIter.
    End RawPathParamsIter.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.
    Section Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.
      Definition Self : Set := axum.extract.path.RawPathParamsIter.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.
    End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.
    
    Module  Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.
    Section Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.
      Definition Self : Set := axum.extract.path.RawPathParamsIter.t.
      
      (*
          type Item = (&'a str, &'a str);
      *)
      Definition Item : Set := (ref str.t) * (ref str.t).
      
      (*
          fn next(&mut self) -> Option<Self::Item> {
              let (key, value) = self.0.next()?;
              Some((&**key, value.as_str()))
          }
      *)
      Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_next :
        Notations.DoubleColon Self "next" := {
        Notations.double_colon := next;
      }.
      
      Global Instance ℐ :
        core.iter.traits.iterator.Iterator.Required.Trait Self := {
        core.iter.traits.iterator.Iterator.Item := Item;
        core.iter.traits.iterator.Iterator.next := next;
        core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
        core.iter.traits.iterator.Iterator.size_hint := Datatypes.None;
        core.iter.traits.iterator.Iterator.count := Datatypes.None;
        core.iter.traits.iterator.Iterator.last := Datatypes.None;
        core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.nth := Datatypes.None;
        core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.chain := Datatypes.None;
        core.iter.traits.iterator.Iterator.zip := Datatypes.None;
        core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
        core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
        core.iter.traits.iterator.Iterator.map := Datatypes.None;
        core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
        core.iter.traits.iterator.Iterator.filter := Datatypes.None;
        core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
        core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
        core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
        core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
        core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
        core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
        core.iter.traits.iterator.Iterator.skip := Datatypes.None;
        core.iter.traits.iterator.Iterator.take := Datatypes.None;
        core.iter.traits.iterator.Iterator.scan := Datatypes.None;
        core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
        core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
        core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
        core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
        core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
        core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
        core.iter.traits.iterator.Iterator.collect := Datatypes.None;
        core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
        core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
        core.iter.traits.iterator.Iterator.partition := Datatypes.None;
        core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
        core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
        core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
        core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
        core.iter.traits.iterator.Iterator.fold := Datatypes.None;
        core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
        core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
        core.iter.traits.iterator.Iterator.all := Datatypes.None;
        core.iter.traits.iterator.Iterator.any := Datatypes.None;
        core.iter.traits.iterator.Iterator.find := Datatypes.None;
        core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
        core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
        core.iter.traits.iterator.Iterator.position := Datatypes.None;
        core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
        core.iter.traits.iterator.Iterator.max := Datatypes.None;
        core.iter.traits.iterator.Iterator.min := Datatypes.None;
        core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
        core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
        core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.rev := Datatypes.None;
        core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
        core.iter.traits.iterator.Iterator.copied := Datatypes.None;
        core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
        core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
        core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
        core.iter.traits.iterator.Iterator.sum := Datatypes.None;
        core.iter.traits.iterator.Iterator.product := Datatypes.None;
        core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
        core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
        core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.eq := Datatypes.None;
        core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.ne := Datatypes.None;
        core.iter.traits.iterator.Iterator.lt := Datatypes.None;
        core.iter.traits.iterator.Iterator.le := Datatypes.None;
        core.iter.traits.iterator.Iterator.gt := Datatypes.None;
        core.iter.traits.iterator.Iterator.ge := Datatypes.None;
        core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
        core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
        core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
          Datatypes.None;
      }.
    End Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.
    End Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.
    
    Module  InvalidUtf8InPathParam.
    Section InvalidUtf8InPathParam.
      Record t : Set := {
        key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
      }.
      
      Definition Get_key :=
        Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
    End InvalidUtf8InPathParam.
    End InvalidUtf8InPathParam.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.
    Section Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.
      Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.
    End Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.
    
    Module  Impl_axum_extract_path_InvalidUtf8InPathParam_t.
    Section Impl_axum_extract_path_InvalidUtf8InPathParam_t.
      Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
      
      (*
          pub fn body_text(&self) -> String {
              self.to_string()
          }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
          pub fn status(&self) -> StatusCode {
              StatusCode::BAD_REQUEST
          }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_path_InvalidUtf8InPathParam_t.
    End Impl_axum_extract_path_InvalidUtf8InPathParam_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.
    Section Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.
      Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              write!(f, "Invalid UTF-8 in `{}`", self.key)
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.
    End Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.
    
    Module  Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.
    Section Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.
      Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.None;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.
    End Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.
      Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
      
      (*
          fn into_response(self) -> Response {
              (self.status(), self.body_text()).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.
  End path.
  
  Module rejection.
    Module  JsonDataError.
    Section JsonDataError.
      Record t : Set := {
        x0 : axum_core.error.Error.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End JsonDataError.
    End JsonDataError.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.
      Definition Self : Set := axum.extract.rejection.JsonDataError.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.
    
    Module  Impl_axum_extract_rejection_JsonDataError_t.
    Section Impl_axum_extract_rejection_JsonDataError_t.
      Definition Self : Set := axum.extract.rejection.JsonDataError.t.
      
      (*
                  pub(crate) fn from_err<E>(err: E) -> Self
                  where
                      E: Into<$crate::BoxError>,
                  {
                      Self($crate::Error::new(err))
                  }
      *)
      Definition from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
          (err : E)
          : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
        Notations.DoubleColon Self "from_err" := {
        Notations.double_colon := from_err (E := E);
      }.
    End Impl_axum_extract_rejection_JsonDataError_t.
    End Impl_axum_extract_rejection_JsonDataError_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.
      Definition Self : Set := axum.extract.rejection.JsonDataError.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = self.body_text(),
                          status = http::StatusCode::$status,
                      );
                      (self.status(), self.body_text()).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.
    
    Module  Impl_axum_extract_rejection_JsonDataError_t_2.
    Section Impl_axum_extract_rejection_JsonDataError_t_2.
      Definition Self : Set := axum.extract.rejection.JsonDataError.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      format!(concat!($body, ": {}"), self.0).into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_JsonDataError_t_2.
    End Impl_axum_extract_rejection_JsonDataError_t_2.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.
      Definition Self : Set := axum.extract.rejection.JsonDataError.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.
      Definition Self : Set := axum.extract.rejection.JsonDataError.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      Some(&self.0)
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.
    End Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.
    
    Module  JsonSyntaxError.
    Section JsonSyntaxError.
      Record t : Set := {
        x0 : axum_core.error.Error.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End JsonSyntaxError.
    End JsonSyntaxError.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.
      Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.
    
    Module  Impl_axum_extract_rejection_JsonSyntaxError_t.
    Section Impl_axum_extract_rejection_JsonSyntaxError_t.
      Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
      
      (*
                  pub(crate) fn from_err<E>(err: E) -> Self
                  where
                      E: Into<$crate::BoxError>,
                  {
                      Self($crate::Error::new(err))
                  }
      *)
      Definition from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
          (err : E)
          : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
        Notations.DoubleColon Self "from_err" := {
        Notations.double_colon := from_err (E := E);
      }.
    End Impl_axum_extract_rejection_JsonSyntaxError_t.
    End Impl_axum_extract_rejection_JsonSyntaxError_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.
      Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = self.body_text(),
                          status = http::StatusCode::$status,
                      );
                      (self.status(), self.body_text()).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.
    
    Module  Impl_axum_extract_rejection_JsonSyntaxError_t_2.
    Section Impl_axum_extract_rejection_JsonSyntaxError_t_2.
      Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      format!(concat!($body, ": {}"), self.0).into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_JsonSyntaxError_t_2.
    End Impl_axum_extract_rejection_JsonSyntaxError_t_2.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.
      Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.
      Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      Some(&self.0)
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.
    End Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.
    
    Module  MissingJsonContentType.
    Section MissingJsonContentType.
      Inductive t : Set := Build.
    End MissingJsonContentType.
    End MissingJsonContentType.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.
      Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.
      Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = $body,
                          status = http::StatusCode::$status,
                      );
                      (self.status(), $body).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.
    
    Module  Impl_axum_extract_rejection_MissingJsonContentType_t.
    Section Impl_axum_extract_rejection_MissingJsonContentType_t.
      Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      $body.into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_MissingJsonContentType_t.
    End Impl_axum_extract_rejection_MissingJsonContentType_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.
      Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.
      Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.None;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.
    End Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.
    
    Module  Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.
    Section Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.
      Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
      
      (*
                  fn default() -> Self {
                      Self
                  }
      *)
      Definition default : M Self := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.
    End Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.
    
    Module  MissingExtension.
    Section MissingExtension.
      Record t : Set := {
        x0 : axum_core.error.Error.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End MissingExtension.
    End MissingExtension.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.
      Definition Self : Set := axum.extract.rejection.MissingExtension.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.
    
    Module  Impl_axum_extract_rejection_MissingExtension_t.
    Section Impl_axum_extract_rejection_MissingExtension_t.
      Definition Self : Set := axum.extract.rejection.MissingExtension.t.
      
      (*
                  pub(crate) fn from_err<E>(err: E) -> Self
                  where
                      E: Into<$crate::BoxError>,
                  {
                      Self($crate::Error::new(err))
                  }
      *)
      Definition from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
          (err : E)
          : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
        Notations.DoubleColon Self "from_err" := {
        Notations.double_colon := from_err (E := E);
      }.
    End Impl_axum_extract_rejection_MissingExtension_t.
    End Impl_axum_extract_rejection_MissingExtension_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.
      Definition Self : Set := axum.extract.rejection.MissingExtension.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = self.body_text(),
                          status = http::StatusCode::$status,
                      );
                      (self.status(), self.body_text()).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.
    
    Module  Impl_axum_extract_rejection_MissingExtension_t_2.
    Section Impl_axum_extract_rejection_MissingExtension_t_2.
      Definition Self : Set := axum.extract.rejection.MissingExtension.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      format!(concat!($body, ": {}"), self.0).into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_MissingExtension_t_2.
    End Impl_axum_extract_rejection_MissingExtension_t_2.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.
      Definition Self : Set := axum.extract.rejection.MissingExtension.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.
      Definition Self : Set := axum.extract.rejection.MissingExtension.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      Some(&self.0)
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.
    End Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.
    
    Module  MissingPathParams.
    Section MissingPathParams.
      Inductive t : Set := Build.
    End MissingPathParams.
    End MissingPathParams.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.
      Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.
      Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = $body,
                          status = http::StatusCode::$status,
                      );
                      (self.status(), $body).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.
    
    Module  Impl_axum_extract_rejection_MissingPathParams_t.
    Section Impl_axum_extract_rejection_MissingPathParams_t.
      Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      $body.into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_MissingPathParams_t.
    End Impl_axum_extract_rejection_MissingPathParams_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.
      Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.
      Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.None;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.
    End Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.
    
    Module  Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.
    Section Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.
      Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
      
      (*
                  fn default() -> Self {
                      Self
                  }
      *)
      Definition default : M Self := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.
    End Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.
    
    Module  InvalidFormContentType.
    Section InvalidFormContentType.
      Inductive t : Set := Build.
    End InvalidFormContentType.
    End InvalidFormContentType.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.
      Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.
      Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = $body,
                          status = http::StatusCode::$status,
                      );
                      (self.status(), $body).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.
    
    Module  Impl_axum_extract_rejection_InvalidFormContentType_t.
    Section Impl_axum_extract_rejection_InvalidFormContentType_t.
      Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      $body.into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_InvalidFormContentType_t.
    End Impl_axum_extract_rejection_InvalidFormContentType_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.
      Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.
      Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.None;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.
    End Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.
    
    Module  Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.
    Section Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.
      Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
      
      (*
                  fn default() -> Self {
                      Self
                  }
      *)
      Definition default : M Self := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.
    End Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.
    
    Module  FailedToResolveHost.
    Section FailedToResolveHost.
      Inductive t : Set := Build.
    End FailedToResolveHost.
    End FailedToResolveHost.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.
      Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.
      Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = $body,
                          status = http::StatusCode::$status,
                      );
                      (self.status(), $body).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.
    
    Module  Impl_axum_extract_rejection_FailedToResolveHost_t.
    Section Impl_axum_extract_rejection_FailedToResolveHost_t.
      Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      $body.into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_FailedToResolveHost_t.
    End Impl_axum_extract_rejection_FailedToResolveHost_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.
      Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.
      Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.None;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.
    End Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.
    
    Module  Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.
    Section Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.
      Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
      
      (*
                  fn default() -> Self {
                      Self
                  }
      *)
      Definition default : M Self := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.
    End Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.
    
    Module  FailedToDeserializeForm.
    Section FailedToDeserializeForm.
      Record t : Set := {
        x0 : axum_core.error.Error.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End FailedToDeserializeForm.
    End FailedToDeserializeForm.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.
      Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.
    
    Module  Impl_axum_extract_rejection_FailedToDeserializeForm_t.
    Section Impl_axum_extract_rejection_FailedToDeserializeForm_t.
      Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
      
      (*
                  pub(crate) fn from_err<E>(err: E) -> Self
                  where
                      E: Into<$crate::BoxError>,
                  {
                      Self($crate::Error::new(err))
                  }
      *)
      Definition from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
          (err : E)
          : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
        Notations.DoubleColon Self "from_err" := {
        Notations.double_colon := from_err (E := E);
      }.
    End Impl_axum_extract_rejection_FailedToDeserializeForm_t.
    End Impl_axum_extract_rejection_FailedToDeserializeForm_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.
      Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = self.body_text(),
                          status = http::StatusCode::$status,
                      );
                      (self.status(), self.body_text()).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.
    
    Module  Impl_axum_extract_rejection_FailedToDeserializeForm_t_2.
    Section Impl_axum_extract_rejection_FailedToDeserializeForm_t_2.
      Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      format!(concat!($body, ": {}"), self.0).into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_FailedToDeserializeForm_t_2.
    End Impl_axum_extract_rejection_FailedToDeserializeForm_t_2.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.
      Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.
      Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      Some(&self.0)
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.
    End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.
    
    Module  FailedToDeserializeFormBody.
    Section FailedToDeserializeFormBody.
      Record t : Set := {
        x0 : axum_core.error.Error.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End FailedToDeserializeFormBody.
    End FailedToDeserializeFormBody.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeFormBody.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    
    Module  Impl_axum_extract_rejection_FailedToDeserializeFormBody_t.
    Section Impl_axum_extract_rejection_FailedToDeserializeFormBody_t.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeFormBody.t.
      
      (*
                  pub(crate) fn from_err<E>(err: E) -> Self
                  where
                      E: Into<$crate::BoxError>,
                  {
                      Self($crate::Error::new(err))
                  }
      *)
      Definition from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
          (err : E)
          : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
        Notations.DoubleColon Self "from_err" := {
        Notations.double_colon := from_err (E := E);
      }.
    End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t.
    End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeFormBody.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = self.body_text(),
                          status = http::StatusCode::$status,
                      );
                      (self.status(), self.body_text()).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    
    Module  Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_2.
    Section Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_2.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeFormBody.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      format!(concat!($body, ": {}"), self.0).into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_2.
    End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_2.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeFormBody.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeFormBody.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      Some(&self.0)
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    
    Module  FailedToDeserializeQueryString.
    Section FailedToDeserializeQueryString.
      Record t : Set := {
        x0 : axum_core.error.Error.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End FailedToDeserializeQueryString.
    End FailedToDeserializeQueryString.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeQueryString.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    
    Module  Impl_axum_extract_rejection_FailedToDeserializeQueryString_t.
    Section Impl_axum_extract_rejection_FailedToDeserializeQueryString_t.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeQueryString.t.
      
      (*
                  pub(crate) fn from_err<E>(err: E) -> Self
                  where
                      E: Into<$crate::BoxError>,
                  {
                      Self($crate::Error::new(err))
                  }
      *)
      Definition from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
          (err : E)
          : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
        Notations.DoubleColon Self "from_err" := {
        Notations.double_colon := from_err (E := E);
      }.
    End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t.
    End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeQueryString.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = self.body_text(),
                          status = http::StatusCode::$status,
                      );
                      (self.status(), self.body_text()).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    
    Module  Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_2.
    Section Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_2.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeQueryString.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      format!(concat!($body, ": {}"), self.0).into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_2.
    End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_2.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeQueryString.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
      Definition Self : Set :=
        axum.extract.rejection.FailedToDeserializeQueryString.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      Some(&self.0)
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    
    Module QueryRejection.
      Inductive t : Set :=
      |
        FailedToDeserializeQueryString
        (_ : axum.extract.rejection.FailedToDeserializeQueryString.t).
      
      Definition Get_FailedToDeserializeQueryString_0 :=
        Ref.map
          (fun α =>
            match α with | FailedToDeserializeQueryString α0 => Some α0 end)
          (fun β α =>
            match α with
            | FailedToDeserializeQueryString _ =>
              Some (FailedToDeserializeQueryString β)
            end).
    End QueryRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.
      Definition Self : Set := axum.extract.rejection.QueryRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.
      Definition Self : Set := axum.extract.rejection.QueryRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.
    
    Module  Impl_axum_extract_rejection_QueryRejection_t.
    Section Impl_axum_extract_rejection_QueryRejection_t.
      Definition Self : Set := axum.extract.rejection.QueryRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_QueryRejection_t.
    End Impl_axum_extract_rejection_QueryRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.
      Definition Self : Set := axum.extract.rejection.QueryRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.FailedToDeserializeQueryString.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.FailedToDeserializeQueryString.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.
      Definition Self : Set := axum.extract.rejection.QueryRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.
      Definition Self : Set := axum.extract.rejection.QueryRejection.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.
    End Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.
    
    Module FormRejection.
      Inductive t : Set :=
      |
        InvalidFormContentType
        (_ : axum.extract.rejection.InvalidFormContentType.t)
      |
        FailedToDeserializeForm
        (_ : axum.extract.rejection.FailedToDeserializeForm.t)
      |
        FailedToDeserializeFormBody
        (_ : axum.extract.rejection.FailedToDeserializeFormBody.t)
      | BytesRejection (_ : axum_core.extract.rejection.BytesRejection.t).
      
      Definition Get_InvalidFormContentType_0 :=
        Ref.map
          (fun α =>
            match α with | InvalidFormContentType α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | InvalidFormContentType _ => Some (InvalidFormContentType β)
            | _ => None
            end).
      
      Definition Get_FailedToDeserializeForm_0 :=
        Ref.map
          (fun α =>
            match α with
            | FailedToDeserializeForm α0 => Some α0
            | _ => None
            end)
          (fun β α =>
            match α with
            | FailedToDeserializeForm _ => Some (FailedToDeserializeForm β)
            | _ => None
            end).
      
      Definition Get_FailedToDeserializeFormBody_0 :=
        Ref.map
          (fun α =>
            match α with
            | FailedToDeserializeFormBody α0 => Some α0
            | _ => None
            end)
          (fun β α =>
            match α with
            | FailedToDeserializeFormBody _ =>
              Some (FailedToDeserializeFormBody β)
            | _ => None
            end).
      
      Definition Get_BytesRejection_0 :=
        Ref.map
          (fun α => match α with | BytesRejection α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | BytesRejection _ => Some (BytesRejection β)
            | _ => None
            end).
    End FormRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.
      Definition Self : Set := axum.extract.rejection.FormRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.
      Definition Self : Set := axum.extract.rejection.FormRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.
    
    Module  Impl_axum_extract_rejection_FormRejection_t.
    Section Impl_axum_extract_rejection_FormRejection_t.
      Definition Self : Set := axum.extract.rejection.FormRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_FormRejection_t.
    End Impl_axum_extract_rejection_FormRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.
      Definition Self : Set := axum.extract.rejection.FormRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.InvalidFormContentType.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.InvalidFormContentType.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.
      Definition Self : Set := axum.extract.rejection.FormRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.FailedToDeserializeForm.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.FailedToDeserializeForm.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.
      Definition Self : Set := axum.extract.rejection.FormRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.FailedToDeserializeFormBody.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.FailedToDeserializeFormBody.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.
    
    Module  Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.
    Section Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.
      Definition Self : Set := axum.extract.rejection.FormRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum_core.extract.rejection.BytesRejection.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum_core.extract.rejection.BytesRejection.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.
    End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.
      Definition Self : Set := axum.extract.rejection.FormRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.
      Definition Self : Set := axum.extract.rejection.FormRejection.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.
    End Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.
    
    Module RawFormRejection.
      Inductive t : Set :=
      |
        InvalidFormContentType
        (_ : axum.extract.rejection.InvalidFormContentType.t)
      | BytesRejection (_ : axum_core.extract.rejection.BytesRejection.t).
      
      Definition Get_InvalidFormContentType_0 :=
        Ref.map
          (fun α =>
            match α with | InvalidFormContentType α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | InvalidFormContentType _ => Some (InvalidFormContentType β)
            | _ => None
            end).
      
      Definition Get_BytesRejection_0 :=
        Ref.map
          (fun α => match α with | BytesRejection α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | BytesRejection _ => Some (BytesRejection β)
            | _ => None
            end).
    End RawFormRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.
      Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.
      Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.
    
    Module  Impl_axum_extract_rejection_RawFormRejection_t.
    Section Impl_axum_extract_rejection_RawFormRejection_t.
      Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_RawFormRejection_t.
    End Impl_axum_extract_rejection_RawFormRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.
      Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.InvalidFormContentType.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.InvalidFormContentType.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.
    
    Module  Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.
    Section Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.
      Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum_core.extract.rejection.BytesRejection.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum_core.extract.rejection.BytesRejection.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.
    End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.
      Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.
      Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.
    End Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.
    
    Module JsonRejection.
      Inductive t : Set :=
      | JsonDataError (_ : axum.extract.rejection.JsonDataError.t)
      | JsonSyntaxError (_ : axum.extract.rejection.JsonSyntaxError.t)
      |
        MissingJsonContentType
        (_ : axum.extract.rejection.MissingJsonContentType.t)
      | BytesRejection (_ : axum_core.extract.rejection.BytesRejection.t).
      
      Definition Get_JsonDataError_0 :=
        Ref.map
          (fun α => match α with | JsonDataError α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | JsonDataError _ => Some (JsonDataError β)
            | _ => None
            end).
      
      Definition Get_JsonSyntaxError_0 :=
        Ref.map
          (fun α =>
            match α with | JsonSyntaxError α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | JsonSyntaxError _ => Some (JsonSyntaxError β)
            | _ => None
            end).
      
      Definition Get_MissingJsonContentType_0 :=
        Ref.map
          (fun α =>
            match α with | MissingJsonContentType α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | MissingJsonContentType _ => Some (MissingJsonContentType β)
            | _ => None
            end).
      
      Definition Get_BytesRejection_0 :=
        Ref.map
          (fun α => match α with | BytesRejection α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | BytesRejection _ => Some (BytesRejection β)
            | _ => None
            end).
    End JsonRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.
      Definition Self : Set := axum.extract.rejection.JsonRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.
      Definition Self : Set := axum.extract.rejection.JsonRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.
    
    Module  Impl_axum_extract_rejection_JsonRejection_t.
    Section Impl_axum_extract_rejection_JsonRejection_t.
      Definition Self : Set := axum.extract.rejection.JsonRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_JsonRejection_t.
    End Impl_axum_extract_rejection_JsonRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.
      Definition Self : Set := axum.extract.rejection.JsonRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.JsonDataError.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.JsonDataError.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.
      Definition Self : Set := axum.extract.rejection.JsonRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.JsonSyntaxError.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.JsonSyntaxError.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.
      Definition Self : Set := axum.extract.rejection.JsonRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.MissingJsonContentType.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.MissingJsonContentType.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.
    
    Module  Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.
    Section Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.
      Definition Self : Set := axum.extract.rejection.JsonRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum_core.extract.rejection.BytesRejection.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum_core.extract.rejection.BytesRejection.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.
    End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.
      Definition Self : Set := axum.extract.rejection.JsonRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.
      Definition Self : Set := axum.extract.rejection.JsonRejection.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.
    End Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.
    
    Module ExtensionRejection.
      Inductive t : Set :=
      | MissingExtension (_ : axum.extract.rejection.MissingExtension.t).
      
      Definition Get_MissingExtension_0 :=
        Ref.map
          (fun α => match α with | MissingExtension α0 => Some α0 end)
          (fun β α =>
            match α with | MissingExtension _ => Some (MissingExtension β) end).
    End ExtensionRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.
      Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.
      Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.
    
    Module  Impl_axum_extract_rejection_ExtensionRejection_t.
    Section Impl_axum_extract_rejection_ExtensionRejection_t.
      Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_ExtensionRejection_t.
    End Impl_axum_extract_rejection_ExtensionRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.
      Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.MissingExtension.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.MissingExtension.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.
      Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.
      Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.
    End Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.
    
    Module PathRejection.
      Inductive t : Set :=
      |
        FailedToDeserializePathParams
        (_ : axum.extract.path.FailedToDeserializePathParams.t)
      | MissingPathParams (_ : axum.extract.rejection.MissingPathParams.t).
      
      Definition Get_FailedToDeserializePathParams_0 :=
        Ref.map
          (fun α =>
            match α with
            | FailedToDeserializePathParams α0 => Some α0
            | _ => None
            end)
          (fun β α =>
            match α with
            | FailedToDeserializePathParams _ =>
              Some (FailedToDeserializePathParams β)
            | _ => None
            end).
      
      Definition Get_MissingPathParams_0 :=
        Ref.map
          (fun α =>
            match α with | MissingPathParams α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | MissingPathParams _ => Some (MissingPathParams β)
            | _ => None
            end).
    End PathRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.
      Definition Self : Set := axum.extract.rejection.PathRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.
      Definition Self : Set := axum.extract.rejection.PathRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.
    
    Module  Impl_axum_extract_rejection_PathRejection_t.
    Section Impl_axum_extract_rejection_PathRejection_t.
      Definition Self : Set := axum.extract.rejection.PathRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_PathRejection_t.
    End Impl_axum_extract_rejection_PathRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.
    Section Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.
      Definition Self : Set := axum.extract.rejection.PathRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.path.FailedToDeserializePathParams.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.path.FailedToDeserializePathParams.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.
    End Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.
      Definition Self : Set := axum.extract.rejection.PathRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.MissingPathParams.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.MissingPathParams.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.
      Definition Self : Set := axum.extract.rejection.PathRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.
      Definition Self : Set := axum.extract.rejection.PathRejection.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.
    End Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.
    
    Module RawPathParamsRejection.
      Inductive t : Set :=
      | InvalidUtf8InPathParam (_ : axum.extract.path.InvalidUtf8InPathParam.t)
      | MissingPathParams (_ : axum.extract.rejection.MissingPathParams.t).
      
      Definition Get_InvalidUtf8InPathParam_0 :=
        Ref.map
          (fun α =>
            match α with | InvalidUtf8InPathParam α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | InvalidUtf8InPathParam _ => Some (InvalidUtf8InPathParam β)
            | _ => None
            end).
      
      Definition Get_MissingPathParams_0 :=
        Ref.map
          (fun α =>
            match α with | MissingPathParams α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | MissingPathParams _ => Some (MissingPathParams β)
            | _ => None
            end).
    End RawPathParamsRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.
      Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.
      Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.
    
    Module  Impl_axum_extract_rejection_RawPathParamsRejection_t.
    Section Impl_axum_extract_rejection_RawPathParamsRejection_t.
      Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_RawPathParamsRejection_t.
    End Impl_axum_extract_rejection_RawPathParamsRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.
    Section Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.
      Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.path.InvalidUtf8InPathParam.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.path.InvalidUtf8InPathParam.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.
    End Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.
      Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.MissingPathParams.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.MissingPathParams.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.
      Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.
      Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.
    End Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.
    
    Module HostRejection.
      Inductive t : Set :=
      | FailedToResolveHost (_ : axum.extract.rejection.FailedToResolveHost.t).
      
      Definition Get_FailedToResolveHost_0 :=
        Ref.map
          (fun α => match α with | FailedToResolveHost α0 => Some α0 end)
          (fun β α =>
            match α with
            | FailedToResolveHost _ => Some (FailedToResolveHost β)
            end).
    End HostRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.
      Definition Self : Set := axum.extract.rejection.HostRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.
      Definition Self : Set := axum.extract.rejection.HostRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.
    
    Module  Impl_axum_extract_rejection_HostRejection_t.
    Section Impl_axum_extract_rejection_HostRejection_t.
      Definition Self : Set := axum.extract.rejection.HostRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_HostRejection_t.
    End Impl_axum_extract_rejection_HostRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.
      Definition Self : Set := axum.extract.rejection.HostRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.FailedToResolveHost.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.FailedToResolveHost.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.
      Definition Self : Set := axum.extract.rejection.HostRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.
      Definition Self : Set := axum.extract.rejection.HostRejection.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.
    End Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.
    
    Module  MatchedPathMissing.
    Section MatchedPathMissing.
      Inductive t : Set := Build.
    End MatchedPathMissing.
    End MatchedPathMissing.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = $body,
                          status = http::StatusCode::$status,
                      );
                      (self.status(), $body).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.
    
    Module  Impl_axum_extract_rejection_MatchedPathMissing_t.
    Section Impl_axum_extract_rejection_MatchedPathMissing_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      $body.into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_MatchedPathMissing_t.
    End Impl_axum_extract_rejection_MatchedPathMissing_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.None;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.
    End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.
    
    Module  Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.
    Section Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
      
      (*
                  fn default() -> Self {
                      Self
                  }
      *)
      Definition default : M Self := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.
    End Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.
    
    Module MatchedPathRejection.
      Inductive t : Set :=
      | MatchedPathMissing (_ : axum.extract.rejection.MatchedPathMissing.t).
      
      Definition Get_MatchedPathMissing_0 :=
        Ref.map
          (fun α => match α with | MatchedPathMissing α0 => Some α0 end)
          (fun β α =>
            match α with
            | MatchedPathMissing _ => Some (MatchedPathMissing β)
            end).
    End MatchedPathRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.
    
    Module  Impl_axum_extract_rejection_MatchedPathRejection_t.
    Section Impl_axum_extract_rejection_MatchedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_MatchedPathRejection_t.
    End Impl_axum_extract_rejection_MatchedPathRejection_t.
    
    Module  Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.
    Section Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum.extract.rejection.MatchedPathMissing.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum.extract.rejection.MatchedPathMissing.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.
    End Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.
    End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.
    
    Module  NestedPathRejection.
    Section NestedPathRejection.
      Inductive t : Set := Build.
    End NestedPathRejection.
    End NestedPathRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.
    Section Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.
    End Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = $body,
                          status = http::StatusCode::$status,
                      );
                      (self.status(), $body).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.
    
    Module  Impl_axum_extract_rejection_NestedPathRejection_t.
    Section Impl_axum_extract_rejection_NestedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      $body.into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_extract_rejection_NestedPathRejection_t.
    End Impl_axum_extract_rejection_NestedPathRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.
    Section Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.
    End Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.
    
    Module  Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.
    Section Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.None;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.
    End Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.
    
    Module  Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.
    Section Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.
      Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
      
      (*
                  fn default() -> Self {
                      Self
                  }
      *)
      Definition default : M Self := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.
    End Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.
  End rejection.
  
  Module host.
    Definition X_FORWARDED_HOST_HEADER_KEY : M.Val (ref str.t) :=
      M.run (M.pure foo).
    
    Module  Host.
    Section Host.
      Record t : Set := {
        x0 : alloc.string.String.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End Host.
    End Host.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_host_Host_t.
    Section Impl_core_fmt_Debug_for_axum_extract_host_Host_t.
      Definition Self : Set := axum.extract.host.Host.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_host_Host_t.
    End Impl_core_fmt_Debug_for_axum_extract_host_Host_t.
    
    Module  Impl_core_clone_Clone_for_axum_extract_host_Host_t.
    Section Impl_core_clone_Clone_for_axum_extract_host_Host_t.
      Definition Self : Set := axum.extract.host.Host.t.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M axum.extract.host.Host.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_host_Host_t.
    End Impl_core_clone_Clone_for_axum_extract_host_Host_t.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.extract.host.Host.t.
      
      (*
          type Rejection = HostRejection;
      *)
      Definition Rejection : Set := axum.extract.rejection.HostRejection.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
              if let Some(host) = parse_forwarded(&parts.headers) {
                  return Ok(Host(host.to_owned()));
              }
      
              if let Some(host) = parts
                  .headers
                  .get(X_FORWARDED_HOST_HEADER_KEY)
                  .and_then(|host| host.to_str().ok())
              {
                  return Ok(Host(host.to_owned()));
              }
      
              if let Some(host) = parts
                  .headers
                  .get(http::header::HOST)
                  .and_then(|host| host.to_str().ok())
              {
                  return Ok(Host(host.to_owned()));
              }
      
              if let Some(host) = parts.uri.host() {
                  return Ok(Host(host.to_owned()));
              }
      
              Err(HostRejection::FailedToResolveHost(FailedToResolveHost))
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (_state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* _state := M.alloc _state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.
    
    (*
    fn parse_forwarded(headers: &HeaderMap) -> Option<&str> {
        // if there are multiple `Forwarded` `HeaderMap::get` will return the first one
        let forwarded_values = headers.get(FORWARDED)?.to_str().ok()?;
    
        // get the first set of values
        let first_value = forwarded_values.split(',').nth(0)?;
    
        // find the value of the `host` field
        first_value.split(';').find_map(|pair| {
            let (key, value) = pair.split_once('=')?;
            key.trim()
                .eq_ignore_ascii_case("host")
                .then(|| value.trim().trim_matches('"'))
        })
    }
    "
    *)
    Definition parse_forwarded
        (headers
          :
          ref (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
        : M (core.option.Option.t (ref str.t)) :=
      let* headers := M.alloc headers in
      M.read foo.
  End host.
  
  Module nested_path.
    Module  NestedPath.
    Section NestedPath.
      Record t : Set := {
        x0 : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End NestedPath.
    End NestedPath.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.
    Section Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.
      Definition Self : Set := axum.extract.nested_path.NestedPath.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.
    End Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.
    
    Module  Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.
    Section Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.
      Definition Self : Set := axum.extract.nested_path.NestedPath.t.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum.extract.nested_path.NestedPath.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.
    End Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.
    
    Module  Impl_axum_extract_nested_path_NestedPath_t.
    Section Impl_axum_extract_nested_path_NestedPath_t.
      Definition Self : Set := axum.extract.nested_path.NestedPath.t.
      
      (*
          pub fn as_str(&self) -> &str {
              &self.0
          }
      *)
      Definition as_str (self : ref Self) : M (ref str.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_as_str :
        Notations.DoubleColon Self "as_str" := {
        Notations.double_colon := as_str;
      }.
    End Impl_axum_extract_nested_path_NestedPath_t.
    End Impl_axum_extract_nested_path_NestedPath_t.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.extract.nested_path.NestedPath.t.
      
      (*
          type Rejection = NestedPathRejection;
      *)
      Definition Rejection : Set :=
        axum.extract.rejection.NestedPathRejection.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
              match parts.extensions.get::<Self>() {
                  Some(nested_path) => Ok(nested_path.clone()),
                  None => Err(NestedPathRejection),
              }
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (_state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* _state := M.alloc _state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.
    
    Module  SetNestedPath.
    Section SetNestedPath.
      Context (S : Set).
      
      Record t : Set := {
        inner : S;
        path : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
      }.
      
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
      Definition Get_path :=
        Ref.map (fun α => Some α.(path)) (fun β α => Some (α <| path := β |>)).
    End SetNestedPath.
    End SetNestedPath.
    
    Module  Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.
    Section Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set := axum.extract.nested_path.SetNestedPath.t S.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M (axum.extract.nested_path.SetNestedPath.t S) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.
    End Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.
    
    Module  Impl_axum_extract_nested_path_SetNestedPath_t_S.
    Section Impl_axum_extract_nested_path_SetNestedPath_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.extract.nested_path.SetNestedPath.t S.
      
      (*
          pub(crate) fn layer(path: &str) -> impl Layer<S, Service = Self> + Clone {
              let path = Arc::from(path);
              layer_fn(move |inner| Self {
                  inner,
                  path: Arc::clone(&path),
              })
          }
      *)
      Definition layer (path : ref str.t) : M _ (* OpaqueTy *) :=
        let* path := M.alloc path in
        M.read foo.
      
      Global Instance AssociatedFunction_layer :
        Notations.DoubleColon Self "layer" := {
        Notations.double_colon := layer;
      }.
    End Impl_axum_extract_nested_path_SetNestedPath_t_S.
    End Impl_axum_extract_nested_path_SetNestedPath_t_S.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.
    Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.
      Context {S B : Set}.
      
      Context
        {ℋ_0 :
          tower_service.Service.Trait S
            (Request := ltac:(axum_core.extract.Request B))}.
      
      Definition Self : Set := axum.extract.nested_path.SetNestedPath.t S.
      
      (*
          type Response = S::Response;
      *)
      Definition Response : Set := S::type["Response"].t.
      
      (*
          type Error = S::Error;
      *)
      Definition Error : Set := S::type["Error"].t.
      
      (*
          type Future = S::Future;
      *)
      Definition Future : Set := S::type["Future"].t.
      
      (*
          fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              self.inner.poll_ready(cx)
          }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
          fn call(&mut self, mut req: Request<B>) -> Self::Future {
              if let Some(prev) = req.extensions_mut().get_mut::<NestedPath>() {
                  let new_path = if prev.as_str() == "/" {
                      Arc::clone(&self.path)
                  } else {
                      format!("{}{}", prev.as_str().trim_end_matches('/'), self.path).into()
                  };
                  prev.0 = new_path;
              } else {
                  req.extensions_mut()
                      .insert(NestedPath(Arc::clone(&self.path)));
              };
      
              self.inner.call(req)
          }
      *)
      Definition call
          (self : mut_ref Self)
          (req : ltac:(axum_core.extract.Request B))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request B)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.
    End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.
  End nested_path.
  
  Module raw_form.
    Module  RawForm.
    Section RawForm.
      Record t : Set := {
        x0 : bytes.bytes.Bytes.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End RawForm.
    End RawForm.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.
    Section Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.
      Definition Self : Set := axum.extract.raw_form.RawForm.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.
    End Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.
    Section Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.extract.raw_form.RawForm.t.
      
      (*
          type Rejection = RawFormRejection;
      *)
      Definition Rejection : Set := axum.extract.rejection.RawFormRejection.t.
      
      (*
          async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
              if req.method() == Method::GET {
                  if let Some(query) = req.uri().query() {
                      return Ok(Self(Bytes::copy_from_slice(query.as_bytes())));
                  }
      
                  Ok(Self(Bytes::new()))
              } else {
                  if !has_content_type(req.headers(), &mime::APPLICATION_WWW_FORM_URLENCODED) {
                      return Err(InvalidFormContentType.into());
                  }
      
                  Ok(Self(Bytes::from_request(req, state).await?))
              }
          }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.
    End Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.
  End raw_form.
  
  Module raw_query.
    Module  RawQuery.
    Section RawQuery.
      Record t : Set := {
        x0 : core.option.Option.t alloc.string.String.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End RawQuery.
    End RawQuery.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.
    Section Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.
      Definition Self : Set := axum.extract.raw_query.RawQuery.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.
    End Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.extract.raw_query.RawQuery.t.
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
              let query = parts.uri.query().map(|query| query.to_owned());
              Ok(Self(query))
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (_state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* _state := M.alloc _state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.
  End raw_query.
  
  Module request_parts.
    Module  OriginalUri.
    Section OriginalUri.
      Record t : Set := {
        x0 : http.uri.Uri.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End OriginalUri.
    End OriginalUri.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.
    Section Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.
      Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.
    End Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.
    
    Module  Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.
    Section Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.
      Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum.extract.request_parts.OriginalUri.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.
    End Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
              let uri = Extension::<Self>::from_request_parts(parts, state)
                  .await
                  .unwrap_or_else(|_| Extension(OriginalUri(parts.uri.clone())))
                  .0;
              Ok(uri)
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.
    
    Module  Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.
    Section Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.
      Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
      
      (*
                  type Target = $ty;
      *)
      Definition Target : Set := http.uri.Uri.t.
      
      (*
                  fn deref(&self) -> &Self::Target {
                      &self.0
                  }
      *)
      Definition deref (self : ref Self) : M (ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref :
        Notations.DoubleColon Self "deref" := {
        Notations.double_colon := deref;
      }.
      
      Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
        core.ops.deref.Deref.Target := Target;
        core.ops.deref.Deref.deref := deref;
      }.
    End Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.
    End Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.
    
    Module  Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.
    Section Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.
      Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
      
      (*
                  fn deref_mut(&mut self) -> &mut Self::Target {
                      &mut self.0
                  }
      *)
      Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref_mut :
        Notations.DoubleColon Self "deref_mut" := {
        Notations.double_colon := deref_mut;
      }.
      
      Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
        core.ops.deref.DerefMut.deref_mut := deref_mut;
      }.
    End Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.
    End Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.
  End request_parts.
  
  Module state.
    Module  State.
    Section State.
      Context {S : Set}.
      
      Record t : Set := {
        x0 : S;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End State.
    End State.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.
    Section Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S}.
      
      Definition Self : Set := axum.extract.state.State.t S.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.
    End Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.
    
    Module  Impl_core_default_Default_for_axum_extract_state_State_t_S.
    Section Impl_core_default_Default_for_axum_extract_state_State_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.default.Default.Trait S}.
      
      Definition Self : Set := axum.extract.state.State.t S.
      
      (*
      Default
      *)
      Definition default : M (axum.extract.state.State.t S) := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_extract_state_State_t_S.
    End Impl_core_default_Default_for_axum_extract_state_State_t_S.
    
    Module  Impl_core_clone_Clone_for_axum_extract_state_State_t_S.
    Section Impl_core_clone_Clone_for_axum_extract_state_State_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set := axum.extract.state.State.t S.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M (axum.extract.state.State.t S) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_state_State_t_S.
    End Impl_core_clone_Clone_for_axum_extract_state_State_t_S.
    
    Module  Impl_core_marker_Copy_for_axum_extract_state_State_t_S.
    Section Impl_core_marker_Copy_for_axum_extract_state_State_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Copy.Trait S}.
      
      Definition Self : Set := axum.extract.state.State.t S.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_extract_state_State_t_S.
    End Impl_core_marker_Copy_for_axum_extract_state_State_t_S.
    
    Module  Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.
    Section Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.
      Context {OuterState InnerState : Set}.
      
      Context
        {ℋ_0 :
          axum_core.extract.from_ref.FromRef.Trait InnerState (T := OuterState)}
        {ℋ_1 : core.marker.Send.Trait OuterState}
        {ℋ_2 : core.marker.Sync.Trait OuterState}.
      
      Definition Self : Set := axum.extract.state.State.t InnerState.
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request_parts(
              _parts: &mut Parts,
              state: &OuterState,
          ) -> Result<Self, Self::Rejection> {
              let inner_state = InnerState::from_ref(state);
              Ok(Self(inner_state))
          }
      *)
      Definition from_request_parts
          (_parts : mut_ref http.request.Parts.t)
          (state : ref OuterState)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* _parts := M.alloc _parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := OuterState) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.
    End Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.
    
    Module  Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.
    Section Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.extract.state.State.t S.
      
      (*
          type Target = S;
      *)
      Definition Target : Set := S.
      
      (*
          fn deref(&self) -> &Self::Target {
              &self.0
          }
      *)
      Definition deref (self : ref Self) : M (ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref :
        Notations.DoubleColon Self "deref" := {
        Notations.double_colon := deref;
      }.
      
      Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
        core.ops.deref.Deref.Target := Target;
        core.ops.deref.Deref.deref := deref;
      }.
    End Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.
    End Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.
    
    Module  Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.
    Section Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.extract.state.State.t S.
      
      (*
          fn deref_mut(&mut self) -> &mut Self::Target {
              &mut self.0
          }
      *)
      Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref_mut :
        Notations.DoubleColon Self "deref_mut" := {
        Notations.double_colon := deref_mut;
      }.
      
      Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
        core.ops.deref.DerefMut.deref_mut := deref_mut;
      }.
    End Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.
    End Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.
  End state.
  
  Module matched_path.
    Module  MatchedPath.
    Section MatchedPath.
      Record t : Set := {
        x0 : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End MatchedPath.
    End MatchedPath.
    
    Module  Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.
    Section Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.
      Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum.extract.matched_path.MatchedPath.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.
    End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.
    Section Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.
      Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.
    End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.
    
    Module  Impl_axum_extract_matched_path_MatchedPath_t.
    Section Impl_axum_extract_matched_path_MatchedPath_t.
      Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
      
      (*
          pub fn as_str(&self) -> &str {
              &self.0
          }
      *)
      Definition as_str (self : ref Self) : M (ref str.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_as_str :
        Notations.DoubleColon Self "as_str" := {
        Notations.double_colon := as_str;
      }.
    End Impl_axum_extract_matched_path_MatchedPath_t.
    End Impl_axum_extract_matched_path_MatchedPath_t.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
      
      (*
          type Rejection = MatchedPathRejection;
      *)
      Definition Rejection : Set :=
        axum.extract.rejection.MatchedPathRejection.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
              let matched_path = parts
                  .extensions
                  .get::<Self>()
                  .ok_or(MatchedPathRejection::MatchedPathMissing(MatchedPathMissing))?
                  .clone();
      
              Ok(matched_path)
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (_state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* _state := M.alloc _state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.
    
    Module  MatchedNestedPath.
    Section MatchedNestedPath.
      Record t : Set := {
        x0 : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End MatchedNestedPath.
    End MatchedNestedPath.
    
    Module  Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.
    Section Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.
      Definition Self : Set := axum.extract.matched_path.MatchedNestedPath.t.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum.extract.matched_path.MatchedNestedPath.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.
    End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.
    Section Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.
      Definition Self : Set := axum.extract.matched_path.MatchedNestedPath.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.
    End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.
    
    (*
    pub(crate) fn set_matched_path_for_request(
        id: RouteId,
        route_id_to_path: &HashMap<RouteId, Arc<str>>,
        extensions: &mut http::Extensions,
    ) {
        let matched_path = if let Some(matched_path) = route_id_to_path.get(&id) {
            matched_path
        } else {
            #[cfg(debug_assertions)]
            panic!("should always have a matched path for a route id");
            #[cfg(not(debug_assertions))]
            return;
        };
    
        let matched_path = append_nested_matched_path(matched_path, extensions);
    
        if matched_path.ends_with(NEST_TAIL_PARAM_CAPTURE) {
            extensions.insert(MatchedNestedPath(matched_path));
            debug_assert!(extensions.remove::<MatchedPath>().is_none());
        } else {
            extensions.insert(MatchedPath(matched_path));
            extensions.remove::<MatchedNestedPath>();
        }
    }
    *)
    Definition set_matched_path_for_request
        (id : axum.routing.RouteId.t)
        (route_id_to_path
          :
          ref
            (std.collections.hash.map.HashMap.t
              axum.routing.RouteId.t
              (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
              std.collections.hash.map.HashMap.Default.S))
        (extensions : mut_ref http.extensions.Extensions.t)
        : M unit :=
      let* id := M.alloc id in
      let* route_id_to_path := M.alloc route_id_to_path in
      let* extensions := M.alloc extensions in
      M.read foo.
    
    (*
    fn append_nested_matched_path(matched_path: &Arc<str>, extensions: &http::Extensions) -> Arc<str> {
        if let Some(previous) = extensions
            .get::<MatchedPath>()
            .map(|matched_path| matched_path.as_str())
            .or_else(|| Some(&extensions.get::<MatchedNestedPath>()?.0))
        {
            let previous = previous
                .strip_suffix(NEST_TAIL_PARAM_CAPTURE)
                .unwrap_or(previous);
    
            let matched_path = format!("{previous}{matched_path}");
            matched_path.into()
        } else {
            Arc::clone(matched_path)
        }
    }
    *)
    Definition append_nested_matched_path
        (matched_path : ref (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A))
        (extensions : ref http.extensions.Extensions.t)
        : M (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A) :=
      let* matched_path := M.alloc matched_path in
      let* extensions := M.alloc extensions in
      M.read foo.
  End matched_path.
  
  Module query.
    Module  Query.
    Section Query.
      Context {T : Set}.
      
      Record t : Set := {
        x0 : T;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End Query.
    End Query.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.
    Section Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait T}.
      
      Definition Self : Set := axum.extract.query.Query.t T.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.
    End Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.
    
    Module  Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.
    Section Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait T}.
      
      Definition Self : Set := axum.extract.query.Query.t T.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M (axum.extract.query.Query.t T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.
    End Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.
    
    Module  Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.
    Section Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.marker.Copy.Trait T}.
      
      Definition Self : Set := axum.extract.query.Query.t T.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.
    End Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.
    
    Module  Impl_core_default_Default_for_axum_extract_query_Query_t_T.
    Section Impl_core_default_Default_for_axum_extract_query_Query_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.default.Default.Trait T}.
      
      Definition Self : Set := axum.extract.query.Query.t T.
      
      (*
      Default
      *)
      Definition default : M (axum.extract.query.Query.t T) := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_extract_query_Query_t_T.
    End Impl_core_default_Default_for_axum_extract_query_Query_t_T.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.
      Context {T S : Set}.
      
      Context
        {ℋ_0 : serde.de.DeserializeOwned.Trait T}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.extract.query.Query.t T.
      
      (*
          type Rejection = QueryRejection;
      *)
      Definition Rejection : Set := axum.extract.rejection.QueryRejection.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
              Self::try_from_uri(&parts.uri)
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (_state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* _state := M.alloc _state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.
    
    Module  Impl_axum_extract_query_Query_t_T.
    Section Impl_axum_extract_query_Query_t_T.
      Context {T : Set}.
      
      Definition Self : Set := axum.extract.query.Query.t T.
      
      (*
          pub fn try_from_uri(value: &Uri) -> Result<Self, QueryRejection> {
              let query = value.query().unwrap_or_default();
              let params =
                  serde_urlencoded::from_str(query).map_err(FailedToDeserializeQueryString::from_err)?;
              Ok(Query(params))
          }
      *)
      Definition try_from_uri
          (value : ref http.uri.Uri.t)
          :
            M
              (core.result.Result.t
                Self
                axum.extract.rejection.QueryRejection.t) :=
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_try_from_uri :
        Notations.DoubleColon Self "try_from_uri" := {
        Notations.double_colon := try_from_uri;
      }.
    End Impl_axum_extract_query_Query_t_T.
    End Impl_axum_extract_query_Query_t_T.
    
    Module  Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.
    Section Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.
      Context {T : Set}.
      
      Definition Self : Set := axum.extract.query.Query.t T.
      
      (*
                  type Target = T;
      *)
      Definition Target : Set := T.
      
      (*
                  fn deref(&self) -> &Self::Target {
                      &self.0
                  }
      *)
      Definition deref (self : ref Self) : M (ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref :
        Notations.DoubleColon Self "deref" := {
        Notations.double_colon := deref;
      }.
      
      Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
        core.ops.deref.Deref.Target := Target;
        core.ops.deref.Deref.deref := deref;
      }.
    End Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.
    End Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.
    
    Module  Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.
    Section Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.
      Context {T : Set}.
      
      Definition Self : Set := axum.extract.query.Query.t T.
      
      (*
                  fn deref_mut(&mut self) -> &mut Self::Target {
                      &mut self.0
                  }
      *)
      Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref_mut :
        Notations.DoubleColon Self "deref_mut" := {
        Notations.double_colon := deref_mut;
      }.
      
      Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
        core.ops.deref.DerefMut.deref_mut := deref_mut;
      }.
    End Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.
    End Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.
  End query.
  
  (*
  pub(super) fn has_content_type(headers: &HeaderMap, expected_content_type: &mime::Mime) -> bool {
      let content_type = if let Some(content_type) = headers.get(header::CONTENT_TYPE) {
          content_type
      } else {
          return false;
      };
  
      let content_type = if let Ok(content_type) = content_type.to_str() {
          content_type
      } else {
          return false;
      };
  
      content_type.starts_with(expected_content_type.as_ref())
  }
  *)
  Definition has_content_type
      (headers
        :
        ref (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
      (expected_content_type : ref mime.Mime.t)
      : M bool.t :=
    let* headers := M.alloc headers in
    let* expected_content_type := M.alloc expected_content_type in
    M.read foo.
End extract.

Module connect_info.
  Module  IntoMakeServiceWithConnectInfo.
  Section IntoMakeServiceWithConnectInfo.
    Context (S C : Set).
    
    Record t : Set := {
      svc : S;
      _connect_info : core.marker.PhantomData.t C;
    }.
    
    Definition Get_svc :=
      Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
    Definition Get__connect_info :=
      Ref.map
        (fun α => Some α.(_connect_info))
        (fun β α => Some (α <| _connect_info := β |>)).
  End IntoMakeServiceWithConnectInfo.
  End IntoMakeServiceWithConnectInfo.
  
  Module  Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C_2.
  Section Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C_2.
    Context {S C : Set}.
    
    Definition Self : Set :=
      axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
    
    (*
        pub(crate) fn new(svc: S) -> Self {
            Self {
                svc,
                _connect_info: PhantomData,
            }
        }
    *)
    Definition new (svc : S) : M Self :=
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C_2.
  End Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C_2.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  Section Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    Context {S C : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set :=
      axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("IntoMakeServiceWithConnectInfo")
                .field("svc", &self.svc)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  End Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  
  Module  Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  Section Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    Context {S C : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set :=
      axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
    
    (*
        fn clone(&self) -> Self {
            Self {
                svc: self.svc.clone(),
                _connect_info: PhantomData,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  End Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  
  Module  Connected.
  Section Connected.
    Class Trait (Self : Set) {T : Set} : Type := {
      ℒ_0 :: core.clone.Clone.Trait Self;
      ℒ_1 :: core.marker.Send.Trait Self;
      ℒ_2 :: core.marker.Sync.Trait Self;
      connect_info : T -> M Self;
    }.
    
  End Connected.
  End Connected.
  
  Module  Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.
  Section Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.
    Definition Self : Set := core.net.socket_addr.SocketAddr.t.
    
    (*
        fn connect_info(remote_addr: SocketAddr) -> Self {
            remote_addr
        }
    *)
    Definition connect_info
        (remote_addr : core.net.socket_addr.SocketAddr.t)
        : M Self :=
      let* remote_addr := M.alloc remote_addr in
      M.read foo.
    
    Global Instance AssociatedFunction_connect_info :
      Notations.DoubleColon Self "connect_info" := {
      Notations.double_colon := connect_info;
    }.
    
    Global Instance ℐ :
      axum.extract.connect_info.Connected.Trait Self
        (T := core.net.socket_addr.SocketAddr.t) := {
      axum.extract.connect_info.Connected.connect_info := connect_info;
    }.
  End Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.
  End Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.
  
  Module  Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  Section Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
    Context {S C T : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait S}
      {ℋ_1 : axum.extract.connect_info.Connected.Trait C (T := T)}.
    
    Definition Self : Set :=
      axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
    
    (*
        type Response = AddExtension<S, ConnectInfo<C>>;
    *)
    Definition Response : Set :=
      axum.extension.AddExtension.t
          S
          (axum.extract.connect_info.ConnectInfo.t C).
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        type Future = ResponseFuture<S, C>;
    *)
    Definition Future : Set := axum.extract.connect_info.ResponseFuture.t S C.
    
    (*
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (_cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* _cx := M.alloc _cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, target: T) -> Self::Future {
            let connect_info = ConnectInfo(C::connect_info(target));
            let svc = Extension(connect_info).layer(self.svc.clone());
            ResponseFuture::new(ready(Ok(svc)))
        }
    *)
    Definition call (self : mut_ref Self) (target : T) : M Future :=
      let* self := M.alloc self in
      let* target := M.alloc target in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ : tower_service.Service.Trait Self (Request := T) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  End Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  
  Module  ResponseFuture.
  Section ResponseFuture.
    Context (S C : Set).
    
    Record t : Set := {
      future :
        core.future.ready.Ready.t
          (core.result.Result.t
            (axum.extension.AddExtension.t
              S
              (axum.extract.connect_info.ConnectInfo.t C))
            core.convert.Infallible.t);
    }.
    
    Definition Get_future :=
      Ref.map
        (fun α => Some α.(future))
        (fun β α => Some (α <| future := β |>)).
  End ResponseFuture.
  End ResponseFuture.
  
  Module  Impl_axum_extract_connect_info_ResponseFuture_t_S_C_2.
  Section Impl_axum_extract_connect_info_ResponseFuture_t_S_C_2.
    Context {S C : Set}.
    
    Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
    
    (*
                pub(crate) fn new(future: $actual) -> Self {
                    Self { future }
                }
    *)
    Definition new
        (future
          :
          core.future.ready.Ready.t
            (core.result.Result.t
              (axum.extension.AddExtension.t
                S
                (axum.extract.connect_info.ConnectInfo.t C))
              core.convert.Infallible.t))
        : M Self :=
      let* future := M.alloc future in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_axum_extract_connect_info_ResponseFuture_t_S_C_2.
  End Impl_axum_extract_connect_info_ResponseFuture_t_S_C_2.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.
  Section Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.
    Context {S C : Set}.
    
    Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.debug_struct(stringify!($name)).finish_non_exhaustive()
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.
  End Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.
  
  Module  Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.
  Section Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.
    Context {S C : Set}.
    
    Context
      {ℋ_0 :
        core.future.future.Future.Trait
            (core.future.ready.Ready.t
              (core.result.Result.t
                (axum.extension.AddExtension.t
                  S
                  (axum.extract.connect_info.ConnectInfo.t C))
                core.convert.Infallible.t))}.
    
    Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
    
    (*
                type Output = <$actual as std::future::Future>::Output;
    *)
    Definition Output : Set :=
      core.future.future.Future.Output
          (Self := core.future.ready.Ready.t
            (core.result.Result.t
              (axum.extension.AddExtension.t
                S
                (axum.extract.connect_info.ConnectInfo.t C))
              core.convert.Infallible.t))
          (Trait := ltac:(refine _)).
    
    (*
                fn poll(
                    self: std::pin::Pin<&mut Self>,
                    cx: &mut std::task::Context<'_>,
                ) -> std::task::Poll<Self::Output> {
                    self.project().future.poll(cx)
                }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.
  End Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.
  
  Module  ConnectInfo.
  Section ConnectInfo.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End ConnectInfo.
  End ConnectInfo.
  
  Module  Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.
  Section Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum.extract.connect_info.ConnectInfo.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.
  End Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.
  
  Module  Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.
  Section Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.
  End Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.
  Section Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.
  End Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.
    Context {S T : Set}.
    
    Context
      {ℋ_0 : core.marker.Send.Trait S}
      {ℋ_1 : core.marker.Sync.Trait S}
      {ℋ_2 : core.clone.Clone.Trait T}
      {ℋ_3 : core.marker.Send.Trait T}
      {ℋ_4 : core.marker.Sync.Trait T}.
    
    Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
    
    (*
        type Rejection = <Extension<Self> as FromRequestParts<S>>::Rejection;
    *)
    Definition Rejection : Set :=
      axum_core.extract.FromRequestParts.Rejection
          (Self := axum.extension.Extension.t Self)
          (Trait := ltac:(refine _)).
    
    (*
        async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
            match Extension::<Self>::from_request_parts(parts, state).await {
                Ok(Extension(connect_info)) => Ok(connect_info),
                Err(err) => match parts.extensions.get::<MockConnectInfo<T>>() {
                    Some(MockConnectInfo(connect_info)) => Ok(Self(connect_info.clone())),
                    None => Err(err),
                },
            }
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.
  
  Module  Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.
  Section Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
    
    (*
                type Target = T;
    *)
    Definition Target : Set := T.
    
    (*
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.
  End Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.
  
  Module  Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.
  Section Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
    
    (*
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
    *)
    Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref_mut :
      Notations.DoubleColon Self "deref_mut" := {
      Notations.double_colon := deref_mut;
    }.
    
    Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
      core.ops.deref.DerefMut.deref_mut := deref_mut;
    }.
  End Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.
  End Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.
  
  Module  MockConnectInfo.
  Section MockConnectInfo.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End MockConnectInfo.
  End MockConnectInfo.
  
  Module  Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.
  Section Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum.extract.connect_info.MockConnectInfo.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.
  End Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.
  
  Module  Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.
  Section Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.
  End Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.
  Section Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.
  End Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.
  
  Module  Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.
  Section Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.
    Context {S T : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait T}
      {ℋ_1 : core.marker.Send.Trait T}
      {ℋ_2 : core.marker.Sync.Trait T}.
    
    Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
    
    (*
        type Service = <Extension<Self> as Layer<S>>::Service;
    *)
    Definition Service : Set :=
      tower_layer.Layer.Service
          (Self := axum.extension.Extension.t Self)
          (Trait := ltac:(refine _)).
    
    (*
        fn layer(&self, inner: S) -> Self::Service {
            Extension(self.clone()).layer(inner)
        }
    *)
    Definition layer (self : ref Self) (inner : S) : M Service :=
      let* self := M.alloc self in
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_layer :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer;
    }.
    
    Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
      tower_layer.Layer.Service := Service;
      tower_layer.Layer.layer := layer;
    }.
  End Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.
  End Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.
End connect_info.

Module  IntoMakeServiceWithConnectInfo.
Section IntoMakeServiceWithConnectInfo.
  Context (S C : Set).
  
  Record t : Set := {
    svc : S;
    _connect_info : core.marker.PhantomData.t C;
  }.
  
  Definition Get_svc :=
    Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
  Definition Get__connect_info :=
    Ref.map
      (fun α => Some α.(_connect_info))
      (fun β α => Some (α <| _connect_info := β |>)).
End IntoMakeServiceWithConnectInfo.
End IntoMakeServiceWithConnectInfo.

Module  Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C_3.
Section Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C_3.
  Context {S C : Set}.
  
  Definition Self : Set :=
    axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
  
  (*
      pub(crate) fn new(svc: S) -> Self {
          Self {
              svc,
              _connect_info: PhantomData,
          }
      }
  *)
  Definition new (svc : S) : M Self :=
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C_3.
End Impl_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C_3.

Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
Section Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  Context {S C : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set :=
    axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("IntoMakeServiceWithConnectInfo")
              .field("svc", &self.svc)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
End Impl_core_fmt_Debug_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.

Module  Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
Section Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  Context {S C : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set :=
    axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
  
  (*
      fn clone(&self) -> Self {
          Self {
              svc: self.svc.clone(),
              _connect_info: PhantomData,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
End Impl_core_clone_Clone_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.

Module  Connected.
Section Connected.
  Class Trait (Self : Set) {T : Set} : Type := {
    ℒ_0 :: core.clone.Clone.Trait Self;
    ℒ_1 :: core.marker.Send.Trait Self;
    ℒ_2 :: core.marker.Sync.Trait Self;
    connect_info : T -> M Self;
  }.
  
End Connected.
End Connected.

Module  Impl_axum_extract_connect_info_Connected_axum_serve_IncomingStream_t_for_core_net_socket_addr_SocketAddr_t.
Section Impl_axum_extract_connect_info_Connected_axum_serve_IncomingStream_t_for_core_net_socket_addr_SocketAddr_t.
  Definition Self : Set := core.net.socket_addr.SocketAddr.t.
  
  (*
          fn connect_info(target: IncomingStream<'_>) -> Self {
              target.remote_addr()
          }
  *)
  Definition connect_info (target : axum.serve.IncomingStream.t) : M Self :=
    let* target := M.alloc target in
    M.read foo.
  
  Global Instance AssociatedFunction_connect_info :
    Notations.DoubleColon Self "connect_info" := {
    Notations.double_colon := connect_info;
  }.
  
  Global Instance ℐ :
    axum.extract.connect_info.Connected.Trait Self
      (T := axum.serve.IncomingStream.t) := {
    axum.extract.connect_info.Connected.connect_info := connect_info;
  }.
End Impl_axum_extract_connect_info_Connected_axum_serve_IncomingStream_t_for_core_net_socket_addr_SocketAddr_t.
End Impl_axum_extract_connect_info_Connected_axum_serve_IncomingStream_t_for_core_net_socket_addr_SocketAddr_t.

Module  Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.
Section Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.
  Definition Self : Set := core.net.socket_addr.SocketAddr.t.
  
  (*
      fn connect_info(remote_addr: SocketAddr) -> Self {
          remote_addr
      }
  *)
  Definition connect_info
      (remote_addr : core.net.socket_addr.SocketAddr.t)
      : M Self :=
    let* remote_addr := M.alloc remote_addr in
    M.read foo.
  
  Global Instance AssociatedFunction_connect_info :
    Notations.DoubleColon Self "connect_info" := {
    Notations.double_colon := connect_info;
  }.
  
  Global Instance ℐ :
    axum.extract.connect_info.Connected.Trait Self
      (T := core.net.socket_addr.SocketAddr.t) := {
    axum.extract.connect_info.Connected.connect_info := connect_info;
  }.
End Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.
End Impl_axum_extract_connect_info_Connected_core_net_socket_addr_SocketAddr_t_for_core_net_socket_addr_SocketAddr_t.

Module  Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
Section Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
  Context {S C T : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait S}
    {ℋ_1 : axum.extract.connect_info.Connected.Trait C (T := T)}.
  
  Definition Self : Set :=
    axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t S C.
  
  (*
      type Response = AddExtension<S, ConnectInfo<C>>;
  *)
  Definition Response : Set :=
    axum.extension.AddExtension.t S (axum.extract.connect_info.ConnectInfo.t C).
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      type Future = ResponseFuture<S, C>;
  *)
  Definition Future : Set := axum.extract.connect_info.ResponseFuture.t S C.
  
  (*
      fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          Poll::Ready(Ok(()))
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (_cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* _cx := M.alloc _cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, target: T) -> Self::Future {
          let connect_info = ConnectInfo(C::connect_info(target));
          let svc = Extension(connect_info).layer(self.svc.clone());
          ResponseFuture::new(ready(Ok(svc)))
      }
  *)
  Definition call (self : mut_ref Self) (target : T) : M Future :=
    let* self := M.alloc self in
    let* target := M.alloc target in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ : tower_service.Service.Trait Self (Request := T) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.
End Impl_tower_service_Service_T_for_axum_extract_connect_info_IntoMakeServiceWithConnectInfo_t_S_C.

Module  ResponseFuture.
Section ResponseFuture.
  Context (S C : Set).
  
  Record t : Set := {
    future :
      core.future.ready.Ready.t
        (core.result.Result.t
          (axum.extension.AddExtension.t
            S
            (axum.extract.connect_info.ConnectInfo.t C))
          core.convert.Infallible.t);
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End ResponseFuture.
End ResponseFuture.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Context (S C : Set).
  
  Record t : Set := {
    future :
      core.pin.Pin.t
        (mut_ref
          (core.future.ready.Ready.t
            (core.result.Result.t
              (axum.extension.AddExtension.t
                S
                (axum.extract.connect_info.ConnectInfo.t C))
              core.convert.Infallible.t)));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Context (S C : Set).
  
  Record t : Set := {
    future :
      core.pin.Pin.t
        (ref
          (core.future.ready.Ready.t
            (core.result.Result.t
              (axum.extension.AddExtension.t
                S
                (axum.extract.connect_info.ConnectInfo.t C))
              core.convert.Infallible.t)));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_extract_connect_info_ResponseFuture_t_S_C_3.
Section Impl_axum_extract_connect_info_ResponseFuture_t_S_C_3.
  Context {S C : Set}.
  
  Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum.extract.connect_info._.Projection.t S C) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M (axum.extract.connect_info._.ProjectionRef.t S C) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_extract_connect_info_ResponseFuture_t_S_C_3.
End Impl_axum_extract_connect_info_ResponseFuture_t_S_C_3.

Module  __Origin.
Section __Origin.
  Context (S C : Set).
  
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    future :
      core.future.ready.Ready.t
        (core.result.Result.t
          (axum.extension.AddExtension.t
            S
            (axum.extract.connect_info.ConnectInfo.t C))
          core.convert.Infallible.t);
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_extract_connect_info_ResponseFuture_t_S_C.
Section Impl_core_marker_Unpin_for_axum_extract_connect_info_ResponseFuture_t_S_C.
  Context {S C : Set}.
  
  Context
    {ℋ_0 :
      core.marker.Unpin.Trait (axum.extract.connect_info._.__Origin.t S C)}.
  
  Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_extract_connect_info_ResponseFuture_t_S_C.
End Impl_core_marker_Unpin_for_axum_extract_connect_info_ResponseFuture_t_S_C.

Module  Impl_axum_extract_connect_info___MustNotImplDrop_for_T.
Section Impl_axum_extract_connect_info___MustNotImplDrop_for_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.ops.drop.Drop.Trait T}.
  
  Definition Self : Set := T.
  
  Global Instance ℐ :
    axum.extract.connect_info._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_extract_connect_info___MustNotImplDrop_for_T.
End Impl_axum_extract_connect_info___MustNotImplDrop_for_T.

Module  Impl_axum_extract_connect_info___MustNotImplDrop_for_axum_extract_connect_info_ResponseFuture_t_S_C.
Section Impl_axum_extract_connect_info___MustNotImplDrop_for_axum_extract_connect_info_ResponseFuture_t_S_C.
  Context {S C : Set}.
  
  Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
  
  Global Instance ℐ :
    axum.extract.connect_info._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_extract_connect_info___MustNotImplDrop_for_axum_extract_connect_info_ResponseFuture_t_S_C.
End Impl_axum_extract_connect_info___MustNotImplDrop_for_axum_extract_connect_info_ResponseFuture_t_S_C.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    {S C : Set}
    (this : ref (axum.extract.connect_info.ResponseFuture.t S C))
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module  Impl_axum_extract_connect_info_ResponseFuture_t_S_C_4.
Section Impl_axum_extract_connect_info_ResponseFuture_t_S_C_4.
  Context {S C : Set}.
  
  Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
  
  (*
              pub(crate) fn new(future: $actual) -> Self {
                  Self { future }
              }
  *)
  Definition new
      (future
        :
        core.future.ready.Ready.t
          (core.result.Result.t
            (axum.extension.AddExtension.t
              S
              (axum.extract.connect_info.ConnectInfo.t C))
            core.convert.Infallible.t))
      : M Self :=
    let* future := M.alloc future in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_axum_extract_connect_info_ResponseFuture_t_S_C_4.
End Impl_axum_extract_connect_info_ResponseFuture_t_S_C_4.

Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.
Section Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.
  Context {S C : Set}.
  
  Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  f.debug_struct(stringify!($name)).finish_non_exhaustive()
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.
End Impl_core_fmt_Debug_for_axum_extract_connect_info_ResponseFuture_t_S_C.

Module  Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.
Section Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.
  Context {S C : Set}.
  
  Context
    {ℋ_0 :
      core.future.future.Future.Trait
          (core.future.ready.Ready.t
            (core.result.Result.t
              (axum.extension.AddExtension.t
                S
                (axum.extract.connect_info.ConnectInfo.t C))
              core.convert.Infallible.t))}.
  
  Definition Self : Set := axum.extract.connect_info.ResponseFuture.t S C.
  
  (*
              type Output = <$actual as std::future::Future>::Output;
  *)
  Definition Output : Set :=
    core.future.future.Future.Output
        (Self := core.future.ready.Ready.t
          (core.result.Result.t
            (axum.extension.AddExtension.t
              S
              (axum.extract.connect_info.ConnectInfo.t C))
            core.convert.Infallible.t))
        (Trait := ltac:(refine _)).
  
  (*
              fn poll(
                  self: std::pin::Pin<&mut Self>,
                  cx: &mut std::task::Context<'_>,
              ) -> std::task::Poll<Self::Output> {
                  self.project().future.poll(cx)
              }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.
End Impl_core_future_future_Future_for_axum_extract_connect_info_ResponseFuture_t_S_C.

Module  ConnectInfo.
Section ConnectInfo.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End ConnectInfo.
End ConnectInfo.

Module  Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.
Section Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum.extract.connect_info.ConnectInfo.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.
End Impl_core_clone_Clone_for_axum_extract_connect_info_ConnectInfo_t_T.

Module  Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.
Section Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.
End Impl_core_marker_Copy_for_axum_extract_connect_info_ConnectInfo_t_T.

Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.
Section Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.
End Impl_core_fmt_Debug_for_axum_extract_connect_info_ConnectInfo_t_T.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.
  Context {S T : Set}.
  
  Context
    {ℋ_0 : core.marker.Send.Trait S}
    {ℋ_1 : core.marker.Sync.Trait S}
    {ℋ_2 : core.clone.Clone.Trait T}
    {ℋ_3 : core.marker.Send.Trait T}
    {ℋ_4 : core.marker.Sync.Trait T}.
  
  Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
  
  (*
      type Rejection = <Extension<Self> as FromRequestParts<S>>::Rejection;
  *)
  Definition Rejection : Set :=
    axum_core.extract.FromRequestParts.Rejection
        (Self := axum.extension.Extension.t Self)
        (Trait := ltac:(refine _)).
  
  (*
      async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
          match Extension::<Self>::from_request_parts(parts, state).await {
              Ok(Extension(connect_info)) => Ok(connect_info),
              Err(err) => match parts.extensions.get::<MockConnectInfo<T>>() {
                  Some(MockConnectInfo(connect_info)) => Ok(Self(connect_info.clone())),
                  None => Err(err),
              },
          }
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_connect_info_ConnectInfo_t_T.

Module  Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.
Section Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
  
  (*
              type Target = T;
  *)
  Definition Target : Set := T.
  
  (*
              fn deref(&self) -> &Self::Target {
                  &self.0
              }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.
End Impl_core_ops_deref_Deref_for_axum_extract_connect_info_ConnectInfo_t_T.

Module  Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.
Section Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.extract.connect_info.ConnectInfo.t T.
  
  (*
              fn deref_mut(&mut self) -> &mut Self::Target {
                  &mut self.0
              }
  *)
  Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref_mut :
    Notations.DoubleColon Self "deref_mut" := {
    Notations.double_colon := deref_mut;
  }.
  
  Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
    core.ops.deref.DerefMut.deref_mut := deref_mut;
  }.
End Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.
End Impl_core_ops_deref_DerefMut_for_axum_extract_connect_info_ConnectInfo_t_T.

Module  MockConnectInfo.
Section MockConnectInfo.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End MockConnectInfo.
End MockConnectInfo.

Module  Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.
Section Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum.extract.connect_info.MockConnectInfo.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.
End Impl_core_clone_Clone_for_axum_extract_connect_info_MockConnectInfo_t_T.

Module  Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.
Section Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.
End Impl_core_marker_Copy_for_axum_extract_connect_info_MockConnectInfo_t_T.

Module  Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.
Section Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.
End Impl_core_fmt_Debug_for_axum_extract_connect_info_MockConnectInfo_t_T.

Module  Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.
Section Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.
  Context {S T : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait T}
    {ℋ_1 : core.marker.Send.Trait T}
    {ℋ_2 : core.marker.Sync.Trait T}.
  
  Definition Self : Set := axum.extract.connect_info.MockConnectInfo.t T.
  
  (*
      type Service = <Extension<Self> as Layer<S>>::Service;
  *)
  Definition Service : Set :=
    tower_layer.Layer.Service
        (Self := axum.extension.Extension.t Self)
        (Trait := ltac:(refine _)).
  
  (*
      fn layer(&self, inner: S) -> Self::Service {
          Extension(self.clone()).layer(inner)
      }
  *)
  Definition layer (self : ref Self) (inner : S) : M Service :=
    let* self := M.alloc self in
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_layer :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer;
  }.
  
  Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
    tower_layer.Layer.Service := Service;
    tower_layer.Layer.layer := layer;
  }.
End Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.
End Impl_tower_layer_Layer_S_for_axum_extract_connect_info_MockConnectInfo_t_T.

Module path.
  Module de.
    Module  PathDeserializer.
    Section PathDeserializer.
      Record t : Set := {
        url_params :
          ref
            (slice
              ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
              *
              axum.util.PercentDecodedStr.t));
      }.
      
      Definition Get_url_params :=
        Ref.map
          (fun α => Some α.(url_params))
          (fun β α => Some (α <| url_params := β |>)).
    End PathDeserializer.
    End PathDeserializer.
    
    Module  Impl_axum_extract_path_de_PathDeserializer_t_2.
    Section Impl_axum_extract_path_de_PathDeserializer_t_2.
      Definition Self : Set := axum.extract.path.de.PathDeserializer.t.
      
      (*
          pub(crate) fn new(url_params: &'de [(Arc<str>, PercentDecodedStr)]) -> Self {
              PathDeserializer { url_params }
          }
      *)
      Definition new
          (url_params
            :
            ref
              (slice
                ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
                *
                axum.util.PercentDecodedStr.t)))
          : M Self :=
        let* url_params := M.alloc url_params in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_axum_extract_path_de_PathDeserializer_t_2.
    End Impl_axum_extract_path_de_PathDeserializer_t_2.
    
    Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
    Section Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
      Definition Self : Set := axum.extract.path.de.PathDeserializer.t.
      
      (*
          type Error = PathDeserializationError;
      *)
      Definition Error : Set := axum.extract.path.PathDeserializationError.t.
      
      (*
              fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  Err(PathDeserializationError::unsupported_type(type_name::<
                      V::Value,
                  >()))
              }
      *)
      Definition deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (Pattern : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bytes" := {
        Notations.double_colon := deserialize_bytes (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  Err(PathDeserializationError::unsupported_type(type_name::<
                      V::Value,
                  >()))
              }
      *)
      Definition deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (Pattern : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_option" := {
        Notations.double_colon := deserialize_option (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  Err(PathDeserializationError::unsupported_type(type_name::<
                      V::Value,
                  >()))
              }
      *)
      Definition deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (Pattern : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_identifier" := {
        Notations.double_colon := deserialize_identifier (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  Err(PathDeserializationError::unsupported_type(type_name::<
                      V::Value,
                  >()))
              }
      *)
      Definition deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (Pattern : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_ignored_any" := {
        Notations.double_colon := deserialize_ignored_any (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bool" := {
        Notations.double_colon := deserialize_bool (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i8" := {
        Notations.double_colon := deserialize_i8 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i16" := {
        Notations.double_colon := deserialize_i16 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i32" := {
        Notations.double_colon := deserialize_i32 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i64" := {
        Notations.double_colon := deserialize_i64 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i128" := {
        Notations.double_colon := deserialize_i128 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u8" := {
        Notations.double_colon := deserialize_u8 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u16" := {
        Notations.double_colon := deserialize_u16 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u32" := {
        Notations.double_colon := deserialize_u32 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u64" := {
        Notations.double_colon := deserialize_u64 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u128" := {
        Notations.double_colon := deserialize_u128 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f32" := {
        Notations.double_colon := deserialize_f32 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f64" := {
        Notations.double_colon := deserialize_f64 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_string" := {
        Notations.double_colon := deserialize_string (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_byte_buf" := {
        Notations.double_colon := deserialize_byte_buf (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  if self.url_params.len() != 1 {
                      return Err(PathDeserializationError::wrong_number_of_parameters()
                          .got(self.url_params.len())
                          .expected(1));
                  }
      
                  let value = self.url_params[0].1.parse().map_err(|_| {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.url_params[0].1.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  })?;
                  visitor.$visit_fn(value)
              }
      *)
      Definition deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_char" := {
        Notations.double_colon := deserialize_char (V := V);
      }.
      
      (*
          fn deserialize_any<V>(self, v: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_str(v)
          }
      *)
      Definition deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (v : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_any" := {
        Notations.double_colon := deserialize_any (V := V);
      }.
      
      (*
          fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
              visitor.visit_borrowed_str(&self.url_params[0].1)
          }
      *)
      Definition deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_str" := {
        Notations.double_colon := deserialize_str (V := V);
      }.
      
      (*
          fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_unit()
          }
      *)
      Definition deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit" := {
        Notations.double_colon := deserialize_unit (V := V);
      }.
      
      (*
          fn deserialize_unit_struct<V>(
              self,
              _name: &'static str,
              visitor: V,
          ) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_unit()
          }
      *)
      Definition deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit_struct" := {
        Notations.double_colon := deserialize_unit_struct (V := V);
      }.
      
      (*
          fn deserialize_newtype_struct<V>(
              self,
              _name: &'static str,
              visitor: V,
          ) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_newtype_struct(self)
          }
      *)
      Definition deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_newtype_struct" := {
        Notations.double_colon := deserialize_newtype_struct (V := V);
      }.
      
      (*
          fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_seq(SeqDeserializer {
                  params: self.url_params,
                  idx: 0,
              })
          }
      *)
      Definition deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_seq" := {
        Notations.double_colon := deserialize_seq (V := V);
      }.
      
      (*
          fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() < len {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(len));
              }
              visitor.visit_seq(SeqDeserializer {
                  params: self.url_params,
                  idx: 0,
              })
          }
      *)
      Definition deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (len : usize.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* len := M.alloc len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple" := {
        Notations.double_colon := deserialize_tuple (V := V);
      }.
      
      (*
          fn deserialize_tuple_struct<V>(
              self,
              _name: &'static str,
              len: usize,
              visitor: V,
          ) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() < len {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(len));
              }
              visitor.visit_seq(SeqDeserializer {
                  params: self.url_params,
                  idx: 0,
              })
          }
      *)
      Definition deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (len : usize.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* len := M.alloc len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple_struct" := {
        Notations.double_colon := deserialize_tuple_struct (V := V);
      }.
      
      (*
          fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_map(MapDeserializer {
                  params: self.url_params,
                  value: None,
                  key: None,
              })
          }
      *)
      Definition deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_map" := {
        Notations.double_colon := deserialize_map (V := V);
      }.
      
      (*
          fn deserialize_struct<V>(
              self,
              _name: &'static str,
              _fields: &'static [&'static str],
              visitor: V,
          ) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_map(visitor)
          }
      *)
      Definition deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_fields : ref (slice (ref str.t)))
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _fields := M.alloc _fields in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_struct" := {
        Notations.double_colon := deserialize_struct (V := V);
      }.
      
      (*
          fn deserialize_enum<V>(
              self,
              _name: &'static str,
              _variants: &'static [&'static str],
              visitor: V,
          ) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
      
              visitor.visit_enum(EnumDeserializer {
                  value: self.url_params[0].1.clone().into_inner(),
              })
          }
      *)
      Definition deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_variants : ref (slice (ref str.t)))
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variants := M.alloc _variants in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_enum" := {
        Notations.double_colon := deserialize_enum (V := V);
      }.
      
      Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
        serde.de.Deserializer.Error := Error;
        serde.de.Deserializer.deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bytes (V := V);
        serde.de.Deserializer.deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_option (V := V);
        serde.de.Deserializer.deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_identifier (V := V);
        serde.de.Deserializer.deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_ignored_any (V := V);
        serde.de.Deserializer.deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bool (V := V);
        serde.de.Deserializer.deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i8 (V := V);
        serde.de.Deserializer.deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i16 (V := V);
        serde.de.Deserializer.deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i32 (V := V);
        serde.de.Deserializer.deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i64 (V := V);
        serde.de.Deserializer.deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_i128 (V := V));
        serde.de.Deserializer.deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u8 (V := V);
        serde.de.Deserializer.deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u16 (V := V);
        serde.de.Deserializer.deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u32 (V := V);
        serde.de.Deserializer.deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u64 (V := V);
        serde.de.Deserializer.deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_u128 (V := V));
        serde.de.Deserializer.deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f32 (V := V);
        serde.de.Deserializer.deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f64 (V := V);
        serde.de.Deserializer.deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_string (V := V);
        serde.de.Deserializer.deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_byte_buf (V := V);
        serde.de.Deserializer.deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_char (V := V);
        serde.de.Deserializer.deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_any (V := V);
        serde.de.Deserializer.deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_str (V := V);
        serde.de.Deserializer.deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit (V := V);
        serde.de.Deserializer.deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit_struct (V := V);
        serde.de.Deserializer.deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_newtype_struct (V := V);
        serde.de.Deserializer.deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_seq (V := V);
        serde.de.Deserializer.deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple (V := V);
        serde.de.Deserializer.deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple_struct (V := V);
        serde.de.Deserializer.deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_map (V := V);
        serde.de.Deserializer.deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_struct (V := V);
        serde.de.Deserializer.deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_enum (V := V);
        serde.de.Deserializer.is_human_readable := Datatypes.None;
        serde.de.Deserializer.__deserialize_content := Datatypes.None;
      }.
    End Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
    End Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
    
    Module  MapDeserializer.
    Section MapDeserializer.
      Record t : Set := {
        params :
          ref
            (slice
              ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
              *
              axum.util.PercentDecodedStr.t));
        key : core.option.Option.t axum.extract.path.de.KeyOrIdx.t;
        value : core.option.Option.t (ref axum.util.PercentDecodedStr.t);
      }.
      
      Definition Get_params :=
        Ref.map
          (fun α => Some α.(params))
          (fun β α => Some (α <| params := β |>)).
      Definition Get_key :=
        Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
      Definition Get_value :=
        Ref.map
          (fun α => Some α.(value))
          (fun β α => Some (α <| value := β |>)).
    End MapDeserializer.
    End MapDeserializer.
    
    Module  Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
    Section Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
      Definition Self : Set := axum.extract.path.de.MapDeserializer.t.
      
      (*
          type Error = PathDeserializationError;
      *)
      Definition Error : Set := axum.extract.path.PathDeserializationError.t.
      
      (*
          fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>
          where
              K: DeserializeSeed<'de>,
          {
              match self.params.split_first() {
                  Some(((key, value), tail)) => {
                      self.value = Some(value);
                      self.params = tail;
                      self.key = Some(KeyOrIdx::Key(key.clone()));
                      seed.deserialize(KeyDeserializer {
                          key: Arc::clone(key),
                      })
                      .map(Some)
                  }
                  None => Ok(None),
              }
          }
      *)
      Definition next_key_seed
          {K : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait K}
          (self : mut_ref Self)
          (seed : K)
          :
            M
              (core.result.Result.t
                (core.option.Option.t K::type["Value"].t)
                Error) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_next_key_seed
          {K : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait K} :
        Notations.DoubleColon Self "next_key_seed" := {
        Notations.double_colon := next_key_seed (K := K);
      }.
      
      (*
          fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>
          where
              V: DeserializeSeed<'de>,
          {
              match self.value.take() {
                  Some(value) => seed.deserialize(ValueDeserializer {
                      key: self.key.take(),
                      value,
                  }),
                  None => Err(PathDeserializationError::custom("value is missing")),
              }
          }
      *)
      Definition next_value_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V}
          (self : mut_ref Self)
          (seed : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_next_value_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
        Notations.DoubleColon Self "next_value_seed" := {
        Notations.double_colon := next_value_seed (V := V);
      }.
      
      Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
        serde.de.MapAccess.Error := Error;
        serde.de.MapAccess.next_key_seed
          {K : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait K} :=
          next_key_seed (K := K);
        serde.de.MapAccess.next_value_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
          next_value_seed (V := V);
        serde.de.MapAccess.next_entry_seed := Datatypes.None;
        serde.de.MapAccess.next_key := Datatypes.None;
        serde.de.MapAccess.next_value := Datatypes.None;
        serde.de.MapAccess.next_entry := Datatypes.None;
        serde.de.MapAccess.size_hint := Datatypes.None;
      }.
    End Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
    End Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
    
    Module  KeyDeserializer.
    Section KeyDeserializer.
      Record t : Set := {
        key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
      }.
      
      Definition Get_key :=
        Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
    End KeyDeserializer.
    End KeyDeserializer.
    
    Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
    Section Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
      Definition Self : Set := axum.extract.path.de.KeyDeserializer.t.
      
      (*
          type Error = PathDeserializationError;
      *)
      Definition Error : Set := axum.extract.path.PathDeserializationError.t.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  visitor.visit_str(&self.key)
              }
      *)
      Definition deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_identifier" := {
        Notations.double_colon := deserialize_identifier (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  visitor.visit_str(&self.key)
              }
      *)
      Definition deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_str" := {
        Notations.double_colon := deserialize_str (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  visitor.visit_str(&self.key)
              }
      *)
      Definition deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_string" := {
        Notations.double_colon := deserialize_string (V := V);
      }.
      
      (*
          fn deserialize_any<V>(self, _visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::custom("Unexpected key type"))
          }
      *)
      Definition deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _visitor := M.alloc _visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_any" := {
        Notations.double_colon := deserialize_any (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bool" := {
        Notations.double_colon := deserialize_bool (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i8" := {
        Notations.double_colon := deserialize_i8 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i16" := {
        Notations.double_colon := deserialize_i16 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i32" := {
        Notations.double_colon := deserialize_i32 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i64" := {
        Notations.double_colon := deserialize_i64 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i128" := {
        Notations.double_colon := deserialize_i128 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u8" := {
        Notations.double_colon := deserialize_u8 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u16" := {
        Notations.double_colon := deserialize_u16 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u32" := {
        Notations.double_colon := deserialize_u32 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u64" := {
        Notations.double_colon := deserialize_u64 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u128" := {
        Notations.double_colon := deserialize_u128 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f32" := {
        Notations.double_colon := deserialize_f32 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f64" := {
        Notations.double_colon := deserialize_f64 (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_char" := {
        Notations.double_colon := deserialize_char (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bytes" := {
        Notations.double_colon := deserialize_bytes (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_byte_buf" := {
        Notations.double_colon := deserialize_byte_buf (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_option" := {
        Notations.double_colon := deserialize_option (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit" := {
        Notations.double_colon := deserialize_unit (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit_struct" := {
        Notations.double_colon := deserialize_unit_struct (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_seq" := {
        Notations.double_colon := deserialize_seq (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (len : usize.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* len := M.alloc len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple" := {
        Notations.double_colon := deserialize_tuple (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (len : usize.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* len := M.alloc len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple_struct" := {
        Notations.double_colon := deserialize_tuple_struct (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_map" := {
        Notations.double_colon := deserialize_map (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_newtype_struct" := {
        Notations.double_colon := deserialize_newtype_struct (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (fields : ref (slice (ref str.t)))
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* fields := M.alloc fields in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_struct" := {
        Notations.double_colon := deserialize_struct (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (name : ref str.t)
          (variants : ref (slice (ref str.t)))
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* variants := M.alloc variants in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_enum" := {
        Notations.double_colon := deserialize_enum (V := V);
      }.
      
      (*
              fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
              where
                  $v: $crate::de::Visitor<$l>,
              {
                  $(
                      let _ = $arg;
                  )*
                  self.deserialize_any(visitor)
              }
      *)
      Definition deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_ignored_any" := {
        Notations.double_colon := deserialize_ignored_any (V := V);
      }.
      
      Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
        serde.de.Deserializer.Error := Error;
        serde.de.Deserializer.deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_identifier (V := V);
        serde.de.Deserializer.deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_str (V := V);
        serde.de.Deserializer.deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_string (V := V);
        serde.de.Deserializer.deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_any (V := V);
        serde.de.Deserializer.deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bool (V := V);
        serde.de.Deserializer.deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i8 (V := V);
        serde.de.Deserializer.deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i16 (V := V);
        serde.de.Deserializer.deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i32 (V := V);
        serde.de.Deserializer.deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i64 (V := V);
        serde.de.Deserializer.deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_i128 (V := V));
        serde.de.Deserializer.deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u8 (V := V);
        serde.de.Deserializer.deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u16 (V := V);
        serde.de.Deserializer.deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u32 (V := V);
        serde.de.Deserializer.deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u64 (V := V);
        serde.de.Deserializer.deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_u128 (V := V));
        serde.de.Deserializer.deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f32 (V := V);
        serde.de.Deserializer.deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f64 (V := V);
        serde.de.Deserializer.deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_char (V := V);
        serde.de.Deserializer.deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bytes (V := V);
        serde.de.Deserializer.deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_byte_buf (V := V);
        serde.de.Deserializer.deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_option (V := V);
        serde.de.Deserializer.deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit (V := V);
        serde.de.Deserializer.deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit_struct (V := V);
        serde.de.Deserializer.deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_seq (V := V);
        serde.de.Deserializer.deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple (V := V);
        serde.de.Deserializer.deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple_struct (V := V);
        serde.de.Deserializer.deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_map (V := V);
        serde.de.Deserializer.deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_newtype_struct (V := V);
        serde.de.Deserializer.deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_struct (V := V);
        serde.de.Deserializer.deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_enum (V := V);
        serde.de.Deserializer.deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_ignored_any (V := V);
        serde.de.Deserializer.is_human_readable := Datatypes.None;
        serde.de.Deserializer.__deserialize_content := Datatypes.None;
      }.
    End Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
    End Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
    
    Module  ValueDeserializer.
    Section ValueDeserializer.
      Record t : Set := {
        key : core.option.Option.t axum.extract.path.de.KeyOrIdx.t;
        value : ref axum.util.PercentDecodedStr.t;
      }.
      
      Definition Get_key :=
        Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
      Definition Get_value :=
        Ref.map
          (fun α => Some α.(value))
          (fun β α => Some (α <| value := β |>)).
    End ValueDeserializer.
    End ValueDeserializer.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
    Section Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
      Definition Self : Set := axum.extract.path.de.ValueDeserializer.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
    End Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
    
    Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
    Section Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
      Definition Self : Set := axum.extract.path.de.ValueDeserializer.t.
      
      (*
          type Error = PathDeserializationError;
      *)
      Definition Error : Set := axum.extract.path.PathDeserializationError.t.
      
      (*
              fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  Err(PathDeserializationError::unsupported_type(type_name::<
                      V::Value,
                  >()))
              }
      *)
      Definition deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (Pattern : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_map" := {
        Notations.double_colon := deserialize_map (V := V);
      }.
      
      (*
              fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  Err(PathDeserializationError::unsupported_type(type_name::<
                      V::Value,
                  >()))
              }
      *)
      Definition deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (Pattern : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_identifier" := {
        Notations.double_colon := deserialize_identifier (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bool" := {
        Notations.double_colon := deserialize_bool (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i8" := {
        Notations.double_colon := deserialize_i8 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i16" := {
        Notations.double_colon := deserialize_i16 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i32" := {
        Notations.double_colon := deserialize_i32 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i64" := {
        Notations.double_colon := deserialize_i64 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_i128" := {
        Notations.double_colon := deserialize_i128 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u8" := {
        Notations.double_colon := deserialize_u8 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u16" := {
        Notations.double_colon := deserialize_u16 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u32" := {
        Notations.double_colon := deserialize_u32 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u64" := {
        Notations.double_colon := deserialize_u64 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_u128" := {
        Notations.double_colon := deserialize_u128 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f32" := {
        Notations.double_colon := deserialize_f32 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_f64" := {
        Notations.double_colon := deserialize_f64 (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_string" := {
        Notations.double_colon := deserialize_string (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_byte_buf" := {
        Notations.double_colon := deserialize_byte_buf (V := V);
      }.
      
      (*
              fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
              where
                  V: Visitor<'de>,
              {
                  let v = self.value.parse().map_err(|_| {
                      if let Some(key) = self.key.take() {
                          let kind = match key {
                              KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                  key: key.to_string(),
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                              KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                  index,
                                  value: self.value.as_str().to_owned(),
                                  expected_type: $ty,
                              },
                          };
                          PathDeserializationError::new(kind)
                      } else {
                          PathDeserializationError::new(ErrorKind::ParseError {
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          })
                      }
                  })?;
                  visitor.$visit_fn(v)
              }
      *)
      Definition deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_char" := {
        Notations.double_colon := deserialize_char (V := V);
      }.
      
      (*
          fn deserialize_any<V>(self, v: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              self.deserialize_str(v)
          }
      *)
      Definition deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (v : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* v := M.alloc v in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_any" := {
        Notations.double_colon := deserialize_any (V := V);
      }.
      
      (*
          fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_borrowed_str(self.value)
          }
      *)
      Definition deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_str" := {
        Notations.double_colon := deserialize_str (V := V);
      }.
      
      (*
          fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_borrowed_bytes(self.value.as_bytes())
          }
      *)
      Definition deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_bytes" := {
        Notations.double_colon := deserialize_bytes (V := V);
      }.
      
      (*
          fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_some(self)
          }
      *)
      Definition deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_option" := {
        Notations.double_colon := deserialize_option (V := V);
      }.
      
      (*
          fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_unit()
          }
      *)
      Definition deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit" := {
        Notations.double_colon := deserialize_unit (V := V);
      }.
      
      (*
          fn deserialize_unit_struct<V>(
              self,
              _name: &'static str,
              visitor: V,
          ) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_unit()
          }
      *)
      Definition deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_unit_struct" := {
        Notations.double_colon := deserialize_unit_struct (V := V);
      }.
      
      (*
          fn deserialize_newtype_struct<V>(
              self,
              _name: &'static str,
              visitor: V,
          ) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_newtype_struct(self)
          }
      *)
      Definition deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_newtype_struct" := {
        Notations.double_colon := deserialize_newtype_struct (V := V);
      }.
      
      (*
          fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              struct PairDeserializer<'de> {
                  key: Option<KeyOrIdx>,
                  value: Option<&'de PercentDecodedStr>,
              }
      
              impl<'de> SeqAccess<'de> for PairDeserializer<'de> {
                  type Error = PathDeserializationError;
      
                  fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
                  where
                      T: DeserializeSeed<'de>,
                  {
                      match self.key.take() {
                          Some(KeyOrIdx::Idx { idx: _, key }) => {
                              return seed.deserialize(KeyDeserializer { key }).map(Some);
                          }
                          // `KeyOrIdx::Key` is only used when deserializing maps so `deserialize_seq`
                          // wouldn't be called for that
                          Some(KeyOrIdx::Key(_)) => unreachable!(),
                          None => {}
                      };
      
                      self.value
                          .take()
                          .map(|value| seed.deserialize(ValueDeserializer { key: None, value }))
                          .transpose()
                  }
              }
      
              if len == 2 {
                  match self.key {
                      Some(key) => visitor.visit_seq(PairDeserializer {
                          key: Some(key),
                          value: Some(self.value),
                      }),
                      // `self.key` is only `None` when deserializing maps so `deserialize_seq`
                      // wouldn't be called for that
                      None => unreachable!(),
                  }
              } else {
                  Err(PathDeserializationError::unsupported_type(type_name::<
                      V::Value,
                  >()))
              }
          }
      *)
      Definition deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (len : usize.t)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* len := M.alloc len in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple" := {
        Notations.double_colon := deserialize_tuple (V := V);
      }.
      
      (*
          fn deserialize_seq<V>(self, _visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::unsupported_type(type_name::<
                  V::Value,
              >()))
          }
      *)
      Definition deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _visitor := M.alloc _visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_seq" := {
        Notations.double_colon := deserialize_seq (V := V);
      }.
      
      (*
          fn deserialize_tuple_struct<V>(
              self,
              _name: &'static str,
              _len: usize,
              _visitor: V,
          ) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::unsupported_type(type_name::<
                  V::Value,
              >()))
          }
      *)
      Definition deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_len : usize.t)
          (_visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _len := M.alloc _len in
        let* _visitor := M.alloc _visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_tuple_struct" := {
        Notations.double_colon := deserialize_tuple_struct (V := V);
      }.
      
      (*
          fn deserialize_struct<V>(
              self,
              _name: &'static str,
              _fields: &'static [&'static str],
              _visitor: V,
          ) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::unsupported_type(type_name::<
                  V::Value,
              >()))
          }
      *)
      Definition deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_fields : ref (slice (ref str.t)))
          (_visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _fields := M.alloc _fields in
        let* _visitor := M.alloc _visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_struct" := {
        Notations.double_colon := deserialize_struct (V := V);
      }.
      
      (*
          fn deserialize_enum<V>(
              self,
              _name: &'static str,
              _variants: &'static [&'static str],
              visitor: V,
          ) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_enum(EnumDeserializer {
                  value: self.value.clone().into_inner(),
              })
          }
      *)
      Definition deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_name : ref str.t)
          (_variants : ref (slice (ref str.t)))
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _name := M.alloc _name in
        let* _variants := M.alloc _variants in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_enum" := {
        Notations.double_colon := deserialize_enum (V := V);
      }.
      
      (*
          fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_unit()
          }
      *)
      Definition deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* visitor := M.alloc visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "deserialize_ignored_any" := {
        Notations.double_colon := deserialize_ignored_any (V := V);
      }.
      
      Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
        serde.de.Deserializer.Error := Error;
        serde.de.Deserializer.deserialize_map
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_map (V := V);
        serde.de.Deserializer.deserialize_identifier
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_identifier (V := V);
        serde.de.Deserializer.deserialize_bool
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bool (V := V);
        serde.de.Deserializer.deserialize_i8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i8 (V := V);
        serde.de.Deserializer.deserialize_i16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i16 (V := V);
        serde.de.Deserializer.deserialize_i32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i32 (V := V);
        serde.de.Deserializer.deserialize_i64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_i64 (V := V);
        serde.de.Deserializer.deserialize_i128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_i128 (V := V));
        serde.de.Deserializer.deserialize_u8
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u8 (V := V);
        serde.de.Deserializer.deserialize_u16
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u16 (V := V);
        serde.de.Deserializer.deserialize_u32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u32 (V := V);
        serde.de.Deserializer.deserialize_u64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_u64 (V := V);
        serde.de.Deserializer.deserialize_u128
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          Datatypes.Some (deserialize_u128 (V := V));
        serde.de.Deserializer.deserialize_f32
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f32 (V := V);
        serde.de.Deserializer.deserialize_f64
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_f64 (V := V);
        serde.de.Deserializer.deserialize_string
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_string (V := V);
        serde.de.Deserializer.deserialize_byte_buf
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_byte_buf (V := V);
        serde.de.Deserializer.deserialize_char
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_char (V := V);
        serde.de.Deserializer.deserialize_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_any (V := V);
        serde.de.Deserializer.deserialize_str
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_str (V := V);
        serde.de.Deserializer.deserialize_bytes
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_bytes (V := V);
        serde.de.Deserializer.deserialize_option
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_option (V := V);
        serde.de.Deserializer.deserialize_unit
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit (V := V);
        serde.de.Deserializer.deserialize_unit_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_unit_struct (V := V);
        serde.de.Deserializer.deserialize_newtype_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_newtype_struct (V := V);
        serde.de.Deserializer.deserialize_tuple
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple (V := V);
        serde.de.Deserializer.deserialize_seq
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_seq (V := V);
        serde.de.Deserializer.deserialize_tuple_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_tuple_struct (V := V);
        serde.de.Deserializer.deserialize_struct
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_struct (V := V);
        serde.de.Deserializer.deserialize_enum
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_enum (V := V);
        serde.de.Deserializer.deserialize_ignored_any
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          deserialize_ignored_any (V := V);
        serde.de.Deserializer.is_human_readable := Datatypes.None;
        serde.de.Deserializer.__deserialize_content := Datatypes.None;
      }.
    End Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
    End Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
    
    Module  EnumDeserializer.
    Section EnumDeserializer.
      Record t : Set := {
        value : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
      }.
      
      Definition Get_value :=
        Ref.map
          (fun α => Some α.(value))
          (fun β α => Some (α <| value := β |>)).
    End EnumDeserializer.
    End EnumDeserializer.
    
    Module  Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
    Section Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
      Definition Self : Set := axum.extract.path.de.EnumDeserializer.t.
      
      (*
          type Error = PathDeserializationError;
      *)
      Definition Error : Set := axum.extract.path.PathDeserializationError.t.
      
      (*
          type Variant = UnitVariant;
      *)
      Definition Variant : Set := axum.extract.path.de.UnitVariant.t.
      
      (*
          fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>
          where
              V: de::DeserializeSeed<'de>,
          {
              Ok((
                  seed.deserialize(KeyDeserializer { key: self.value })?,
                  UnitVariant,
              ))
          }
      *)
      Definition variant_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V}
          (self : Self)
          (seed : V)
          : M (core.result.Result.t (V::type["Value"].t * Variant) Error) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_variant_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
        Notations.DoubleColon Self "variant_seed" := {
        Notations.double_colon := variant_seed (V := V);
      }.
      
      Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
        serde.de.EnumAccess.Error := Error;
        serde.de.EnumAccess.Variant := Variant;
        serde.de.EnumAccess.variant_seed
          {V : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
          variant_seed (V := V);
        serde.de.EnumAccess.variant := Datatypes.None;
      }.
    End Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
    End Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
    
    Module  UnitVariant.
    Section UnitVariant.
      Inductive t : Set := Build.
    End UnitVariant.
    End UnitVariant.
    
    Module  Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
    Section Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
      Definition Self : Set := axum.extract.path.de.UnitVariant.t.
      
      (*
          type Error = PathDeserializationError;
      *)
      Definition Error : Set := axum.extract.path.PathDeserializationError.t.
      
      (*
          fn unit_variant(self) -> Result<(), Self::Error> {
              Ok(())
          }
      *)
      Definition unit_variant
          (self : Self)
          : M (core.result.Result.t unit Error) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_unit_variant :
        Notations.DoubleColon Self "unit_variant" := {
        Notations.double_colon := unit_variant;
      }.
      
      (*
          fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>
          where
              T: DeserializeSeed<'de>,
          {
              Err(PathDeserializationError::unsupported_type(
                  "newtype enum variant",
              ))
          }
      *)
      Definition newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : Self)
          (_seed : T)
          : M (core.result.Result.t T::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _seed := M.alloc _seed in
        M.read foo.
      
      Global Instance AssociatedFunction_newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "newtype_variant_seed" := {
        Notations.double_colon := newtype_variant_seed (T := T);
      }.
      
      (*
          fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::unsupported_type(
                  "tuple enum variant",
              ))
          }
      *)
      Definition tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_len : usize.t)
          (_visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _len := M.alloc _len in
        let* _visitor := M.alloc _visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "tuple_variant" := {
        Notations.double_colon := tuple_variant (V := V);
      }.
      
      (*
          fn struct_variant<V>(
              self,
              _fields: &'static [&'static str],
              _visitor: V,
          ) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::unsupported_type(
                  "struct enum variant",
              ))
          }
      *)
      Definition struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V}
          (self : Self)
          (_fields : ref (slice (ref str.t)))
          (_visitor : V)
          : M (core.result.Result.t V::type["Value"].t Error) :=
        let* self := M.alloc self in
        let* _fields := M.alloc _fields in
        let* _visitor := M.alloc _visitor in
        M.read foo.
      
      Global Instance AssociatedFunction_struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :
        Notations.DoubleColon Self "struct_variant" := {
        Notations.double_colon := struct_variant (V := V);
      }.
      
      Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
        serde.de.VariantAccess.Error := Error;
        serde.de.VariantAccess.unit_variant := unit_variant;
        serde.de.VariantAccess.newtype_variant_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          newtype_variant_seed (T := T);
        serde.de.VariantAccess.tuple_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          tuple_variant (V := V);
        serde.de.VariantAccess.struct_variant
          {V : Set}
          {ℋ_0 : serde.de.Visitor.Trait V} :=
          struct_variant (V := V);
        serde.de.VariantAccess.newtype_variant := Datatypes.None;
      }.
    End Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
    End Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
    
    Module  SeqDeserializer.
    Section SeqDeserializer.
      Record t : Set := {
        params :
          ref
            (slice
              ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
              *
              axum.util.PercentDecodedStr.t));
        idx : usize.t;
      }.
      
      Definition Get_params :=
        Ref.map
          (fun α => Some α.(params))
          (fun β α => Some (α <| params := β |>)).
      Definition Get_idx :=
        Ref.map (fun α => Some α.(idx)) (fun β α => Some (α <| idx := β |>)).
    End SeqDeserializer.
    End SeqDeserializer.
    
    Module  Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
    Section Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
      Definition Self : Set := axum.extract.path.de.SeqDeserializer.t.
      
      (*
          type Error = PathDeserializationError;
      *)
      Definition Error : Set := axum.extract.path.PathDeserializationError.t.
      
      (*
          fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
          where
              T: DeserializeSeed<'de>,
          {
              match self.params.split_first() {
                  Some(((key, value), tail)) => {
                      self.params = tail;
                      let idx = self.idx;
                      self.idx += 1;
                      Ok(Some(seed.deserialize(ValueDeserializer {
                          key: Some(KeyOrIdx::Idx {
                              idx,
                              key: key.clone(),
                          }),
                          value,
                      })?))
                  }
                  None => Ok(None),
              }
          }
      *)
      Definition next_element_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T}
          (self : mut_ref Self)
          (seed : T)
          :
            M
              (core.result.Result.t
                (core.option.Option.t T::type["Value"].t)
                Error) :=
        let* self := M.alloc self in
        let* seed := M.alloc seed in
        M.read foo.
      
      Global Instance AssociatedFunction_next_element_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
        Notations.DoubleColon Self "next_element_seed" := {
        Notations.double_colon := next_element_seed (T := T);
      }.
      
      Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
        serde.de.SeqAccess.Error := Error;
        serde.de.SeqAccess.next_element_seed
          {T : Set}
          {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
          next_element_seed (T := T);
        serde.de.SeqAccess.next_element := Datatypes.None;
        serde.de.SeqAccess.size_hint := Datatypes.None;
      }.
    End Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
    End Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
    
    Module KeyOrIdx.
      Module Idx.
        Record t : Set := {
          idx : usize.t;
          key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
        }.
      End Idx.
      
      Inductive t : Set :=
      | Key (_ : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
      | Idx (_ : Idx.t).
      
      Definition Get_Key_0 :=
        Ref.map
          (fun α => match α with | Key α0 => Some α0 | _ => None end)
          (fun β α => match α with | Key _ => Some (Key β) | _ => None end).
      
      Definition Get_Idx_idx :=
        Ref.map
          (fun α => match α with | Idx α => Some α.(Idx.idx) | _ => None end)
          (fun β α =>
            match α with
            | Idx α => Some (Idx (α <| Idx.idx := β |>))
            | _ => None
            end).
      
      Definition Get_Idx_key :=
        Ref.map
          (fun α => match α with | Idx α => Some α.(Idx.key) | _ => None end)
          (fun β α =>
            match α with
            | Idx α => Some (Idx (α <| Idx.key := β |>))
            | _ => None
            end).
    End KeyOrIdx.
    
    Module  Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
    Section Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
      Definition Self : Set := axum.extract.path.de.KeyOrIdx.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
    End Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
    
    Module  Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
    Section Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
      Definition Self : Set := axum.extract.path.de.KeyOrIdx.t.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M axum.extract.path.de.KeyOrIdx.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
    End Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
  End de.
  
  Module  Path.
  Section Path.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Path.
  End Path.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.
  Section Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum.extract.path.Path.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.
  End Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.
  
  Module  Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.
  Section Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.extract.path.Path.t T.
    
    (*
                type Target = T;
    *)
    Definition Target : Set := T.
    
    (*
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.
  End Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.
  
  Module  Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.
  Section Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.extract.path.Path.t T.
    
    (*
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
    *)
    Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref_mut :
      Notations.DoubleColon Self "deref_mut" := {
      Notations.double_colon := deref_mut;
    }.
    
    Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
      core.ops.deref.DerefMut.deref_mut := deref_mut;
    }.
  End Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.
  End Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.
    Context {T S : Set}.
    
    Context
      {ℋ_0 : serde.de.DeserializeOwned.Trait T}
      {ℋ_1 : core.marker.Send.Trait T}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.extract.path.Path.t T.
    
    (*
        type Rejection = PathRejection;
    *)
    Definition Rejection : Set := axum.extract.rejection.PathRejection.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
            let params = match parts.extensions.get::<UrlParams>() {
                Some(UrlParams::Params(params)) => params,
                Some(UrlParams::InvalidUtf8InPathParam { key }) => {
                    let err = PathDeserializationError {
                        kind: ErrorKind::InvalidUtf8InPathParam {
                            key: key.to_string(),
                        },
                    };
                    let err = FailedToDeserializePathParams(err);
                    return Err(err.into());
                }
                None => {
                    return Err(MissingPathParams.into());
                }
            };
    
            T::deserialize(de::PathDeserializer::new(params))
                .map_err(|err| {
                    PathRejection::FailedToDeserializePathParams(FailedToDeserializePathParams(err))
                })
                .map(Path)
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (_state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.
  
  Module  PathDeserializationError.
  Section PathDeserializationError.
    Record t : Set := {
      kind : axum.extract.path.ErrorKind.t;
    }.
    
    Definition Get_kind :=
      Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
  End PathDeserializationError.
  End PathDeserializationError.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.
  Section Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.
    Definition Self : Set := axum.extract.path.PathDeserializationError.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.
  End Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.
  
  Module  Impl_axum_extract_path_PathDeserializationError_t_2.
  Section Impl_axum_extract_path_PathDeserializationError_t_2.
    Definition Self : Set := axum.extract.path.PathDeserializationError.t.
    
    (*
        pub(super) fn new(kind: ErrorKind) -> Self {
            Self { kind }
        }
    *)
    Definition new (kind : axum.extract.path.ErrorKind.t) : M Self :=
      let* kind := M.alloc kind in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
    
    (*
        pub(super) fn wrong_number_of_parameters() -> WrongNumberOfParameters<()> {
            WrongNumberOfParameters { got: () }
        }
    *)
    Definition wrong_number_of_parameters
        : M (axum.extract.path.WrongNumberOfParameters.t unit) :=
      M.read foo.
    
    Global Instance AssociatedFunction_wrong_number_of_parameters :
      Notations.DoubleColon Self "wrong_number_of_parameters" := {
      Notations.double_colon := wrong_number_of_parameters;
    }.
    
    (*
        pub(super) fn unsupported_type(name: &'static str) -> Self {
            Self::new(ErrorKind::UnsupportedType { name })
        }
    *)
    Definition unsupported_type (name : ref str.t) : M Self :=
      let* name := M.alloc name in
      M.read foo.
    
    Global Instance AssociatedFunction_unsupported_type :
      Notations.DoubleColon Self "unsupported_type" := {
      Notations.double_colon := unsupported_type;
    }.
  End Impl_axum_extract_path_PathDeserializationError_t_2.
  End Impl_axum_extract_path_PathDeserializationError_t_2.
  
  Module  WrongNumberOfParameters.
  Section WrongNumberOfParameters.
    Context (G : Set).
    
    Record t : Set := {
      got : G;
    }.
    
    Definition Get_got :=
      Ref.map (fun α => Some α.(got)) (fun β α => Some (α <| got := β |>)).
  End WrongNumberOfParameters.
  End WrongNumberOfParameters.
  
  Module  Impl_axum_extract_path_WrongNumberOfParameters_t_G_2.
  Section Impl_axum_extract_path_WrongNumberOfParameters_t_G_2.
    Context {G : Set}.
    
    Definition Self : Set := axum.extract.path.WrongNumberOfParameters.t G.
    
    (*
        pub(super) fn got<G2>(self, got: G2) -> WrongNumberOfParameters<G2> {
            WrongNumberOfParameters { got }
        }
    *)
    Definition got
        {G2 : Set}
        (self : Self)
        (got : G2)
        : M (axum.extract.path.WrongNumberOfParameters.t G2) :=
      let* self := M.alloc self in
      let* got := M.alloc got in
      M.read foo.
    
    Global Instance AssociatedFunction_got {G2 : Set} :
      Notations.DoubleColon Self "got" := {
      Notations.double_colon := got (G2 := G2);
    }.
  End Impl_axum_extract_path_WrongNumberOfParameters_t_G_2.
  End Impl_axum_extract_path_WrongNumberOfParameters_t_G_2.
  
  Module  Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t_2.
  Section Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t_2.
    Definition Self : Set :=
      axum.extract.path.WrongNumberOfParameters.t usize.t.
    
    (*
        pub(super) fn expected(self, expected: usize) -> PathDeserializationError {
            PathDeserializationError::new(ErrorKind::WrongNumberOfParameters {
                got: self.got,
                expected,
            })
        }
    *)
    Definition expected
        (self : Self)
        (expected : usize.t)
        : M axum.extract.path.PathDeserializationError.t :=
      let* self := M.alloc self in
      let* expected := M.alloc expected in
      M.read foo.
    
    Global Instance AssociatedFunction_expected :
      Notations.DoubleColon Self "expected" := {
      Notations.double_colon := expected;
    }.
  End Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t_2.
  End Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t_2.
  
  Module  Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.
  Section Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.
    Definition Self : Set := axum.extract.path.PathDeserializationError.t.
    
    (*
        fn custom<T>(msg: T) -> Self
        where
            T: fmt::Display,
        {
            Self {
                kind: ErrorKind::Message(msg.to_string()),
            }
        }
    *)
    Definition custom
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T}
        (msg : T)
        : M Self :=
      let* msg := M.alloc msg in
      M.read foo.
    
    Global Instance AssociatedFunction_custom
        {T : Set}
        {ℋ_0 : core.fmt.Display.Trait T} :
      Notations.DoubleColon Self "custom" := {
      Notations.double_colon := custom (T := T);
    }.
    
    Global Instance ℐ : serde.de.Error.Required.Trait Self := {
      serde.de.Error.custom {T : Set} {ℋ_0 : core.fmt.Display.Trait T} :=
        custom (T := T);
      serde.de.Error.invalid_type := Datatypes.None;
      serde.de.Error.invalid_value := Datatypes.None;
      serde.de.Error.invalid_length := Datatypes.None;
      serde.de.Error.unknown_variant := Datatypes.None;
      serde.de.Error.unknown_field := Datatypes.None;
      serde.de.Error.missing_field := Datatypes.None;
      serde.de.Error.duplicate_field := Datatypes.None;
    }.
  End Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.
  End Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.
  Section Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.
    Definition Self : Set := axum.extract.path.PathDeserializationError.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.kind.fmt(f)
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.
  End Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.
  
  Module  Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.
  Section Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.
    Definition Self : Set := axum.extract.path.PathDeserializationError.t.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.None;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.
  End Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.
  
  Module ErrorKind.
    Module WrongNumberOfParameters.
      Record t : Set := {
        got : usize.t;
        expected : usize.t;
      }.
    End WrongNumberOfParameters.
    
    Module ParseErrorAtKey.
      Record t : Set := {
        key : alloc.string.String.t;
        value : alloc.string.String.t;
        expected_type : ref str.t;
      }.
    End ParseErrorAtKey.
    
    Module ParseErrorAtIndex.
      Record t : Set := {
        index : usize.t;
        value : alloc.string.String.t;
        expected_type : ref str.t;
      }.
    End ParseErrorAtIndex.
    
    Module ParseError.
      Record t : Set := {
        value : alloc.string.String.t;
        expected_type : ref str.t;
      }.
    End ParseError.
    
    Module InvalidUtf8InPathParam.
      Record t : Set := {
        key : alloc.string.String.t;
      }.
    End InvalidUtf8InPathParam.
    
    Module UnsupportedType.
      Record t : Set := {
        name : ref str.t;
      }.
    End UnsupportedType.
    
    Inductive t : Set :=
    | WrongNumberOfParameters (_ : WrongNumberOfParameters.t)
    | ParseErrorAtKey (_ : ParseErrorAtKey.t)
    | ParseErrorAtIndex (_ : ParseErrorAtIndex.t)
    | ParseError (_ : ParseError.t)
    | InvalidUtf8InPathParam (_ : InvalidUtf8InPathParam.t)
    | UnsupportedType (_ : UnsupportedType.t)
    | Message (_ : alloc.string.String.t).
    
    Definition Get_WrongNumberOfParameters_got :=
      Ref.map
        (fun α =>
          match α with
          | WrongNumberOfParameters α => Some α.(WrongNumberOfParameters.got)
          | _ => None
          end)
        (fun β α =>
          match α with
          | WrongNumberOfParameters α =>
            Some
              (WrongNumberOfParameters
                (α <| WrongNumberOfParameters.got := β |>))
          | _ => None
          end).
    
    Definition Get_WrongNumberOfParameters_expected :=
      Ref.map
        (fun α =>
          match α with
          | WrongNumberOfParameters α =>
            Some α.(WrongNumberOfParameters.expected)
          | _ => None
          end)
        (fun β α =>
          match α with
          | WrongNumberOfParameters α =>
            Some
              (WrongNumberOfParameters
                (α <| WrongNumberOfParameters.expected := β |>))
          | _ => None
          end).
    
    Definition Get_ParseErrorAtKey_key :=
      Ref.map
        (fun α =>
          match α with
          | ParseErrorAtKey α => Some α.(ParseErrorAtKey.key)
          | _ => None
          end)
        (fun β α =>
          match α with
          | ParseErrorAtKey α =>
            Some (ParseErrorAtKey (α <| ParseErrorAtKey.key := β |>))
          | _ => None
          end).
    
    Definition Get_ParseErrorAtKey_value :=
      Ref.map
        (fun α =>
          match α with
          | ParseErrorAtKey α => Some α.(ParseErrorAtKey.value)
          | _ => None
          end)
        (fun β α =>
          match α with
          | ParseErrorAtKey α =>
            Some (ParseErrorAtKey (α <| ParseErrorAtKey.value := β |>))
          | _ => None
          end).
    
    Definition Get_ParseErrorAtKey_expected_type :=
      Ref.map
        (fun α =>
          match α with
          | ParseErrorAtKey α => Some α.(ParseErrorAtKey.expected_type)
          | _ => None
          end)
        (fun β α =>
          match α with
          | ParseErrorAtKey α =>
            Some (ParseErrorAtKey (α <| ParseErrorAtKey.expected_type := β |>))
          | _ => None
          end).
    
    Definition Get_ParseErrorAtIndex_index :=
      Ref.map
        (fun α =>
          match α with
          | ParseErrorAtIndex α => Some α.(ParseErrorAtIndex.index)
          | _ => None
          end)
        (fun β α =>
          match α with
          | ParseErrorAtIndex α =>
            Some (ParseErrorAtIndex (α <| ParseErrorAtIndex.index := β |>))
          | _ => None
          end).
    
    Definition Get_ParseErrorAtIndex_value :=
      Ref.map
        (fun α =>
          match α with
          | ParseErrorAtIndex α => Some α.(ParseErrorAtIndex.value)
          | _ => None
          end)
        (fun β α =>
          match α with
          | ParseErrorAtIndex α =>
            Some (ParseErrorAtIndex (α <| ParseErrorAtIndex.value := β |>))
          | _ => None
          end).
    
    Definition Get_ParseErrorAtIndex_expected_type :=
      Ref.map
        (fun α =>
          match α with
          | ParseErrorAtIndex α => Some α.(ParseErrorAtIndex.expected_type)
          | _ => None
          end)
        (fun β α =>
          match α with
          | ParseErrorAtIndex α =>
            Some
              (ParseErrorAtIndex (α <| ParseErrorAtIndex.expected_type := β |>))
          | _ => None
          end).
    
    Definition Get_ParseError_value :=
      Ref.map
        (fun α =>
          match α with
          | ParseError α => Some α.(ParseError.value)
          | _ => None
          end)
        (fun β α =>
          match α with
          | ParseError α => Some (ParseError (α <| ParseError.value := β |>))
          | _ => None
          end).
    
    Definition Get_ParseError_expected_type :=
      Ref.map
        (fun α =>
          match α with
          | ParseError α => Some α.(ParseError.expected_type)
          | _ => None
          end)
        (fun β α =>
          match α with
          | ParseError α =>
            Some (ParseError (α <| ParseError.expected_type := β |>))
          | _ => None
          end).
    
    Definition Get_InvalidUtf8InPathParam_key :=
      Ref.map
        (fun α =>
          match α with
          | InvalidUtf8InPathParam α => Some α.(InvalidUtf8InPathParam.key)
          | _ => None
          end)
        (fun β α =>
          match α with
          | InvalidUtf8InPathParam α =>
            Some
              (InvalidUtf8InPathParam (α <| InvalidUtf8InPathParam.key := β |>))
          | _ => None
          end).
    
    Definition Get_UnsupportedType_name :=
      Ref.map
        (fun α =>
          match α with
          | UnsupportedType α => Some α.(UnsupportedType.name)
          | _ => None
          end)
        (fun β α =>
          match α with
          | UnsupportedType α =>
            Some (UnsupportedType (α <| UnsupportedType.name := β |>))
          | _ => None
          end).
    
    Definition Get_Message_0 :=
      Ref.map
        (fun α => match α with | Message α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with | Message _ => Some (Message β) | _ => None end).
  End ErrorKind.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.
  Section Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.
    Definition Self : Set := axum.extract.path.ErrorKind.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.
  End Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.
  
  Module  Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.
  Section Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.
    Definition Self : Set := axum.extract.path.ErrorKind.t.
    
    Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.
  End Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.
  
  Module  Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.
  Section Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.
    Definition Self : Set := axum.extract.path.ErrorKind.t.
    
    (*
    PartialEq
    *)
    Definition eq
        (self : ref Self)
        (other : ref axum.extract.path.ErrorKind.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.
  End Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.
  
  Module  Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.
  Section Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.
    Definition Self : Set := axum.extract.path.ErrorKind.t.
    
    Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.
  End Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.
  
  Module  Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.
  Section Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.
    Definition Self : Set := axum.extract.path.ErrorKind.t.
    
    (*
    Eq
    *)
    Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_assert_receiver_is_total_eq :
      Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
      Notations.double_colon := assert_receiver_is_total_eq;
    }.
    
    Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
      core.cmp.Eq.assert_receiver_is_total_eq :=
        Datatypes.Some assert_receiver_is_total_eq;
    }.
  End Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.
  End Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.
  Section Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.
    Definition Self : Set := axum.extract.path.ErrorKind.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                ErrorKind::Message(error) => error.fmt(f),
                ErrorKind::InvalidUtf8InPathParam { key } => write!(f, "Invalid UTF-8 in `{key}`"),
                ErrorKind::WrongNumberOfParameters { got, expected } => {
                    write!(
                        f,
                        "Wrong number of path arguments for `Path`. Expected {expected} but got {got}"
                    )?;
    
                    if *expected == 1 {
                        write!(f, ". Note that multiple parameters must be extracted with a tuple `Path<(_, _)>` or a struct `Path<YourParams>`")?;
                    }
    
                    Ok(())
                }
                ErrorKind::UnsupportedType { name } => write!(f, "Unsupported type `{name}`"),
                ErrorKind::ParseErrorAtKey {
                    key,
                    value,
                    expected_type,
                } => write!(
                    f,
                    "Cannot parse `{key}` with value `{value:?}` to a `{expected_type}`"
                ),
                ErrorKind::ParseError {
                    value,
                    expected_type,
                } => write!(f, "Cannot parse `{value:?}` to a `{expected_type}`"),
                ErrorKind::ParseErrorAtIndex {
                    index,
                    value,
                    expected_type,
                } => write!(
                    f,
                    "Cannot parse value at index {index} with value `{value:?}` to a `{expected_type}`"
                ),
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.
  End Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.
  
  Module  FailedToDeserializePathParams.
  Section FailedToDeserializePathParams.
    Record t : Set := {
      x0 : axum.extract.path.PathDeserializationError.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End FailedToDeserializePathParams.
  End FailedToDeserializePathParams.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.
  Section Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.
    Definition Self : Set := axum.extract.path.FailedToDeserializePathParams.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.
  End Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.
  
  Module  Impl_axum_extract_path_FailedToDeserializePathParams_t_2.
  Section Impl_axum_extract_path_FailedToDeserializePathParams_t_2.
    Definition Self : Set := axum.extract.path.FailedToDeserializePathParams.t.
    
    (*
        pub fn kind(&self) -> &ErrorKind {
            &self.0.kind
        }
    *)
    Definition kind (self : ref Self) : M (ref axum.extract.path.ErrorKind.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_kind :
      Notations.DoubleColon Self "kind" := {
      Notations.double_colon := kind;
    }.
    
    (*
        pub fn into_kind(self) -> ErrorKind {
            self.0.kind
        }
    *)
    Definition into_kind (self : Self) : M axum.extract.path.ErrorKind.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_kind :
      Notations.DoubleColon Self "into_kind" := {
      Notations.double_colon := into_kind;
    }.
    
    (*
        pub fn body_text(&self) -> String {
            match self.0.kind {
                ErrorKind::Message(_)
                | ErrorKind::InvalidUtf8InPathParam { .. }
                | ErrorKind::ParseError { .. }
                | ErrorKind::ParseErrorAtIndex { .. }
                | ErrorKind::ParseErrorAtKey { .. } => format!("Invalid URL: {}", self.0.kind),
                ErrorKind::WrongNumberOfParameters { .. } | ErrorKind::UnsupportedType { .. } => {
                    self.0.kind.to_string()
                }
            }
        }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
        pub fn status(&self) -> StatusCode {
            match self.0.kind {
                ErrorKind::Message(_)
                | ErrorKind::InvalidUtf8InPathParam { .. }
                | ErrorKind::ParseError { .. }
                | ErrorKind::ParseErrorAtIndex { .. }
                | ErrorKind::ParseErrorAtKey { .. } => StatusCode::BAD_REQUEST,
                ErrorKind::WrongNumberOfParameters { .. } | ErrorKind::UnsupportedType { .. } => {
                    StatusCode::INTERNAL_SERVER_ERROR
                }
            }
        }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_path_FailedToDeserializePathParams_t_2.
  End Impl_axum_extract_path_FailedToDeserializePathParams_t_2.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.
    Definition Self : Set := axum.extract.path.FailedToDeserializePathParams.t.
    
    (*
        fn into_response(self) -> Response {
            axum_core::__log_rejection!(
                rejection_type = Self,
                body_text = self.body_text(),
                status = self.status(),
            );
            (self.status(), self.body_text()).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.
  Section Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.
    Definition Self : Set := axum.extract.path.FailedToDeserializePathParams.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.0.fmt(f)
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.
  End Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.
  
  Module  Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.
  Section Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.
    Definition Self : Set := axum.extract.path.FailedToDeserializePathParams.t.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.None;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.
  End Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.
  
  Module  RawPathParams.
  Section RawPathParams.
    Record t : Set := {
      x0 :
        alloc.vec.Vec.t
          ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
          *
          axum.util.PercentDecodedStr.t)
          alloc.vec.Vec.Default.A;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End RawPathParams.
  End RawPathParams.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.
  Section Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.
    Definition Self : Set := axum.extract.path.RawPathParams.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.
  End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.extract.path.RawPathParams.t.
    
    (*
        type Rejection = RawPathParamsRejection;
    *)
    Definition Rejection : Set :=
      axum.extract.rejection.RawPathParamsRejection.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
            let params = match parts.extensions.get::<UrlParams>() {
                Some(UrlParams::Params(params)) => params,
                Some(UrlParams::InvalidUtf8InPathParam { key }) => {
                    return Err(InvalidUtf8InPathParam {
                        key: Arc::clone(key),
                    }
                    .into());
                }
                None => {
                    return Err(MissingPathParams.into());
                }
            };
    
            Ok(Self(params.clone()))
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (_state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.
  
  Module  Impl_axum_extract_path_RawPathParams_t_2.
  Section Impl_axum_extract_path_RawPathParams_t_2.
    Definition Self : Set := axum.extract.path.RawPathParams.t.
    
    (*
        pub fn iter(&self) -> RawPathParamsIter<'_> {
            self.into_iter()
        }
    *)
    Definition iter
        (self : ref Self)
        : M axum.extract.path.RawPathParamsIter.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_iter :
      Notations.DoubleColon Self "iter" := {
      Notations.double_colon := iter;
    }.
  End Impl_axum_extract_path_RawPathParams_t_2.
  End Impl_axum_extract_path_RawPathParams_t_2.
  
  Module  Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.
  Section Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.
    Definition Self : Set := ref axum.extract.path.RawPathParams.t.
    
    (*
        type Item = (&'a str, &'a str);
    *)
    Definition Item : Set := (ref str.t) * (ref str.t).
    
    (*
        type IntoIter = RawPathParamsIter<'a>;
    *)
    Definition IntoIter : Set := axum.extract.path.RawPathParamsIter.t.
    
    (*
        fn into_iter(self) -> Self::IntoIter {
            RawPathParamsIter(self.0.iter())
        }
    *)
    Definition into_iter (self : Self) : M IntoIter :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_iter :
      Notations.DoubleColon Self "into_iter" := {
      Notations.double_colon := into_iter;
    }.
    
    Global Instance ℐ : core.iter.traits.collect.IntoIterator.Trait Self := {
      core.iter.traits.collect.IntoIterator.Item := Item;
      core.iter.traits.collect.IntoIterator.IntoIter := IntoIter;
      core.iter.traits.collect.IntoIterator.into_iter := into_iter;
    }.
  End Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.
  End Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.
  
  Module  RawPathParamsIter.
  Section RawPathParamsIter.
    Record t : Set := {
      x0 :
        core.slice.iter.Iter.t
          ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
          *
          axum.util.PercentDecodedStr.t);
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End RawPathParamsIter.
  End RawPathParamsIter.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.
  Section Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.
    Definition Self : Set := axum.extract.path.RawPathParamsIter.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.
  End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.
  
  Module  Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.
  Section Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.
    Definition Self : Set := axum.extract.path.RawPathParamsIter.t.
    
    (*
        type Item = (&'a str, &'a str);
    *)
    Definition Item : Set := (ref str.t) * (ref str.t).
    
    (*
        fn next(&mut self) -> Option<Self::Item> {
            let (key, value) = self.0.next()?;
            Some((&**key, value.as_str()))
        }
    *)
    Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    Global Instance ℐ :
      core.iter.traits.iterator.Iterator.Required.Trait Self := {
      core.iter.traits.iterator.Iterator.Item := Item;
      core.iter.traits.iterator.Iterator.next := next;
      core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
      core.iter.traits.iterator.Iterator.size_hint := Datatypes.None;
      core.iter.traits.iterator.Iterator.count := Datatypes.None;
      core.iter.traits.iterator.Iterator.last := Datatypes.None;
      core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.nth := Datatypes.None;
      core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.chain := Datatypes.None;
      core.iter.traits.iterator.Iterator.zip := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
      core.iter.traits.iterator.Iterator.map := Datatypes.None;
      core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
      core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip := Datatypes.None;
      core.iter.traits.iterator.Iterator.take := Datatypes.None;
      core.iter.traits.iterator.Iterator.scan := Datatypes.None;
      core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
      core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
      core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
      core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.all := Datatypes.None;
      core.iter.traits.iterator.Iterator.any := Datatypes.None;
      core.iter.traits.iterator.Iterator.find := Datatypes.None;
      core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
      core.iter.traits.iterator.Iterator.position := Datatypes.None;
      core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
      core.iter.traits.iterator.Iterator.max := Datatypes.None;
      core.iter.traits.iterator.Iterator.min := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.rev := Datatypes.None;
      core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
      core.iter.traits.iterator.Iterator.copied := Datatypes.None;
      core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
      core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
      core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
      core.iter.traits.iterator.Iterator.sum := Datatypes.None;
      core.iter.traits.iterator.Iterator.product := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.ne := Datatypes.None;
      core.iter.traits.iterator.Iterator.lt := Datatypes.None;
      core.iter.traits.iterator.Iterator.le := Datatypes.None;
      core.iter.traits.iterator.Iterator.gt := Datatypes.None;
      core.iter.traits.iterator.Iterator.ge := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
        Datatypes.None;
    }.
  End Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.
  End Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.
  
  Module  InvalidUtf8InPathParam.
  Section InvalidUtf8InPathParam.
    Record t : Set := {
      key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
    }.
    
    Definition Get_key :=
      Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
  End InvalidUtf8InPathParam.
  End InvalidUtf8InPathParam.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.
  Section Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.
    Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.
  End Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.
  
  Module  Impl_axum_extract_path_InvalidUtf8InPathParam_t_2.
  Section Impl_axum_extract_path_InvalidUtf8InPathParam_t_2.
    Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
    
    (*
        pub fn body_text(&self) -> String {
            self.to_string()
        }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
        pub fn status(&self) -> StatusCode {
            StatusCode::BAD_REQUEST
        }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_path_InvalidUtf8InPathParam_t_2.
  End Impl_axum_extract_path_InvalidUtf8InPathParam_t_2.
  
  Module  Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.
  Section Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.
    Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "Invalid UTF-8 in `{}`", self.key)
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.
  End Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.
  
  Module  Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.
  Section Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.
    Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.None;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.
  End Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.
    Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
    
    (*
        fn into_response(self) -> Response {
            (self.status(), self.body_text()).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.
End path.

Module de.
  Module  PathDeserializer.
  Section PathDeserializer.
    Record t : Set := {
      url_params :
        ref
          (slice
            ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
            *
            axum.util.PercentDecodedStr.t));
    }.
    
    Definition Get_url_params :=
      Ref.map
        (fun α => Some α.(url_params))
        (fun β α => Some (α <| url_params := β |>)).
  End PathDeserializer.
  End PathDeserializer.
  
  Module  Impl_axum_extract_path_de_PathDeserializer_t_3.
  Section Impl_axum_extract_path_de_PathDeserializer_t_3.
    Definition Self : Set := axum.extract.path.de.PathDeserializer.t.
    
    (*
        pub(crate) fn new(url_params: &'de [(Arc<str>, PercentDecodedStr)]) -> Self {
            PathDeserializer { url_params }
        }
    *)
    Definition new
        (url_params
          :
          ref
            (slice
              ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
              *
              axum.util.PercentDecodedStr.t)))
        : M Self :=
      let* url_params := M.alloc url_params in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_axum_extract_path_de_PathDeserializer_t_3.
  End Impl_axum_extract_path_de_PathDeserializer_t_3.
  
  Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
  Section Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
    Definition Self : Set := axum.extract.path.de.PathDeserializer.t.
    
    (*
        type Error = PathDeserializationError;
    *)
    Definition Error : Set := axum.extract.path.PathDeserializationError.t.
    
    (*
            fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::unsupported_type(type_name::<
                    V::Value,
                >()))
            }
    *)
    Definition deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (Pattern : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bytes" := {
      Notations.double_colon := deserialize_bytes (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::unsupported_type(type_name::<
                    V::Value,
                >()))
            }
    *)
    Definition deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (Pattern : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_option" := {
      Notations.double_colon := deserialize_option (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::unsupported_type(type_name::<
                    V::Value,
                >()))
            }
    *)
    Definition deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (Pattern : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_identifier" := {
      Notations.double_colon := deserialize_identifier (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::unsupported_type(type_name::<
                    V::Value,
                >()))
            }
    *)
    Definition deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (Pattern : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_ignored_any" := {
      Notations.double_colon := deserialize_ignored_any (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bool" := {
      Notations.double_colon := deserialize_bool (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i8" := {
      Notations.double_colon := deserialize_i8 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i16" := {
      Notations.double_colon := deserialize_i16 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i32" := {
      Notations.double_colon := deserialize_i32 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i64" := {
      Notations.double_colon := deserialize_i64 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i128" := {
      Notations.double_colon := deserialize_i128 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u8" := {
      Notations.double_colon := deserialize_u8 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u16" := {
      Notations.double_colon := deserialize_u16 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u32" := {
      Notations.double_colon := deserialize_u32 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u64" := {
      Notations.double_colon := deserialize_u64 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u128" := {
      Notations.double_colon := deserialize_u128 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f32" := {
      Notations.double_colon := deserialize_f32 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f64" := {
      Notations.double_colon := deserialize_f64 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_string" := {
      Notations.double_colon := deserialize_string (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_byte_buf" := {
      Notations.double_colon := deserialize_byte_buf (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                if self.url_params.len() != 1 {
                    return Err(PathDeserializationError::wrong_number_of_parameters()
                        .got(self.url_params.len())
                        .expected(1));
                }
    
                let value = self.url_params[0].1.parse().map_err(|_| {
                    PathDeserializationError::new(ErrorKind::ParseError {
                        value: self.url_params[0].1.as_str().to_owned(),
                        expected_type: $ty,
                    })
                })?;
                visitor.$visit_fn(value)
            }
    *)
    Definition deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_char" := {
      Notations.double_colon := deserialize_char (V := V);
    }.
    
    (*
        fn deserialize_any<V>(self, v: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_str(v)
        }
    *)
    Definition deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (v : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_any" := {
      Notations.double_colon := deserialize_any (V := V);
    }.
    
    (*
        fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            if self.url_params.len() != 1 {
                return Err(PathDeserializationError::wrong_number_of_parameters()
                    .got(self.url_params.len())
                    .expected(1));
            }
            visitor.visit_borrowed_str(&self.url_params[0].1)
        }
    *)
    Definition deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_str" := {
      Notations.double_colon := deserialize_str (V := V);
    }.
    
    (*
        fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_unit()
        }
    *)
    Definition deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit" := {
      Notations.double_colon := deserialize_unit (V := V);
    }.
    
    (*
        fn deserialize_unit_struct<V>(
            self,
            _name: &'static str,
            visitor: V,
        ) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_unit()
        }
    *)
    Definition deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit_struct" := {
      Notations.double_colon := deserialize_unit_struct (V := V);
    }.
    
    (*
        fn deserialize_newtype_struct<V>(
            self,
            _name: &'static str,
            visitor: V,
        ) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_newtype_struct(self)
        }
    *)
    Definition deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_newtype_struct" := {
      Notations.double_colon := deserialize_newtype_struct (V := V);
    }.
    
    (*
        fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_seq(SeqDeserializer {
                params: self.url_params,
                idx: 0,
            })
        }
    *)
    Definition deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_seq" := {
      Notations.double_colon := deserialize_seq (V := V);
    }.
    
    (*
        fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            if self.url_params.len() < len {
                return Err(PathDeserializationError::wrong_number_of_parameters()
                    .got(self.url_params.len())
                    .expected(len));
            }
            visitor.visit_seq(SeqDeserializer {
                params: self.url_params,
                idx: 0,
            })
        }
    *)
    Definition deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple" := {
      Notations.double_colon := deserialize_tuple (V := V);
    }.
    
    (*
        fn deserialize_tuple_struct<V>(
            self,
            _name: &'static str,
            len: usize,
            visitor: V,
        ) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            if self.url_params.len() < len {
                return Err(PathDeserializationError::wrong_number_of_parameters()
                    .got(self.url_params.len())
                    .expected(len));
            }
            visitor.visit_seq(SeqDeserializer {
                params: self.url_params,
                idx: 0,
            })
        }
    *)
    Definition deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple_struct" := {
      Notations.double_colon := deserialize_tuple_struct (V := V);
    }.
    
    (*
        fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_map(MapDeserializer {
                params: self.url_params,
                value: None,
                key: None,
            })
        }
    *)
    Definition deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_map" := {
      Notations.double_colon := deserialize_map (V := V);
    }.
    
    (*
        fn deserialize_struct<V>(
            self,
            _name: &'static str,
            _fields: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_map(visitor)
        }
    *)
    Definition deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_fields : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _fields := M.alloc _fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_struct" := {
      Notations.double_colon := deserialize_struct (V := V);
    }.
    
    (*
        fn deserialize_enum<V>(
            self,
            _name: &'static str,
            _variants: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            if self.url_params.len() != 1 {
                return Err(PathDeserializationError::wrong_number_of_parameters()
                    .got(self.url_params.len())
                    .expected(1));
            }
    
            visitor.visit_enum(EnumDeserializer {
                value: self.url_params[0].1.clone().into_inner(),
            })
        }
    *)
    Definition deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_variants : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variants := M.alloc _variants in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_enum" := {
      Notations.double_colon := deserialize_enum (V := V);
    }.
    
    Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
      serde.de.Deserializer.Error := Error;
      serde.de.Deserializer.deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bytes (V := V);
      serde.de.Deserializer.deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_option (V := V);
      serde.de.Deserializer.deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_identifier (V := V);
      serde.de.Deserializer.deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_ignored_any (V := V);
      serde.de.Deserializer.deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bool (V := V);
      serde.de.Deserializer.deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i8 (V := V);
      serde.de.Deserializer.deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i16 (V := V);
      serde.de.Deserializer.deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i32 (V := V);
      serde.de.Deserializer.deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i64 (V := V);
      serde.de.Deserializer.deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_i128 (V := V));
      serde.de.Deserializer.deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u8 (V := V);
      serde.de.Deserializer.deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u16 (V := V);
      serde.de.Deserializer.deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u32 (V := V);
      serde.de.Deserializer.deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u64 (V := V);
      serde.de.Deserializer.deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_u128 (V := V));
      serde.de.Deserializer.deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f32 (V := V);
      serde.de.Deserializer.deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f64 (V := V);
      serde.de.Deserializer.deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_string (V := V);
      serde.de.Deserializer.deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_byte_buf (V := V);
      serde.de.Deserializer.deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_char (V := V);
      serde.de.Deserializer.deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_any (V := V);
      serde.de.Deserializer.deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_str (V := V);
      serde.de.Deserializer.deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit (V := V);
      serde.de.Deserializer.deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit_struct (V := V);
      serde.de.Deserializer.deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_newtype_struct (V := V);
      serde.de.Deserializer.deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_seq (V := V);
      serde.de.Deserializer.deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple (V := V);
      serde.de.Deserializer.deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple_struct (V := V);
      serde.de.Deserializer.deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_map (V := V);
      serde.de.Deserializer.deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_struct (V := V);
      serde.de.Deserializer.deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_enum (V := V);
      serde.de.Deserializer.is_human_readable := Datatypes.None;
      serde.de.Deserializer.__deserialize_content := Datatypes.None;
    }.
  End Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
  End Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
  
  Module  MapDeserializer.
  Section MapDeserializer.
    Record t : Set := {
      params :
        ref
          (slice
            ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
            *
            axum.util.PercentDecodedStr.t));
      key : core.option.Option.t axum.extract.path.de.KeyOrIdx.t;
      value : core.option.Option.t (ref axum.util.PercentDecodedStr.t);
    }.
    
    Definition Get_params :=
      Ref.map
        (fun α => Some α.(params))
        (fun β α => Some (α <| params := β |>)).
    Definition Get_key :=
      Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
    Definition Get_value :=
      Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  End MapDeserializer.
  End MapDeserializer.
  
  Module  Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
  Section Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
    Definition Self : Set := axum.extract.path.de.MapDeserializer.t.
    
    (*
        type Error = PathDeserializationError;
    *)
    Definition Error : Set := axum.extract.path.PathDeserializationError.t.
    
    (*
        fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>
        where
            K: DeserializeSeed<'de>,
        {
            match self.params.split_first() {
                Some(((key, value), tail)) => {
                    self.value = Some(value);
                    self.params = tail;
                    self.key = Some(KeyOrIdx::Key(key.clone()));
                    seed.deserialize(KeyDeserializer {
                        key: Arc::clone(key),
                    })
                    .map(Some)
                }
                None => Ok(None),
            }
        }
    *)
    Definition next_key_seed
        {K : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait K}
        (self : mut_ref Self)
        (seed : K)
        :
          M
            (core.result.Result.t
              (core.option.Option.t K::type["Value"].t)
              Error) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_key_seed
        {K : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait K} :
      Notations.DoubleColon Self "next_key_seed" := {
      Notations.double_colon := next_key_seed (K := K);
    }.
    
    (*
        fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>
        where
            V: DeserializeSeed<'de>,
        {
            match self.value.take() {
                Some(value) => seed.deserialize(ValueDeserializer {
                    key: self.key.take(),
                    value,
                }),
                None => Err(PathDeserializationError::custom("value is missing")),
            }
        }
    *)
    Definition next_value_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V}
        (self : mut_ref Self)
        (seed : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_value_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
      Notations.DoubleColon Self "next_value_seed" := {
      Notations.double_colon := next_value_seed (V := V);
    }.
    
    Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
      serde.de.MapAccess.Error := Error;
      serde.de.MapAccess.next_key_seed
        {K : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait K} :=
        next_key_seed (K := K);
      serde.de.MapAccess.next_value_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
        next_value_seed (V := V);
      serde.de.MapAccess.next_entry_seed := Datatypes.None;
      serde.de.MapAccess.next_key := Datatypes.None;
      serde.de.MapAccess.next_value := Datatypes.None;
      serde.de.MapAccess.next_entry := Datatypes.None;
      serde.de.MapAccess.size_hint := Datatypes.None;
    }.
  End Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
  End Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
  
  Module  KeyDeserializer.
  Section KeyDeserializer.
    Record t : Set := {
      key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
    }.
    
    Definition Get_key :=
      Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
  End KeyDeserializer.
  End KeyDeserializer.
  
  Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
  Section Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
    Definition Self : Set := axum.extract.path.de.KeyDeserializer.t.
    
    (*
        type Error = PathDeserializationError;
    *)
    Definition Error : Set := axum.extract.path.PathDeserializationError.t.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_str(&self.key)
            }
    *)
    Definition deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_identifier" := {
      Notations.double_colon := deserialize_identifier (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_str(&self.key)
            }
    *)
    Definition deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_str" := {
      Notations.double_colon := deserialize_str (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                visitor.visit_str(&self.key)
            }
    *)
    Definition deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_string" := {
      Notations.double_colon := deserialize_string (V := V);
    }.
    
    (*
        fn deserialize_any<V>(self, _visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            Err(PathDeserializationError::custom("Unexpected key type"))
        }
    *)
    Definition deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _visitor := M.alloc _visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_any" := {
      Notations.double_colon := deserialize_any (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bool" := {
      Notations.double_colon := deserialize_bool (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i8" := {
      Notations.double_colon := deserialize_i8 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i16" := {
      Notations.double_colon := deserialize_i16 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i32" := {
      Notations.double_colon := deserialize_i32 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i64" := {
      Notations.double_colon := deserialize_i64 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i128" := {
      Notations.double_colon := deserialize_i128 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u8" := {
      Notations.double_colon := deserialize_u8 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u16" := {
      Notations.double_colon := deserialize_u16 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u32" := {
      Notations.double_colon := deserialize_u32 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u64" := {
      Notations.double_colon := deserialize_u64 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u128" := {
      Notations.double_colon := deserialize_u128 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f32" := {
      Notations.double_colon := deserialize_f32 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f64" := {
      Notations.double_colon := deserialize_f64 (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_char" := {
      Notations.double_colon := deserialize_char (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bytes" := {
      Notations.double_colon := deserialize_bytes (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_byte_buf" := {
      Notations.double_colon := deserialize_byte_buf (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_option" := {
      Notations.double_colon := deserialize_option (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit" := {
      Notations.double_colon := deserialize_unit (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit_struct" := {
      Notations.double_colon := deserialize_unit_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_seq" := {
      Notations.double_colon := deserialize_seq (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple" := {
      Notations.double_colon := deserialize_tuple (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple_struct" := {
      Notations.double_colon := deserialize_tuple_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_map" := {
      Notations.double_colon := deserialize_map (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_newtype_struct" := {
      Notations.double_colon := deserialize_newtype_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (fields : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* fields := M.alloc fields in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_struct" := {
      Notations.double_colon := deserialize_struct (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (name : ref str.t)
        (variants : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* variants := M.alloc variants in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_enum" := {
      Notations.double_colon := deserialize_enum (V := V);
    }.
    
    (*
            fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
            where
                $v: $crate::de::Visitor<$l>,
            {
                $(
                    let _ = $arg;
                )*
                self.deserialize_any(visitor)
            }
    *)
    Definition deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_ignored_any" := {
      Notations.double_colon := deserialize_ignored_any (V := V);
    }.
    
    Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
      serde.de.Deserializer.Error := Error;
      serde.de.Deserializer.deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_identifier (V := V);
      serde.de.Deserializer.deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_str (V := V);
      serde.de.Deserializer.deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_string (V := V);
      serde.de.Deserializer.deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_any (V := V);
      serde.de.Deserializer.deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bool (V := V);
      serde.de.Deserializer.deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i8 (V := V);
      serde.de.Deserializer.deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i16 (V := V);
      serde.de.Deserializer.deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i32 (V := V);
      serde.de.Deserializer.deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i64 (V := V);
      serde.de.Deserializer.deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_i128 (V := V));
      serde.de.Deserializer.deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u8 (V := V);
      serde.de.Deserializer.deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u16 (V := V);
      serde.de.Deserializer.deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u32 (V := V);
      serde.de.Deserializer.deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u64 (V := V);
      serde.de.Deserializer.deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_u128 (V := V));
      serde.de.Deserializer.deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f32 (V := V);
      serde.de.Deserializer.deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f64 (V := V);
      serde.de.Deserializer.deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_char (V := V);
      serde.de.Deserializer.deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bytes (V := V);
      serde.de.Deserializer.deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_byte_buf (V := V);
      serde.de.Deserializer.deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_option (V := V);
      serde.de.Deserializer.deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit (V := V);
      serde.de.Deserializer.deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit_struct (V := V);
      serde.de.Deserializer.deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_seq (V := V);
      serde.de.Deserializer.deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple (V := V);
      serde.de.Deserializer.deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple_struct (V := V);
      serde.de.Deserializer.deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_map (V := V);
      serde.de.Deserializer.deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_newtype_struct (V := V);
      serde.de.Deserializer.deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_struct (V := V);
      serde.de.Deserializer.deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_enum (V := V);
      serde.de.Deserializer.deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_ignored_any (V := V);
      serde.de.Deserializer.is_human_readable := Datatypes.None;
      serde.de.Deserializer.__deserialize_content := Datatypes.None;
    }.
  End Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
  End Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
  
  Module  ValueDeserializer.
  Section ValueDeserializer.
    Record t : Set := {
      key : core.option.Option.t axum.extract.path.de.KeyOrIdx.t;
      value : ref axum.util.PercentDecodedStr.t;
    }.
    
    Definition Get_key :=
      Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
    Definition Get_value :=
      Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  End ValueDeserializer.
  End ValueDeserializer.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
  Section Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
    Definition Self : Set := axum.extract.path.de.ValueDeserializer.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
  End Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
  
  Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
  Section Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
    Definition Self : Set := axum.extract.path.de.ValueDeserializer.t.
    
    (*
        type Error = PathDeserializationError;
    *)
    Definition Error : Set := axum.extract.path.PathDeserializationError.t.
    
    (*
            fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::unsupported_type(type_name::<
                    V::Value,
                >()))
            }
    *)
    Definition deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (Pattern : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_map" := {
      Notations.double_colon := deserialize_map (V := V);
    }.
    
    (*
            fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                Err(PathDeserializationError::unsupported_type(type_name::<
                    V::Value,
                >()))
            }
    *)
    Definition deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (Pattern : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_identifier" := {
      Notations.double_colon := deserialize_identifier (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bool" := {
      Notations.double_colon := deserialize_bool (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i8" := {
      Notations.double_colon := deserialize_i8 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i16" := {
      Notations.double_colon := deserialize_i16 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i32" := {
      Notations.double_colon := deserialize_i32 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i64" := {
      Notations.double_colon := deserialize_i64 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_i128" := {
      Notations.double_colon := deserialize_i128 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u8" := {
      Notations.double_colon := deserialize_u8 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u16" := {
      Notations.double_colon := deserialize_u16 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u32" := {
      Notations.double_colon := deserialize_u32 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u64" := {
      Notations.double_colon := deserialize_u64 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_u128" := {
      Notations.double_colon := deserialize_u128 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f32" := {
      Notations.double_colon := deserialize_f32 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_f64" := {
      Notations.double_colon := deserialize_f64 (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_string" := {
      Notations.double_colon := deserialize_string (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_byte_buf" := {
      Notations.double_colon := deserialize_byte_buf (V := V);
    }.
    
    (*
            fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
            where
                V: Visitor<'de>,
            {
                let v = self.value.parse().map_err(|_| {
                    if let Some(key) = self.key.take() {
                        let kind = match key {
                            KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                                key: key.to_string(),
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                            KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                                index,
                                value: self.value.as_str().to_owned(),
                                expected_type: $ty,
                            },
                        };
                        PathDeserializationError::new(kind)
                    } else {
                        PathDeserializationError::new(ErrorKind::ParseError {
                            value: self.value.as_str().to_owned(),
                            expected_type: $ty,
                        })
                    }
                })?;
                visitor.$visit_fn(v)
            }
    *)
    Definition deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_char" := {
      Notations.double_colon := deserialize_char (V := V);
    }.
    
    (*
        fn deserialize_any<V>(self, v: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            self.deserialize_str(v)
        }
    *)
    Definition deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (v : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* v := M.alloc v in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_any" := {
      Notations.double_colon := deserialize_any (V := V);
    }.
    
    (*
        fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_borrowed_str(self.value)
        }
    *)
    Definition deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_str" := {
      Notations.double_colon := deserialize_str (V := V);
    }.
    
    (*
        fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_borrowed_bytes(self.value.as_bytes())
        }
    *)
    Definition deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_bytes" := {
      Notations.double_colon := deserialize_bytes (V := V);
    }.
    
    (*
        fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_some(self)
        }
    *)
    Definition deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_option" := {
      Notations.double_colon := deserialize_option (V := V);
    }.
    
    (*
        fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_unit()
        }
    *)
    Definition deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit" := {
      Notations.double_colon := deserialize_unit (V := V);
    }.
    
    (*
        fn deserialize_unit_struct<V>(
            self,
            _name: &'static str,
            visitor: V,
        ) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_unit()
        }
    *)
    Definition deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_unit_struct" := {
      Notations.double_colon := deserialize_unit_struct (V := V);
    }.
    
    (*
        fn deserialize_newtype_struct<V>(
            self,
            _name: &'static str,
            visitor: V,
        ) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_newtype_struct(self)
        }
    *)
    Definition deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_newtype_struct" := {
      Notations.double_colon := deserialize_newtype_struct (V := V);
    }.
    
    (*
        fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            struct PairDeserializer<'de> {
                key: Option<KeyOrIdx>,
                value: Option<&'de PercentDecodedStr>,
            }
    
            impl<'de> SeqAccess<'de> for PairDeserializer<'de> {
                type Error = PathDeserializationError;
    
                fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
                where
                    T: DeserializeSeed<'de>,
                {
                    match self.key.take() {
                        Some(KeyOrIdx::Idx { idx: _, key }) => {
                            return seed.deserialize(KeyDeserializer { key }).map(Some);
                        }
                        // `KeyOrIdx::Key` is only used when deserializing maps so `deserialize_seq`
                        // wouldn't be called for that
                        Some(KeyOrIdx::Key(_)) => unreachable!(),
                        None => {}
                    };
    
                    self.value
                        .take()
                        .map(|value| seed.deserialize(ValueDeserializer { key: None, value }))
                        .transpose()
                }
            }
    
            if len == 2 {
                match self.key {
                    Some(key) => visitor.visit_seq(PairDeserializer {
                        key: Some(key),
                        value: Some(self.value),
                    }),
                    // `self.key` is only `None` when deserializing maps so `deserialize_seq`
                    // wouldn't be called for that
                    None => unreachable!(),
                }
            } else {
                Err(PathDeserializationError::unsupported_type(type_name::<
                    V::Value,
                >()))
            }
        }
    *)
    Definition deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (len : usize.t)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* len := M.alloc len in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple" := {
      Notations.double_colon := deserialize_tuple (V := V);
    }.
    
    (*
        fn deserialize_seq<V>(self, _visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            Err(PathDeserializationError::unsupported_type(type_name::<
                V::Value,
            >()))
        }
    *)
    Definition deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _visitor := M.alloc _visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_seq" := {
      Notations.double_colon := deserialize_seq (V := V);
    }.
    
    (*
        fn deserialize_tuple_struct<V>(
            self,
            _name: &'static str,
            _len: usize,
            _visitor: V,
        ) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            Err(PathDeserializationError::unsupported_type(type_name::<
                V::Value,
            >()))
        }
    *)
    Definition deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_len : usize.t)
        (_visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _len := M.alloc _len in
      let* _visitor := M.alloc _visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_tuple_struct" := {
      Notations.double_colon := deserialize_tuple_struct (V := V);
    }.
    
    (*
        fn deserialize_struct<V>(
            self,
            _name: &'static str,
            _fields: &'static [&'static str],
            _visitor: V,
        ) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            Err(PathDeserializationError::unsupported_type(type_name::<
                V::Value,
            >()))
        }
    *)
    Definition deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_fields : ref (slice (ref str.t)))
        (_visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _fields := M.alloc _fields in
      let* _visitor := M.alloc _visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_struct" := {
      Notations.double_colon := deserialize_struct (V := V);
    }.
    
    (*
        fn deserialize_enum<V>(
            self,
            _name: &'static str,
            _variants: &'static [&'static str],
            visitor: V,
        ) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_enum(EnumDeserializer {
                value: self.value.clone().into_inner(),
            })
        }
    *)
    Definition deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_name : ref str.t)
        (_variants : ref (slice (ref str.t)))
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _name := M.alloc _name in
      let* _variants := M.alloc _variants in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_enum" := {
      Notations.double_colon := deserialize_enum (V := V);
    }.
    
    (*
        fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            visitor.visit_unit()
        }
    *)
    Definition deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* visitor := M.alloc visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "deserialize_ignored_any" := {
      Notations.double_colon := deserialize_ignored_any (V := V);
    }.
    
    Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
      serde.de.Deserializer.Error := Error;
      serde.de.Deserializer.deserialize_map
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_map (V := V);
      serde.de.Deserializer.deserialize_identifier
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_identifier (V := V);
      serde.de.Deserializer.deserialize_bool
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bool (V := V);
      serde.de.Deserializer.deserialize_i8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i8 (V := V);
      serde.de.Deserializer.deserialize_i16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i16 (V := V);
      serde.de.Deserializer.deserialize_i32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i32 (V := V);
      serde.de.Deserializer.deserialize_i64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_i64 (V := V);
      serde.de.Deserializer.deserialize_i128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_i128 (V := V));
      serde.de.Deserializer.deserialize_u8
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u8 (V := V);
      serde.de.Deserializer.deserialize_u16
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u16 (V := V);
      serde.de.Deserializer.deserialize_u32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u32 (V := V);
      serde.de.Deserializer.deserialize_u64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_u64 (V := V);
      serde.de.Deserializer.deserialize_u128
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        Datatypes.Some (deserialize_u128 (V := V));
      serde.de.Deserializer.deserialize_f32
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f32 (V := V);
      serde.de.Deserializer.deserialize_f64
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_f64 (V := V);
      serde.de.Deserializer.deserialize_string
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_string (V := V);
      serde.de.Deserializer.deserialize_byte_buf
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_byte_buf (V := V);
      serde.de.Deserializer.deserialize_char
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_char (V := V);
      serde.de.Deserializer.deserialize_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_any (V := V);
      serde.de.Deserializer.deserialize_str
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_str (V := V);
      serde.de.Deserializer.deserialize_bytes
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_bytes (V := V);
      serde.de.Deserializer.deserialize_option
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_option (V := V);
      serde.de.Deserializer.deserialize_unit
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit (V := V);
      serde.de.Deserializer.deserialize_unit_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_unit_struct (V := V);
      serde.de.Deserializer.deserialize_newtype_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_newtype_struct (V := V);
      serde.de.Deserializer.deserialize_tuple
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple (V := V);
      serde.de.Deserializer.deserialize_seq
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_seq (V := V);
      serde.de.Deserializer.deserialize_tuple_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_tuple_struct (V := V);
      serde.de.Deserializer.deserialize_struct
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_struct (V := V);
      serde.de.Deserializer.deserialize_enum
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_enum (V := V);
      serde.de.Deserializer.deserialize_ignored_any
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        deserialize_ignored_any (V := V);
      serde.de.Deserializer.is_human_readable := Datatypes.None;
      serde.de.Deserializer.__deserialize_content := Datatypes.None;
    }.
  End Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
  End Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
  
  Module  EnumDeserializer.
  Section EnumDeserializer.
    Record t : Set := {
      value : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
    }.
    
    Definition Get_value :=
      Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  End EnumDeserializer.
  End EnumDeserializer.
  
  Module  Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
  Section Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
    Definition Self : Set := axum.extract.path.de.EnumDeserializer.t.
    
    (*
        type Error = PathDeserializationError;
    *)
    Definition Error : Set := axum.extract.path.PathDeserializationError.t.
    
    (*
        type Variant = UnitVariant;
    *)
    Definition Variant : Set := axum.extract.path.de.UnitVariant.t.
    
    (*
        fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>
        where
            V: de::DeserializeSeed<'de>,
        {
            Ok((
                seed.deserialize(KeyDeserializer { key: self.value })?,
                UnitVariant,
            ))
        }
    *)
    Definition variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V}
        (self : Self)
        (seed : V)
        : M (core.result.Result.t (V::type["Value"].t * Variant) Error) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
      Notations.DoubleColon Self "variant_seed" := {
      Notations.double_colon := variant_seed (V := V);
    }.
    
    Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
      serde.de.EnumAccess.Error := Error;
      serde.de.EnumAccess.Variant := Variant;
      serde.de.EnumAccess.variant_seed
        {V : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
        variant_seed (V := V);
      serde.de.EnumAccess.variant := Datatypes.None;
    }.
  End Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
  End Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
  
  Module  UnitVariant.
  Section UnitVariant.
    Inductive t : Set := Build.
  End UnitVariant.
  End UnitVariant.
  
  Module  Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
  Section Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
    Definition Self : Set := axum.extract.path.de.UnitVariant.t.
    
    (*
        type Error = PathDeserializationError;
    *)
    Definition Error : Set := axum.extract.path.PathDeserializationError.t.
    
    (*
        fn unit_variant(self) -> Result<(), Self::Error> {
            Ok(())
        }
    *)
    Definition unit_variant
        (self : Self)
        : M (core.result.Result.t unit Error) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_unit_variant :
      Notations.DoubleColon Self "unit_variant" := {
      Notations.double_colon := unit_variant;
    }.
    
    (*
        fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>
        where
            T: DeserializeSeed<'de>,
        {
            Err(PathDeserializationError::unsupported_type(
                "newtype enum variant",
            ))
        }
    *)
    Definition newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : Self)
        (_seed : T)
        : M (core.result.Result.t T::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _seed := M.alloc _seed in
      M.read foo.
    
    Global Instance AssociatedFunction_newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "newtype_variant_seed" := {
      Notations.double_colon := newtype_variant_seed (T := T);
    }.
    
    (*
        fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            Err(PathDeserializationError::unsupported_type(
                "tuple enum variant",
            ))
        }
    *)
    Definition tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_len : usize.t)
        (_visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _len := M.alloc _len in
      let* _visitor := M.alloc _visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "tuple_variant" := {
      Notations.double_colon := tuple_variant (V := V);
    }.
    
    (*
        fn struct_variant<V>(
            self,
            _fields: &'static [&'static str],
            _visitor: V,
        ) -> Result<V::Value, Self::Error>
        where
            V: Visitor<'de>,
        {
            Err(PathDeserializationError::unsupported_type(
                "struct enum variant",
            ))
        }
    *)
    Definition struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V}
        (self : Self)
        (_fields : ref (slice (ref str.t)))
        (_visitor : V)
        : M (core.result.Result.t V::type["Value"].t Error) :=
      let* self := M.alloc self in
      let* _fields := M.alloc _fields in
      let* _visitor := M.alloc _visitor in
      M.read foo.
    
    Global Instance AssociatedFunction_struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :
      Notations.DoubleColon Self "struct_variant" := {
      Notations.double_colon := struct_variant (V := V);
    }.
    
    Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
      serde.de.VariantAccess.Error := Error;
      serde.de.VariantAccess.unit_variant := unit_variant;
      serde.de.VariantAccess.newtype_variant_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        newtype_variant_seed (T := T);
      serde.de.VariantAccess.tuple_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        tuple_variant (V := V);
      serde.de.VariantAccess.struct_variant
        {V : Set}
        {ℋ_0 : serde.de.Visitor.Trait V} :=
        struct_variant (V := V);
      serde.de.VariantAccess.newtype_variant := Datatypes.None;
    }.
  End Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
  End Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
  
  Module  SeqDeserializer.
  Section SeqDeserializer.
    Record t : Set := {
      params :
        ref
          (slice
            ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
            *
            axum.util.PercentDecodedStr.t));
      idx : usize.t;
    }.
    
    Definition Get_params :=
      Ref.map
        (fun α => Some α.(params))
        (fun β α => Some (α <| params := β |>)).
    Definition Get_idx :=
      Ref.map (fun α => Some α.(idx)) (fun β α => Some (α <| idx := β |>)).
  End SeqDeserializer.
  End SeqDeserializer.
  
  Module  Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
  Section Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
    Definition Self : Set := axum.extract.path.de.SeqDeserializer.t.
    
    (*
        type Error = PathDeserializationError;
    *)
    Definition Error : Set := axum.extract.path.PathDeserializationError.t.
    
    (*
        fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
        where
            T: DeserializeSeed<'de>,
        {
            match self.params.split_first() {
                Some(((key, value), tail)) => {
                    self.params = tail;
                    let idx = self.idx;
                    self.idx += 1;
                    Ok(Some(seed.deserialize(ValueDeserializer {
                        key: Some(KeyOrIdx::Idx {
                            idx,
                            key: key.clone(),
                        }),
                        value,
                    })?))
                }
                None => Ok(None),
            }
        }
    *)
    Definition next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T}
        (self : mut_ref Self)
        (seed : T)
        :
          M
            (core.result.Result.t
              (core.option.Option.t T::type["Value"].t)
              Error) :=
      let* self := M.alloc self in
      let* seed := M.alloc seed in
      M.read foo.
    
    Global Instance AssociatedFunction_next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
      Notations.DoubleColon Self "next_element_seed" := {
      Notations.double_colon := next_element_seed (T := T);
    }.
    
    Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
      serde.de.SeqAccess.Error := Error;
      serde.de.SeqAccess.next_element_seed
        {T : Set}
        {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
        next_element_seed (T := T);
      serde.de.SeqAccess.next_element := Datatypes.None;
      serde.de.SeqAccess.size_hint := Datatypes.None;
    }.
  End Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
  End Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
  
  Module KeyOrIdx.
    Module Idx.
      Record t : Set := {
        idx : usize.t;
        key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
      }.
    End Idx.
    
    Inductive t : Set :=
    | Key (_ : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
    | Idx (_ : Idx.t).
    
    Definition Get_Key_0 :=
      Ref.map
        (fun α => match α with | Key α0 => Some α0 | _ => None end)
        (fun β α => match α with | Key _ => Some (Key β) | _ => None end).
    
    Definition Get_Idx_idx :=
      Ref.map
        (fun α => match α with | Idx α => Some α.(Idx.idx) | _ => None end)
        (fun β α =>
          match α with
          | Idx α => Some (Idx (α <| Idx.idx := β |>))
          | _ => None
          end).
    
    Definition Get_Idx_key :=
      Ref.map
        (fun α => match α with | Idx α => Some α.(Idx.key) | _ => None end)
        (fun β α =>
          match α with
          | Idx α => Some (Idx (α <| Idx.key := β |>))
          | _ => None
          end).
  End KeyOrIdx.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
  Section Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
    Definition Self : Set := axum.extract.path.de.KeyOrIdx.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
  End Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
  
  Module  Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
  Section Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
    Definition Self : Set := axum.extract.path.de.KeyOrIdx.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum.extract.path.de.KeyOrIdx.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
  End Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
End de.

Module  PathDeserializer.
Section PathDeserializer.
  Record t : Set := {
    url_params :
      ref
        (slice
          ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
          *
          axum.util.PercentDecodedStr.t));
  }.
  
  Definition Get_url_params :=
    Ref.map
      (fun α => Some α.(url_params))
      (fun β α => Some (α <| url_params := β |>)).
End PathDeserializer.
End PathDeserializer.

Module  Impl_axum_extract_path_de_PathDeserializer_t_4.
Section Impl_axum_extract_path_de_PathDeserializer_t_4.
  Definition Self : Set := axum.extract.path.de.PathDeserializer.t.
  
  (*
      pub(crate) fn new(url_params: &'de [(Arc<str>, PercentDecodedStr)]) -> Self {
          PathDeserializer { url_params }
      }
  *)
  Definition new
      (url_params
        :
        ref
          (slice
            ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
            *
            axum.util.PercentDecodedStr.t)))
      : M Self :=
    let* url_params := M.alloc url_params in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_axum_extract_path_de_PathDeserializer_t_4.
End Impl_axum_extract_path_de_PathDeserializer_t_4.

Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
Section Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
  Definition Self : Set := axum.extract.path.de.PathDeserializer.t.
  
  (*
      type Error = PathDeserializationError;
  *)
  Definition Error : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
          fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::unsupported_type(type_name::<
                  V::Value,
              >()))
          }
  *)
  Definition deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (Pattern : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bytes" := {
    Notations.double_colon := deserialize_bytes (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::unsupported_type(type_name::<
                  V::Value,
              >()))
          }
  *)
  Definition deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (Pattern : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_option" := {
    Notations.double_colon := deserialize_option (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::unsupported_type(type_name::<
                  V::Value,
              >()))
          }
  *)
  Definition deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (Pattern : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_identifier" := {
    Notations.double_colon := deserialize_identifier (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::unsupported_type(type_name::<
                  V::Value,
              >()))
          }
  *)
  Definition deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (Pattern : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_ignored_any" := {
    Notations.double_colon := deserialize_ignored_any (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bool" := {
    Notations.double_colon := deserialize_bool (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i8" := {
    Notations.double_colon := deserialize_i8 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i16" := {
    Notations.double_colon := deserialize_i16 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i32" := {
    Notations.double_colon := deserialize_i32 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i64" := {
    Notations.double_colon := deserialize_i64 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i128" := {
    Notations.double_colon := deserialize_i128 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u8" := {
    Notations.double_colon := deserialize_u8 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u16" := {
    Notations.double_colon := deserialize_u16 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u32" := {
    Notations.double_colon := deserialize_u32 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u64" := {
    Notations.double_colon := deserialize_u64 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u128" := {
    Notations.double_colon := deserialize_u128 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f32" := {
    Notations.double_colon := deserialize_f32 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f64" := {
    Notations.double_colon := deserialize_f64 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_string" := {
    Notations.double_colon := deserialize_string (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_byte_buf" := {
    Notations.double_colon := deserialize_byte_buf (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              if self.url_params.len() != 1 {
                  return Err(PathDeserializationError::wrong_number_of_parameters()
                      .got(self.url_params.len())
                      .expected(1));
              }
  
              let value = self.url_params[0].1.parse().map_err(|_| {
                  PathDeserializationError::new(ErrorKind::ParseError {
                      value: self.url_params[0].1.as_str().to_owned(),
                      expected_type: $ty,
                  })
              })?;
              visitor.$visit_fn(value)
          }
  *)
  Definition deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_char" := {
    Notations.double_colon := deserialize_char (V := V);
  }.
  
  (*
      fn deserialize_any<V>(self, v: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_str(v)
      }
  *)
  Definition deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (v : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_any" := {
    Notations.double_colon := deserialize_any (V := V);
  }.
  
  (*
      fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          if self.url_params.len() != 1 {
              return Err(PathDeserializationError::wrong_number_of_parameters()
                  .got(self.url_params.len())
                  .expected(1));
          }
          visitor.visit_borrowed_str(&self.url_params[0].1)
      }
  *)
  Definition deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_str" := {
    Notations.double_colon := deserialize_str (V := V);
  }.
  
  (*
      fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_unit()
      }
  *)
  Definition deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit" := {
    Notations.double_colon := deserialize_unit (V := V);
  }.
  
  (*
      fn deserialize_unit_struct<V>(
          self,
          _name: &'static str,
          visitor: V,
      ) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_unit()
      }
  *)
  Definition deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit_struct" := {
    Notations.double_colon := deserialize_unit_struct (V := V);
  }.
  
  (*
      fn deserialize_newtype_struct<V>(
          self,
          _name: &'static str,
          visitor: V,
      ) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_newtype_struct(self)
      }
  *)
  Definition deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_newtype_struct" := {
    Notations.double_colon := deserialize_newtype_struct (V := V);
  }.
  
  (*
      fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_seq(SeqDeserializer {
              params: self.url_params,
              idx: 0,
          })
      }
  *)
  Definition deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_seq" := {
    Notations.double_colon := deserialize_seq (V := V);
  }.
  
  (*
      fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          if self.url_params.len() < len {
              return Err(PathDeserializationError::wrong_number_of_parameters()
                  .got(self.url_params.len())
                  .expected(len));
          }
          visitor.visit_seq(SeqDeserializer {
              params: self.url_params,
              idx: 0,
          })
      }
  *)
  Definition deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple" := {
    Notations.double_colon := deserialize_tuple (V := V);
  }.
  
  (*
      fn deserialize_tuple_struct<V>(
          self,
          _name: &'static str,
          len: usize,
          visitor: V,
      ) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          if self.url_params.len() < len {
              return Err(PathDeserializationError::wrong_number_of_parameters()
                  .got(self.url_params.len())
                  .expected(len));
          }
          visitor.visit_seq(SeqDeserializer {
              params: self.url_params,
              idx: 0,
          })
      }
  *)
  Definition deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple_struct" := {
    Notations.double_colon := deserialize_tuple_struct (V := V);
  }.
  
  (*
      fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_map(MapDeserializer {
              params: self.url_params,
              value: None,
              key: None,
          })
      }
  *)
  Definition deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_map" := {
    Notations.double_colon := deserialize_map (V := V);
  }.
  
  (*
      fn deserialize_struct<V>(
          self,
          _name: &'static str,
          _fields: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_map(visitor)
      }
  *)
  Definition deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_fields : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _fields := M.alloc _fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_struct" := {
    Notations.double_colon := deserialize_struct (V := V);
  }.
  
  (*
      fn deserialize_enum<V>(
          self,
          _name: &'static str,
          _variants: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          if self.url_params.len() != 1 {
              return Err(PathDeserializationError::wrong_number_of_parameters()
                  .got(self.url_params.len())
                  .expected(1));
          }
  
          visitor.visit_enum(EnumDeserializer {
              value: self.url_params[0].1.clone().into_inner(),
          })
      }
  *)
  Definition deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_variants : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variants := M.alloc _variants in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_enum" := {
    Notations.double_colon := deserialize_enum (V := V);
  }.
  
  Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
    serde.de.Deserializer.Error := Error;
    serde.de.Deserializer.deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bytes (V := V);
    serde.de.Deserializer.deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_option (V := V);
    serde.de.Deserializer.deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_identifier (V := V);
    serde.de.Deserializer.deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_ignored_any (V := V);
    serde.de.Deserializer.deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bool (V := V);
    serde.de.Deserializer.deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i8 (V := V);
    serde.de.Deserializer.deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i16 (V := V);
    serde.de.Deserializer.deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i32 (V := V);
    serde.de.Deserializer.deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i64 (V := V);
    serde.de.Deserializer.deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_i128 (V := V));
    serde.de.Deserializer.deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u8 (V := V);
    serde.de.Deserializer.deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u16 (V := V);
    serde.de.Deserializer.deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u32 (V := V);
    serde.de.Deserializer.deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u64 (V := V);
    serde.de.Deserializer.deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_u128 (V := V));
    serde.de.Deserializer.deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f32 (V := V);
    serde.de.Deserializer.deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f64 (V := V);
    serde.de.Deserializer.deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_string (V := V);
    serde.de.Deserializer.deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_byte_buf (V := V);
    serde.de.Deserializer.deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_char (V := V);
    serde.de.Deserializer.deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_any (V := V);
    serde.de.Deserializer.deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_str (V := V);
    serde.de.Deserializer.deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit (V := V);
    serde.de.Deserializer.deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit_struct (V := V);
    serde.de.Deserializer.deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_newtype_struct (V := V);
    serde.de.Deserializer.deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_seq (V := V);
    serde.de.Deserializer.deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple (V := V);
    serde.de.Deserializer.deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple_struct (V := V);
    serde.de.Deserializer.deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_map (V := V);
    serde.de.Deserializer.deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_struct (V := V);
    serde.de.Deserializer.deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_enum (V := V);
    serde.de.Deserializer.is_human_readable := Datatypes.None;
    serde.de.Deserializer.__deserialize_content := Datatypes.None;
  }.
End Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.
End Impl_serde_de_Deserializer_for_axum_extract_path_de_PathDeserializer_t.

Module  MapDeserializer.
Section MapDeserializer.
  Record t : Set := {
    params :
      ref
        (slice
          ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
          *
          axum.util.PercentDecodedStr.t));
    key : core.option.Option.t axum.extract.path.de.KeyOrIdx.t;
    value : core.option.Option.t (ref axum.util.PercentDecodedStr.t);
  }.
  
  Definition Get_params :=
    Ref.map (fun α => Some α.(params)) (fun β α => Some (α <| params := β |>)).
  Definition Get_key :=
    Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End MapDeserializer.
End MapDeserializer.

Module  Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
Section Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
  Definition Self : Set := axum.extract.path.de.MapDeserializer.t.
  
  (*
      type Error = PathDeserializationError;
  *)
  Definition Error : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
      fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>
      where
          K: DeserializeSeed<'de>,
      {
          match self.params.split_first() {
              Some(((key, value), tail)) => {
                  self.value = Some(value);
                  self.params = tail;
                  self.key = Some(KeyOrIdx::Key(key.clone()));
                  seed.deserialize(KeyDeserializer {
                      key: Arc::clone(key),
                  })
                  .map(Some)
              }
              None => Ok(None),
          }
      }
  *)
  Definition next_key_seed
      {K : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait K}
      (self : mut_ref Self)
      (seed : K)
      :
        M
          (core.result.Result.t
            (core.option.Option.t K::type["Value"].t)
            Error) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_key_seed
      {K : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait K} :
    Notations.DoubleColon Self "next_key_seed" := {
    Notations.double_colon := next_key_seed (K := K);
  }.
  
  (*
      fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>
      where
          V: DeserializeSeed<'de>,
      {
          match self.value.take() {
              Some(value) => seed.deserialize(ValueDeserializer {
                  key: self.key.take(),
                  value,
              }),
              None => Err(PathDeserializationError::custom("value is missing")),
          }
      }
  *)
  Definition next_value_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V}
      (self : mut_ref Self)
      (seed : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_value_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
    Notations.DoubleColon Self "next_value_seed" := {
    Notations.double_colon := next_value_seed (V := V);
  }.
  
  Global Instance ℐ : serde.de.MapAccess.Required.Trait Self := {
    serde.de.MapAccess.Error := Error;
    serde.de.MapAccess.next_key_seed
      {K : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait K} :=
      next_key_seed (K := K);
    serde.de.MapAccess.next_value_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
      next_value_seed (V := V);
    serde.de.MapAccess.next_entry_seed := Datatypes.None;
    serde.de.MapAccess.next_key := Datatypes.None;
    serde.de.MapAccess.next_value := Datatypes.None;
    serde.de.MapAccess.next_entry := Datatypes.None;
    serde.de.MapAccess.size_hint := Datatypes.None;
  }.
End Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.
End Impl_serde_de_MapAccess_for_axum_extract_path_de_MapDeserializer_t.

Module  KeyDeserializer.
Section KeyDeserializer.
  Record t : Set := {
    key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
  }.
  
  Definition Get_key :=
    Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
End KeyDeserializer.
End KeyDeserializer.

Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
Section Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
  Definition Self : Set := axum.extract.path.de.KeyDeserializer.t.
  
  (*
      type Error = PathDeserializationError;
  *)
  Definition Error : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_str(&self.key)
          }
  *)
  Definition deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_identifier" := {
    Notations.double_colon := deserialize_identifier (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_str(&self.key)
          }
  *)
  Definition deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_str" := {
    Notations.double_colon := deserialize_str (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              visitor.visit_str(&self.key)
          }
  *)
  Definition deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_string" := {
    Notations.double_colon := deserialize_string (V := V);
  }.
  
  (*
      fn deserialize_any<V>(self, _visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          Err(PathDeserializationError::custom("Unexpected key type"))
      }
  *)
  Definition deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _visitor := M.alloc _visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_any" := {
    Notations.double_colon := deserialize_any (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bool" := {
    Notations.double_colon := deserialize_bool (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i8" := {
    Notations.double_colon := deserialize_i8 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i16" := {
    Notations.double_colon := deserialize_i16 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i32" := {
    Notations.double_colon := deserialize_i32 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i64" := {
    Notations.double_colon := deserialize_i64 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i128" := {
    Notations.double_colon := deserialize_i128 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u8" := {
    Notations.double_colon := deserialize_u8 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u16" := {
    Notations.double_colon := deserialize_u16 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u32" := {
    Notations.double_colon := deserialize_u32 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u64" := {
    Notations.double_colon := deserialize_u64 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u128" := {
    Notations.double_colon := deserialize_u128 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f32" := {
    Notations.double_colon := deserialize_f32 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f64" := {
    Notations.double_colon := deserialize_f64 (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_char" := {
    Notations.double_colon := deserialize_char (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bytes" := {
    Notations.double_colon := deserialize_bytes (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_byte_buf" := {
    Notations.double_colon := deserialize_byte_buf (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_option" := {
    Notations.double_colon := deserialize_option (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit" := {
    Notations.double_colon := deserialize_unit (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit_struct" := {
    Notations.double_colon := deserialize_unit_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_seq" := {
    Notations.double_colon := deserialize_seq (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple" := {
    Notations.double_colon := deserialize_tuple (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple_struct" := {
    Notations.double_colon := deserialize_tuple_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_map" := {
    Notations.double_colon := deserialize_map (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_newtype_struct" := {
    Notations.double_colon := deserialize_newtype_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (fields : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* fields := M.alloc fields in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_struct" := {
    Notations.double_colon := deserialize_struct (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (name : ref str.t)
      (variants : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* variants := M.alloc variants in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_enum" := {
    Notations.double_colon := deserialize_enum (V := V);
  }.
  
  (*
          fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, Self::Error>
          where
              $v: $crate::de::Visitor<$l>,
          {
              $(
                  let _ = $arg;
              )*
              self.deserialize_any(visitor)
          }
  *)
  Definition deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_ignored_any" := {
    Notations.double_colon := deserialize_ignored_any (V := V);
  }.
  
  Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
    serde.de.Deserializer.Error := Error;
    serde.de.Deserializer.deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_identifier (V := V);
    serde.de.Deserializer.deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_str (V := V);
    serde.de.Deserializer.deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_string (V := V);
    serde.de.Deserializer.deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_any (V := V);
    serde.de.Deserializer.deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bool (V := V);
    serde.de.Deserializer.deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i8 (V := V);
    serde.de.Deserializer.deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i16 (V := V);
    serde.de.Deserializer.deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i32 (V := V);
    serde.de.Deserializer.deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i64 (V := V);
    serde.de.Deserializer.deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_i128 (V := V));
    serde.de.Deserializer.deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u8 (V := V);
    serde.de.Deserializer.deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u16 (V := V);
    serde.de.Deserializer.deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u32 (V := V);
    serde.de.Deserializer.deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u64 (V := V);
    serde.de.Deserializer.deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_u128 (V := V));
    serde.de.Deserializer.deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f32 (V := V);
    serde.de.Deserializer.deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f64 (V := V);
    serde.de.Deserializer.deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_char (V := V);
    serde.de.Deserializer.deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bytes (V := V);
    serde.de.Deserializer.deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_byte_buf (V := V);
    serde.de.Deserializer.deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_option (V := V);
    serde.de.Deserializer.deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit (V := V);
    serde.de.Deserializer.deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit_struct (V := V);
    serde.de.Deserializer.deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_seq (V := V);
    serde.de.Deserializer.deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple (V := V);
    serde.de.Deserializer.deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple_struct (V := V);
    serde.de.Deserializer.deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_map (V := V);
    serde.de.Deserializer.deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_newtype_struct (V := V);
    serde.de.Deserializer.deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_struct (V := V);
    serde.de.Deserializer.deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_enum (V := V);
    serde.de.Deserializer.deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_ignored_any (V := V);
    serde.de.Deserializer.is_human_readable := Datatypes.None;
    serde.de.Deserializer.__deserialize_content := Datatypes.None;
  }.
End Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.
End Impl_serde_de_Deserializer_for_axum_extract_path_de_KeyDeserializer_t.

Module  ValueDeserializer.
Section ValueDeserializer.
  Record t : Set := {
    key : core.option.Option.t axum.extract.path.de.KeyOrIdx.t;
    value : ref axum.util.PercentDecodedStr.t;
  }.
  
  Definition Get_key :=
    Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End ValueDeserializer.
End ValueDeserializer.

Module  Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
Section Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
  Definition Self : Set := axum.extract.path.de.ValueDeserializer.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.
End Impl_core_fmt_Debug_for_axum_extract_path_de_ValueDeserializer_t.

Module  Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
Section Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
  Definition Self : Set := axum.extract.path.de.ValueDeserializer.t.
  
  (*
      type Error = PathDeserializationError;
  *)
  Definition Error : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
          fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::unsupported_type(type_name::<
                  V::Value,
              >()))
          }
  *)
  Definition deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (Pattern : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_map" := {
    Notations.double_colon := deserialize_map (V := V);
  }.
  
  (*
          fn $trait_fn<V>(self, _: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              Err(PathDeserializationError::unsupported_type(type_name::<
                  V::Value,
              >()))
          }
  *)
  Definition deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (Pattern : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_identifier" := {
    Notations.double_colon := deserialize_identifier (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bool" := {
    Notations.double_colon := deserialize_bool (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i8" := {
    Notations.double_colon := deserialize_i8 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i16" := {
    Notations.double_colon := deserialize_i16 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i32" := {
    Notations.double_colon := deserialize_i32 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i64" := {
    Notations.double_colon := deserialize_i64 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_i128" := {
    Notations.double_colon := deserialize_i128 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u8" := {
    Notations.double_colon := deserialize_u8 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u16" := {
    Notations.double_colon := deserialize_u16 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u32" := {
    Notations.double_colon := deserialize_u32 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u64" := {
    Notations.double_colon := deserialize_u64 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_u128" := {
    Notations.double_colon := deserialize_u128 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f32" := {
    Notations.double_colon := deserialize_f32 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_f64" := {
    Notations.double_colon := deserialize_f64 (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_string" := {
    Notations.double_colon := deserialize_string (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_byte_buf" := {
    Notations.double_colon := deserialize_byte_buf (V := V);
  }.
  
  (*
          fn $trait_fn<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>
          where
              V: Visitor<'de>,
          {
              let v = self.value.parse().map_err(|_| {
                  if let Some(key) = self.key.take() {
                      let kind = match key {
                          KeyOrIdx::Key(key) => ErrorKind::ParseErrorAtKey {
                              key: key.to_string(),
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                          KeyOrIdx::Idx { idx: index, key: _ } => ErrorKind::ParseErrorAtIndex {
                              index,
                              value: self.value.as_str().to_owned(),
                              expected_type: $ty,
                          },
                      };
                      PathDeserializationError::new(kind)
                  } else {
                      PathDeserializationError::new(ErrorKind::ParseError {
                          value: self.value.as_str().to_owned(),
                          expected_type: $ty,
                      })
                  }
              })?;
              visitor.$visit_fn(v)
          }
  *)
  Definition deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_char" := {
    Notations.double_colon := deserialize_char (V := V);
  }.
  
  (*
      fn deserialize_any<V>(self, v: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          self.deserialize_str(v)
      }
  *)
  Definition deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (v : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* v := M.alloc v in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_any" := {
    Notations.double_colon := deserialize_any (V := V);
  }.
  
  (*
      fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_borrowed_str(self.value)
      }
  *)
  Definition deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_str" := {
    Notations.double_colon := deserialize_str (V := V);
  }.
  
  (*
      fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_borrowed_bytes(self.value.as_bytes())
      }
  *)
  Definition deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_bytes" := {
    Notations.double_colon := deserialize_bytes (V := V);
  }.
  
  (*
      fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_some(self)
      }
  *)
  Definition deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_option" := {
    Notations.double_colon := deserialize_option (V := V);
  }.
  
  (*
      fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_unit()
      }
  *)
  Definition deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit" := {
    Notations.double_colon := deserialize_unit (V := V);
  }.
  
  (*
      fn deserialize_unit_struct<V>(
          self,
          _name: &'static str,
          visitor: V,
      ) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_unit()
      }
  *)
  Definition deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_unit_struct" := {
    Notations.double_colon := deserialize_unit_struct (V := V);
  }.
  
  (*
      fn deserialize_newtype_struct<V>(
          self,
          _name: &'static str,
          visitor: V,
      ) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_newtype_struct(self)
      }
  *)
  Definition deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_newtype_struct" := {
    Notations.double_colon := deserialize_newtype_struct (V := V);
  }.
  
  (*
      fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          struct PairDeserializer<'de> {
              key: Option<KeyOrIdx>,
              value: Option<&'de PercentDecodedStr>,
          }
  
          impl<'de> SeqAccess<'de> for PairDeserializer<'de> {
              type Error = PathDeserializationError;
  
              fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
              where
                  T: DeserializeSeed<'de>,
              {
                  match self.key.take() {
                      Some(KeyOrIdx::Idx { idx: _, key }) => {
                          return seed.deserialize(KeyDeserializer { key }).map(Some);
                      }
                      // `KeyOrIdx::Key` is only used when deserializing maps so `deserialize_seq`
                      // wouldn't be called for that
                      Some(KeyOrIdx::Key(_)) => unreachable!(),
                      None => {}
                  };
  
                  self.value
                      .take()
                      .map(|value| seed.deserialize(ValueDeserializer { key: None, value }))
                      .transpose()
              }
          }
  
          if len == 2 {
              match self.key {
                  Some(key) => visitor.visit_seq(PairDeserializer {
                      key: Some(key),
                      value: Some(self.value),
                  }),
                  // `self.key` is only `None` when deserializing maps so `deserialize_seq`
                  // wouldn't be called for that
                  None => unreachable!(),
              }
          } else {
              Err(PathDeserializationError::unsupported_type(type_name::<
                  V::Value,
              >()))
          }
      }
  *)
  Definition deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (len : usize.t)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* len := M.alloc len in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple" := {
    Notations.double_colon := deserialize_tuple (V := V);
  }.
  
  (*
      fn deserialize_seq<V>(self, _visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          Err(PathDeserializationError::unsupported_type(type_name::<
              V::Value,
          >()))
      }
  *)
  Definition deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _visitor := M.alloc _visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_seq" := {
    Notations.double_colon := deserialize_seq (V := V);
  }.
  
  (*
      fn deserialize_tuple_struct<V>(
          self,
          _name: &'static str,
          _len: usize,
          _visitor: V,
      ) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          Err(PathDeserializationError::unsupported_type(type_name::<
              V::Value,
          >()))
      }
  *)
  Definition deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_len : usize.t)
      (_visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _len := M.alloc _len in
    let* _visitor := M.alloc _visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_tuple_struct" := {
    Notations.double_colon := deserialize_tuple_struct (V := V);
  }.
  
  (*
      fn deserialize_struct<V>(
          self,
          _name: &'static str,
          _fields: &'static [&'static str],
          _visitor: V,
      ) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          Err(PathDeserializationError::unsupported_type(type_name::<
              V::Value,
          >()))
      }
  *)
  Definition deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_fields : ref (slice (ref str.t)))
      (_visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _fields := M.alloc _fields in
    let* _visitor := M.alloc _visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_struct" := {
    Notations.double_colon := deserialize_struct (V := V);
  }.
  
  (*
      fn deserialize_enum<V>(
          self,
          _name: &'static str,
          _variants: &'static [&'static str],
          visitor: V,
      ) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_enum(EnumDeserializer {
              value: self.value.clone().into_inner(),
          })
      }
  *)
  Definition deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_name : ref str.t)
      (_variants : ref (slice (ref str.t)))
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _name := M.alloc _name in
    let* _variants := M.alloc _variants in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_enum" := {
    Notations.double_colon := deserialize_enum (V := V);
  }.
  
  (*
      fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          visitor.visit_unit()
      }
  *)
  Definition deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* visitor := M.alloc visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "deserialize_ignored_any" := {
    Notations.double_colon := deserialize_ignored_any (V := V);
  }.
  
  Global Instance ℐ : serde.de.Deserializer.Required.Trait Self := {
    serde.de.Deserializer.Error := Error;
    serde.de.Deserializer.deserialize_map
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_map (V := V);
    serde.de.Deserializer.deserialize_identifier
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_identifier (V := V);
    serde.de.Deserializer.deserialize_bool
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bool (V := V);
    serde.de.Deserializer.deserialize_i8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i8 (V := V);
    serde.de.Deserializer.deserialize_i16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i16 (V := V);
    serde.de.Deserializer.deserialize_i32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i32 (V := V);
    serde.de.Deserializer.deserialize_i64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_i64 (V := V);
    serde.de.Deserializer.deserialize_i128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_i128 (V := V));
    serde.de.Deserializer.deserialize_u8
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u8 (V := V);
    serde.de.Deserializer.deserialize_u16
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u16 (V := V);
    serde.de.Deserializer.deserialize_u32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u32 (V := V);
    serde.de.Deserializer.deserialize_u64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_u64 (V := V);
    serde.de.Deserializer.deserialize_u128
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      Datatypes.Some (deserialize_u128 (V := V));
    serde.de.Deserializer.deserialize_f32
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f32 (V := V);
    serde.de.Deserializer.deserialize_f64
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_f64 (V := V);
    serde.de.Deserializer.deserialize_string
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_string (V := V);
    serde.de.Deserializer.deserialize_byte_buf
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_byte_buf (V := V);
    serde.de.Deserializer.deserialize_char
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_char (V := V);
    serde.de.Deserializer.deserialize_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_any (V := V);
    serde.de.Deserializer.deserialize_str
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_str (V := V);
    serde.de.Deserializer.deserialize_bytes
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_bytes (V := V);
    serde.de.Deserializer.deserialize_option
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_option (V := V);
    serde.de.Deserializer.deserialize_unit
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit (V := V);
    serde.de.Deserializer.deserialize_unit_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_unit_struct (V := V);
    serde.de.Deserializer.deserialize_newtype_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_newtype_struct (V := V);
    serde.de.Deserializer.deserialize_tuple
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple (V := V);
    serde.de.Deserializer.deserialize_seq
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_seq (V := V);
    serde.de.Deserializer.deserialize_tuple_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_tuple_struct (V := V);
    serde.de.Deserializer.deserialize_struct
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_struct (V := V);
    serde.de.Deserializer.deserialize_enum
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_enum (V := V);
    serde.de.Deserializer.deserialize_ignored_any
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      deserialize_ignored_any (V := V);
    serde.de.Deserializer.is_human_readable := Datatypes.None;
    serde.de.Deserializer.__deserialize_content := Datatypes.None;
  }.
End Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.
End Impl_serde_de_Deserializer_for_axum_extract_path_de_ValueDeserializer_t.

Module  PairDeserializer.
Section PairDeserializer.
  Record t : Set := {
    key : core.option.Option.t axum.extract.path.de.KeyOrIdx.t;
    value : core.option.Option.t (ref axum.util.PercentDecodedStr.t);
  }.
  
  Definition Get_key :=
    Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End PairDeserializer.
End PairDeserializer.

Module  Impl_serde_de_SeqAccess_for_axum_extract_path_de_deserialize_tuple_PairDeserializer_t.
Section Impl_serde_de_SeqAccess_for_axum_extract_path_de_deserialize_tuple_PairDeserializer_t.
  Definition Self : Set :=
    axum.extract.path.de.deserialize_tuple.PairDeserializer.t.
  
  (*
              type Error = PathDeserializationError;
  *)
  Definition Error : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
              fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
              where
                  T: DeserializeSeed<'de>,
              {
                  match self.key.take() {
                      Some(KeyOrIdx::Idx { idx: _, key }) => {
                          return seed.deserialize(KeyDeserializer { key }).map(Some);
                      }
                      // `KeyOrIdx::Key` is only used when deserializing maps so `deserialize_seq`
                      // wouldn't be called for that
                      Some(KeyOrIdx::Key(_)) => unreachable!(),
                      None => {}
                  };
  
                  self.value
                      .take()
                      .map(|value| seed.deserialize(ValueDeserializer { key: None, value }))
                      .transpose()
              }
  *)
  Definition next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : mut_ref Self)
      (seed : T)
      :
        M
          (core.result.Result.t
            (core.option.Option.t T::type["Value"].t)
            Error) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "next_element_seed" := {
    Notations.double_colon := next_element_seed (T := T);
  }.
  
  Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
    serde.de.SeqAccess.Error := Error;
    serde.de.SeqAccess.next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      next_element_seed (T := T);
    serde.de.SeqAccess.next_element := Datatypes.None;
    serde.de.SeqAccess.size_hint := Datatypes.None;
  }.
End Impl_serde_de_SeqAccess_for_axum_extract_path_de_deserialize_tuple_PairDeserializer_t.
End Impl_serde_de_SeqAccess_for_axum_extract_path_de_deserialize_tuple_PairDeserializer_t.

Module  EnumDeserializer.
Section EnumDeserializer.
  Record t : Set := {
    value : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
  }.
  
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
End EnumDeserializer.
End EnumDeserializer.

Module  Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
Section Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
  Definition Self : Set := axum.extract.path.de.EnumDeserializer.t.
  
  (*
      type Error = PathDeserializationError;
  *)
  Definition Error : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
      type Variant = UnitVariant;
  *)
  Definition Variant : Set := axum.extract.path.de.UnitVariant.t.
  
  (*
      fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>
      where
          V: de::DeserializeSeed<'de>,
      {
          Ok((
              seed.deserialize(KeyDeserializer { key: self.value })?,
              UnitVariant,
          ))
      }
  *)
  Definition variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V}
      (self : Self)
      (seed : V)
      : M (core.result.Result.t (V::type["Value"].t * Variant) Error) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :
    Notations.DoubleColon Self "variant_seed" := {
    Notations.double_colon := variant_seed (V := V);
  }.
  
  Global Instance ℐ : serde.de.EnumAccess.Required.Trait Self := {
    serde.de.EnumAccess.Error := Error;
    serde.de.EnumAccess.Variant := Variant;
    serde.de.EnumAccess.variant_seed
      {V : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait V} :=
      variant_seed (V := V);
    serde.de.EnumAccess.variant := Datatypes.None;
  }.
End Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.
End Impl_serde_de_EnumAccess_for_axum_extract_path_de_EnumDeserializer_t.

Module  UnitVariant.
Section UnitVariant.
  Inductive t : Set := Build.
End UnitVariant.
End UnitVariant.

Module  Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
Section Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
  Definition Self : Set := axum.extract.path.de.UnitVariant.t.
  
  (*
      type Error = PathDeserializationError;
  *)
  Definition Error : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
      fn unit_variant(self) -> Result<(), Self::Error> {
          Ok(())
      }
  *)
  Definition unit_variant (self : Self) : M (core.result.Result.t unit Error) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_unit_variant :
    Notations.DoubleColon Self "unit_variant" := {
    Notations.double_colon := unit_variant;
  }.
  
  (*
      fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>
      where
          T: DeserializeSeed<'de>,
      {
          Err(PathDeserializationError::unsupported_type(
              "newtype enum variant",
          ))
      }
  *)
  Definition newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : Self)
      (_seed : T)
      : M (core.result.Result.t T::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _seed := M.alloc _seed in
    M.read foo.
  
  Global Instance AssociatedFunction_newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "newtype_variant_seed" := {
    Notations.double_colon := newtype_variant_seed (T := T);
  }.
  
  (*
      fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          Err(PathDeserializationError::unsupported_type(
              "tuple enum variant",
          ))
      }
  *)
  Definition tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_len : usize.t)
      (_visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _len := M.alloc _len in
    let* _visitor := M.alloc _visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "tuple_variant" := {
    Notations.double_colon := tuple_variant (V := V);
  }.
  
  (*
      fn struct_variant<V>(
          self,
          _fields: &'static [&'static str],
          _visitor: V,
      ) -> Result<V::Value, Self::Error>
      where
          V: Visitor<'de>,
      {
          Err(PathDeserializationError::unsupported_type(
              "struct enum variant",
          ))
      }
  *)
  Definition struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V}
      (self : Self)
      (_fields : ref (slice (ref str.t)))
      (_visitor : V)
      : M (core.result.Result.t V::type["Value"].t Error) :=
    let* self := M.alloc self in
    let* _fields := M.alloc _fields in
    let* _visitor := M.alloc _visitor in
    M.read foo.
  
  Global Instance AssociatedFunction_struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :
    Notations.DoubleColon Self "struct_variant" := {
    Notations.double_colon := struct_variant (V := V);
  }.
  
  Global Instance ℐ : serde.de.VariantAccess.Required.Trait Self := {
    serde.de.VariantAccess.Error := Error;
    serde.de.VariantAccess.unit_variant := unit_variant;
    serde.de.VariantAccess.newtype_variant_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      newtype_variant_seed (T := T);
    serde.de.VariantAccess.tuple_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      tuple_variant (V := V);
    serde.de.VariantAccess.struct_variant
      {V : Set}
      {ℋ_0 : serde.de.Visitor.Trait V} :=
      struct_variant (V := V);
    serde.de.VariantAccess.newtype_variant := Datatypes.None;
  }.
End Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.
End Impl_serde_de_VariantAccess_for_axum_extract_path_de_UnitVariant_t.

Module  SeqDeserializer.
Section SeqDeserializer.
  Record t : Set := {
    params :
      ref
        (slice
          ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
          *
          axum.util.PercentDecodedStr.t));
    idx : usize.t;
  }.
  
  Definition Get_params :=
    Ref.map (fun α => Some α.(params)) (fun β α => Some (α <| params := β |>)).
  Definition Get_idx :=
    Ref.map (fun α => Some α.(idx)) (fun β α => Some (α <| idx := β |>)).
End SeqDeserializer.
End SeqDeserializer.

Module  Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
Section Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
  Definition Self : Set := axum.extract.path.de.SeqDeserializer.t.
  
  (*
      type Error = PathDeserializationError;
  *)
  Definition Error : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
      fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
      where
          T: DeserializeSeed<'de>,
      {
          match self.params.split_first() {
              Some(((key, value), tail)) => {
                  self.params = tail;
                  let idx = self.idx;
                  self.idx += 1;
                  Ok(Some(seed.deserialize(ValueDeserializer {
                      key: Some(KeyOrIdx::Idx {
                          idx,
                          key: key.clone(),
                      }),
                      value,
                  })?))
              }
              None => Ok(None),
          }
      }
  *)
  Definition next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T}
      (self : mut_ref Self)
      (seed : T)
      :
        M
          (core.result.Result.t
            (core.option.Option.t T::type["Value"].t)
            Error) :=
    let* self := M.alloc self in
    let* seed := M.alloc seed in
    M.read foo.
  
  Global Instance AssociatedFunction_next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :
    Notations.DoubleColon Self "next_element_seed" := {
    Notations.double_colon := next_element_seed (T := T);
  }.
  
  Global Instance ℐ : serde.de.SeqAccess.Required.Trait Self := {
    serde.de.SeqAccess.Error := Error;
    serde.de.SeqAccess.next_element_seed
      {T : Set}
      {ℋ_0 : serde.de.DeserializeSeed.Trait T} :=
      next_element_seed (T := T);
    serde.de.SeqAccess.next_element := Datatypes.None;
    serde.de.SeqAccess.size_hint := Datatypes.None;
  }.
End Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.
End Impl_serde_de_SeqAccess_for_axum_extract_path_de_SeqDeserializer_t.

Module KeyOrIdx.
  Module Idx.
    Record t : Set := {
      idx : usize.t;
      key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
    }.
  End Idx.
  
  Inductive t : Set :=
  | Key (_ : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
  | Idx (_ : Idx.t).
  
  Definition Get_Key_0 :=
    Ref.map
      (fun α => match α with | Key α0 => Some α0 | _ => None end)
      (fun β α => match α with | Key _ => Some (Key β) | _ => None end).
  
  Definition Get_Idx_idx :=
    Ref.map
      (fun α => match α with | Idx α => Some α.(Idx.idx) | _ => None end)
      (fun β α =>
        match α with
        | Idx α => Some (Idx (α <| Idx.idx := β |>))
        | _ => None
        end).
  
  Definition Get_Idx_key :=
    Ref.map
      (fun α => match α with | Idx α => Some α.(Idx.key) | _ => None end)
      (fun β α =>
        match α with
        | Idx α => Some (Idx (α <| Idx.key := β |>))
        | _ => None
        end).
End KeyOrIdx.

Module  Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
Section Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
  Definition Self : Set := axum.extract.path.de.KeyOrIdx.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.
End Impl_core_fmt_Debug_for_axum_extract_path_de_KeyOrIdx_t.

Module  Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
Section Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
  Definition Self : Set := axum.extract.path.de.KeyOrIdx.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.extract.path.de.KeyOrIdx.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.
End Impl_core_clone_Clone_for_axum_extract_path_de_KeyOrIdx_t.

Module  Path.
Section Path.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Path.
End Path.

Module  Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.
Section Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum.extract.path.Path.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.
End Impl_core_fmt_Debug_for_axum_extract_path_Path_t_T.

Module  Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.
Section Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.extract.path.Path.t T.
  
  (*
              type Target = T;
  *)
  Definition Target : Set := T.
  
  (*
              fn deref(&self) -> &Self::Target {
                  &self.0
              }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.
End Impl_core_ops_deref_Deref_for_axum_extract_path_Path_t_T.

Module  Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.
Section Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.extract.path.Path.t T.
  
  (*
              fn deref_mut(&mut self) -> &mut Self::Target {
                  &mut self.0
              }
  *)
  Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref_mut :
    Notations.DoubleColon Self "deref_mut" := {
    Notations.double_colon := deref_mut;
  }.
  
  Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
    core.ops.deref.DerefMut.deref_mut := deref_mut;
  }.
End Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.
End Impl_core_ops_deref_DerefMut_for_axum_extract_path_Path_t_T.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.
  Context {T S : Set}.
  
  Context
    {ℋ_0 : serde.de.DeserializeOwned.Trait T}
    {ℋ_1 : core.marker.Send.Trait T}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.extract.path.Path.t T.
  
  (*
      type Rejection = PathRejection;
  *)
  Definition Rejection : Set := axum.extract.rejection.PathRejection.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
          let params = match parts.extensions.get::<UrlParams>() {
              Some(UrlParams::Params(params)) => params,
              Some(UrlParams::InvalidUtf8InPathParam { key }) => {
                  let err = PathDeserializationError {
                      kind: ErrorKind::InvalidUtf8InPathParam {
                          key: key.to_string(),
                      },
                  };
                  let err = FailedToDeserializePathParams(err);
                  return Err(err.into());
              }
              None => {
                  return Err(MissingPathParams.into());
              }
          };
  
          T::deserialize(de::PathDeserializer::new(params))
              .map_err(|err| {
                  PathRejection::FailedToDeserializePathParams(FailedToDeserializePathParams(err))
              })
              .map(Path)
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (_state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_Path_t_T.

Module  PathDeserializationError.
Section PathDeserializationError.
  Record t : Set := {
    kind : axum.extract.path.ErrorKind.t;
  }.
  
  Definition Get_kind :=
    Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
End PathDeserializationError.
End PathDeserializationError.

Module  Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.
Section Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.
  Definition Self : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.
End Impl_core_fmt_Debug_for_axum_extract_path_PathDeserializationError_t.

Module  Impl_axum_extract_path_PathDeserializationError_t_3.
Section Impl_axum_extract_path_PathDeserializationError_t_3.
  Definition Self : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
      pub(super) fn new(kind: ErrorKind) -> Self {
          Self { kind }
      }
  *)
  Definition new (kind : axum.extract.path.ErrorKind.t) : M Self :=
    let* kind := M.alloc kind in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub(super) fn wrong_number_of_parameters() -> WrongNumberOfParameters<()> {
          WrongNumberOfParameters { got: () }
      }
  *)
  Definition wrong_number_of_parameters
      : M (axum.extract.path.WrongNumberOfParameters.t unit) :=
    M.read foo.
  
  Global Instance AssociatedFunction_wrong_number_of_parameters :
    Notations.DoubleColon Self "wrong_number_of_parameters" := {
    Notations.double_colon := wrong_number_of_parameters;
  }.
  
  (*
      pub(super) fn unsupported_type(name: &'static str) -> Self {
          Self::new(ErrorKind::UnsupportedType { name })
      }
  *)
  Definition unsupported_type (name : ref str.t) : M Self :=
    let* name := M.alloc name in
    M.read foo.
  
  Global Instance AssociatedFunction_unsupported_type :
    Notations.DoubleColon Self "unsupported_type" := {
    Notations.double_colon := unsupported_type;
  }.
End Impl_axum_extract_path_PathDeserializationError_t_3.
End Impl_axum_extract_path_PathDeserializationError_t_3.

Module  WrongNumberOfParameters.
Section WrongNumberOfParameters.
  Context (G : Set).
  
  Record t : Set := {
    got : G;
  }.
  
  Definition Get_got :=
    Ref.map (fun α => Some α.(got)) (fun β α => Some (α <| got := β |>)).
End WrongNumberOfParameters.
End WrongNumberOfParameters.

Module  Impl_axum_extract_path_WrongNumberOfParameters_t_G_3.
Section Impl_axum_extract_path_WrongNumberOfParameters_t_G_3.
  Context {G : Set}.
  
  Definition Self : Set := axum.extract.path.WrongNumberOfParameters.t G.
  
  (*
      pub(super) fn got<G2>(self, got: G2) -> WrongNumberOfParameters<G2> {
          WrongNumberOfParameters { got }
      }
  *)
  Definition got
      {G2 : Set}
      (self : Self)
      (got : G2)
      : M (axum.extract.path.WrongNumberOfParameters.t G2) :=
    let* self := M.alloc self in
    let* got := M.alloc got in
    M.read foo.
  
  Global Instance AssociatedFunction_got {G2 : Set} :
    Notations.DoubleColon Self "got" := {
    Notations.double_colon := got (G2 := G2);
  }.
End Impl_axum_extract_path_WrongNumberOfParameters_t_G_3.
End Impl_axum_extract_path_WrongNumberOfParameters_t_G_3.

Module  Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t_3.
Section Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t_3.
  Definition Self : Set := axum.extract.path.WrongNumberOfParameters.t usize.t.
  
  (*
      pub(super) fn expected(self, expected: usize) -> PathDeserializationError {
          PathDeserializationError::new(ErrorKind::WrongNumberOfParameters {
              got: self.got,
              expected,
          })
      }
  *)
  Definition expected
      (self : Self)
      (expected : usize.t)
      : M axum.extract.path.PathDeserializationError.t :=
    let* self := M.alloc self in
    let* expected := M.alloc expected in
    M.read foo.
  
  Global Instance AssociatedFunction_expected :
    Notations.DoubleColon Self "expected" := {
    Notations.double_colon := expected;
  }.
End Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t_3.
End Impl_axum_extract_path_WrongNumberOfParameters_t_usize_t_3.

Module  Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.
Section Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.
  Definition Self : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
      fn custom<T>(msg: T) -> Self
      where
          T: fmt::Display,
      {
          Self {
              kind: ErrorKind::Message(msg.to_string()),
          }
      }
  *)
  Definition custom
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T}
      (msg : T)
      : M Self :=
    let* msg := M.alloc msg in
    M.read foo.
  
  Global Instance AssociatedFunction_custom
      {T : Set}
      {ℋ_0 : core.fmt.Display.Trait T} :
    Notations.DoubleColon Self "custom" := {
    Notations.double_colon := custom (T := T);
  }.
  
  Global Instance ℐ : serde.de.Error.Required.Trait Self := {
    serde.de.Error.custom {T : Set} {ℋ_0 : core.fmt.Display.Trait T} :=
      custom (T := T);
    serde.de.Error.invalid_type := Datatypes.None;
    serde.de.Error.invalid_value := Datatypes.None;
    serde.de.Error.invalid_length := Datatypes.None;
    serde.de.Error.unknown_variant := Datatypes.None;
    serde.de.Error.unknown_field := Datatypes.None;
    serde.de.Error.missing_field := Datatypes.None;
    serde.de.Error.duplicate_field := Datatypes.None;
  }.
End Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.
End Impl_serde_de_Error_for_axum_extract_path_PathDeserializationError_t.

Module  Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.
Section Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.
  Definition Self : Set := axum.extract.path.PathDeserializationError.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          self.kind.fmt(f)
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.
End Impl_core_fmt_Display_for_axum_extract_path_PathDeserializationError_t.

Module  Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.
Section Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.
  Definition Self : Set := axum.extract.path.PathDeserializationError.t.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.None;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.
End Impl_core_error_Error_for_axum_extract_path_PathDeserializationError_t.

Module ErrorKind.
  Module WrongNumberOfParameters.
    Record t : Set := {
      got : usize.t;
      expected : usize.t;
    }.
  End WrongNumberOfParameters.
  
  Module ParseErrorAtKey.
    Record t : Set := {
      key : alloc.string.String.t;
      value : alloc.string.String.t;
      expected_type : ref str.t;
    }.
  End ParseErrorAtKey.
  
  Module ParseErrorAtIndex.
    Record t : Set := {
      index : usize.t;
      value : alloc.string.String.t;
      expected_type : ref str.t;
    }.
  End ParseErrorAtIndex.
  
  Module ParseError.
    Record t : Set := {
      value : alloc.string.String.t;
      expected_type : ref str.t;
    }.
  End ParseError.
  
  Module InvalidUtf8InPathParam.
    Record t : Set := {
      key : alloc.string.String.t;
    }.
  End InvalidUtf8InPathParam.
  
  Module UnsupportedType.
    Record t : Set := {
      name : ref str.t;
    }.
  End UnsupportedType.
  
  Inductive t : Set :=
  | WrongNumberOfParameters (_ : WrongNumberOfParameters.t)
  | ParseErrorAtKey (_ : ParseErrorAtKey.t)
  | ParseErrorAtIndex (_ : ParseErrorAtIndex.t)
  | ParseError (_ : ParseError.t)
  | InvalidUtf8InPathParam (_ : InvalidUtf8InPathParam.t)
  | UnsupportedType (_ : UnsupportedType.t)
  | Message (_ : alloc.string.String.t).
  
  Definition Get_WrongNumberOfParameters_got :=
    Ref.map
      (fun α =>
        match α with
        | WrongNumberOfParameters α => Some α.(WrongNumberOfParameters.got)
        | _ => None
        end)
      (fun β α =>
        match α with
        | WrongNumberOfParameters α =>
          Some
            (WrongNumberOfParameters (α <| WrongNumberOfParameters.got := β |>))
        | _ => None
        end).
  
  Definition Get_WrongNumberOfParameters_expected :=
    Ref.map
      (fun α =>
        match α with
        | WrongNumberOfParameters α => Some α.(WrongNumberOfParameters.expected)
        | _ => None
        end)
      (fun β α =>
        match α with
        | WrongNumberOfParameters α =>
          Some
            (WrongNumberOfParameters
              (α <| WrongNumberOfParameters.expected := β |>))
        | _ => None
        end).
  
  Definition Get_ParseErrorAtKey_key :=
    Ref.map
      (fun α =>
        match α with
        | ParseErrorAtKey α => Some α.(ParseErrorAtKey.key)
        | _ => None
        end)
      (fun β α =>
        match α with
        | ParseErrorAtKey α =>
          Some (ParseErrorAtKey (α <| ParseErrorAtKey.key := β |>))
        | _ => None
        end).
  
  Definition Get_ParseErrorAtKey_value :=
    Ref.map
      (fun α =>
        match α with
        | ParseErrorAtKey α => Some α.(ParseErrorAtKey.value)
        | _ => None
        end)
      (fun β α =>
        match α with
        | ParseErrorAtKey α =>
          Some (ParseErrorAtKey (α <| ParseErrorAtKey.value := β |>))
        | _ => None
        end).
  
  Definition Get_ParseErrorAtKey_expected_type :=
    Ref.map
      (fun α =>
        match α with
        | ParseErrorAtKey α => Some α.(ParseErrorAtKey.expected_type)
        | _ => None
        end)
      (fun β α =>
        match α with
        | ParseErrorAtKey α =>
          Some (ParseErrorAtKey (α <| ParseErrorAtKey.expected_type := β |>))
        | _ => None
        end).
  
  Definition Get_ParseErrorAtIndex_index :=
    Ref.map
      (fun α =>
        match α with
        | ParseErrorAtIndex α => Some α.(ParseErrorAtIndex.index)
        | _ => None
        end)
      (fun β α =>
        match α with
        | ParseErrorAtIndex α =>
          Some (ParseErrorAtIndex (α <| ParseErrorAtIndex.index := β |>))
        | _ => None
        end).
  
  Definition Get_ParseErrorAtIndex_value :=
    Ref.map
      (fun α =>
        match α with
        | ParseErrorAtIndex α => Some α.(ParseErrorAtIndex.value)
        | _ => None
        end)
      (fun β α =>
        match α with
        | ParseErrorAtIndex α =>
          Some (ParseErrorAtIndex (α <| ParseErrorAtIndex.value := β |>))
        | _ => None
        end).
  
  Definition Get_ParseErrorAtIndex_expected_type :=
    Ref.map
      (fun α =>
        match α with
        | ParseErrorAtIndex α => Some α.(ParseErrorAtIndex.expected_type)
        | _ => None
        end)
      (fun β α =>
        match α with
        | ParseErrorAtIndex α =>
          Some
            (ParseErrorAtIndex (α <| ParseErrorAtIndex.expected_type := β |>))
        | _ => None
        end).
  
  Definition Get_ParseError_value :=
    Ref.map
      (fun α =>
        match α with
        | ParseError α => Some α.(ParseError.value)
        | _ => None
        end)
      (fun β α =>
        match α with
        | ParseError α => Some (ParseError (α <| ParseError.value := β |>))
        | _ => None
        end).
  
  Definition Get_ParseError_expected_type :=
    Ref.map
      (fun α =>
        match α with
        | ParseError α => Some α.(ParseError.expected_type)
        | _ => None
        end)
      (fun β α =>
        match α with
        | ParseError α =>
          Some (ParseError (α <| ParseError.expected_type := β |>))
        | _ => None
        end).
  
  Definition Get_InvalidUtf8InPathParam_key :=
    Ref.map
      (fun α =>
        match α with
        | InvalidUtf8InPathParam α => Some α.(InvalidUtf8InPathParam.key)
        | _ => None
        end)
      (fun β α =>
        match α with
        | InvalidUtf8InPathParam α =>
          Some
            (InvalidUtf8InPathParam (α <| InvalidUtf8InPathParam.key := β |>))
        | _ => None
        end).
  
  Definition Get_UnsupportedType_name :=
    Ref.map
      (fun α =>
        match α with
        | UnsupportedType α => Some α.(UnsupportedType.name)
        | _ => None
        end)
      (fun β α =>
        match α with
        | UnsupportedType α =>
          Some (UnsupportedType (α <| UnsupportedType.name := β |>))
        | _ => None
        end).
  
  Definition Get_Message_0 :=
    Ref.map
      (fun α => match α with | Message α0 => Some α0 | _ => None end)
      (fun β α => match α with | Message _ => Some (Message β) | _ => None end).
End ErrorKind.

Module  Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.
Section Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.
  Definition Self : Set := axum.extract.path.ErrorKind.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.
End Impl_core_fmt_Debug_for_axum_extract_path_ErrorKind_t.

Module  Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.
Section Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.
  Definition Self : Set := axum.extract.path.ErrorKind.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.
End Impl_core_marker_StructuralPartialEq_for_axum_extract_path_ErrorKind_t.

Module  Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.
Section Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.
  Definition Self : Set := axum.extract.path.ErrorKind.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref axum.extract.path.ErrorKind.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.
End Impl_core_cmp_PartialEq_for_axum_extract_path_ErrorKind_t.

Module  Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.
Section Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.
  Definition Self : Set := axum.extract.path.ErrorKind.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.
End Impl_core_marker_StructuralEq_for_axum_extract_path_ErrorKind_t.

Module  Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.
Section Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.
  Definition Self : Set := axum.extract.path.ErrorKind.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.
End Impl_core_cmp_Eq_for_axum_extract_path_ErrorKind_t.

Module  Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.
Section Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.
  Definition Self : Set := axum.extract.path.ErrorKind.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          match self {
              ErrorKind::Message(error) => error.fmt(f),
              ErrorKind::InvalidUtf8InPathParam { key } => write!(f, "Invalid UTF-8 in `{key}`"),
              ErrorKind::WrongNumberOfParameters { got, expected } => {
                  write!(
                      f,
                      "Wrong number of path arguments for `Path`. Expected {expected} but got {got}"
                  )?;
  
                  if *expected == 1 {
                      write!(f, ". Note that multiple parameters must be extracted with a tuple `Path<(_, _)>` or a struct `Path<YourParams>`")?;
                  }
  
                  Ok(())
              }
              ErrorKind::UnsupportedType { name } => write!(f, "Unsupported type `{name}`"),
              ErrorKind::ParseErrorAtKey {
                  key,
                  value,
                  expected_type,
              } => write!(
                  f,
                  "Cannot parse `{key}` with value `{value:?}` to a `{expected_type}`"
              ),
              ErrorKind::ParseError {
                  value,
                  expected_type,
              } => write!(f, "Cannot parse `{value:?}` to a `{expected_type}`"),
              ErrorKind::ParseErrorAtIndex {
                  index,
                  value,
                  expected_type,
              } => write!(
                  f,
                  "Cannot parse value at index {index} with value `{value:?}` to a `{expected_type}`"
              ),
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.
End Impl_core_fmt_Display_for_axum_extract_path_ErrorKind_t.

Module  FailedToDeserializePathParams.
Section FailedToDeserializePathParams.
  Record t : Set := {
    x0 : axum.extract.path.PathDeserializationError.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End FailedToDeserializePathParams.
End FailedToDeserializePathParams.

Module  Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.
Section Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.
  Definition Self : Set := axum.extract.path.FailedToDeserializePathParams.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.
End Impl_core_fmt_Debug_for_axum_extract_path_FailedToDeserializePathParams_t.

Module  Impl_axum_extract_path_FailedToDeserializePathParams_t_3.
Section Impl_axum_extract_path_FailedToDeserializePathParams_t_3.
  Definition Self : Set := axum.extract.path.FailedToDeserializePathParams.t.
  
  (*
      pub fn kind(&self) -> &ErrorKind {
          &self.0.kind
      }
  *)
  Definition kind (self : ref Self) : M (ref axum.extract.path.ErrorKind.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_kind :
    Notations.DoubleColon Self "kind" := {
    Notations.double_colon := kind;
  }.
  
  (*
      pub fn into_kind(self) -> ErrorKind {
          self.0.kind
      }
  *)
  Definition into_kind (self : Self) : M axum.extract.path.ErrorKind.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_kind :
    Notations.DoubleColon Self "into_kind" := {
    Notations.double_colon := into_kind;
  }.
  
  (*
      pub fn body_text(&self) -> String {
          match self.0.kind {
              ErrorKind::Message(_)
              | ErrorKind::InvalidUtf8InPathParam { .. }
              | ErrorKind::ParseError { .. }
              | ErrorKind::ParseErrorAtIndex { .. }
              | ErrorKind::ParseErrorAtKey { .. } => format!("Invalid URL: {}", self.0.kind),
              ErrorKind::WrongNumberOfParameters { .. } | ErrorKind::UnsupportedType { .. } => {
                  self.0.kind.to_string()
              }
          }
      }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
      pub fn status(&self) -> StatusCode {
          match self.0.kind {
              ErrorKind::Message(_)
              | ErrorKind::InvalidUtf8InPathParam { .. }
              | ErrorKind::ParseError { .. }
              | ErrorKind::ParseErrorAtIndex { .. }
              | ErrorKind::ParseErrorAtKey { .. } => StatusCode::BAD_REQUEST,
              ErrorKind::WrongNumberOfParameters { .. } | ErrorKind::UnsupportedType { .. } => {
                  StatusCode::INTERNAL_SERVER_ERROR
              }
          }
      }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_path_FailedToDeserializePathParams_t_3.
End Impl_axum_extract_path_FailedToDeserializePathParams_t_3.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.
  Definition Self : Set := axum.extract.path.FailedToDeserializePathParams.t.
  
  (*
      fn into_response(self) -> Response {
          axum_core::__log_rejection!(
              rejection_type = Self,
              body_text = self.body_text(),
              status = self.status(),
          );
          (self.status(), self.body_text()).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_FailedToDeserializePathParams_t.

Definition __CALLSITE : M.Val (ref tracing_core.callsite.DefaultCallsite.t) :=
  M.run (M.alloc foo).

Definition META : M.Val (ref tracing_core.metadata.Metadata.t) :=
  M.run (M.alloc foo).

Module  Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.
Section Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.
  Definition Self : Set := axum.extract.path.FailedToDeserializePathParams.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          self.0.fmt(f)
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.
End Impl_core_fmt_Display_for_axum_extract_path_FailedToDeserializePathParams_t.

Module  Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.
Section Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.
  Definition Self : Set := axum.extract.path.FailedToDeserializePathParams.t.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.None;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.
End Impl_core_error_Error_for_axum_extract_path_FailedToDeserializePathParams_t.

Module  RawPathParams.
Section RawPathParams.
  Record t : Set := {
    x0 :
      alloc.vec.Vec.t
        ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
        *
        axum.util.PercentDecodedStr.t)
        alloc.vec.Vec.Default.A;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End RawPathParams.
End RawPathParams.

Module  Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.
Section Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.
  Definition Self : Set := axum.extract.path.RawPathParams.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.
End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParams_t.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.extract.path.RawPathParams.t.
  
  (*
      type Rejection = RawPathParamsRejection;
  *)
  Definition Rejection : Set := axum.extract.rejection.RawPathParamsRejection.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
          let params = match parts.extensions.get::<UrlParams>() {
              Some(UrlParams::Params(params)) => params,
              Some(UrlParams::InvalidUtf8InPathParam { key }) => {
                  return Err(InvalidUtf8InPathParam {
                      key: Arc::clone(key),
                  }
                  .into());
              }
              None => {
                  return Err(MissingPathParams.into());
              }
          };
  
          Ok(Self(params.clone()))
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (_state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_path_RawPathParams_t.

Module  Impl_axum_extract_path_RawPathParams_t_3.
Section Impl_axum_extract_path_RawPathParams_t_3.
  Definition Self : Set := axum.extract.path.RawPathParams.t.
  
  (*
      pub fn iter(&self) -> RawPathParamsIter<'_> {
          self.into_iter()
      }
  *)
  Definition iter (self : ref Self) : M axum.extract.path.RawPathParamsIter.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_iter :
    Notations.DoubleColon Self "iter" := {
    Notations.double_colon := iter;
  }.
End Impl_axum_extract_path_RawPathParams_t_3.
End Impl_axum_extract_path_RawPathParams_t_3.

Module  Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.
Section Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.
  Definition Self : Set := ref axum.extract.path.RawPathParams.t.
  
  (*
      type Item = (&'a str, &'a str);
  *)
  Definition Item : Set := (ref str.t) * (ref str.t).
  
  (*
      type IntoIter = RawPathParamsIter<'a>;
  *)
  Definition IntoIter : Set := axum.extract.path.RawPathParamsIter.t.
  
  (*
      fn into_iter(self) -> Self::IntoIter {
          RawPathParamsIter(self.0.iter())
      }
  *)
  Definition into_iter (self : Self) : M IntoIter :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_iter :
    Notations.DoubleColon Self "into_iter" := {
    Notations.double_colon := into_iter;
  }.
  
  Global Instance ℐ : core.iter.traits.collect.IntoIterator.Trait Self := {
    core.iter.traits.collect.IntoIterator.Item := Item;
    core.iter.traits.collect.IntoIterator.IntoIter := IntoIter;
    core.iter.traits.collect.IntoIterator.into_iter := into_iter;
  }.
End Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.
End Impl_core_iter_traits_collect_IntoIterator_for_ref_axum_extract_path_RawPathParams_t.

Module  RawPathParamsIter.
Section RawPathParamsIter.
  Record t : Set := {
    x0 :
      core.slice.iter.Iter.t
        ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
        *
        axum.util.PercentDecodedStr.t);
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End RawPathParamsIter.
End RawPathParamsIter.

Module  Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.
Section Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.
  Definition Self : Set := axum.extract.path.RawPathParamsIter.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.
End Impl_core_fmt_Debug_for_axum_extract_path_RawPathParamsIter_t.

Module  Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.
Section Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.
  Definition Self : Set := axum.extract.path.RawPathParamsIter.t.
  
  (*
      type Item = (&'a str, &'a str);
  *)
  Definition Item : Set := (ref str.t) * (ref str.t).
  
  (*
      fn next(&mut self) -> Option<Self::Item> {
          let (key, value) = self.0.next()?;
          Some((&**key, value.as_str()))
      }
  *)
  Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  Global Instance ℐ :
    core.iter.traits.iterator.Iterator.Required.Trait Self := {
    core.iter.traits.iterator.Iterator.Item := Item;
    core.iter.traits.iterator.Iterator.next := next;
    core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
    core.iter.traits.iterator.Iterator.size_hint := Datatypes.None;
    core.iter.traits.iterator.Iterator.count := Datatypes.None;
    core.iter.traits.iterator.Iterator.last := Datatypes.None;
    core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.nth := Datatypes.None;
    core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.chain := Datatypes.None;
    core.iter.traits.iterator.Iterator.zip := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
    core.iter.traits.iterator.Iterator.map := Datatypes.None;
    core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
    core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip := Datatypes.None;
    core.iter.traits.iterator.Iterator.take := Datatypes.None;
    core.iter.traits.iterator.Iterator.scan := Datatypes.None;
    core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
    core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
    core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
    core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.all := Datatypes.None;
    core.iter.traits.iterator.Iterator.any := Datatypes.None;
    core.iter.traits.iterator.Iterator.find := Datatypes.None;
    core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
    core.iter.traits.iterator.Iterator.position := Datatypes.None;
    core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
    core.iter.traits.iterator.Iterator.max := Datatypes.None;
    core.iter.traits.iterator.Iterator.min := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.rev := Datatypes.None;
    core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
    core.iter.traits.iterator.Iterator.copied := Datatypes.None;
    core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
    core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
    core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
    core.iter.traits.iterator.Iterator.sum := Datatypes.None;
    core.iter.traits.iterator.Iterator.product := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.ne := Datatypes.None;
    core.iter.traits.iterator.Iterator.lt := Datatypes.None;
    core.iter.traits.iterator.Iterator.le := Datatypes.None;
    core.iter.traits.iterator.Iterator.gt := Datatypes.None;
    core.iter.traits.iterator.Iterator.ge := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
      Datatypes.None;
  }.
End Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.
End Impl_core_iter_traits_iterator_Iterator_for_axum_extract_path_RawPathParamsIter_t.

Module  InvalidUtf8InPathParam.
Section InvalidUtf8InPathParam.
  Record t : Set := {
    key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
  }.
  
  Definition Get_key :=
    Ref.map (fun α => Some α.(key)) (fun β α => Some (α <| key := β |>)).
End InvalidUtf8InPathParam.
End InvalidUtf8InPathParam.

Module  Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.
Section Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.
  Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.
End Impl_core_fmt_Debug_for_axum_extract_path_InvalidUtf8InPathParam_t.

Module  Impl_axum_extract_path_InvalidUtf8InPathParam_t_3.
Section Impl_axum_extract_path_InvalidUtf8InPathParam_t_3.
  Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
  
  (*
      pub fn body_text(&self) -> String {
          self.to_string()
      }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
      pub fn status(&self) -> StatusCode {
          StatusCode::BAD_REQUEST
      }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_path_InvalidUtf8InPathParam_t_3.
End Impl_axum_extract_path_InvalidUtf8InPathParam_t_3.

Module  Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.
Section Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.
  Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          write!(f, "Invalid UTF-8 in `{}`", self.key)
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.
End Impl_core_fmt_Display_for_axum_extract_path_InvalidUtf8InPathParam_t.

Module  Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.
Section Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.
  Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.None;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.
End Impl_core_error_Error_for_axum_extract_path_InvalidUtf8InPathParam_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.
  Definition Self : Set := axum.extract.path.InvalidUtf8InPathParam.t.
  
  (*
      fn into_response(self) -> Response {
          (self.status(), self.body_text()).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_path_InvalidUtf8InPathParam_t.

Module rejection.
  Module  JsonDataError.
  Section JsonDataError.
    Record t : Set := {
      x0 : axum_core.error.Error.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End JsonDataError.
  End JsonDataError.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.
    Definition Self : Set := axum.extract.rejection.JsonDataError.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.
  
  Module  Impl_axum_extract_rejection_JsonDataError_t_3.
  Section Impl_axum_extract_rejection_JsonDataError_t_3.
    Definition Self : Set := axum.extract.rejection.JsonDataError.t.
    
    (*
                pub(crate) fn from_err<E>(err: E) -> Self
                where
                    E: Into<$crate::BoxError>,
                {
                    Self($crate::Error::new(err))
                }
    *)
    Definition from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
        (err : E)
        : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "from_err" := {
      Notations.double_colon := from_err (E := E);
    }.
  End Impl_axum_extract_rejection_JsonDataError_t_3.
  End Impl_axum_extract_rejection_JsonDataError_t_3.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.
    Definition Self : Set := axum.extract.rejection.JsonDataError.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = self.body_text(),
                        status = http::StatusCode::$status,
                    );
                    (self.status(), self.body_text()).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.
  
  Module  Impl_axum_extract_rejection_JsonDataError_t_4.
  Section Impl_axum_extract_rejection_JsonDataError_t_4.
    Definition Self : Set := axum.extract.rejection.JsonDataError.t.
    
    (*
                pub fn body_text(&self) -> String {
                    format!(concat!($body, ": {}"), self.0).into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_JsonDataError_t_4.
  End Impl_axum_extract_rejection_JsonDataError_t_4.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.
    Definition Self : Set := axum.extract.rejection.JsonDataError.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.
    Definition Self : Set := axum.extract.rejection.JsonDataError.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    Some(&self.0)
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.
  End Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.
  
  Module  JsonSyntaxError.
  Section JsonSyntaxError.
    Record t : Set := {
      x0 : axum_core.error.Error.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End JsonSyntaxError.
  End JsonSyntaxError.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.
    Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.
  
  Module  Impl_axum_extract_rejection_JsonSyntaxError_t_3.
  Section Impl_axum_extract_rejection_JsonSyntaxError_t_3.
    Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
    
    (*
                pub(crate) fn from_err<E>(err: E) -> Self
                where
                    E: Into<$crate::BoxError>,
                {
                    Self($crate::Error::new(err))
                }
    *)
    Definition from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
        (err : E)
        : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "from_err" := {
      Notations.double_colon := from_err (E := E);
    }.
  End Impl_axum_extract_rejection_JsonSyntaxError_t_3.
  End Impl_axum_extract_rejection_JsonSyntaxError_t_3.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.
    Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = self.body_text(),
                        status = http::StatusCode::$status,
                    );
                    (self.status(), self.body_text()).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.
  
  Module  Impl_axum_extract_rejection_JsonSyntaxError_t_4.
  Section Impl_axum_extract_rejection_JsonSyntaxError_t_4.
    Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
    
    (*
                pub fn body_text(&self) -> String {
                    format!(concat!($body, ": {}"), self.0).into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_JsonSyntaxError_t_4.
  End Impl_axum_extract_rejection_JsonSyntaxError_t_4.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.
    Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.
    Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    Some(&self.0)
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.
  End Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.
  
  Module  MissingJsonContentType.
  Section MissingJsonContentType.
    Inductive t : Set := Build.
  End MissingJsonContentType.
  End MissingJsonContentType.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.
    Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.
    Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = $body,
                        status = http::StatusCode::$status,
                    );
                    (self.status(), $body).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.
  
  Module  Impl_axum_extract_rejection_MissingJsonContentType_t_2.
  Section Impl_axum_extract_rejection_MissingJsonContentType_t_2.
    Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
    
    (*
                pub fn body_text(&self) -> String {
                    $body.into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_MissingJsonContentType_t_2.
  End Impl_axum_extract_rejection_MissingJsonContentType_t_2.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.
    Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.
    Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.None;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.
  End Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.
  
  Module  Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.
  Section Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.
    Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
    
    (*
                fn default() -> Self {
                    Self
                }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.
  End Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.
  
  Module  MissingExtension.
  Section MissingExtension.
    Record t : Set := {
      x0 : axum_core.error.Error.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End MissingExtension.
  End MissingExtension.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.
    Definition Self : Set := axum.extract.rejection.MissingExtension.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.
  
  Module  Impl_axum_extract_rejection_MissingExtension_t_3.
  Section Impl_axum_extract_rejection_MissingExtension_t_3.
    Definition Self : Set := axum.extract.rejection.MissingExtension.t.
    
    (*
                pub(crate) fn from_err<E>(err: E) -> Self
                where
                    E: Into<$crate::BoxError>,
                {
                    Self($crate::Error::new(err))
                }
    *)
    Definition from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
        (err : E)
        : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "from_err" := {
      Notations.double_colon := from_err (E := E);
    }.
  End Impl_axum_extract_rejection_MissingExtension_t_3.
  End Impl_axum_extract_rejection_MissingExtension_t_3.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.
    Definition Self : Set := axum.extract.rejection.MissingExtension.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = self.body_text(),
                        status = http::StatusCode::$status,
                    );
                    (self.status(), self.body_text()).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.
  
  Module  Impl_axum_extract_rejection_MissingExtension_t_4.
  Section Impl_axum_extract_rejection_MissingExtension_t_4.
    Definition Self : Set := axum.extract.rejection.MissingExtension.t.
    
    (*
                pub fn body_text(&self) -> String {
                    format!(concat!($body, ": {}"), self.0).into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_MissingExtension_t_4.
  End Impl_axum_extract_rejection_MissingExtension_t_4.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.
    Definition Self : Set := axum.extract.rejection.MissingExtension.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.
    Definition Self : Set := axum.extract.rejection.MissingExtension.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    Some(&self.0)
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.
  End Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.
  
  Module  MissingPathParams.
  Section MissingPathParams.
    Inductive t : Set := Build.
  End MissingPathParams.
  End MissingPathParams.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.
    Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.
    Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = $body,
                        status = http::StatusCode::$status,
                    );
                    (self.status(), $body).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.
  
  Module  Impl_axum_extract_rejection_MissingPathParams_t_2.
  Section Impl_axum_extract_rejection_MissingPathParams_t_2.
    Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
    
    (*
                pub fn body_text(&self) -> String {
                    $body.into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_MissingPathParams_t_2.
  End Impl_axum_extract_rejection_MissingPathParams_t_2.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.
    Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.
    Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.None;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.
  End Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.
  
  Module  Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.
  Section Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.
    Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
    
    (*
                fn default() -> Self {
                    Self
                }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.
  End Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.
  
  Module  InvalidFormContentType.
  Section InvalidFormContentType.
    Inductive t : Set := Build.
  End InvalidFormContentType.
  End InvalidFormContentType.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.
    Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.
    Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = $body,
                        status = http::StatusCode::$status,
                    );
                    (self.status(), $body).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.
  
  Module  Impl_axum_extract_rejection_InvalidFormContentType_t_2.
  Section Impl_axum_extract_rejection_InvalidFormContentType_t_2.
    Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
    
    (*
                pub fn body_text(&self) -> String {
                    $body.into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_InvalidFormContentType_t_2.
  End Impl_axum_extract_rejection_InvalidFormContentType_t_2.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.
    Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.
    Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.None;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.
  End Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.
  
  Module  Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.
  Section Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.
    Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
    
    (*
                fn default() -> Self {
                    Self
                }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.
  End Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.
  
  Module  FailedToResolveHost.
  Section FailedToResolveHost.
    Inductive t : Set := Build.
  End FailedToResolveHost.
  End FailedToResolveHost.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.
    Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.
    Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = $body,
                        status = http::StatusCode::$status,
                    );
                    (self.status(), $body).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.
  
  Module  Impl_axum_extract_rejection_FailedToResolveHost_t_2.
  Section Impl_axum_extract_rejection_FailedToResolveHost_t_2.
    Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
    
    (*
                pub fn body_text(&self) -> String {
                    $body.into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_FailedToResolveHost_t_2.
  End Impl_axum_extract_rejection_FailedToResolveHost_t_2.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.
    Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.
    Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.None;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.
  End Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.
  
  Module  Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.
  Section Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.
    Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
    
    (*
                fn default() -> Self {
                    Self
                }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.
  End Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.
  
  Module  FailedToDeserializeForm.
  Section FailedToDeserializeForm.
    Record t : Set := {
      x0 : axum_core.error.Error.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End FailedToDeserializeForm.
  End FailedToDeserializeForm.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.
    Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.
  
  Module  Impl_axum_extract_rejection_FailedToDeserializeForm_t_3.
  Section Impl_axum_extract_rejection_FailedToDeserializeForm_t_3.
    Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
    
    (*
                pub(crate) fn from_err<E>(err: E) -> Self
                where
                    E: Into<$crate::BoxError>,
                {
                    Self($crate::Error::new(err))
                }
    *)
    Definition from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
        (err : E)
        : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "from_err" := {
      Notations.double_colon := from_err (E := E);
    }.
  End Impl_axum_extract_rejection_FailedToDeserializeForm_t_3.
  End Impl_axum_extract_rejection_FailedToDeserializeForm_t_3.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.
    Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = self.body_text(),
                        status = http::StatusCode::$status,
                    );
                    (self.status(), self.body_text()).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.
  
  Module  Impl_axum_extract_rejection_FailedToDeserializeForm_t_4.
  Section Impl_axum_extract_rejection_FailedToDeserializeForm_t_4.
    Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
    
    (*
                pub fn body_text(&self) -> String {
                    format!(concat!($body, ": {}"), self.0).into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_FailedToDeserializeForm_t_4.
  End Impl_axum_extract_rejection_FailedToDeserializeForm_t_4.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.
    Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.
    Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    Some(&self.0)
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.
  End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.
  
  Module  FailedToDeserializeFormBody.
  Section FailedToDeserializeFormBody.
    Record t : Set := {
      x0 : axum_core.error.Error.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End FailedToDeserializeFormBody.
  End FailedToDeserializeFormBody.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeFormBody.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  
  Module  Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_3.
  Section Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_3.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeFormBody.t.
    
    (*
                pub(crate) fn from_err<E>(err: E) -> Self
                where
                    E: Into<$crate::BoxError>,
                {
                    Self($crate::Error::new(err))
                }
    *)
    Definition from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
        (err : E)
        : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "from_err" := {
      Notations.double_colon := from_err (E := E);
    }.
  End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_3.
  End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_3.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeFormBody.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = self.body_text(),
                        status = http::StatusCode::$status,
                    );
                    (self.status(), self.body_text()).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  
  Module  Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_4.
  Section Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_4.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeFormBody.t.
    
    (*
                pub fn body_text(&self) -> String {
                    format!(concat!($body, ": {}"), self.0).into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_4.
  End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_4.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeFormBody.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeFormBody.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    Some(&self.0)
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  
  Module  FailedToDeserializeQueryString.
  Section FailedToDeserializeQueryString.
    Record t : Set := {
      x0 : axum_core.error.Error.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End FailedToDeserializeQueryString.
  End FailedToDeserializeQueryString.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeQueryString.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  
  Module  Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_3.
  Section Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_3.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeQueryString.t.
    
    (*
                pub(crate) fn from_err<E>(err: E) -> Self
                where
                    E: Into<$crate::BoxError>,
                {
                    Self($crate::Error::new(err))
                }
    *)
    Definition from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
        (err : E)
        : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "from_err" := {
      Notations.double_colon := from_err (E := E);
    }.
  End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_3.
  End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_3.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeQueryString.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = self.body_text(),
                        status = http::StatusCode::$status,
                    );
                    (self.status(), self.body_text()).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  
  Module  Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_4.
  Section Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_4.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeQueryString.t.
    
    (*
                pub fn body_text(&self) -> String {
                    format!(concat!($body, ": {}"), self.0).into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_4.
  End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_4.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeQueryString.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
    Definition Self : Set :=
      axum.extract.rejection.FailedToDeserializeQueryString.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    Some(&self.0)
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  
  Module QueryRejection.
    Inductive t : Set :=
    |
      FailedToDeserializeQueryString
      (_ : axum.extract.rejection.FailedToDeserializeQueryString.t).
    
    Definition Get_FailedToDeserializeQueryString_0 :=
      Ref.map
        (fun α =>
          match α with | FailedToDeserializeQueryString α0 => Some α0 end)
        (fun β α =>
          match α with
          | FailedToDeserializeQueryString _ =>
            Some (FailedToDeserializeQueryString β)
          end).
  End QueryRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.
    Definition Self : Set := axum.extract.rejection.QueryRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.
    Definition Self : Set := axum.extract.rejection.QueryRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.
  
  Module  Impl_axum_extract_rejection_QueryRejection_t_2.
  Section Impl_axum_extract_rejection_QueryRejection_t_2.
    Definition Self : Set := axum.extract.rejection.QueryRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_QueryRejection_t_2.
  End Impl_axum_extract_rejection_QueryRejection_t_2.
  
  Module  Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.
    Definition Self : Set := axum.extract.rejection.QueryRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.FailedToDeserializeQueryString.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.FailedToDeserializeQueryString.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.
    Definition Self : Set := axum.extract.rejection.QueryRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.
    Definition Self : Set := axum.extract.rejection.QueryRejection.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.
  End Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.
  
  Module FormRejection.
    Inductive t : Set :=
    |
      InvalidFormContentType
      (_ : axum.extract.rejection.InvalidFormContentType.t)
    |
      FailedToDeserializeForm
      (_ : axum.extract.rejection.FailedToDeserializeForm.t)
    |
      FailedToDeserializeFormBody
      (_ : axum.extract.rejection.FailedToDeserializeFormBody.t)
    | BytesRejection (_ : axum_core.extract.rejection.BytesRejection.t).
    
    Definition Get_InvalidFormContentType_0 :=
      Ref.map
        (fun α =>
          match α with | InvalidFormContentType α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | InvalidFormContentType _ => Some (InvalidFormContentType β)
          | _ => None
          end).
    
    Definition Get_FailedToDeserializeForm_0 :=
      Ref.map
        (fun α =>
          match α with | FailedToDeserializeForm α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | FailedToDeserializeForm _ => Some (FailedToDeserializeForm β)
          | _ => None
          end).
    
    Definition Get_FailedToDeserializeFormBody_0 :=
      Ref.map
        (fun α =>
          match α with
          | FailedToDeserializeFormBody α0 => Some α0
          | _ => None
          end)
        (fun β α =>
          match α with
          | FailedToDeserializeFormBody _ =>
            Some (FailedToDeserializeFormBody β)
          | _ => None
          end).
    
    Definition Get_BytesRejection_0 :=
      Ref.map
        (fun α => match α with | BytesRejection α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | BytesRejection _ => Some (BytesRejection β)
          | _ => None
          end).
  End FormRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.
    Definition Self : Set := axum.extract.rejection.FormRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.
    Definition Self : Set := axum.extract.rejection.FormRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.
  
  Module  Impl_axum_extract_rejection_FormRejection_t_2.
  Section Impl_axum_extract_rejection_FormRejection_t_2.
    Definition Self : Set := axum.extract.rejection.FormRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_FormRejection_t_2.
  End Impl_axum_extract_rejection_FormRejection_t_2.
  
  Module  Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.
    Definition Self : Set := axum.extract.rejection.FormRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.InvalidFormContentType.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.InvalidFormContentType.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.
  
  Module  Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.
    Definition Self : Set := axum.extract.rejection.FormRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.FailedToDeserializeForm.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.FailedToDeserializeForm.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.
  
  Module  Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.
    Definition Self : Set := axum.extract.rejection.FormRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.FailedToDeserializeFormBody.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.FailedToDeserializeFormBody.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.
  
  Module  Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.
  Section Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.
    Definition Self : Set := axum.extract.rejection.FormRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum_core.extract.rejection.BytesRejection.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum_core.extract.rejection.BytesRejection.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.
  End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.
    Definition Self : Set := axum.extract.rejection.FormRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.
    Definition Self : Set := axum.extract.rejection.FormRejection.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.
  End Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.
  
  Module RawFormRejection.
    Inductive t : Set :=
    |
      InvalidFormContentType
      (_ : axum.extract.rejection.InvalidFormContentType.t)
    | BytesRejection (_ : axum_core.extract.rejection.BytesRejection.t).
    
    Definition Get_InvalidFormContentType_0 :=
      Ref.map
        (fun α =>
          match α with | InvalidFormContentType α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | InvalidFormContentType _ => Some (InvalidFormContentType β)
          | _ => None
          end).
    
    Definition Get_BytesRejection_0 :=
      Ref.map
        (fun α => match α with | BytesRejection α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | BytesRejection _ => Some (BytesRejection β)
          | _ => None
          end).
  End RawFormRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.
    Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.
    Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.
  
  Module  Impl_axum_extract_rejection_RawFormRejection_t_2.
  Section Impl_axum_extract_rejection_RawFormRejection_t_2.
    Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_RawFormRejection_t_2.
  End Impl_axum_extract_rejection_RawFormRejection_t_2.
  
  Module  Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.
    Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.InvalidFormContentType.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.InvalidFormContentType.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.
  
  Module  Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.
  Section Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.
    Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum_core.extract.rejection.BytesRejection.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum_core.extract.rejection.BytesRejection.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.
  End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.
    Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.
    Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.
  End Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.
  
  Module JsonRejection.
    Inductive t : Set :=
    | JsonDataError (_ : axum.extract.rejection.JsonDataError.t)
    | JsonSyntaxError (_ : axum.extract.rejection.JsonSyntaxError.t)
    |
      MissingJsonContentType
      (_ : axum.extract.rejection.MissingJsonContentType.t)
    | BytesRejection (_ : axum_core.extract.rejection.BytesRejection.t).
    
    Definition Get_JsonDataError_0 :=
      Ref.map
        (fun α => match α with | JsonDataError α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | JsonDataError _ => Some (JsonDataError β)
          | _ => None
          end).
    
    Definition Get_JsonSyntaxError_0 :=
      Ref.map
        (fun α => match α with | JsonSyntaxError α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | JsonSyntaxError _ => Some (JsonSyntaxError β)
          | _ => None
          end).
    
    Definition Get_MissingJsonContentType_0 :=
      Ref.map
        (fun α =>
          match α with | MissingJsonContentType α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | MissingJsonContentType _ => Some (MissingJsonContentType β)
          | _ => None
          end).
    
    Definition Get_BytesRejection_0 :=
      Ref.map
        (fun α => match α with | BytesRejection α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | BytesRejection _ => Some (BytesRejection β)
          | _ => None
          end).
  End JsonRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.
    Definition Self : Set := axum.extract.rejection.JsonRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.
    Definition Self : Set := axum.extract.rejection.JsonRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.
  
  Module  Impl_axum_extract_rejection_JsonRejection_t_2.
  Section Impl_axum_extract_rejection_JsonRejection_t_2.
    Definition Self : Set := axum.extract.rejection.JsonRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_JsonRejection_t_2.
  End Impl_axum_extract_rejection_JsonRejection_t_2.
  
  Module  Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.
    Definition Self : Set := axum.extract.rejection.JsonRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from (inner : axum.extract.rejection.JsonDataError.t) : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.JsonDataError.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.
  
  Module  Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.
    Definition Self : Set := axum.extract.rejection.JsonRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.JsonSyntaxError.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.JsonSyntaxError.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.
  
  Module  Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.
    Definition Self : Set := axum.extract.rejection.JsonRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.MissingJsonContentType.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.MissingJsonContentType.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.
  
  Module  Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.
  Section Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.
    Definition Self : Set := axum.extract.rejection.JsonRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum_core.extract.rejection.BytesRejection.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum_core.extract.rejection.BytesRejection.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.
  End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.
    Definition Self : Set := axum.extract.rejection.JsonRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.
    Definition Self : Set := axum.extract.rejection.JsonRejection.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.
  End Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.
  
  Module ExtensionRejection.
    Inductive t : Set :=
    | MissingExtension (_ : axum.extract.rejection.MissingExtension.t).
    
    Definition Get_MissingExtension_0 :=
      Ref.map
        (fun α => match α with | MissingExtension α0 => Some α0 end)
        (fun β α =>
          match α with | MissingExtension _ => Some (MissingExtension β) end).
  End ExtensionRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.
    Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.
    Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.
  
  Module  Impl_axum_extract_rejection_ExtensionRejection_t_2.
  Section Impl_axum_extract_rejection_ExtensionRejection_t_2.
    Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_ExtensionRejection_t_2.
  End Impl_axum_extract_rejection_ExtensionRejection_t_2.
  
  Module  Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.
    Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.MissingExtension.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.MissingExtension.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.
    Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.
    Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.
  End Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.
  
  Module PathRejection.
    Inductive t : Set :=
    |
      FailedToDeserializePathParams
      (_ : axum.extract.path.FailedToDeserializePathParams.t)
    | MissingPathParams (_ : axum.extract.rejection.MissingPathParams.t).
    
    Definition Get_FailedToDeserializePathParams_0 :=
      Ref.map
        (fun α =>
          match α with
          | FailedToDeserializePathParams α0 => Some α0
          | _ => None
          end)
        (fun β α =>
          match α with
          | FailedToDeserializePathParams _ =>
            Some (FailedToDeserializePathParams β)
          | _ => None
          end).
    
    Definition Get_MissingPathParams_0 :=
      Ref.map
        (fun α =>
          match α with | MissingPathParams α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | MissingPathParams _ => Some (MissingPathParams β)
          | _ => None
          end).
  End PathRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.
    Definition Self : Set := axum.extract.rejection.PathRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.
    Definition Self : Set := axum.extract.rejection.PathRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.
  
  Module  Impl_axum_extract_rejection_PathRejection_t_2.
  Section Impl_axum_extract_rejection_PathRejection_t_2.
    Definition Self : Set := axum.extract.rejection.PathRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_PathRejection_t_2.
  End Impl_axum_extract_rejection_PathRejection_t_2.
  
  Module  Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.
  Section Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.
    Definition Self : Set := axum.extract.rejection.PathRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.path.FailedToDeserializePathParams.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.path.FailedToDeserializePathParams.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.
  End Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.
  
  Module  Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.
    Definition Self : Set := axum.extract.rejection.PathRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.MissingPathParams.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.MissingPathParams.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.
    Definition Self : Set := axum.extract.rejection.PathRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.
    Definition Self : Set := axum.extract.rejection.PathRejection.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.
  End Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.
  
  Module RawPathParamsRejection.
    Inductive t : Set :=
    | InvalidUtf8InPathParam (_ : axum.extract.path.InvalidUtf8InPathParam.t)
    | MissingPathParams (_ : axum.extract.rejection.MissingPathParams.t).
    
    Definition Get_InvalidUtf8InPathParam_0 :=
      Ref.map
        (fun α =>
          match α with | InvalidUtf8InPathParam α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | InvalidUtf8InPathParam _ => Some (InvalidUtf8InPathParam β)
          | _ => None
          end).
    
    Definition Get_MissingPathParams_0 :=
      Ref.map
        (fun α =>
          match α with | MissingPathParams α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | MissingPathParams _ => Some (MissingPathParams β)
          | _ => None
          end).
  End RawPathParamsRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.
    Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.
    Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.
  
  Module  Impl_axum_extract_rejection_RawPathParamsRejection_t_2.
  Section Impl_axum_extract_rejection_RawPathParamsRejection_t_2.
    Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_RawPathParamsRejection_t_2.
  End Impl_axum_extract_rejection_RawPathParamsRejection_t_2.
  
  Module  Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.
  Section Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.
    Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.path.InvalidUtf8InPathParam.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.path.InvalidUtf8InPathParam.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.
  End Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.
  
  Module  Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.
    Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.MissingPathParams.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.MissingPathParams.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.
    Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.
    Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.
  End Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.
  
  Module HostRejection.
    Inductive t : Set :=
    | FailedToResolveHost (_ : axum.extract.rejection.FailedToResolveHost.t).
    
    Definition Get_FailedToResolveHost_0 :=
      Ref.map
        (fun α => match α with | FailedToResolveHost α0 => Some α0 end)
        (fun β α =>
          match α with
          | FailedToResolveHost _ => Some (FailedToResolveHost β)
          end).
  End HostRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.
    Definition Self : Set := axum.extract.rejection.HostRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.
    Definition Self : Set := axum.extract.rejection.HostRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.
  
  Module  Impl_axum_extract_rejection_HostRejection_t_2.
  Section Impl_axum_extract_rejection_HostRejection_t_2.
    Definition Self : Set := axum.extract.rejection.HostRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_HostRejection_t_2.
  End Impl_axum_extract_rejection_HostRejection_t_2.
  
  Module  Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.
    Definition Self : Set := axum.extract.rejection.HostRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.FailedToResolveHost.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.FailedToResolveHost.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.
    Definition Self : Set := axum.extract.rejection.HostRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.
    Definition Self : Set := axum.extract.rejection.HostRejection.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.
  End Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.
  
  Module  MatchedPathMissing.
  Section MatchedPathMissing.
    Inductive t : Set := Build.
  End MatchedPathMissing.
  End MatchedPathMissing.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.
    Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.
    Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = $body,
                        status = http::StatusCode::$status,
                    );
                    (self.status(), $body).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.
  
  Module  Impl_axum_extract_rejection_MatchedPathMissing_t_2.
  Section Impl_axum_extract_rejection_MatchedPathMissing_t_2.
    Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
    
    (*
                pub fn body_text(&self) -> String {
                    $body.into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_MatchedPathMissing_t_2.
  End Impl_axum_extract_rejection_MatchedPathMissing_t_2.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.
    Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.
    Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.None;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.
  End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.
  
  Module  Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.
  Section Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.
    Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
    
    (*
                fn default() -> Self {
                    Self
                }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.
  End Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.
  
  Module MatchedPathRejection.
    Inductive t : Set :=
    | MatchedPathMissing (_ : axum.extract.rejection.MatchedPathMissing.t).
    
    Definition Get_MatchedPathMissing_0 :=
      Ref.map
        (fun α => match α with | MatchedPathMissing α0 => Some α0 end)
        (fun β α =>
          match α with
          | MatchedPathMissing _ => Some (MatchedPathMissing β)
          end).
  End MatchedPathRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.
    Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.
    Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.
  
  Module  Impl_axum_extract_rejection_MatchedPathRejection_t_2.
  Section Impl_axum_extract_rejection_MatchedPathRejection_t_2.
    Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_MatchedPathRejection_t_2.
  End Impl_axum_extract_rejection_MatchedPathRejection_t_2.
  
  Module  Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.
  Section Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.
    Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum.extract.rejection.MatchedPathMissing.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum.extract.rejection.MatchedPathMissing.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.
  End Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.
    Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.
    Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.
  End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.
  
  Module  NestedPathRejection.
  Section NestedPathRejection.
    Inductive t : Set := Build.
  End NestedPathRejection.
  End NestedPathRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.
  Section Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.
    Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.
  End Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.
    Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = $body,
                        status = http::StatusCode::$status,
                    );
                    (self.status(), $body).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.
  
  Module  Impl_axum_extract_rejection_NestedPathRejection_t_2.
  Section Impl_axum_extract_rejection_NestedPathRejection_t_2.
    Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    $body.into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_extract_rejection_NestedPathRejection_t_2.
  End Impl_axum_extract_rejection_NestedPathRejection_t_2.
  
  Module  Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.
  Section Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.
    Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.
  End Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.
  
  Module  Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.
  Section Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.
    Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.None;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.
  End Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.
  
  Module  Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.
  Section Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.
    Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
    
    (*
                fn default() -> Self {
                    Self
                }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.
  End Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.
End rejection.

Module  JsonDataError.
Section JsonDataError.
  Record t : Set := {
    x0 : axum_core.error.Error.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End JsonDataError.
End JsonDataError.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.
  Definition Self : Set := axum.extract.rejection.JsonDataError.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonDataError_t.

Module  Impl_axum_extract_rejection_JsonDataError_t_5.
Section Impl_axum_extract_rejection_JsonDataError_t_5.
  Definition Self : Set := axum.extract.rejection.JsonDataError.t.
  
  (*
              pub(crate) fn from_err<E>(err: E) -> Self
              where
                  E: Into<$crate::BoxError>,
              {
                  Self($crate::Error::new(err))
              }
  *)
  Definition from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
      (err : E)
      : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "from_err" := {
    Notations.double_colon := from_err (E := E);
  }.
End Impl_axum_extract_rejection_JsonDataError_t_5.
End Impl_axum_extract_rejection_JsonDataError_t_5.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.
  Definition Self : Set := axum.extract.rejection.JsonDataError.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = self.body_text(),
                      status = http::StatusCode::$status,
                  );
                  (self.status(), self.body_text()).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonDataError_t.

Module  Impl_axum_extract_rejection_JsonDataError_t_6.
Section Impl_axum_extract_rejection_JsonDataError_t_6.
  Definition Self : Set := axum.extract.rejection.JsonDataError.t.
  
  (*
              pub fn body_text(&self) -> String {
                  format!(concat!($body, ": {}"), self.0).into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_JsonDataError_t_6.
End Impl_axum_extract_rejection_JsonDataError_t_6.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.
  Definition Self : Set := axum.extract.rejection.JsonDataError.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_JsonDataError_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.
Section Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.
  Definition Self : Set := axum.extract.rejection.JsonDataError.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  Some(&self.0)
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.
End Impl_core_error_Error_for_axum_extract_rejection_JsonDataError_t.

Module  JsonSyntaxError.
Section JsonSyntaxError.
  Record t : Set := {
    x0 : axum_core.error.Error.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End JsonSyntaxError.
End JsonSyntaxError.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.
  Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonSyntaxError_t.

Module  Impl_axum_extract_rejection_JsonSyntaxError_t_5.
Section Impl_axum_extract_rejection_JsonSyntaxError_t_5.
  Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
  
  (*
              pub(crate) fn from_err<E>(err: E) -> Self
              where
                  E: Into<$crate::BoxError>,
              {
                  Self($crate::Error::new(err))
              }
  *)
  Definition from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
      (err : E)
      : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "from_err" := {
    Notations.double_colon := from_err (E := E);
  }.
End Impl_axum_extract_rejection_JsonSyntaxError_t_5.
End Impl_axum_extract_rejection_JsonSyntaxError_t_5.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.
  Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = self.body_text(),
                      status = http::StatusCode::$status,
                  );
                  (self.status(), self.body_text()).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonSyntaxError_t.

Module  Impl_axum_extract_rejection_JsonSyntaxError_t_6.
Section Impl_axum_extract_rejection_JsonSyntaxError_t_6.
  Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
  
  (*
              pub fn body_text(&self) -> String {
                  format!(concat!($body, ": {}"), self.0).into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_JsonSyntaxError_t_6.
End Impl_axum_extract_rejection_JsonSyntaxError_t_6.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.
  Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_JsonSyntaxError_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.
Section Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.
  Definition Self : Set := axum.extract.rejection.JsonSyntaxError.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  Some(&self.0)
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.
End Impl_core_error_Error_for_axum_extract_rejection_JsonSyntaxError_t.

Module  MissingJsonContentType.
Section MissingJsonContentType.
  Inductive t : Set := Build.
End MissingJsonContentType.
End MissingJsonContentType.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.
  Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingJsonContentType_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.
  Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = $body,
                      status = http::StatusCode::$status,
                  );
                  (self.status(), $body).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingJsonContentType_t.

Module  Impl_axum_extract_rejection_MissingJsonContentType_t_3.
Section Impl_axum_extract_rejection_MissingJsonContentType_t_3.
  Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
  
  (*
              pub fn body_text(&self) -> String {
                  $body.into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_MissingJsonContentType_t_3.
End Impl_axum_extract_rejection_MissingJsonContentType_t_3.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.
  Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_MissingJsonContentType_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.
Section Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.
  Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.None;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.
End Impl_core_error_Error_for_axum_extract_rejection_MissingJsonContentType_t.

Module  Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.
Section Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.
  Definition Self : Set := axum.extract.rejection.MissingJsonContentType.t.
  
  (*
              fn default() -> Self {
                  Self
              }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.
End Impl_core_default_Default_for_axum_extract_rejection_MissingJsonContentType_t.

Module  MissingExtension.
Section MissingExtension.
  Record t : Set := {
    x0 : axum_core.error.Error.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End MissingExtension.
End MissingExtension.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.
  Definition Self : Set := axum.extract.rejection.MissingExtension.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingExtension_t.

Module  Impl_axum_extract_rejection_MissingExtension_t_5.
Section Impl_axum_extract_rejection_MissingExtension_t_5.
  Definition Self : Set := axum.extract.rejection.MissingExtension.t.
  
  (*
              pub(crate) fn from_err<E>(err: E) -> Self
              where
                  E: Into<$crate::BoxError>,
              {
                  Self($crate::Error::new(err))
              }
  *)
  Definition from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
      (err : E)
      : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "from_err" := {
    Notations.double_colon := from_err (E := E);
  }.
End Impl_axum_extract_rejection_MissingExtension_t_5.
End Impl_axum_extract_rejection_MissingExtension_t_5.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.
  Definition Self : Set := axum.extract.rejection.MissingExtension.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = self.body_text(),
                      status = http::StatusCode::$status,
                  );
                  (self.status(), self.body_text()).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingExtension_t.

Module  Impl_axum_extract_rejection_MissingExtension_t_6.
Section Impl_axum_extract_rejection_MissingExtension_t_6.
  Definition Self : Set := axum.extract.rejection.MissingExtension.t.
  
  (*
              pub fn body_text(&self) -> String {
                  format!(concat!($body, ": {}"), self.0).into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_MissingExtension_t_6.
End Impl_axum_extract_rejection_MissingExtension_t_6.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.
  Definition Self : Set := axum.extract.rejection.MissingExtension.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_MissingExtension_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.
Section Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.
  Definition Self : Set := axum.extract.rejection.MissingExtension.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  Some(&self.0)
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.
End Impl_core_error_Error_for_axum_extract_rejection_MissingExtension_t.

Module  MissingPathParams.
Section MissingPathParams.
  Inductive t : Set := Build.
End MissingPathParams.
End MissingPathParams.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.
  Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_MissingPathParams_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.
  Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = $body,
                      status = http::StatusCode::$status,
                  );
                  (self.status(), $body).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MissingPathParams_t.

Module  Impl_axum_extract_rejection_MissingPathParams_t_3.
Section Impl_axum_extract_rejection_MissingPathParams_t_3.
  Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
  
  (*
              pub fn body_text(&self) -> String {
                  $body.into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_MissingPathParams_t_3.
End Impl_axum_extract_rejection_MissingPathParams_t_3.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.
  Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_MissingPathParams_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.
Section Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.
  Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.None;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.
End Impl_core_error_Error_for_axum_extract_rejection_MissingPathParams_t.

Module  Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.
Section Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.
  Definition Self : Set := axum.extract.rejection.MissingPathParams.t.
  
  (*
              fn default() -> Self {
                  Self
              }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.
End Impl_core_default_Default_for_axum_extract_rejection_MissingPathParams_t.

Module  InvalidFormContentType.
Section InvalidFormContentType.
  Inductive t : Set := Build.
End InvalidFormContentType.
End InvalidFormContentType.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.
  Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_InvalidFormContentType_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.
  Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = $body,
                      status = http::StatusCode::$status,
                  );
                  (self.status(), $body).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_InvalidFormContentType_t.

Module  Impl_axum_extract_rejection_InvalidFormContentType_t_3.
Section Impl_axum_extract_rejection_InvalidFormContentType_t_3.
  Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
  
  (*
              pub fn body_text(&self) -> String {
                  $body.into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_InvalidFormContentType_t_3.
End Impl_axum_extract_rejection_InvalidFormContentType_t_3.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.
  Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_InvalidFormContentType_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.
Section Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.
  Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.None;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.
End Impl_core_error_Error_for_axum_extract_rejection_InvalidFormContentType_t.

Module  Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.
Section Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.
  Definition Self : Set := axum.extract.rejection.InvalidFormContentType.t.
  
  (*
              fn default() -> Self {
                  Self
              }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.
End Impl_core_default_Default_for_axum_extract_rejection_InvalidFormContentType_t.

Module  FailedToResolveHost.
Section FailedToResolveHost.
  Inductive t : Set := Build.
End FailedToResolveHost.
End FailedToResolveHost.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.
  Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToResolveHost_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.
  Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = $body,
                      status = http::StatusCode::$status,
                  );
                  (self.status(), $body).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToResolveHost_t.

Module  Impl_axum_extract_rejection_FailedToResolveHost_t_3.
Section Impl_axum_extract_rejection_FailedToResolveHost_t_3.
  Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
  
  (*
              pub fn body_text(&self) -> String {
                  $body.into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_FailedToResolveHost_t_3.
End Impl_axum_extract_rejection_FailedToResolveHost_t_3.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.
  Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToResolveHost_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.
Section Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.
  Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.None;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.
End Impl_core_error_Error_for_axum_extract_rejection_FailedToResolveHost_t.

Module  Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.
Section Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.
  Definition Self : Set := axum.extract.rejection.FailedToResolveHost.t.
  
  (*
              fn default() -> Self {
                  Self
              }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.
End Impl_core_default_Default_for_axum_extract_rejection_FailedToResolveHost_t.

Module  FailedToDeserializeForm.
Section FailedToDeserializeForm.
  Record t : Set := {
    x0 : axum_core.error.Error.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End FailedToDeserializeForm.
End FailedToDeserializeForm.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeForm_t.

Module  Impl_axum_extract_rejection_FailedToDeserializeForm_t_5.
Section Impl_axum_extract_rejection_FailedToDeserializeForm_t_5.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
  
  (*
              pub(crate) fn from_err<E>(err: E) -> Self
              where
                  E: Into<$crate::BoxError>,
              {
                  Self($crate::Error::new(err))
              }
  *)
  Definition from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
      (err : E)
      : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "from_err" := {
    Notations.double_colon := from_err (E := E);
  }.
End Impl_axum_extract_rejection_FailedToDeserializeForm_t_5.
End Impl_axum_extract_rejection_FailedToDeserializeForm_t_5.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = self.body_text(),
                      status = http::StatusCode::$status,
                  );
                  (self.status(), self.body_text()).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeForm_t.

Module  Impl_axum_extract_rejection_FailedToDeserializeForm_t_6.
Section Impl_axum_extract_rejection_FailedToDeserializeForm_t_6.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
  
  (*
              pub fn body_text(&self) -> String {
                  format!(concat!($body, ": {}"), self.0).into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_FailedToDeserializeForm_t_6.
End Impl_axum_extract_rejection_FailedToDeserializeForm_t_6.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeForm_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.
Section Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeForm.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  Some(&self.0)
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.
End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeForm_t.

Module  FailedToDeserializeFormBody.
Section FailedToDeserializeFormBody.
  Record t : Set := {
    x0 : axum_core.error.Error.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End FailedToDeserializeFormBody.
End FailedToDeserializeFormBody.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeFormBody.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeFormBody_t.

Module  Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_5.
Section Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_5.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeFormBody.t.
  
  (*
              pub(crate) fn from_err<E>(err: E) -> Self
              where
                  E: Into<$crate::BoxError>,
              {
                  Self($crate::Error::new(err))
              }
  *)
  Definition from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
      (err : E)
      : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "from_err" := {
    Notations.double_colon := from_err (E := E);
  }.
End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_5.
End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_5.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeFormBody.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = self.body_text(),
                      status = http::StatusCode::$status,
                  );
                  (self.status(), self.body_text()).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeFormBody_t.

Module  Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_6.
Section Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_6.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeFormBody.t.
  
  (*
              pub fn body_text(&self) -> String {
                  format!(concat!($body, ": {}"), self.0).into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_6.
End Impl_axum_extract_rejection_FailedToDeserializeFormBody_t_6.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeFormBody.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeFormBody_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
Section Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
  Definition Self : Set := axum.extract.rejection.FailedToDeserializeFormBody.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  Some(&self.0)
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.
End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeFormBody_t.

Module  FailedToDeserializeQueryString.
Section FailedToDeserializeQueryString.
  Record t : Set := {
    x0 : axum_core.error.Error.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End FailedToDeserializeQueryString.
End FailedToDeserializeQueryString.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  Definition Self : Set :=
    axum.extract.rejection.FailedToDeserializeQueryString.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_FailedToDeserializeQueryString_t.

Module  Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_5.
Section Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_5.
  Definition Self : Set :=
    axum.extract.rejection.FailedToDeserializeQueryString.t.
  
  (*
              pub(crate) fn from_err<E>(err: E) -> Self
              where
                  E: Into<$crate::BoxError>,
              {
                  Self($crate::Error::new(err))
              }
  *)
  Definition from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
      (err : E)
      : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "from_err" := {
    Notations.double_colon := from_err (E := E);
  }.
End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_5.
End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_5.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  Definition Self : Set :=
    axum.extract.rejection.FailedToDeserializeQueryString.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = self.body_text(),
                      status = http::StatusCode::$status,
                  );
                  (self.status(), self.body_text()).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FailedToDeserializeQueryString_t.

Module  Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_6.
Section Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_6.
  Definition Self : Set :=
    axum.extract.rejection.FailedToDeserializeQueryString.t.
  
  (*
              pub fn body_text(&self) -> String {
                  format!(concat!($body, ": {}"), self.0).into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_6.
End Impl_axum_extract_rejection_FailedToDeserializeQueryString_t_6.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  Definition Self : Set :=
    axum.extract.rejection.FailedToDeserializeQueryString.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_FailedToDeserializeQueryString_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
Section Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
  Definition Self : Set :=
    axum.extract.rejection.FailedToDeserializeQueryString.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  Some(&self.0)
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.
End Impl_core_error_Error_for_axum_extract_rejection_FailedToDeserializeQueryString_t.

Module QueryRejection.
  Inductive t : Set :=
  |
    FailedToDeserializeQueryString
    (_ : axum.extract.rejection.FailedToDeserializeQueryString.t).
  
  Definition Get_FailedToDeserializeQueryString_0 :=
    Ref.map
      (fun α => match α with | FailedToDeserializeQueryString α0 => Some α0 end)
      (fun β α =>
        match α with
        | FailedToDeserializeQueryString _ =>
          Some (FailedToDeserializeQueryString β)
        end).
End QueryRejection.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.
  Definition Self : Set := axum.extract.rejection.QueryRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_QueryRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.
  Definition Self : Set := axum.extract.rejection.QueryRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_QueryRejection_t.

Module  Impl_axum_extract_rejection_QueryRejection_t_3.
Section Impl_axum_extract_rejection_QueryRejection_t_3.
  Definition Self : Set := axum.extract.rejection.QueryRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_QueryRejection_t_3.
End Impl_axum_extract_rejection_QueryRejection_t_3.

Module  Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.
  Definition Self : Set := axum.extract.rejection.QueryRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.rejection.FailedToDeserializeQueryString.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.FailedToDeserializeQueryString.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.
End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeQueryString_t_for_axum_extract_rejection_QueryRejection_t.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.
  Definition Self : Set := axum.extract.rejection.QueryRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_QueryRejection_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.
Section Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.
  Definition Self : Set := axum.extract.rejection.QueryRejection.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.
End Impl_core_error_Error_for_axum_extract_rejection_QueryRejection_t.

Module FormRejection.
  Inductive t : Set :=
  | InvalidFormContentType (_ : axum.extract.rejection.InvalidFormContentType.t)
  |
    FailedToDeserializeForm
    (_ : axum.extract.rejection.FailedToDeserializeForm.t)
  |
    FailedToDeserializeFormBody
    (_ : axum.extract.rejection.FailedToDeserializeFormBody.t)
  | BytesRejection (_ : axum_core.extract.rejection.BytesRejection.t).
  
  Definition Get_InvalidFormContentType_0 :=
    Ref.map
      (fun α =>
        match α with | InvalidFormContentType α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | InvalidFormContentType _ => Some (InvalidFormContentType β)
        | _ => None
        end).
  
  Definition Get_FailedToDeserializeForm_0 :=
    Ref.map
      (fun α =>
        match α with | FailedToDeserializeForm α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | FailedToDeserializeForm _ => Some (FailedToDeserializeForm β)
        | _ => None
        end).
  
  Definition Get_FailedToDeserializeFormBody_0 :=
    Ref.map
      (fun α =>
        match α with
        | FailedToDeserializeFormBody α0 => Some α0
        | _ => None
        end)
      (fun β α =>
        match α with
        | FailedToDeserializeFormBody _ => Some (FailedToDeserializeFormBody β)
        | _ => None
        end).
  
  Definition Get_BytesRejection_0 :=
    Ref.map
      (fun α => match α with | BytesRejection α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | BytesRejection _ => Some (BytesRejection β)
        | _ => None
        end).
End FormRejection.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.
  Definition Self : Set := axum.extract.rejection.FormRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_FormRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.
  Definition Self : Set := axum.extract.rejection.FormRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_FormRejection_t.

Module  Impl_axum_extract_rejection_FormRejection_t_3.
Section Impl_axum_extract_rejection_FormRejection_t_3.
  Definition Self : Set := axum.extract.rejection.FormRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_FormRejection_t_3.
End Impl_axum_extract_rejection_FormRejection_t_3.

Module  Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.
  Definition Self : Set := axum.extract.rejection.FormRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.rejection.InvalidFormContentType.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.InvalidFormContentType.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.
End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_FormRejection_t.

Module  Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.
  Definition Self : Set := axum.extract.rejection.FormRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.rejection.FailedToDeserializeForm.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.FailedToDeserializeForm.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.
End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeForm_t_for_axum_extract_rejection_FormRejection_t.

Module  Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.
  Definition Self : Set := axum.extract.rejection.FormRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.rejection.FailedToDeserializeFormBody.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.FailedToDeserializeFormBody.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.
End Impl_core_convert_From_axum_extract_rejection_FailedToDeserializeFormBody_t_for_axum_extract_rejection_FormRejection_t.

Module  Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.
Section Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.
  Definition Self : Set := axum.extract.rejection.FormRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum_core.extract.rejection.BytesRejection.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum_core.extract.rejection.BytesRejection.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.
End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_FormRejection_t.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.
  Definition Self : Set := axum.extract.rejection.FormRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_FormRejection_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.
Section Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.
  Definition Self : Set := axum.extract.rejection.FormRejection.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.
End Impl_core_error_Error_for_axum_extract_rejection_FormRejection_t.

Module RawFormRejection.
  Inductive t : Set :=
  | InvalidFormContentType (_ : axum.extract.rejection.InvalidFormContentType.t)
  | BytesRejection (_ : axum_core.extract.rejection.BytesRejection.t).
  
  Definition Get_InvalidFormContentType_0 :=
    Ref.map
      (fun α =>
        match α with | InvalidFormContentType α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | InvalidFormContentType _ => Some (InvalidFormContentType β)
        | _ => None
        end).
  
  Definition Get_BytesRejection_0 :=
    Ref.map
      (fun α => match α with | BytesRejection α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | BytesRejection _ => Some (BytesRejection β)
        | _ => None
        end).
End RawFormRejection.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.
  Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_RawFormRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.
  Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawFormRejection_t.

Module  Impl_axum_extract_rejection_RawFormRejection_t_3.
Section Impl_axum_extract_rejection_RawFormRejection_t_3.
  Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_RawFormRejection_t_3.
End Impl_axum_extract_rejection_RawFormRejection_t_3.

Module  Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.
  Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.rejection.InvalidFormContentType.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.InvalidFormContentType.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.
End Impl_core_convert_From_axum_extract_rejection_InvalidFormContentType_t_for_axum_extract_rejection_RawFormRejection_t.

Module  Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.
Section Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.
  Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum_core.extract.rejection.BytesRejection.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum_core.extract.rejection.BytesRejection.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.
End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_RawFormRejection_t.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.
  Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_RawFormRejection_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.
Section Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.
  Definition Self : Set := axum.extract.rejection.RawFormRejection.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.
End Impl_core_error_Error_for_axum_extract_rejection_RawFormRejection_t.

Module JsonRejection.
  Inductive t : Set :=
  | JsonDataError (_ : axum.extract.rejection.JsonDataError.t)
  | JsonSyntaxError (_ : axum.extract.rejection.JsonSyntaxError.t)
  | MissingJsonContentType (_ : axum.extract.rejection.MissingJsonContentType.t)
  | BytesRejection (_ : axum_core.extract.rejection.BytesRejection.t).
  
  Definition Get_JsonDataError_0 :=
    Ref.map
      (fun α => match α with | JsonDataError α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | JsonDataError _ => Some (JsonDataError β)
        | _ => None
        end).
  
  Definition Get_JsonSyntaxError_0 :=
    Ref.map
      (fun α => match α with | JsonSyntaxError α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | JsonSyntaxError _ => Some (JsonSyntaxError β)
        | _ => None
        end).
  
  Definition Get_MissingJsonContentType_0 :=
    Ref.map
      (fun α =>
        match α with | MissingJsonContentType α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | MissingJsonContentType _ => Some (MissingJsonContentType β)
        | _ => None
        end).
  
  Definition Get_BytesRejection_0 :=
    Ref.map
      (fun α => match α with | BytesRejection α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | BytesRejection _ => Some (BytesRejection β)
        | _ => None
        end).
End JsonRejection.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.
  Definition Self : Set := axum.extract.rejection.JsonRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_JsonRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.
  Definition Self : Set := axum.extract.rejection.JsonRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_JsonRejection_t.

Module  Impl_axum_extract_rejection_JsonRejection_t_3.
Section Impl_axum_extract_rejection_JsonRejection_t_3.
  Definition Self : Set := axum.extract.rejection.JsonRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_JsonRejection_t_3.
End Impl_axum_extract_rejection_JsonRejection_t_3.

Module  Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.
  Definition Self : Set := axum.extract.rejection.JsonRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from (inner : axum.extract.rejection.JsonDataError.t) : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.JsonDataError.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.
End Impl_core_convert_From_axum_extract_rejection_JsonDataError_t_for_axum_extract_rejection_JsonRejection_t.

Module  Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.
  Definition Self : Set := axum.extract.rejection.JsonRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from (inner : axum.extract.rejection.JsonSyntaxError.t) : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.JsonSyntaxError.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.
End Impl_core_convert_From_axum_extract_rejection_JsonSyntaxError_t_for_axum_extract_rejection_JsonRejection_t.

Module  Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.
  Definition Self : Set := axum.extract.rejection.JsonRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.rejection.MissingJsonContentType.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.MissingJsonContentType.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.
End Impl_core_convert_From_axum_extract_rejection_MissingJsonContentType_t_for_axum_extract_rejection_JsonRejection_t.

Module  Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.
Section Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.
  Definition Self : Set := axum.extract.rejection.JsonRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum_core.extract.rejection.BytesRejection.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum_core.extract.rejection.BytesRejection.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.
End Impl_core_convert_From_axum_core_extract_rejection_BytesRejection_t_for_axum_extract_rejection_JsonRejection_t.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.
  Definition Self : Set := axum.extract.rejection.JsonRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_JsonRejection_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.
Section Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.
  Definition Self : Set := axum.extract.rejection.JsonRejection.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.
End Impl_core_error_Error_for_axum_extract_rejection_JsonRejection_t.

Module ExtensionRejection.
  Inductive t : Set :=
  | MissingExtension (_ : axum.extract.rejection.MissingExtension.t).
  
  Definition Get_MissingExtension_0 :=
    Ref.map
      (fun α => match α with | MissingExtension α0 => Some α0 end)
      (fun β α =>
        match α with | MissingExtension _ => Some (MissingExtension β) end).
End ExtensionRejection.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.
  Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_ExtensionRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.
  Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_ExtensionRejection_t.

Module  Impl_axum_extract_rejection_ExtensionRejection_t_3.
Section Impl_axum_extract_rejection_ExtensionRejection_t_3.
  Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_ExtensionRejection_t_3.
End Impl_axum_extract_rejection_ExtensionRejection_t_3.

Module  Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.
  Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.rejection.MissingExtension.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.MissingExtension.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.
End Impl_core_convert_From_axum_extract_rejection_MissingExtension_t_for_axum_extract_rejection_ExtensionRejection_t.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.
  Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_ExtensionRejection_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.
Section Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.
  Definition Self : Set := axum.extract.rejection.ExtensionRejection.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.
End Impl_core_error_Error_for_axum_extract_rejection_ExtensionRejection_t.

Module PathRejection.
  Inductive t : Set :=
  |
    FailedToDeserializePathParams
    (_ : axum.extract.path.FailedToDeserializePathParams.t)
  | MissingPathParams (_ : axum.extract.rejection.MissingPathParams.t).
  
  Definition Get_FailedToDeserializePathParams_0 :=
    Ref.map
      (fun α =>
        match α with
        | FailedToDeserializePathParams α0 => Some α0
        | _ => None
        end)
      (fun β α =>
        match α with
        | FailedToDeserializePathParams _ =>
          Some (FailedToDeserializePathParams β)
        | _ => None
        end).
  
  Definition Get_MissingPathParams_0 :=
    Ref.map
      (fun α => match α with | MissingPathParams α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | MissingPathParams _ => Some (MissingPathParams β)
        | _ => None
        end).
End PathRejection.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.
  Definition Self : Set := axum.extract.rejection.PathRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_PathRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.
  Definition Self : Set := axum.extract.rejection.PathRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_PathRejection_t.

Module  Impl_axum_extract_rejection_PathRejection_t_3.
Section Impl_axum_extract_rejection_PathRejection_t_3.
  Definition Self : Set := axum.extract.rejection.PathRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_PathRejection_t_3.
End Impl_axum_extract_rejection_PathRejection_t_3.

Module  Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.
Section Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.
  Definition Self : Set := axum.extract.rejection.PathRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.path.FailedToDeserializePathParams.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.path.FailedToDeserializePathParams.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.
End Impl_core_convert_From_axum_extract_path_FailedToDeserializePathParams_t_for_axum_extract_rejection_PathRejection_t.

Module  Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.
  Definition Self : Set := axum.extract.rejection.PathRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.rejection.MissingPathParams.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.MissingPathParams.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.
End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_PathRejection_t.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.
  Definition Self : Set := axum.extract.rejection.PathRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_PathRejection_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.
Section Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.
  Definition Self : Set := axum.extract.rejection.PathRejection.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.
End Impl_core_error_Error_for_axum_extract_rejection_PathRejection_t.

Module RawPathParamsRejection.
  Inductive t : Set :=
  | InvalidUtf8InPathParam (_ : axum.extract.path.InvalidUtf8InPathParam.t)
  | MissingPathParams (_ : axum.extract.rejection.MissingPathParams.t).
  
  Definition Get_InvalidUtf8InPathParam_0 :=
    Ref.map
      (fun α =>
        match α with | InvalidUtf8InPathParam α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | InvalidUtf8InPathParam _ => Some (InvalidUtf8InPathParam β)
        | _ => None
        end).
  
  Definition Get_MissingPathParams_0 :=
    Ref.map
      (fun α => match α with | MissingPathParams α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | MissingPathParams _ => Some (MissingPathParams β)
        | _ => None
        end).
End RawPathParamsRejection.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.
  Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_RawPathParamsRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.
  Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_RawPathParamsRejection_t.

Module  Impl_axum_extract_rejection_RawPathParamsRejection_t_3.
Section Impl_axum_extract_rejection_RawPathParamsRejection_t_3.
  Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_RawPathParamsRejection_t_3.
End Impl_axum_extract_rejection_RawPathParamsRejection_t_3.

Module  Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.
Section Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.
  Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.path.InvalidUtf8InPathParam.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.path.InvalidUtf8InPathParam.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.
End Impl_core_convert_From_axum_extract_path_InvalidUtf8InPathParam_t_for_axum_extract_rejection_RawPathParamsRejection_t.

Module  Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.
  Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.rejection.MissingPathParams.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.MissingPathParams.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.
End Impl_core_convert_From_axum_extract_rejection_MissingPathParams_t_for_axum_extract_rejection_RawPathParamsRejection_t.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.
  Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_RawPathParamsRejection_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.
Section Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.
  Definition Self : Set := axum.extract.rejection.RawPathParamsRejection.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.
End Impl_core_error_Error_for_axum_extract_rejection_RawPathParamsRejection_t.

Module HostRejection.
  Inductive t : Set :=
  | FailedToResolveHost (_ : axum.extract.rejection.FailedToResolveHost.t).
  
  Definition Get_FailedToResolveHost_0 :=
    Ref.map
      (fun α => match α with | FailedToResolveHost α0 => Some α0 end)
      (fun β α =>
        match α with
        | FailedToResolveHost _ => Some (FailedToResolveHost β)
        end).
End HostRejection.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.
  Definition Self : Set := axum.extract.rejection.HostRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_HostRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.
  Definition Self : Set := axum.extract.rejection.HostRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_HostRejection_t.

Module  Impl_axum_extract_rejection_HostRejection_t_3.
Section Impl_axum_extract_rejection_HostRejection_t_3.
  Definition Self : Set := axum.extract.rejection.HostRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_HostRejection_t_3.
End Impl_axum_extract_rejection_HostRejection_t_3.

Module  Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.
  Definition Self : Set := axum.extract.rejection.HostRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.rejection.FailedToResolveHost.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.FailedToResolveHost.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.
End Impl_core_convert_From_axum_extract_rejection_FailedToResolveHost_t_for_axum_extract_rejection_HostRejection_t.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.
  Definition Self : Set := axum.extract.rejection.HostRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_HostRejection_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.
Section Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.
  Definition Self : Set := axum.extract.rejection.HostRejection.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.
End Impl_core_error_Error_for_axum_extract_rejection_HostRejection_t.

Module  MatchedPathMissing.
Section MatchedPathMissing.
  Inductive t : Set := Build.
End MatchedPathMissing.
End MatchedPathMissing.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.
  Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathMissing_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.
  Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = $body,
                      status = http::StatusCode::$status,
                  );
                  (self.status(), $body).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathMissing_t.

Module  Impl_axum_extract_rejection_MatchedPathMissing_t_3.
Section Impl_axum_extract_rejection_MatchedPathMissing_t_3.
  Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
  
  (*
              pub fn body_text(&self) -> String {
                  $body.into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_MatchedPathMissing_t_3.
End Impl_axum_extract_rejection_MatchedPathMissing_t_3.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.
  Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathMissing_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.
Section Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.
  Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.None;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.
End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathMissing_t.

Module  Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.
Section Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.
  Definition Self : Set := axum.extract.rejection.MatchedPathMissing.t.
  
  (*
              fn default() -> Self {
                  Self
              }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.
End Impl_core_default_Default_for_axum_extract_rejection_MatchedPathMissing_t.

Module MatchedPathRejection.
  Inductive t : Set :=
  | MatchedPathMissing (_ : axum.extract.rejection.MatchedPathMissing.t).
  
  Definition Get_MatchedPathMissing_0 :=
    Ref.map
      (fun α => match α with | MatchedPathMissing α0 => Some α0 end)
      (fun β α =>
        match α with | MatchedPathMissing _ => Some (MatchedPathMissing β) end).
End MatchedPathRejection.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.
  Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_MatchedPathRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.
  Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_MatchedPathRejection_t.

Module  Impl_axum_extract_rejection_MatchedPathRejection_t_3.
Section Impl_axum_extract_rejection_MatchedPathRejection_t_3.
  Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_MatchedPathRejection_t_3.
End Impl_axum_extract_rejection_MatchedPathRejection_t_3.

Module  Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.
Section Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.
  Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum.extract.rejection.MatchedPathMissing.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum.extract.rejection.MatchedPathMissing.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.
End Impl_core_convert_From_axum_extract_rejection_MatchedPathMissing_t_for_axum_extract_rejection_MatchedPathRejection_t.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.
  Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_MatchedPathRejection_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.
Section Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.
  Definition Self : Set := axum.extract.rejection.MatchedPathRejection.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.
End Impl_core_error_Error_for_axum_extract_rejection_MatchedPathRejection_t.

Module  NestedPathRejection.
Section NestedPathRejection.
  Inductive t : Set := Build.
End NestedPathRejection.
End NestedPathRejection.

Module  Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.
Section Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.
  Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.
End Impl_core_fmt_Debug_for_axum_extract_rejection_NestedPathRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.
  Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = $body,
                      status = http::StatusCode::$status,
                  );
                  (self.status(), $body).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extract_rejection_NestedPathRejection_t.

Module  Impl_axum_extract_rejection_NestedPathRejection_t_3.
Section Impl_axum_extract_rejection_NestedPathRejection_t_3.
  Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  $body.into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_extract_rejection_NestedPathRejection_t_3.
End Impl_axum_extract_rejection_NestedPathRejection_t_3.

Module  Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.
Section Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.
  Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.
End Impl_core_fmt_Display_for_axum_extract_rejection_NestedPathRejection_t.

Module  Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.
Section Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.
  Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.None;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.
End Impl_core_error_Error_for_axum_extract_rejection_NestedPathRejection_t.

Module  Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.
Section Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.
  Definition Self : Set := axum.extract.rejection.NestedPathRejection.t.
  
  (*
              fn default() -> Self {
                  Self
              }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.
End Impl_core_default_Default_for_axum_extract_rejection_NestedPathRejection_t.

Module host.
  Definition X_FORWARDED_HOST_HEADER_KEY : M.Val (ref str.t) :=
    M.run (M.pure foo).
  
  Module  Host.
  Section Host.
    Record t : Set := {
      x0 : alloc.string.String.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Host.
  End Host.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_host_Host_t.
  Section Impl_core_fmt_Debug_for_axum_extract_host_Host_t.
    Definition Self : Set := axum.extract.host.Host.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_host_Host_t.
  End Impl_core_fmt_Debug_for_axum_extract_host_Host_t.
  
  Module  Impl_core_clone_Clone_for_axum_extract_host_Host_t.
  Section Impl_core_clone_Clone_for_axum_extract_host_Host_t.
    Definition Self : Set := axum.extract.host.Host.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum.extract.host.Host.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_host_Host_t.
  End Impl_core_clone_Clone_for_axum_extract_host_Host_t.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.extract.host.Host.t.
    
    (*
        type Rejection = HostRejection;
    *)
    Definition Rejection : Set := axum.extract.rejection.HostRejection.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
            if let Some(host) = parse_forwarded(&parts.headers) {
                return Ok(Host(host.to_owned()));
            }
    
            if let Some(host) = parts
                .headers
                .get(X_FORWARDED_HOST_HEADER_KEY)
                .and_then(|host| host.to_str().ok())
            {
                return Ok(Host(host.to_owned()));
            }
    
            if let Some(host) = parts
                .headers
                .get(http::header::HOST)
                .and_then(|host| host.to_str().ok())
            {
                return Ok(Host(host.to_owned()));
            }
    
            if let Some(host) = parts.uri.host() {
                return Ok(Host(host.to_owned()));
            }
    
            Err(HostRejection::FailedToResolveHost(FailedToResolveHost))
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (_state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.
  
  (*
  fn parse_forwarded(headers: &HeaderMap) -> Option<&str> {
      // if there are multiple `Forwarded` `HeaderMap::get` will return the first one
      let forwarded_values = headers.get(FORWARDED)?.to_str().ok()?;
  
      // get the first set of values
      let first_value = forwarded_values.split(',').nth(0)?;
  
      // find the value of the `host` field
      first_value.split(';').find_map(|pair| {
          let (key, value) = pair.split_once('=')?;
          key.trim()
              .eq_ignore_ascii_case("host")
              .then(|| value.trim().trim_matches('"'))
      })
  }
  "
  *)
  Definition parse_forwarded
      (headers
        :
        ref (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
      : M (core.option.Option.t (ref str.t)) :=
    let* headers := M.alloc headers in
    M.read foo.
End host.

Definition X_FORWARDED_HOST_HEADER_KEY : M.Val (ref str.t) :=
  M.run (M.pure foo).

Module  Host.
Section Host.
  Record t : Set := {
    x0 : alloc.string.String.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Host.
End Host.

Module  Impl_core_fmt_Debug_for_axum_extract_host_Host_t.
Section Impl_core_fmt_Debug_for_axum_extract_host_Host_t.
  Definition Self : Set := axum.extract.host.Host.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_host_Host_t.
End Impl_core_fmt_Debug_for_axum_extract_host_Host_t.

Module  Impl_core_clone_Clone_for_axum_extract_host_Host_t.
Section Impl_core_clone_Clone_for_axum_extract_host_Host_t.
  Definition Self : Set := axum.extract.host.Host.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.extract.host.Host.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_host_Host_t.
End Impl_core_clone_Clone_for_axum_extract_host_Host_t.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.extract.host.Host.t.
  
  (*
      type Rejection = HostRejection;
  *)
  Definition Rejection : Set := axum.extract.rejection.HostRejection.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
          if let Some(host) = parse_forwarded(&parts.headers) {
              return Ok(Host(host.to_owned()));
          }
  
          if let Some(host) = parts
              .headers
              .get(X_FORWARDED_HOST_HEADER_KEY)
              .and_then(|host| host.to_str().ok())
          {
              return Ok(Host(host.to_owned()));
          }
  
          if let Some(host) = parts
              .headers
              .get(http::header::HOST)
              .and_then(|host| host.to_str().ok())
          {
              return Ok(Host(host.to_owned()));
          }
  
          if let Some(host) = parts.uri.host() {
              return Ok(Host(host.to_owned()));
          }
  
          Err(HostRejection::FailedToResolveHost(FailedToResolveHost))
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (_state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_host_Host_t.

(*
fn parse_forwarded(headers: &HeaderMap) -> Option<&str> {
    // if there are multiple `Forwarded` `HeaderMap::get` will return the first one
    let forwarded_values = headers.get(FORWARDED)?.to_str().ok()?;

    // get the first set of values
    let first_value = forwarded_values.split(',').nth(0)?;

    // find the value of the `host` field
    first_value.split(';').find_map(|pair| {
        let (key, value) = pair.split_once('=')?;
        key.trim()
            .eq_ignore_ascii_case("host")
            .then(|| value.trim().trim_matches('"'))
    })
}
"
*)
Definition parse_forwarded
    (headers
      :
      ref (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
    : M (core.option.Option.t (ref str.t)) :=
  let* headers := M.alloc headers in
  M.read foo.

Module nested_path.
  Module  NestedPath.
  Section NestedPath.
    Record t : Set := {
      x0 : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End NestedPath.
  End NestedPath.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.
  Section Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.
    Definition Self : Set := axum.extract.nested_path.NestedPath.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.
  End Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.
  
  Module  Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.
  Section Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.
    Definition Self : Set := axum.extract.nested_path.NestedPath.t.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M axum.extract.nested_path.NestedPath.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.
  End Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.
  
  Module  Impl_axum_extract_nested_path_NestedPath_t_2.
  Section Impl_axum_extract_nested_path_NestedPath_t_2.
    Definition Self : Set := axum.extract.nested_path.NestedPath.t.
    
    (*
        pub fn as_str(&self) -> &str {
            &self.0
        }
    *)
    Definition as_str (self : ref Self) : M (ref str.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_str :
      Notations.DoubleColon Self "as_str" := {
      Notations.double_colon := as_str;
    }.
  End Impl_axum_extract_nested_path_NestedPath_t_2.
  End Impl_axum_extract_nested_path_NestedPath_t_2.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.extract.nested_path.NestedPath.t.
    
    (*
        type Rejection = NestedPathRejection;
    *)
    Definition Rejection : Set := axum.extract.rejection.NestedPathRejection.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
            match parts.extensions.get::<Self>() {
                Some(nested_path) => Ok(nested_path.clone()),
                None => Err(NestedPathRejection),
            }
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (_state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.
  
  Module  SetNestedPath.
  Section SetNestedPath.
    Context (S : Set).
    
    Record t : Set := {
      inner : S;
      path : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Definition Get_path :=
      Ref.map (fun α => Some α.(path)) (fun β α => Some (α <| path := β |>)).
  End SetNestedPath.
  End SetNestedPath.
  
  Module  Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.
  Section Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.extract.nested_path.SetNestedPath.t S.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum.extract.nested_path.SetNestedPath.t S) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.
  End Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.
  
  Module  Impl_axum_extract_nested_path_SetNestedPath_t_S_2.
  Section Impl_axum_extract_nested_path_SetNestedPath_t_S_2.
    Context {S : Set}.
    
    Definition Self : Set := axum.extract.nested_path.SetNestedPath.t S.
    
    (*
        pub(crate) fn layer(path: &str) -> impl Layer<S, Service = Self> + Clone {
            let path = Arc::from(path);
            layer_fn(move |inner| Self {
                inner,
                path: Arc::clone(&path),
            })
        }
    *)
    Definition layer (path : ref str.t) : M _ (* OpaqueTy *) :=
      let* path := M.alloc path in
      M.read foo.
    
    Global Instance AssociatedFunction_layer :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer;
    }.
  End Impl_axum_extract_nested_path_SetNestedPath_t_S_2.
  End Impl_axum_extract_nested_path_SetNestedPath_t_S_2.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.
  Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.
    Context {S B : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S
          (Request := ltac:(axum_core.extract.Request B))}.
    
    Definition Self : Set := axum.extract.nested_path.SetNestedPath.t S.
    
    (*
        type Response = S::Response;
    *)
    Definition Response : Set := S::type["Response"].t.
    
    (*
        type Error = S::Error;
    *)
    Definition Error : Set := S::type["Error"].t.
    
    (*
        type Future = S::Future;
    *)
    Definition Future : Set := S::type["Future"].t.
    
    (*
        fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            self.inner.poll_ready(cx)
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, mut req: Request<B>) -> Self::Future {
            if let Some(prev) = req.extensions_mut().get_mut::<NestedPath>() {
                let new_path = if prev.as_str() == "/" {
                    Arc::clone(&self.path)
                } else {
                    format!("{}{}", prev.as_str().trim_end_matches('/'), self.path).into()
                };
                prev.0 = new_path;
            } else {
                req.extensions_mut()
                    .insert(NestedPath(Arc::clone(&self.path)));
            };
    
            self.inner.call(req)
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req : ltac:(axum_core.extract.Request B))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request B)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.
End nested_path.

Module  NestedPath.
Section NestedPath.
  Record t : Set := {
    x0 : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End NestedPath.
End NestedPath.

Module  Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.
Section Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.
  Definition Self : Set := axum.extract.nested_path.NestedPath.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.
End Impl_core_fmt_Debug_for_axum_extract_nested_path_NestedPath_t.

Module  Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.
Section Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.
  Definition Self : Set := axum.extract.nested_path.NestedPath.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M axum.extract.nested_path.NestedPath.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.
End Impl_core_clone_Clone_for_axum_extract_nested_path_NestedPath_t.

Module  Impl_axum_extract_nested_path_NestedPath_t_3.
Section Impl_axum_extract_nested_path_NestedPath_t_3.
  Definition Self : Set := axum.extract.nested_path.NestedPath.t.
  
  (*
      pub fn as_str(&self) -> &str {
          &self.0
      }
  *)
  Definition as_str (self : ref Self) : M (ref str.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_str :
    Notations.DoubleColon Self "as_str" := {
    Notations.double_colon := as_str;
  }.
End Impl_axum_extract_nested_path_NestedPath_t_3.
End Impl_axum_extract_nested_path_NestedPath_t_3.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.extract.nested_path.NestedPath.t.
  
  (*
      type Rejection = NestedPathRejection;
  *)
  Definition Rejection : Set := axum.extract.rejection.NestedPathRejection.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
          match parts.extensions.get::<Self>() {
              Some(nested_path) => Ok(nested_path.clone()),
              None => Err(NestedPathRejection),
          }
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (_state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_nested_path_NestedPath_t.

Module  SetNestedPath.
Section SetNestedPath.
  Context (S : Set).
  
  Record t : Set := {
    inner : S;
    path : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Definition Get_path :=
    Ref.map (fun α => Some α.(path)) (fun β α => Some (α <| path := β |>)).
End SetNestedPath.
End SetNestedPath.

Module  Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.
Section Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.extract.nested_path.SetNestedPath.t S.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum.extract.nested_path.SetNestedPath.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.
End Impl_core_clone_Clone_for_axum_extract_nested_path_SetNestedPath_t_S.

Module  Impl_axum_extract_nested_path_SetNestedPath_t_S_3.
Section Impl_axum_extract_nested_path_SetNestedPath_t_S_3.
  Context {S : Set}.
  
  Definition Self : Set := axum.extract.nested_path.SetNestedPath.t S.
  
  (*
      pub(crate) fn layer(path: &str) -> impl Layer<S, Service = Self> + Clone {
          let path = Arc::from(path);
          layer_fn(move |inner| Self {
              inner,
              path: Arc::clone(&path),
          })
      }
  *)
  Definition layer (path : ref str.t) : M _ (* OpaqueTy *) :=
    let* path := M.alloc path in
    M.read foo.
  
  Global Instance AssociatedFunction_layer :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer;
  }.
End Impl_axum_extract_nested_path_SetNestedPath_t_S_3.
End Impl_axum_extract_nested_path_SetNestedPath_t_S_3.

Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.
Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.
  Context {S B : Set}.
  
  Context
    {ℋ_0 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request B))}.
  
  Definition Self : Set := axum.extract.nested_path.SetNestedPath.t S.
  
  (*
      type Response = S::Response;
  *)
  Definition Response : Set := S::type["Response"].t.
  
  (*
      type Error = S::Error;
  *)
  Definition Error : Set := S::type["Error"].t.
  
  (*
      type Future = S::Future;
  *)
  Definition Future : Set := S::type["Future"].t.
  
  (*
      fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          self.inner.poll_ready(cx)
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, mut req: Request<B>) -> Self::Future {
          if let Some(prev) = req.extensions_mut().get_mut::<NestedPath>() {
              let new_path = if prev.as_str() == "/" {
                  Arc::clone(&self.path)
              } else {
                  format!("{}{}", prev.as_str().trim_end_matches('/'), self.path).into()
              };
              prev.0 = new_path;
          } else {
              req.extensions_mut()
                  .insert(NestedPath(Arc::clone(&self.path)));
          };
  
          self.inner.call(req)
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req : ltac:(axum_core.extract.Request B))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request B)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_extract_nested_path_SetNestedPath_t_S.

Module raw_form.
  Module  RawForm.
  Section RawForm.
    Record t : Set := {
      x0 : bytes.bytes.Bytes.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End RawForm.
  End RawForm.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.
  Section Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.
    Definition Self : Set := axum.extract.raw_form.RawForm.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.
  End Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.
  Section Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.extract.raw_form.RawForm.t.
    
    (*
        type Rejection = RawFormRejection;
    *)
    Definition Rejection : Set := axum.extract.rejection.RawFormRejection.t.
    
    (*
        async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
            if req.method() == Method::GET {
                if let Some(query) = req.uri().query() {
                    return Ok(Self(Bytes::copy_from_slice(query.as_bytes())));
                }
    
                Ok(Self(Bytes::new()))
            } else {
                if !has_content_type(req.headers(), &mime::APPLICATION_WWW_FORM_URLENCODED) {
                    return Err(InvalidFormContentType.into());
                }
    
                Ok(Self(Bytes::from_request(req, state).await?))
            }
        }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.
  End Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.
End raw_form.

Module  RawForm.
Section RawForm.
  Record t : Set := {
    x0 : bytes.bytes.Bytes.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End RawForm.
End RawForm.

Module  Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.
Section Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.
  Definition Self : Set := axum.extract.raw_form.RawForm.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.
End Impl_core_fmt_Debug_for_axum_extract_raw_form_RawForm_t.

Module  Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.
Section Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.extract.raw_form.RawForm.t.
  
  (*
      type Rejection = RawFormRejection;
  *)
  Definition Rejection : Set := axum.extract.rejection.RawFormRejection.t.
  
  (*
      async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
          if req.method() == Method::GET {
              if let Some(query) = req.uri().query() {
                  return Ok(Self(Bytes::copy_from_slice(query.as_bytes())));
              }
  
              Ok(Self(Bytes::new()))
          } else {
              if !has_content_type(req.headers(), &mime::APPLICATION_WWW_FORM_URLENCODED) {
                  return Err(InvalidFormContentType.into());
              }
  
              Ok(Self(Bytes::from_request(req, state).await?))
          }
      }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.
End Impl_axum_core_extract_FromRequest_S_for_axum_extract_raw_form_RawForm_t.

Module raw_query.
  Module  RawQuery.
  Section RawQuery.
    Record t : Set := {
      x0 : core.option.Option.t alloc.string.String.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End RawQuery.
  End RawQuery.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.
  Section Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.
    Definition Self : Set := axum.extract.raw_query.RawQuery.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.
  End Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.extract.raw_query.RawQuery.t.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
            let query = parts.uri.query().map(|query| query.to_owned());
            Ok(Self(query))
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (_state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.
End raw_query.

Module  RawQuery.
Section RawQuery.
  Record t : Set := {
    x0 : core.option.Option.t alloc.string.String.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End RawQuery.
End RawQuery.

Module  Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.
Section Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.
  Definition Self : Set := axum.extract.raw_query.RawQuery.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.
End Impl_core_fmt_Debug_for_axum_extract_raw_query_RawQuery_t.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.extract.raw_query.RawQuery.t.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
          let query = parts.uri.query().map(|query| query.to_owned());
          Ok(Self(query))
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (_state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_raw_query_RawQuery_t.

Module request_parts.
  Module  OriginalUri.
  Section OriginalUri.
    Record t : Set := {
      x0 : http.uri.Uri.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End OriginalUri.
  End OriginalUri.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.
  Section Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.
    Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.
  End Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.
  
  Module  Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.
  Section Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.
    Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M axum.extract.request_parts.OriginalUri.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.
  End Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
            let uri = Extension::<Self>::from_request_parts(parts, state)
                .await
                .unwrap_or_else(|_| Extension(OriginalUri(parts.uri.clone())))
                .0;
            Ok(uri)
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.
  
  Module  Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.
  Section Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.
    Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
    
    (*
                type Target = $ty;
    *)
    Definition Target : Set := http.uri.Uri.t.
    
    (*
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.
  End Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.
  
  Module  Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.
  Section Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.
    Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
    
    (*
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
    *)
    Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref_mut :
      Notations.DoubleColon Self "deref_mut" := {
      Notations.double_colon := deref_mut;
    }.
    
    Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
      core.ops.deref.DerefMut.deref_mut := deref_mut;
    }.
  End Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.
  End Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.
End request_parts.

Module  OriginalUri.
Section OriginalUri.
  Record t : Set := {
    x0 : http.uri.Uri.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End OriginalUri.
End OriginalUri.

Module  Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.
Section Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.
  Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.
End Impl_core_fmt_Debug_for_axum_extract_request_parts_OriginalUri_t.

Module  Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.
Section Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.
  Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M axum.extract.request_parts.OriginalUri.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.
End Impl_core_clone_Clone_for_axum_extract_request_parts_OriginalUri_t.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
          let uri = Extension::<Self>::from_request_parts(parts, state)
              .await
              .unwrap_or_else(|_| Extension(OriginalUri(parts.uri.clone())))
              .0;
          Ok(uri)
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_request_parts_OriginalUri_t.

Module  Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.
Section Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.
  Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
  
  (*
              type Target = $ty;
  *)
  Definition Target : Set := http.uri.Uri.t.
  
  (*
              fn deref(&self) -> &Self::Target {
                  &self.0
              }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.
End Impl_core_ops_deref_Deref_for_axum_extract_request_parts_OriginalUri_t.

Module  Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.
Section Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.
  Definition Self : Set := axum.extract.request_parts.OriginalUri.t.
  
  (*
              fn deref_mut(&mut self) -> &mut Self::Target {
                  &mut self.0
              }
  *)
  Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref_mut :
    Notations.DoubleColon Self "deref_mut" := {
    Notations.double_colon := deref_mut;
  }.
  
  Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
    core.ops.deref.DerefMut.deref_mut := deref_mut;
  }.
End Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.
End Impl_core_ops_deref_DerefMut_for_axum_extract_request_parts_OriginalUri_t.

Module state.
  Module  State.
  Section State.
    Context {S : Set}.
    
    Record t : Set := {
      x0 : S;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End State.
  End State.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.
  Section Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set := axum.extract.state.State.t S.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.
  End Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.
  
  Module  Impl_core_default_Default_for_axum_extract_state_State_t_S.
  Section Impl_core_default_Default_for_axum_extract_state_State_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.default.Default.Trait S}.
    
    Definition Self : Set := axum.extract.state.State.t S.
    
    (*
    Default
    *)
    Definition default : M (axum.extract.state.State.t S) := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_extract_state_State_t_S.
  End Impl_core_default_Default_for_axum_extract_state_State_t_S.
  
  Module  Impl_core_clone_Clone_for_axum_extract_state_State_t_S.
  Section Impl_core_clone_Clone_for_axum_extract_state_State_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.extract.state.State.t S.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M (axum.extract.state.State.t S) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_state_State_t_S.
  End Impl_core_clone_Clone_for_axum_extract_state_State_t_S.
  
  Module  Impl_core_marker_Copy_for_axum_extract_state_State_t_S.
  Section Impl_core_marker_Copy_for_axum_extract_state_State_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait S}.
    
    Definition Self : Set := axum.extract.state.State.t S.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extract_state_State_t_S.
  End Impl_core_marker_Copy_for_axum_extract_state_State_t_S.
  
  Module  Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.
  Section Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.
    Context {OuterState InnerState : Set}.
    
    Context
      {ℋ_0 :
        axum_core.extract.from_ref.FromRef.Trait InnerState (T := OuterState)}
      {ℋ_1 : core.marker.Send.Trait OuterState}
      {ℋ_2 : core.marker.Sync.Trait OuterState}.
    
    Definition Self : Set := axum.extract.state.State.t InnerState.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(
            _parts: &mut Parts,
            state: &OuterState,
        ) -> Result<Self, Self::Rejection> {
            let inner_state = InnerState::from_ref(state);
            Ok(Self(inner_state))
        }
    *)
    Definition from_request_parts
        (_parts : mut_ref http.request.Parts.t)
        (state : ref OuterState)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* _parts := M.alloc _parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := OuterState) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.
  End Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.
  
  Module  Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.
  Section Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.extract.state.State.t S.
    
    (*
        type Target = S;
    *)
    Definition Target : Set := S.
    
    (*
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.
  End Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.
  
  Module  Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.
  Section Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.extract.state.State.t S.
    
    (*
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    *)
    Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref_mut :
      Notations.DoubleColon Self "deref_mut" := {
      Notations.double_colon := deref_mut;
    }.
    
    Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
      core.ops.deref.DerefMut.deref_mut := deref_mut;
    }.
  End Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.
  End Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.
End state.

Module  State.
Section State.
  Context {S : Set}.
  
  Record t : Set := {
    x0 : S;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End State.
End State.

Module  Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.
Section Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set := axum.extract.state.State.t S.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.
End Impl_core_fmt_Debug_for_axum_extract_state_State_t_S.

Module  Impl_core_default_Default_for_axum_extract_state_State_t_S.
Section Impl_core_default_Default_for_axum_extract_state_State_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.default.Default.Trait S}.
  
  Definition Self : Set := axum.extract.state.State.t S.
  
  (*
  Default
  *)
  Definition default : M (axum.extract.state.State.t S) := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_extract_state_State_t_S.
End Impl_core_default_Default_for_axum_extract_state_State_t_S.

Module  Impl_core_clone_Clone_for_axum_extract_state_State_t_S.
Section Impl_core_clone_Clone_for_axum_extract_state_State_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.extract.state.State.t S.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M (axum.extract.state.State.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_state_State_t_S.
End Impl_core_clone_Clone_for_axum_extract_state_State_t_S.

Module  Impl_core_marker_Copy_for_axum_extract_state_State_t_S.
Section Impl_core_marker_Copy_for_axum_extract_state_State_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait S}.
  
  Definition Self : Set := axum.extract.state.State.t S.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extract_state_State_t_S.
End Impl_core_marker_Copy_for_axum_extract_state_State_t_S.

Module  Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.
Section Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.
  Context {OuterState InnerState : Set}.
  
  Context
    {ℋ_0 :
      axum_core.extract.from_ref.FromRef.Trait InnerState (T := OuterState)}
    {ℋ_1 : core.marker.Send.Trait OuterState}
    {ℋ_2 : core.marker.Sync.Trait OuterState}.
  
  Definition Self : Set := axum.extract.state.State.t InnerState.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(
          _parts: &mut Parts,
          state: &OuterState,
      ) -> Result<Self, Self::Rejection> {
          let inner_state = InnerState::from_ref(state);
          Ok(Self(inner_state))
      }
  *)
  Definition from_request_parts
      (_parts : mut_ref http.request.Parts.t)
      (state : ref OuterState)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* _parts := M.alloc _parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := OuterState) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.
End Impl_axum_core_extract_FromRequestParts_OuterState_for_axum_extract_state_State_t_InnerState.

Module  Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.
Section Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.extract.state.State.t S.
  
  (*
      type Target = S;
  *)
  Definition Target : Set := S.
  
  (*
      fn deref(&self) -> &Self::Target {
          &self.0
      }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.
End Impl_core_ops_deref_Deref_for_axum_extract_state_State_t_S.

Module  Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.
Section Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.extract.state.State.t S.
  
  (*
      fn deref_mut(&mut self) -> &mut Self::Target {
          &mut self.0
      }
  *)
  Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref_mut :
    Notations.DoubleColon Self "deref_mut" := {
    Notations.double_colon := deref_mut;
  }.
  
  Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
    core.ops.deref.DerefMut.deref_mut := deref_mut;
  }.
End Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.
End Impl_core_ops_deref_DerefMut_for_axum_extract_state_State_t_S.

Module matched_path.
  Module  MatchedPath.
  Section MatchedPath.
    Record t : Set := {
      x0 : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End MatchedPath.
  End MatchedPath.
  
  Module  Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.
  Section Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.
    Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M axum.extract.matched_path.MatchedPath.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.
  End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.
  Section Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.
    Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.
  End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.
  
  Module  Impl_axum_extract_matched_path_MatchedPath_t_2.
  Section Impl_axum_extract_matched_path_MatchedPath_t_2.
    Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
    
    (*
        pub fn as_str(&self) -> &str {
            &self.0
        }
    *)
    Definition as_str (self : ref Self) : M (ref str.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_str :
      Notations.DoubleColon Self "as_str" := {
      Notations.double_colon := as_str;
    }.
  End Impl_axum_extract_matched_path_MatchedPath_t_2.
  End Impl_axum_extract_matched_path_MatchedPath_t_2.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
    
    (*
        type Rejection = MatchedPathRejection;
    *)
    Definition Rejection : Set := axum.extract.rejection.MatchedPathRejection.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
            let matched_path = parts
                .extensions
                .get::<Self>()
                .ok_or(MatchedPathRejection::MatchedPathMissing(MatchedPathMissing))?
                .clone();
    
            Ok(matched_path)
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (_state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.
  
  Module  MatchedNestedPath.
  Section MatchedNestedPath.
    Record t : Set := {
      x0 : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End MatchedNestedPath.
  End MatchedNestedPath.
  
  Module  Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.
  Section Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.
    Definition Self : Set := axum.extract.matched_path.MatchedNestedPath.t.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M axum.extract.matched_path.MatchedNestedPath.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.
  End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.
  Section Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.
    Definition Self : Set := axum.extract.matched_path.MatchedNestedPath.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.
  End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.
  
  (*
  pub(crate) fn set_matched_path_for_request(
      id: RouteId,
      route_id_to_path: &HashMap<RouteId, Arc<str>>,
      extensions: &mut http::Extensions,
  ) {
      let matched_path = if let Some(matched_path) = route_id_to_path.get(&id) {
          matched_path
      } else {
          #[cfg(debug_assertions)]
          panic!("should always have a matched path for a route id");
          #[cfg(not(debug_assertions))]
          return;
      };
  
      let matched_path = append_nested_matched_path(matched_path, extensions);
  
      if matched_path.ends_with(NEST_TAIL_PARAM_CAPTURE) {
          extensions.insert(MatchedNestedPath(matched_path));
          debug_assert!(extensions.remove::<MatchedPath>().is_none());
      } else {
          extensions.insert(MatchedPath(matched_path));
          extensions.remove::<MatchedNestedPath>();
      }
  }
  *)
  Definition set_matched_path_for_request
      (id : axum.routing.RouteId.t)
      (route_id_to_path
        :
        ref
          (std.collections.hash.map.HashMap.t
            axum.routing.RouteId.t
            (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
            std.collections.hash.map.HashMap.Default.S))
      (extensions : mut_ref http.extensions.Extensions.t)
      : M unit :=
    let* id := M.alloc id in
    let* route_id_to_path := M.alloc route_id_to_path in
    let* extensions := M.alloc extensions in
    M.read foo.
  
  (*
  fn append_nested_matched_path(matched_path: &Arc<str>, extensions: &http::Extensions) -> Arc<str> {
      if let Some(previous) = extensions
          .get::<MatchedPath>()
          .map(|matched_path| matched_path.as_str())
          .or_else(|| Some(&extensions.get::<MatchedNestedPath>()?.0))
      {
          let previous = previous
              .strip_suffix(NEST_TAIL_PARAM_CAPTURE)
              .unwrap_or(previous);
  
          let matched_path = format!("{previous}{matched_path}");
          matched_path.into()
      } else {
          Arc::clone(matched_path)
      }
  }
  *)
  Definition append_nested_matched_path
      (matched_path : ref (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A))
      (extensions : ref http.extensions.Extensions.t)
      : M (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A) :=
    let* matched_path := M.alloc matched_path in
    let* extensions := M.alloc extensions in
    M.read foo.
End matched_path.

Module  MatchedPath.
Section MatchedPath.
  Record t : Set := {
    x0 : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End MatchedPath.
End MatchedPath.

Module  Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.
Section Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.
  Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M axum.extract.matched_path.MatchedPath.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.
End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedPath_t.

Module  Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.
Section Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.
  Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.
End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedPath_t.

Module  Impl_axum_extract_matched_path_MatchedPath_t_3.
Section Impl_axum_extract_matched_path_MatchedPath_t_3.
  Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
  
  (*
      pub fn as_str(&self) -> &str {
          &self.0
      }
  *)
  Definition as_str (self : ref Self) : M (ref str.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_str :
    Notations.DoubleColon Self "as_str" := {
    Notations.double_colon := as_str;
  }.
End Impl_axum_extract_matched_path_MatchedPath_t_3.
End Impl_axum_extract_matched_path_MatchedPath_t_3.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.extract.matched_path.MatchedPath.t.
  
  (*
      type Rejection = MatchedPathRejection;
  *)
  Definition Rejection : Set := axum.extract.rejection.MatchedPathRejection.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
          let matched_path = parts
              .extensions
              .get::<Self>()
              .ok_or(MatchedPathRejection::MatchedPathMissing(MatchedPathMissing))?
              .clone();
  
          Ok(matched_path)
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (_state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_matched_path_MatchedPath_t.

Module  MatchedNestedPath.
Section MatchedNestedPath.
  Record t : Set := {
    x0 : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End MatchedNestedPath.
End MatchedNestedPath.

Module  Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.
Section Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.
  Definition Self : Set := axum.extract.matched_path.MatchedNestedPath.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M axum.extract.matched_path.MatchedNestedPath.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.
End Impl_core_clone_Clone_for_axum_extract_matched_path_MatchedNestedPath_t.

Module  Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.
Section Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.
  Definition Self : Set := axum.extract.matched_path.MatchedNestedPath.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.
End Impl_core_fmt_Debug_for_axum_extract_matched_path_MatchedNestedPath_t.

(*
pub(crate) fn set_matched_path_for_request(
    id: RouteId,
    route_id_to_path: &HashMap<RouteId, Arc<str>>,
    extensions: &mut http::Extensions,
) {
    let matched_path = if let Some(matched_path) = route_id_to_path.get(&id) {
        matched_path
    } else {
        #[cfg(debug_assertions)]
        panic!("should always have a matched path for a route id");
        #[cfg(not(debug_assertions))]
        return;
    };

    let matched_path = append_nested_matched_path(matched_path, extensions);

    if matched_path.ends_with(NEST_TAIL_PARAM_CAPTURE) {
        extensions.insert(MatchedNestedPath(matched_path));
        debug_assert!(extensions.remove::<MatchedPath>().is_none());
    } else {
        extensions.insert(MatchedPath(matched_path));
        extensions.remove::<MatchedNestedPath>();
    }
}
*)
Definition set_matched_path_for_request
    (id : axum.routing.RouteId.t)
    (route_id_to_path
      :
      ref
        (std.collections.hash.map.HashMap.t
          axum.routing.RouteId.t
          (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
          std.collections.hash.map.HashMap.Default.S))
    (extensions : mut_ref http.extensions.Extensions.t)
    : M unit :=
  let* id := M.alloc id in
  let* route_id_to_path := M.alloc route_id_to_path in
  let* extensions := M.alloc extensions in
  M.read foo.

(*
fn append_nested_matched_path(matched_path: &Arc<str>, extensions: &http::Extensions) -> Arc<str> {
    if let Some(previous) = extensions
        .get::<MatchedPath>()
        .map(|matched_path| matched_path.as_str())
        .or_else(|| Some(&extensions.get::<MatchedNestedPath>()?.0))
    {
        let previous = previous
            .strip_suffix(NEST_TAIL_PARAM_CAPTURE)
            .unwrap_or(previous);

        let matched_path = format!("{previous}{matched_path}");
        matched_path.into()
    } else {
        Arc::clone(matched_path)
    }
}
*)
Definition append_nested_matched_path
    (matched_path : ref (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A))
    (extensions : ref http.extensions.Extensions.t)
    : M (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A) :=
  let* matched_path := M.alloc matched_path in
  let* extensions := M.alloc extensions in
  M.read foo.

Module query.
  Module  Query.
  Section Query.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Query.
  End Query.
  
  Module  Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.
  Section Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum.extract.query.Query.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.
  End Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.
  
  Module  Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.
  Section Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum.extract.query.Query.t T.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M (axum.extract.query.Query.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.
  End Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.
  
  Module  Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.
  Section Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum.extract.query.Query.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.
  End Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.
  
  Module  Impl_core_default_Default_for_axum_extract_query_Query_t_T.
  Section Impl_core_default_Default_for_axum_extract_query_Query_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.default.Default.Trait T}.
    
    Definition Self : Set := axum.extract.query.Query.t T.
    
    (*
    Default
    *)
    Definition default : M (axum.extract.query.Query.t T) := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_extract_query_Query_t_T.
  End Impl_core_default_Default_for_axum_extract_query_Query_t_T.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.
    Context {T S : Set}.
    
    Context
      {ℋ_0 : serde.de.DeserializeOwned.Trait T}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.extract.query.Query.t T.
    
    (*
        type Rejection = QueryRejection;
    *)
    Definition Rejection : Set := axum.extract.rejection.QueryRejection.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
            Self::try_from_uri(&parts.uri)
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (_state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.
  
  Module  Impl_axum_extract_query_Query_t_T_2.
  Section Impl_axum_extract_query_Query_t_T_2.
    Context {T : Set}.
    
    Definition Self : Set := axum.extract.query.Query.t T.
    
    (*
        pub fn try_from_uri(value: &Uri) -> Result<Self, QueryRejection> {
            let query = value.query().unwrap_or_default();
            let params =
                serde_urlencoded::from_str(query).map_err(FailedToDeserializeQueryString::from_err)?;
            Ok(Query(params))
        }
    *)
    Definition try_from_uri
        (value : ref http.uri.Uri.t)
        :
          M
            (core.result.Result.t
              Self
              axum.extract.rejection.QueryRejection.t) :=
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_try_from_uri :
      Notations.DoubleColon Self "try_from_uri" := {
      Notations.double_colon := try_from_uri;
    }.
  End Impl_axum_extract_query_Query_t_T_2.
  End Impl_axum_extract_query_Query_t_T_2.
  
  Module  Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.
  Section Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.extract.query.Query.t T.
    
    (*
                type Target = T;
    *)
    Definition Target : Set := T.
    
    (*
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.
  End Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.
  
  Module  Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.
  Section Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.extract.query.Query.t T.
    
    (*
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
    *)
    Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref_mut :
      Notations.DoubleColon Self "deref_mut" := {
      Notations.double_colon := deref_mut;
    }.
    
    Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
      core.ops.deref.DerefMut.deref_mut := deref_mut;
    }.
  End Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.
  End Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.
End query.

Module  Query.
Section Query.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Query.
End Query.

Module  Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.
Section Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum.extract.query.Query.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.
End Impl_core_fmt_Debug_for_axum_extract_query_Query_t_T.

Module  Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.
Section Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum.extract.query.Query.t T.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M (axum.extract.query.Query.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.
End Impl_core_clone_Clone_for_axum_extract_query_Query_t_T.

Module  Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.
Section Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum.extract.query.Query.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.
End Impl_core_marker_Copy_for_axum_extract_query_Query_t_T.

Module  Impl_core_default_Default_for_axum_extract_query_Query_t_T.
Section Impl_core_default_Default_for_axum_extract_query_Query_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.default.Default.Trait T}.
  
  Definition Self : Set := axum.extract.query.Query.t T.
  
  (*
  Default
  *)
  Definition default : M (axum.extract.query.Query.t T) := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_extract_query_Query_t_T.
End Impl_core_default_Default_for_axum_extract_query_Query_t_T.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.
  Context {T S : Set}.
  
  Context
    {ℋ_0 : serde.de.DeserializeOwned.Trait T}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.extract.query.Query.t T.
  
  (*
      type Rejection = QueryRejection;
  *)
  Definition Rejection : Set := axum.extract.rejection.QueryRejection.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
          Self::try_from_uri(&parts.uri)
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (_state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extract_query_Query_t_T.

Module  Impl_axum_extract_query_Query_t_T_3.
Section Impl_axum_extract_query_Query_t_T_3.
  Context {T : Set}.
  
  Definition Self : Set := axum.extract.query.Query.t T.
  
  (*
      pub fn try_from_uri(value: &Uri) -> Result<Self, QueryRejection> {
          let query = value.query().unwrap_or_default();
          let params =
              serde_urlencoded::from_str(query).map_err(FailedToDeserializeQueryString::from_err)?;
          Ok(Query(params))
      }
  *)
  Definition try_from_uri
      (value : ref http.uri.Uri.t)
      : M (core.result.Result.t Self axum.extract.rejection.QueryRejection.t) :=
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_try_from_uri :
    Notations.DoubleColon Self "try_from_uri" := {
    Notations.double_colon := try_from_uri;
  }.
End Impl_axum_extract_query_Query_t_T_3.
End Impl_axum_extract_query_Query_t_T_3.

Module  Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.
Section Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.extract.query.Query.t T.
  
  (*
              type Target = T;
  *)
  Definition Target : Set := T.
  
  (*
              fn deref(&self) -> &Self::Target {
                  &self.0
              }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.
End Impl_core_ops_deref_Deref_for_axum_extract_query_Query_t_T.

Module  Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.
Section Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.extract.query.Query.t T.
  
  (*
              fn deref_mut(&mut self) -> &mut Self::Target {
                  &mut self.0
              }
  *)
  Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref_mut :
    Notations.DoubleColon Self "deref_mut" := {
    Notations.double_colon := deref_mut;
  }.
  
  Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
    core.ops.deref.DerefMut.deref_mut := deref_mut;
  }.
End Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.
End Impl_core_ops_deref_DerefMut_for_axum_extract_query_Query_t_T.

(*
pub(super) fn has_content_type(headers: &HeaderMap, expected_content_type: &mime::Mime) -> bool {
    let content_type = if let Some(content_type) = headers.get(header::CONTENT_TYPE) {
        content_type
    } else {
        return false;
    };

    let content_type = if let Ok(content_type) = content_type.to_str() {
        content_type
    } else {
        return false;
    };

    content_type.starts_with(expected_content_type.as_ref())
}
*)
Definition has_content_type
    (headers
      :
      ref (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
    (expected_content_type : ref mime.Mime.t)
    : M bool.t :=
  let* headers := M.alloc headers in
  let* expected_content_type := M.alloc expected_content_type in
  M.read foo.

Module handler.
  Module future.
    Module  IntoServiceFuture.
    Section IntoServiceFuture.
      Context (F : Set).
      
      Record t : Set := {
        future :
          futures_util.future.future.Map.t
            F
            (ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              ->
              core.result.Result.t
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                core.convert.Infallible.t);
      }.
      
      Definition Get_future :=
        Ref.map
          (fun α => Some α.(future))
          (fun β α => Some (α <| future := β |>)).
    End IntoServiceFuture.
    End IntoServiceFuture.
    
    Module  Impl_axum_handler_future_IntoServiceFuture_t_F.
    Section Impl_axum_handler_future_IntoServiceFuture_t_F.
      Context {F : Set}.
      
      Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
      
      (*
                  pub(crate) fn new(future: $actual) -> Self {
                      Self { future }
                  }
      *)
      Definition new
          (future
            :
            futures_util.future.future.Map.t
              F
              (ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                ->
                M
                  (core.result.Result.t
                    ltac:(axum_core.response.Response
                      axum_core.response.Response.Default.T)
                    core.convert.Infallible.t)))
          : M Self :=
        let* future := M.alloc future in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_axum_handler_future_IntoServiceFuture_t_F.
    End Impl_axum_handler_future_IntoServiceFuture_t_F.
    
    Module  Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.
    Section Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.
      Context {F : Set}.
      
      Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      f.debug_struct(stringify!($name)).finish_non_exhaustive()
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.
    End Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.
    
    Module  Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.
    Section Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.
      Context {F : Set}.
      
      Context
        {ℋ_0 :
          core.future.future.Future.Trait
              (futures_util.future.future.Map.t
                F
                (ltac:(axum_core.response.Response
                    axum_core.response.Response.Default.T)
                  ->
                  core.result.Result.t
                    ltac:(axum_core.response.Response
                      axum_core.response.Response.Default.T)
                    core.convert.Infallible.t))}.
      
      Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
      
      (*
                  type Output = <$actual as std::future::Future>::Output;
      *)
      Definition Output : Set :=
        core.future.future.Future.Output
            (Self := futures_util.future.future.Map.t
              F
              (ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                ->
                core.result.Result.t
                  ltac:(axum_core.response.Response
                    axum_core.response.Response.Default.T)
                  core.convert.Infallible.t))
            (Trait := ltac:(refine _)).
      
      (*
                  fn poll(
                      self: std::pin::Pin<&mut Self>,
                      cx: &mut std::task::Context<'_>,
                  ) -> std::task::Poll<Self::Output> {
                      self.project().future.poll(cx)
                  }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.
    End Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.
    
    Module  LayeredFuture.
    Section LayeredFuture.
      Context (S : Set).
      
      Context
        {ℋ_0 :
          tower_service.Service.Trait S
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}.
      Record t : Set := {
        inner :
          futures_util.future.future.Map.t
            (tower.util.oneshot.Oneshot.t
              S
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))
            ((core.result.Result.t S::type["Response"].t S::type["Error"].t) ->
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T));
      }.
      
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
    End LayeredFuture.
    End LayeredFuture.
    
    Module  Impl_axum_handler_future_LayeredFuture_t_S.
    Section Impl_axum_handler_future_LayeredFuture_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.handler.future.LayeredFuture.t S.
      
      (*
          pub(super) fn new(
              inner: Map<Oneshot<S, Request>, fn(Result<S::Response, S::Error>) -> Response>,
          ) -> Self {
              Self { inner }
          }
      *)
      Definition new
          (inner
            :
            futures_util.future.future.Map.t
              (tower.util.oneshot.Oneshot.t
                S
                ltac:(axum_core.extract.Request
                  axum_core.extract.Request.Default.T))
              ((core.result.Result.t S::type["Response"].t S::type["Error"].t)
                ->
                M
                  ltac:(axum_core.response.Response
                    axum_core.response.Response.Default.T)))
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_axum_handler_future_LayeredFuture_t_S.
    End Impl_axum_handler_future_LayeredFuture_t_S.
    
    Module  Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.
    Section Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.
      Context {S : Set}.
      
      Context
        {ℋ_0 :
          tower_service.Service.Trait S
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}.
      
      Definition Self : Set := axum.handler.future.LayeredFuture.t S.
      
      (*
          type Output = Response;
      *)
      Definition Output : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
          fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> std::task::Poll<Self::Output> {
              self.project().inner.poll(cx)
          }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.
    End Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.
  End future.
  
  Module service.
    Module  HandlerService.
    Section HandlerService.
      Context (H T S : Set).
      
      Record t : Set := {
        handler : H;
        state : S;
        _marker : core.marker.PhantomData.t T;
      }.
      
      Definition Get_handler :=
        Ref.map
          (fun α => Some α.(handler))
          (fun β α => Some (α <| handler := β |>)).
      Definition Get_state :=
        Ref.map
          (fun α => Some α.(state))
          (fun β α => Some (α <| state := β |>)).
      Definition Get__marker :=
        Ref.map
          (fun α => Some α.(_marker))
          (fun β α => Some (α <| _marker := β |>)).
    End HandlerService.
    End HandlerService.
    
    Module  Impl_axum_handler_service_HandlerService_t_H_T_S.
    Section Impl_axum_handler_service_HandlerService_t_H_T_S.
      Context {H T S : Set}.
      
      Definition Self : Set := axum.handler.service.HandlerService.t H T S.
      
      (*
          pub fn state(&self) -> &S {
              &self.state
          }
      *)
      Definition state (self : ref Self) : M (ref S) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_state :
        Notations.DoubleColon Self "state" := {
        Notations.double_colon := state;
      }.
      
      (*
          pub fn into_make_service(self) -> IntoMakeService<HandlerService<H, T, S>> {
              IntoMakeService::new(self)
          }
      *)
      Definition into_make_service
          (self : Self)
          :
            M
              (axum.routing.into_make_service.IntoMakeService.t
                (axum.handler.service.HandlerService.t H T S)) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_make_service :
        Notations.DoubleColon Self "into_make_service" := {
        Notations.double_colon := into_make_service;
      }.
      
      (*
          pub fn into_make_service_with_connect_info<C>(
              self,
          ) -> IntoMakeServiceWithConnectInfo<HandlerService<H, T, S>, C> {
              IntoMakeServiceWithConnectInfo::new(self)
          }
      *)
      Definition into_make_service_with_connect_info
          {C : Set}
          (self : Self)
          :
            M
              (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t
                (axum.handler.service.HandlerService.t H T S)
                C) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_make_service_with_connect_info
          {C : Set} :
        Notations.DoubleColon Self "into_make_service_with_connect_info" := {
        Notations.double_colon := into_make_service_with_connect_info (C := C);
      }.
    End Impl_axum_handler_service_HandlerService_t_H_T_S.
    End Impl_axum_handler_service_HandlerService_t_H_T_S.
    
    Module  Impl_axum_handler_service_HandlerService_t_H_T_S_2.
    Section Impl_axum_handler_service_HandlerService_t_H_T_S_2.
      Context {H T S : Set}.
      
      Definition Self : Set := axum.handler.service.HandlerService.t H T S.
      
      (*
          pub(super) fn new(handler: H, state: S) -> Self {
              Self {
                  handler,
                  state,
                  _marker: PhantomData,
              }
          }
      *)
      Definition new (handler : H) (state : S) : M Self :=
        let* handler := M.alloc handler in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_axum_handler_service_HandlerService_t_H_T_S_2.
    End Impl_axum_handler_service_HandlerService_t_H_T_S_2.
    
    Module  Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.
    Section Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.
      Context {H T S : Set}.
      
      Definition Self : Set := axum.handler.service.HandlerService.t H T S.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("IntoService").finish_non_exhaustive()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.
    End Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.
    
    Module  Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.
    Section Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.
      Context {H T S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait H} {ℋ_1 : core.clone.Clone.Trait S}.
      
      Definition Self : Set := axum.handler.service.HandlerService.t H T S.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  handler: self.handler.clone(),
                  state: self.state.clone(),
                  _marker: PhantomData,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.
    End Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.
      Context {H T S B : Set}.
      
      Context
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.clone.Clone.Trait H}
        {ℋ_2 : core.marker.Send.Trait H}
        {ℋ_3 : http_body.Body.Trait B}
        {ℋ_4 : core.marker.Send.Trait B}
        {ℋ_5 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_6 : core.clone.Clone.Trait S}
        {ℋ_7 : core.marker.Send.Trait S}
        {ℋ_8 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.handler.service.HandlerService.t H T S.
      
      (*
          type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
          type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
          type Future = super::future::IntoServiceFuture<H::Future>;
      *)
      Definition Future : Set :=
        axum.handler.future.IntoServiceFuture.t H::type["Future"].t.
      
      (*
          fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              // `IntoService` can only be constructed from async functions which are always ready, or
              // from `Layered` which buffers in `<Layered as Handler>::call` and is therefore
              // also always ready.
              Poll::Ready(Ok(()))
          }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (_cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* _cx := M.alloc _cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
          fn call(&mut self, req: Request<B>) -> Self::Future {
              use futures_util::future::FutureExt;
      
              let req = req.map(Body::new);
      
              let handler = self.handler.clone();
              let future = Handler::call(handler, req, self.state.clone());
              let future = future.map(Ok as _);
      
              super::future::IntoServiceFuture::new(future)
          }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.
  End service.
  
  Module  Handler.
  Section Handler.
    Class Trait (Self : Set) {T S : Set} : Type := {
      ℒ_0 :: core.clone.Clone.Trait Self;
      ℒ_1 :: core.marker.Send.Trait Self;
      Future : Set;
      ℒ_2 :: core.future.future.Future.Trait Future;
      ℒ_3 :: core.marker.Send.Trait Future;
      call :
        Self ->
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T)
          ->
          S ->
          M Future.t;
    }.
    
    Global Instance Method_Future `(Trait) :
      Notations.DoubleColonType Self "Future" := {
      Notations.double_colon_type := Future;
    }.
  End Handler.
  End Handler.
  
  Module  Impl_axum_handler_Handler_Tuple_Tuple___S_for_F.
  Section Impl_axum_handler_Handler_Tuple_Tuple___S_for_F.
    Context {F Fut Res S : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := unit)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait Res}.
    
    Definition Self : Set := F.
    
    (*
        type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
        fn call(self, _req: Request, _state: S) -> Self::Future {
            Box::pin(async move { self().await.into_response() })
        }
    *)
    Definition call
        (self : Self)
        (_req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (_state : S)
        : M Future :=
      let* self := M.alloc self in
      let* _req := M.alloc _req in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self (T := unit) (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_Tuple___S_for_F.
  End Impl_axum_handler_Handler_Tuple_Tuple___S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1__S_for_F.
    Context {F Fut S Res M T1 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := T1)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequest.Trait T1 (S := S) (M := M)}
      {ℋ_9 : core.marker.Send.Trait T1}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self (T := M * T1) (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2__S_for_F.
    Context {F Fut S Res M T1 T2 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := T1 * T2)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequest.Trait T2 (S := S) (M := M)}
      {ℋ_11 : core.marker.Send.Trait T2}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := (M * T1) * T2)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3__S_for_F.
    Context {F Fut S Res M T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := (T1 * T2) * T3)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequest.Trait T3 (S := S) (M := M)}
      {ℋ_13 : core.marker.Send.Trait T3}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := ((M * T1) * T2) * T3)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4__S_for_F.
    Context {F Fut S Res M T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := ((T1 * T2) * T3) * T4)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequest.Trait T4 (S := S) (M := M)}
      {ℋ_15 : core.marker.Send.Trait T4}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := (((M * T1) * T2) * T3) * T4)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5__S_for_F.
    Context {F Fut S Res M T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F (Args := (((T1 * T2) * T3) * T4) * T5)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequest.Trait T5 (S := S) (M := M)}
      {ℋ_17 : core.marker.Send.Trait T5}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := ((((M * T1) * T2) * T3) * T4) * T5)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6__S_for_F.
    Context {F Fut S Res M T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((T1 * T2) * T3) * T4) * T5) * T6)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T5}
      {ℋ_18 : axum_core.extract.FromRequest.Trait T6 (S := S) (M := M)}
      {ℋ_19 : core.marker.Send.Trait T6}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := (((((M * T1) * T2) * T3) * T4) * T5) * T6)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7__S_for_F.
    Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T5}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T6}
      {ℋ_20 : axum_core.extract.FromRequest.Trait T7 (S := S) (M := M)}
      {ℋ_21 : core.marker.Send.Trait T7}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := ((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
    Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T5}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T6}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T7}
      {ℋ_22 : axum_core.extract.FromRequest.Trait T8 (S := S) (M := M)}
      {ℋ_23 : core.marker.Send.Trait T8}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := (((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
    Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T5}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T6}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T7}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T8}
      {ℋ_24 : axum_core.extract.FromRequest.Trait T9 (S := S) (M := M)}
      {ℋ_25 : core.marker.Send.Trait T9}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := ((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
    Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T5}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T6}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T7}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T8}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T9}
      {ℋ_26 : axum_core.extract.FromRequest.Trait T10 (S := S) (M := M)}
      {ℋ_27 : core.marker.Send.Trait T10}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := (((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
    Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T5}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T6}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T7}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T8}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T9}
      {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_27 : core.marker.Send.Trait T10}
      {ℋ_28 : axum_core.extract.FromRequest.Trait T11 (S := S) (M := M)}
      {ℋ_29 : core.marker.Send.Trait T11}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := ((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
    Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T5}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T6}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T7}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T8}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T9}
      {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_27 : core.marker.Send.Trait T10}
      {ℋ_28 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_29 : core.marker.Send.Trait T11}
      {ℋ_30 : axum_core.extract.FromRequest.Trait T12 (S := S) (M := M)}
      {ℋ_31 : core.marker.Send.Trait T12}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := (((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
    Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T5}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T6}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T7}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T8}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T9}
      {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_27 : core.marker.Send.Trait T10}
      {ℋ_28 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_29 : core.marker.Send.Trait T11}
      {ℋ_30 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_31 : core.marker.Send.Trait T12}
      {ℋ_32 : axum_core.extract.FromRequest.Trait T13 (S := S) (M := M)}
      {ℋ_33 : core.marker.Send.Trait T13}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := ((((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
    Context
      {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T5}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T6}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T7}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T8}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T9}
      {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_27 : core.marker.Send.Trait T10}
      {ℋ_28 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_29 : core.marker.Send.Trait T11}
      {ℋ_30 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_31 : core.marker.Send.Trait T12}
      {ℋ_32 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_33 : core.marker.Send.Trait T13}
      {ℋ_34 : axum_core.extract.FromRequest.Trait T14 (S := S) (M := M)}
      {ℋ_35 : core.marker.Send.Trait T14}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := (((((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
    Context
      {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T5}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T6}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T7}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T8}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T9}
      {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_27 : core.marker.Send.Trait T10}
      {ℋ_28 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_29 : core.marker.Send.Trait T11}
      {ℋ_30 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_31 : core.marker.Send.Trait T12}
      {ℋ_32 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_33 : core.marker.Send.Trait T13}
      {ℋ_34 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_35 : core.marker.Send.Trait T14}
      {ℋ_36 : axum_core.extract.FromRequest.Trait T15 (S := S) (M := M)}
      {ℋ_37 : core.marker.Send.Trait T15}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := ((((((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
  
  Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
  Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
    Context
      {F
        Fut
        S
        Res
        M
        T1
        T2
        T3
        T4
        T5
        T6
        T7
        T8
        T9
        T10
        T11
        T12
        T13
        T14
        T15
        T16
        :
        Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          T16)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T1}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T2}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T3}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T4}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T5}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T6}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T7}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T8}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T9}
      {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_27 : core.marker.Send.Trait T10}
      {ℋ_28 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_29 : core.marker.Send.Trait T11}
      {ℋ_30 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_31 : core.marker.Send.Trait T12}
      {ℋ_32 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_33 : core.marker.Send.Trait T13}
      {ℋ_34 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_35 : core.marker.Send.Trait T14}
      {ℋ_36 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
      {ℋ_37 : core.marker.Send.Trait T15}
      {ℋ_38 : axum_core.extract.FromRequest.Trait T16 (S := S) (M := M)}
      {ℋ_39 : core.marker.Send.Trait T16}.
    
    Definition Self : Set := F.
    
    (*
                type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
                fn call(self, req: Request, state: S) -> Self::Future {
                    Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
                        let state = &state;
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let res = self($($ty,)* $last,).await;
    
                        res.into_response()
                    })
                }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := (((((((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
  End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
  
  Module private.
    Module IntoResponseHandler.
      Inductive t : Set :=
      .
    End IntoResponseHandler.
  End private.
  
  Module  Impl_axum_handler_Handler_axum_handler_private_IntoResponseHandler_t_S_for_T.
  Section Impl_axum_handler_Handler_axum_handler_private_IntoResponseHandler_t_S_for_T.
    Context {T S : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}.
    
    Definition Self : Set := T.
    
    (*
        type Future = std::future::Ready<Response>;
    *)
    Definition Future : Set :=
      core.future.ready.Ready.t
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
    
    (*
        fn call(self, _req: Request, _state: S) -> Self::Future {
            std::future::ready(self.into_response())
        }
    *)
    Definition call
        (self : Self)
        (_req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (_state : S)
        : M Future :=
      let* self := M.alloc self in
      let* _req := M.alloc _req in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := axum.handler.private.IntoResponseHandler.t)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_axum_handler_private_IntoResponseHandler_t_S_for_T.
  End Impl_axum_handler_Handler_axum_handler_private_IntoResponseHandler_t_S_for_T.
  
  Module  Layered.
  Section Layered.
    Context (L H T S : Set).
    
    Record t : Set := {
      layer : L;
      handler : H;
      _marker : core.marker.PhantomData.t (T * S);
    }.
    
    Definition Get_layer :=
      Ref.map (fun α => Some α.(layer)) (fun β α => Some (α <| layer := β |>)).
    Definition Get_handler :=
      Ref.map
        (fun α => Some α.(handler))
        (fun β α => Some (α <| handler := β |>)).
    Definition Get__marker :=
      Ref.map
        (fun α => Some α.(_marker))
        (fun β α => Some (α <| _marker := β |>)).
  End Layered.
  End Layered.
  
  Module  Impl_core_fmt_Debug_for_axum_handler_Layered_t_L_H_T_S.
  Section Impl_core_fmt_Debug_for_axum_handler_Layered_t_L_H_T_S.
    Context {L H T S : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait L}.
    
    Definition Self : Set := axum.handler.Layered.t L H T S.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Layered")
                .field("layer", &self.layer)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_handler_Layered_t_L_H_T_S.
  End Impl_core_fmt_Debug_for_axum_handler_Layered_t_L_H_T_S.
  
  Module  Impl_core_clone_Clone_for_axum_handler_Layered_t_L_H_T_S.
  Section Impl_core_clone_Clone_for_axum_handler_Layered_t_L_H_T_S.
    Context {L H T S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait L} {ℋ_1 : core.clone.Clone.Trait H}.
    
    Definition Self : Set := axum.handler.Layered.t L H T S.
    
    (*
        fn clone(&self) -> Self {
            Self {
                layer: self.layer.clone(),
                handler: self.handler.clone(),
                _marker: PhantomData,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_handler_Layered_t_L_H_T_S.
  End Impl_core_clone_Clone_for_axum_handler_Layered_t_L_H_T_S.
  
  Module  Impl_axum_handler_Handler_T_S_for_axum_handler_Layered_t_L_H_T_S.
  Section Impl_axum_handler_Handler_T_S_for_axum_handler_Layered_t_L_H_T_S.
    Context {H S T L : Set}.
    
    Context
      {ℋ_0 :
        tower_layer.Layer.Trait L
          (S := axum.handler.service.HandlerService.t H T S)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_4 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_5 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_6 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_7 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}.
    
    Definition Self : Set := axum.handler.Layered.t L H T S.
    
    (*
        type Future = future::LayeredFuture<L::Service>;
    *)
    Definition Future : Set :=
      axum.handler.future.LayeredFuture.t L::type["Service"].t.
    
    (*
        fn call(self, req: Request, state: S) -> Self::Future {
            use futures_util::future::{FutureExt, Map};
    
            let svc = self.handler.with_state(state);
            let svc = self.layer.layer(svc);
    
            let future: Map<
                _,
                fn(
                    Result<
                        <L::Service as Service<Request>>::Response,
                        <L::Service as Service<Request>>::Error,
                    >,
                ) -> _,
            > = svc.oneshot(req).map(|result| match result {
                Ok(res) => res.into_response(),
                Err(err) => match err {},
            });
    
            future::LayeredFuture::new(future)
        }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self (T := T) (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_T_S_for_axum_handler_Layered_t_L_H_T_S.
  End Impl_axum_handler_Handler_T_S_for_axum_handler_Layered_t_L_H_T_S.
  
  Module  HandlerWithoutStateExt.
  Section HandlerWithoutStateExt.
    Class Trait (Self : Set) {T : Set} : Type := {
      ℒ_0 :: axum.handler.Handler.Trait Self (T := T) (S := unit);
      into_service :
        Self -> M (axum.handler.service.HandlerService.t Self T unit);
      into_make_service :
        Self ->
          M
            (axum.routing.into_make_service.IntoMakeService.t
              (axum.handler.service.HandlerService.t Self T unit));
      into_make_service_with_connect_info {C : Set} :
        Self ->
          M
            (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t
              (axum.handler.service.HandlerService.t Self T unit)
              C);
    }.
    
  End HandlerWithoutStateExt.
  End HandlerWithoutStateExt.
  
  Module  Impl_axum_handler_HandlerWithoutStateExt_T_for_H.
  Section Impl_axum_handler_HandlerWithoutStateExt_T_for_H.
    Context {H T : Set}.
    
    Context {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := unit)}.
    
    Definition Self : Set := H.
    
    (*
        fn into_service(self) -> HandlerService<Self, T, ()> {
            self.with_state(())
        }
    *)
    Definition into_service
        (self : Self)
        : M (axum.handler.service.HandlerService.t Self T unit) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_service :
      Notations.DoubleColon Self "into_service" := {
      Notations.double_colon := into_service;
    }.
    
    (*
        fn into_make_service(self) -> IntoMakeService<HandlerService<Self, T, ()>> {
            self.into_service().into_make_service()
        }
    *)
    Definition into_make_service
        (self : Self)
        :
          M
            (axum.routing.into_make_service.IntoMakeService.t
              (axum.handler.service.HandlerService.t Self T unit)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_make_service :
      Notations.DoubleColon Self "into_make_service" := {
      Notations.double_colon := into_make_service;
    }.
    
    (*
        fn into_make_service_with_connect_info<C>(
            self,
        ) -> IntoMakeServiceWithConnectInfo<HandlerService<Self, T, ()>, C> {
            self.into_service().into_make_service_with_connect_info()
        }
    *)
    Definition into_make_service_with_connect_info
        {C : Set}
        (self : Self)
        :
          M
            (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t
              (axum.handler.service.HandlerService.t Self T unit)
              C) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_make_service_with_connect_info
        {C : Set} :
      Notations.DoubleColon Self "into_make_service_with_connect_info" := {
      Notations.double_colon := into_make_service_with_connect_info (C := C);
    }.
    
    Global Instance ℐ :
      axum.handler.HandlerWithoutStateExt.Trait Self (T := T) := {
      axum.handler.HandlerWithoutStateExt.into_service := into_service;
      axum.handler.HandlerWithoutStateExt.into_make_service :=
        into_make_service;
      axum.handler.HandlerWithoutStateExt.into_make_service_with_connect_info
        {C : Set} :=
        into_make_service_with_connect_info (C := C);
    }.
  End Impl_axum_handler_HandlerWithoutStateExt_T_for_H.
  End Impl_axum_handler_HandlerWithoutStateExt_T_for_H.
End handler.

Module Wrap_future_1.
Module future.
  Module  IntoServiceFuture.
  Section IntoServiceFuture.
    Context (F : Set).
    
    Record t : Set := {
      future :
        futures_util.future.future.Map.t
          F
          (ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            ->
            core.result.Result.t
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              core.convert.Infallible.t);
    }.
    
    Definition Get_future :=
      Ref.map
        (fun α => Some α.(future))
        (fun β α => Some (α <| future := β |>)).
  End IntoServiceFuture.
  End IntoServiceFuture.
  
  Module  Impl_axum_handler_future_IntoServiceFuture_t_F_2.
  Section Impl_axum_handler_future_IntoServiceFuture_t_F_2.
    Context {F : Set}.
    
    Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
    
    (*
                pub(crate) fn new(future: $actual) -> Self {
                    Self { future }
                }
    *)
    Definition new
        (future
          :
          futures_util.future.future.Map.t
            F
            (ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              ->
              M
                (core.result.Result.t
                  ltac:(axum_core.response.Response
                    axum_core.response.Response.Default.T)
                  core.convert.Infallible.t)))
        : M Self :=
      let* future := M.alloc future in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_axum_handler_future_IntoServiceFuture_t_F_2.
  End Impl_axum_handler_future_IntoServiceFuture_t_F_2.
  
  Module  Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.
  Section Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.
    Context {F : Set}.
    
    Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.debug_struct(stringify!($name)).finish_non_exhaustive()
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.
  End Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.
  
  Module  Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.
  Section Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.
    Context {F : Set}.
    
    Context
      {ℋ_0 :
        core.future.future.Future.Trait
            (futures_util.future.future.Map.t
              F
              (ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                ->
                core.result.Result.t
                  ltac:(axum_core.response.Response
                    axum_core.response.Response.Default.T)
                  core.convert.Infallible.t))}.
    
    Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
    
    (*
                type Output = <$actual as std::future::Future>::Output;
    *)
    Definition Output : Set :=
      core.future.future.Future.Output
          (Self := futures_util.future.future.Map.t
            F
            (ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              ->
              core.result.Result.t
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                core.convert.Infallible.t))
          (Trait := ltac:(refine _)).
    
    (*
                fn poll(
                    self: std::pin::Pin<&mut Self>,
                    cx: &mut std::task::Context<'_>,
                ) -> std::task::Poll<Self::Output> {
                    self.project().future.poll(cx)
                }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.
  End Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.
  
  Module  LayeredFuture.
  Section LayeredFuture.
    Context (S : Set).
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}.
    Record t : Set := {
      inner :
        futures_util.future.future.Map.t
          (tower.util.oneshot.Oneshot.t
            S
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          ((core.result.Result.t S::type["Response"].t S::type["Error"].t) ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T));
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  End LayeredFuture.
  End LayeredFuture.
  
  Module  Impl_axum_handler_future_LayeredFuture_t_S_2.
  Section Impl_axum_handler_future_LayeredFuture_t_S_2.
    Context {S : Set}.
    
    Definition Self : Set := axum.handler.future.LayeredFuture.t S.
    
    (*
        pub(super) fn new(
            inner: Map<Oneshot<S, Request>, fn(Result<S::Response, S::Error>) -> Response>,
        ) -> Self {
            Self { inner }
        }
    *)
    Definition new
        (inner
          :
          futures_util.future.future.Map.t
            (tower.util.oneshot.Oneshot.t
              S
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))
            ((core.result.Result.t S::type["Response"].t S::type["Error"].t) ->
              M
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)))
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_axum_handler_future_LayeredFuture_t_S_2.
  End Impl_axum_handler_future_LayeredFuture_t_S_2.
  
  Module  Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.
  Section Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.
    Context {S : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}.
    
    Definition Self : Set := axum.handler.future.LayeredFuture.t S.
    
    (*
        type Output = Response;
    *)
    Definition Output : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> std::task::Poll<Self::Output> {
            self.project().inner.poll(cx)
        }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.
  End Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.
End future.
End Wrap_future_1.
Import Wrap_future_1.

Module  IntoServiceFuture.
Section IntoServiceFuture.
  Context (F : Set).
  
  Record t : Set := {
    future :
      futures_util.future.future.Map.t
        F
        (ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          ->
          core.result.Result.t
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            core.convert.Infallible.t);
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End IntoServiceFuture.
End IntoServiceFuture.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Context (F : Set).
  
  Record t : Set := {
    future :
      core.pin.Pin.t
        (mut_ref
          (futures_util.future.future.Map.t
            F
            (ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              ->
              core.result.Result.t
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                core.convert.Infallible.t)));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Context (F : Set).
  
  Record t : Set := {
    future :
      core.pin.Pin.t
        (ref
          (futures_util.future.future.Map.t
            F
            (ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              ->
              core.result.Result.t
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                core.convert.Infallible.t)));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_handler_future_IntoServiceFuture_t_F_3.
Section Impl_axum_handler_future_IntoServiceFuture_t_F_3.
  Context {F : Set}.
  
  Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum.handler.future._.Projection.t F) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M (axum.handler.future._.ProjectionRef.t F) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_handler_future_IntoServiceFuture_t_F_3.
End Impl_axum_handler_future_IntoServiceFuture_t_F_3.

Module  __Origin.
Section __Origin.
  Context (F : Set).
  
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    future :
      futures_util.future.future.Map.t
        F
        (ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          ->
          core.result.Result.t
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            core.convert.Infallible.t);
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_handler_future_IntoServiceFuture_t_F.
Section Impl_core_marker_Unpin_for_axum_handler_future_IntoServiceFuture_t_F.
  Context {F : Set}.
  
  Context {ℋ_0 : core.marker.Unpin.Trait (axum.handler.future._.__Origin.t F)}.
  
  Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_handler_future_IntoServiceFuture_t_F.
End Impl_core_marker_Unpin_for_axum_handler_future_IntoServiceFuture_t_F.

Module  Impl_axum_handler_future___MustNotImplDrop_for_T.
Section Impl_axum_handler_future___MustNotImplDrop_for_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.ops.drop.Drop.Trait T}.
  
  Definition Self : Set := T.
  
  Global Instance ℐ : axum.handler.future._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_handler_future___MustNotImplDrop_for_T.
End Impl_axum_handler_future___MustNotImplDrop_for_T.

Module  Impl_axum_handler_future___MustNotImplDrop_for_axum_handler_future_IntoServiceFuture_t_F.
Section Impl_axum_handler_future___MustNotImplDrop_for_axum_handler_future_IntoServiceFuture_t_F.
  Context {F : Set}.
  
  Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
  
  Global Instance ℐ : axum.handler.future._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_handler_future___MustNotImplDrop_for_axum_handler_future_IntoServiceFuture_t_F.
End Impl_axum_handler_future___MustNotImplDrop_for_axum_handler_future_IntoServiceFuture_t_F.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    {F : Set}
    (this : ref (axum.handler.future.IntoServiceFuture.t F))
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module  Impl_axum_handler_future_IntoServiceFuture_t_F_4.
Section Impl_axum_handler_future_IntoServiceFuture_t_F_4.
  Context {F : Set}.
  
  Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
  
  (*
              pub(crate) fn new(future: $actual) -> Self {
                  Self { future }
              }
  *)
  Definition new
      (future
        :
        futures_util.future.future.Map.t
          F
          (ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            ->
            M
              (core.result.Result.t
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                core.convert.Infallible.t)))
      : M Self :=
    let* future := M.alloc future in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_axum_handler_future_IntoServiceFuture_t_F_4.
End Impl_axum_handler_future_IntoServiceFuture_t_F_4.

Module  Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.
Section Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.
  Context {F : Set}.
  
  Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  f.debug_struct(stringify!($name)).finish_non_exhaustive()
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.
End Impl_core_fmt_Debug_for_axum_handler_future_IntoServiceFuture_t_F.

Module  Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.
Section Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.
  Context {F : Set}.
  
  Context
    {ℋ_0 :
      core.future.future.Future.Trait
          (futures_util.future.future.Map.t
            F
            (ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              ->
              core.result.Result.t
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                core.convert.Infallible.t))}.
  
  Definition Self : Set := axum.handler.future.IntoServiceFuture.t F.
  
  (*
              type Output = <$actual as std::future::Future>::Output;
  *)
  Definition Output : Set :=
    core.future.future.Future.Output
        (Self := futures_util.future.future.Map.t
          F
          (ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            ->
            core.result.Result.t
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              core.convert.Infallible.t))
        (Trait := ltac:(refine _)).
  
  (*
              fn poll(
                  self: std::pin::Pin<&mut Self>,
                  cx: &mut std::task::Context<'_>,
              ) -> std::task::Poll<Self::Output> {
                  self.project().future.poll(cx)
              }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.
End Impl_core_future_future_Future_for_axum_handler_future_IntoServiceFuture_t_F.

Module  LayeredFuture.
Section LayeredFuture.
  Context (S : Set).
  
  Context
    {ℋ_0 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}.
  Record t : Set := {
    inner :
      futures_util.future.future.Map.t
        (tower.util.oneshot.Oneshot.t
          S
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        ((core.result.Result.t S::type["Response"].t S::type["Error"].t) ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T));
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
End LayeredFuture.
End LayeredFuture.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Context (S : Set).
  
  Context
    {ℋ_0 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}.
  Record t : Set := {
    inner :
      core.pin.Pin.t
        (mut_ref
          (futures_util.future.future.Map.t
            (tower.util.oneshot.Oneshot.t
              S
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))
            ((core.result.Result.t S::type["Response"].t S::type["Error"].t) ->
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T))));
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Context (S : Set).
  
  Context
    {ℋ_0 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}.
  Record t : Set := {
    inner :
      core.pin.Pin.t
        (ref
          (futures_util.future.future.Map.t
            (tower.util.oneshot.Oneshot.t
              S
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))
            ((core.result.Result.t S::type["Response"].t S::type["Error"].t) ->
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T))));
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_handler_future_LayeredFuture_t_S_3.
Section Impl_axum_handler_future_LayeredFuture_t_S_3.
  Context {S : Set}.
  
  Definition Self : Set := axum.handler.future.LayeredFuture.t S.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum.handler.future._.Projection.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M (axum.handler.future._.ProjectionRef.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_handler_future_LayeredFuture_t_S_3.
End Impl_axum_handler_future_LayeredFuture_t_S_3.

Module  __Origin.
Section __Origin.
  Context (S : Set).
  
  Context
    {ℋ_0 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}.
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    inner :
      futures_util.future.future.Map.t
        (tower.util.oneshot.Oneshot.t
          S
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        ((core.result.Result.t S::type["Response"].t S::type["Error"].t) ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T));
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_handler_future_LayeredFuture_t_S.
Section Impl_core_marker_Unpin_for_axum_handler_future_LayeredFuture_t_S.
  Context {S : Set}.
  
  Context
    {ℋ_0 : core.marker.Unpin.Trait (axum.handler.future._.__Origin.t S)}
    {ℋ_1 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}.
  
  Definition Self : Set := axum.handler.future.LayeredFuture.t S.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_handler_future_LayeredFuture_t_S.
End Impl_core_marker_Unpin_for_axum_handler_future_LayeredFuture_t_S.

Module  Impl_axum_handler_future___MustNotImplDrop_for_axum_handler_future_LayeredFuture_t_S.
Section Impl_axum_handler_future___MustNotImplDrop_for_axum_handler_future_LayeredFuture_t_S.
  Context {S : Set}.
  
  Context
    {ℋ_0 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}.
  
  Definition Self : Set := axum.handler.future.LayeredFuture.t S.
  
  Global Instance ℐ : axum.handler.future._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_handler_future___MustNotImplDrop_for_axum_handler_future_LayeredFuture_t_S.
End Impl_axum_handler_future___MustNotImplDrop_for_axum_handler_future_LayeredFuture_t_S.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    {S : Set}
    {ℋ_0 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    (this : ref (axum.handler.future.LayeredFuture.t S))
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module  Impl_axum_handler_future_LayeredFuture_t_S_4.
Section Impl_axum_handler_future_LayeredFuture_t_S_4.
  Context {S : Set}.
  
  Definition Self : Set := axum.handler.future.LayeredFuture.t S.
  
  (*
      pub(super) fn new(
          inner: Map<Oneshot<S, Request>, fn(Result<S::Response, S::Error>) -> Response>,
      ) -> Self {
          Self { inner }
      }
  *)
  Definition new
      (inner
        :
        futures_util.future.future.Map.t
          (tower.util.oneshot.Oneshot.t
            S
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          ((core.result.Result.t S::type["Response"].t S::type["Error"].t) ->
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)))
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_axum_handler_future_LayeredFuture_t_S_4.
End Impl_axum_handler_future_LayeredFuture_t_S_4.

Module  Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.
Section Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.
  Context {S : Set}.
  
  Context
    {ℋ_0 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}.
  
  Definition Self : Set := axum.handler.future.LayeredFuture.t S.
  
  (*
      type Output = Response;
  *)
  Definition Output : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> std::task::Poll<Self::Output> {
          self.project().inner.poll(cx)
      }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.
End Impl_core_future_future_Future_for_axum_handler_future_LayeredFuture_t_S.

Module service.
  Module  HandlerService.
  Section HandlerService.
    Context (H T S : Set).
    
    Record t : Set := {
      handler : H;
      state : S;
      _marker : core.marker.PhantomData.t T;
    }.
    
    Definition Get_handler :=
      Ref.map
        (fun α => Some α.(handler))
        (fun β α => Some (α <| handler := β |>)).
    Definition Get_state :=
      Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
    Definition Get__marker :=
      Ref.map
        (fun α => Some α.(_marker))
        (fun β α => Some (α <| _marker := β |>)).
  End HandlerService.
  End HandlerService.
  
  Module  Impl_axum_handler_service_HandlerService_t_H_T_S_3.
  Section Impl_axum_handler_service_HandlerService_t_H_T_S_3.
    Context {H T S : Set}.
    
    Definition Self : Set := axum.handler.service.HandlerService.t H T S.
    
    (*
        pub fn state(&self) -> &S {
            &self.state
        }
    *)
    Definition state (self : ref Self) : M (ref S) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_state :
      Notations.DoubleColon Self "state" := {
      Notations.double_colon := state;
    }.
    
    (*
        pub fn into_make_service(self) -> IntoMakeService<HandlerService<H, T, S>> {
            IntoMakeService::new(self)
        }
    *)
    Definition into_make_service
        (self : Self)
        :
          M
            (axum.routing.into_make_service.IntoMakeService.t
              (axum.handler.service.HandlerService.t H T S)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_make_service :
      Notations.DoubleColon Self "into_make_service" := {
      Notations.double_colon := into_make_service;
    }.
    
    (*
        pub fn into_make_service_with_connect_info<C>(
            self,
        ) -> IntoMakeServiceWithConnectInfo<HandlerService<H, T, S>, C> {
            IntoMakeServiceWithConnectInfo::new(self)
        }
    *)
    Definition into_make_service_with_connect_info
        {C : Set}
        (self : Self)
        :
          M
            (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t
              (axum.handler.service.HandlerService.t H T S)
              C) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_make_service_with_connect_info
        {C : Set} :
      Notations.DoubleColon Self "into_make_service_with_connect_info" := {
      Notations.double_colon := into_make_service_with_connect_info (C := C);
    }.
  End Impl_axum_handler_service_HandlerService_t_H_T_S_3.
  End Impl_axum_handler_service_HandlerService_t_H_T_S_3.
  
  Module  Impl_axum_handler_service_HandlerService_t_H_T_S_4.
  Section Impl_axum_handler_service_HandlerService_t_H_T_S_4.
    Context {H T S : Set}.
    
    Definition Self : Set := axum.handler.service.HandlerService.t H T S.
    
    (*
        pub(super) fn new(handler: H, state: S) -> Self {
            Self {
                handler,
                state,
                _marker: PhantomData,
            }
        }
    *)
    Definition new (handler : H) (state : S) : M Self :=
      let* handler := M.alloc handler in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_axum_handler_service_HandlerService_t_H_T_S_4.
  End Impl_axum_handler_service_HandlerService_t_H_T_S_4.
  
  Module  Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.
  Section Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.
    Context {H T S : Set}.
    
    Definition Self : Set := axum.handler.service.HandlerService.t H T S.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("IntoService").finish_non_exhaustive()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.
  End Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.
  
  Module  Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.
  Section Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.
    Context {H T S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait H} {ℋ_1 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.handler.service.HandlerService.t H T S.
    
    (*
        fn clone(&self) -> Self {
            Self {
                handler: self.handler.clone(),
                state: self.state.clone(),
                _marker: PhantomData,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.
  End Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.
    Context {H T S B : Set}.
    
    Context
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait H}
      {ℋ_2 : core.marker.Send.Trait H}
      {ℋ_3 : http_body.Body.Trait B}
      {ℋ_4 : core.marker.Send.Trait B}
      {ℋ_5 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_6 : core.clone.Clone.Trait S}
      {ℋ_7 : core.marker.Send.Trait S}
      {ℋ_8 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.handler.service.HandlerService.t H T S.
    
    (*
        type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        type Future = super::future::IntoServiceFuture<H::Future>;
    *)
    Definition Future : Set :=
      axum.handler.future.IntoServiceFuture.t H::type["Future"].t.
    
    (*
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            // `IntoService` can only be constructed from async functions which are always ready, or
            // from `Layered` which buffers in `<Layered as Handler>::call` and is therefore
            // also always ready.
            Poll::Ready(Ok(()))
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (_cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* _cx := M.alloc _cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, req: Request<B>) -> Self::Future {
            use futures_util::future::FutureExt;
    
            let req = req.map(Body::new);
    
            let handler = self.handler.clone();
            let future = Handler::call(handler, req, self.state.clone());
            let future = future.map(Ok as _);
    
            super::future::IntoServiceFuture::new(future)
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.
End service.

Module  HandlerService.
Section HandlerService.
  Context (H T S : Set).
  
  Record t : Set := {
    handler : H;
    state : S;
    _marker : core.marker.PhantomData.t T;
  }.
  
  Definition Get_handler :=
    Ref.map
      (fun α => Some α.(handler))
      (fun β α => Some (α <| handler := β |>)).
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get__marker :=
    Ref.map
      (fun α => Some α.(_marker))
      (fun β α => Some (α <| _marker := β |>)).
End HandlerService.
End HandlerService.

Module  Impl_axum_handler_service_HandlerService_t_H_T_S_5.
Section Impl_axum_handler_service_HandlerService_t_H_T_S_5.
  Context {H T S : Set}.
  
  Definition Self : Set := axum.handler.service.HandlerService.t H T S.
  
  (*
      pub fn state(&self) -> &S {
          &self.state
      }
  *)
  Definition state (self : ref Self) : M (ref S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_state :
    Notations.DoubleColon Self "state" := {
    Notations.double_colon := state;
  }.
  
  (*
      pub fn into_make_service(self) -> IntoMakeService<HandlerService<H, T, S>> {
          IntoMakeService::new(self)
      }
  *)
  Definition into_make_service
      (self : Self)
      :
        M
          (axum.routing.into_make_service.IntoMakeService.t
            (axum.handler.service.HandlerService.t H T S)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_make_service :
    Notations.DoubleColon Self "into_make_service" := {
    Notations.double_colon := into_make_service;
  }.
  
  (*
      pub fn into_make_service_with_connect_info<C>(
          self,
      ) -> IntoMakeServiceWithConnectInfo<HandlerService<H, T, S>, C> {
          IntoMakeServiceWithConnectInfo::new(self)
      }
  *)
  Definition into_make_service_with_connect_info
      {C : Set}
      (self : Self)
      :
        M
          (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t
            (axum.handler.service.HandlerService.t H T S)
            C) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_make_service_with_connect_info
      {C : Set} :
    Notations.DoubleColon Self "into_make_service_with_connect_info" := {
    Notations.double_colon := into_make_service_with_connect_info (C := C);
  }.
End Impl_axum_handler_service_HandlerService_t_H_T_S_5.
End Impl_axum_handler_service_HandlerService_t_H_T_S_5.

Module  Impl_axum_handler_service_HandlerService_t_H_T_S_6.
Section Impl_axum_handler_service_HandlerService_t_H_T_S_6.
  Context {H T S : Set}.
  
  Definition Self : Set := axum.handler.service.HandlerService.t H T S.
  
  (*
      pub(super) fn new(handler: H, state: S) -> Self {
          Self {
              handler,
              state,
              _marker: PhantomData,
          }
      }
  *)
  Definition new (handler : H) (state : S) : M Self :=
    let* handler := M.alloc handler in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_axum_handler_service_HandlerService_t_H_T_S_6.
End Impl_axum_handler_service_HandlerService_t_H_T_S_6.

Module  Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.
Section Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.
  Context {H T S : Set}.
  
  Definition Self : Set := axum.handler.service.HandlerService.t H T S.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("IntoService").finish_non_exhaustive()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.
End Impl_core_fmt_Debug_for_axum_handler_service_HandlerService_t_H_T_S.

Module  Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.
Section Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.
  Context {H T S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait H} {ℋ_1 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.handler.service.HandlerService.t H T S.
  
  (*
      fn clone(&self) -> Self {
          Self {
              handler: self.handler.clone(),
              state: self.state.clone(),
              _marker: PhantomData,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.
End Impl_core_clone_Clone_for_axum_handler_service_HandlerService_t_H_T_S.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.
  Context {H T S B : Set}.
  
  Context
    {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait H}
    {ℋ_2 : core.marker.Send.Trait H}
    {ℋ_3 : http_body.Body.Trait B}
    {ℋ_4 : core.marker.Send.Trait B}
    {ℋ_5 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_6 : core.clone.Clone.Trait S}
    {ℋ_7 : core.marker.Send.Trait S}
    {ℋ_8 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.handler.service.HandlerService.t H T S.
  
  (*
      type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      type Future = super::future::IntoServiceFuture<H::Future>;
  *)
  Definition Future : Set :=
    axum.handler.future.IntoServiceFuture.t H::type["Future"].t.
  
  (*
      fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          // `IntoService` can only be constructed from async functions which are always ready, or
          // from `Layered` which buffers in `<Layered as Handler>::call` and is therefore
          // also always ready.
          Poll::Ready(Ok(()))
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (_cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* _cx := M.alloc _cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, req: Request<B>) -> Self::Future {
          use futures_util::future::FutureExt;
  
          let req = req.map(Body::new);
  
          let handler = self.handler.clone();
          let future = Handler::call(handler, req, self.state.clone());
          let future = future.map(Ok as _);
  
          super::future::IntoServiceFuture::new(future)
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_handler_service_HandlerService_t_H_T_S.

Module  Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_handler_service_HandlerService_t_H_T_S.
Section Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_handler_service_HandlerService_t_H_T_S.
  Context {H T S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait H} {ℋ_1 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.handler.service.HandlerService.t H T S.
  
  (*
          type Response = Self;
  *)
  Definition Response : Set := Self.
  
  (*
          type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
          type Future = std::future::Ready<Result<Self::Response, Self::Error>>;
  *)
  Definition Future : Set :=
    core.future.ready.Ready.t (core.result.Result.t Response Error).
  
  (*
          fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              Poll::Ready(Ok(()))
          }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (_cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* _cx := M.alloc _cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
          fn call(&mut self, _req: IncomingStream<'_>) -> Self::Future {
              std::future::ready(Ok(self.clone()))
          }
  *)
  Definition call
      (self : mut_ref Self)
      (_req : axum.serve.IncomingStream.t)
      : M Future :=
    let* self := M.alloc self in
    let* _req := M.alloc _req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := axum.serve.IncomingStream.t) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_handler_service_HandlerService_t_H_T_S.
End Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_handler_service_HandlerService_t_H_T_S.

Module  Handler.
Section Handler.
  Class Trait (Self : Set) {T S : Set} : Type := {
    ℒ_0 :: core.clone.Clone.Trait Self;
    ℒ_1 :: core.marker.Send.Trait Self;
    Future : Set;
    ℒ_2 :: core.future.future.Future.Trait Future;
    ℒ_3 :: core.marker.Send.Trait Future;
    call :
      Self ->
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T) ->
        S ->
        M Future.t;
  }.
  
  Global Instance Method_Future `(Trait) :
    Notations.DoubleColonType Self "Future" := {
    Notations.double_colon_type := Future;
  }.
End Handler.
End Handler.

Module  Impl_axum_handler_Handler_Tuple_Tuple___S_for_F.
Section Impl_axum_handler_Handler_Tuple_Tuple___S_for_F.
  Context {F Fut Res S : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := unit)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait Res}.
  
  Definition Self : Set := F.
  
  (*
      type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
      fn call(self, _req: Request, _state: S) -> Self::Future {
          Box::pin(async move { self().await.into_response() })
      }
  *)
  Definition call
      (self : Self)
      (_req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (_state : S)
      : M Future :=
    let* self := M.alloc self in
    let* _req := M.alloc _req in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self (T := unit) (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_Tuple___S_for_F.
End Impl_axum_handler_Handler_Tuple_Tuple___S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1__S_for_F.
  Context {F Fut S Res M T1 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := T1)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequest.Trait T1 (S := S) (M := M)}
    {ℋ_9 : core.marker.Send.Trait T1}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self (T := M * T1) (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2__S_for_F.
  Context {F Fut S Res M T1 T2 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := T1 * T2)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequest.Trait T2 (S := S) (M := M)}
    {ℋ_11 : core.marker.Send.Trait T2}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self (T := (M * T1) * T2) (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3__S_for_F.
  Context {F Fut S Res M T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := (T1 * T2) * T3)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequest.Trait T3 (S := S) (M := M)}
    {ℋ_13 : core.marker.Send.Trait T3}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := ((M * T1) * T2) * T3)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4__S_for_F.
  Context {F Fut S Res M T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := ((T1 * T2) * T3) * T4)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequest.Trait T4 (S := S) (M := M)}
    {ℋ_15 : core.marker.Send.Trait T4}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := (((M * T1) * T2) * T3) * T4)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5__S_for_F.
  Context {F Fut S Res M T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F (Args := (((T1 * T2) * T3) * T4) * T5)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequest.Trait T5 (S := S) (M := M)}
    {ℋ_17 : core.marker.Send.Trait T5}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := ((((M * T1) * T2) * T3) * T4) * T5)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6__S_for_F.
  Context {F Fut S Res M T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((T1 * T2) * T3) * T4) * T5) * T6)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T5}
    {ℋ_18 : axum_core.extract.FromRequest.Trait T6 (S := S) (M := M)}
    {ℋ_19 : core.marker.Send.Trait T6}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := (((((M * T1) * T2) * T3) * T4) * T5) * T6)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7__S_for_F.
  Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T5}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T6}
    {ℋ_20 : axum_core.extract.FromRequest.Trait T7 (S := S) (M := M)}
    {ℋ_21 : core.marker.Send.Trait T7}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := ((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
  Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T5}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T6}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T7}
    {ℋ_22 : axum_core.extract.FromRequest.Trait T8 (S := S) (M := M)}
    {ℋ_23 : core.marker.Send.Trait T8}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := (((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
  Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T5}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T6}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T7}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T8}
    {ℋ_24 : axum_core.extract.FromRequest.Trait T9 (S := S) (M := M)}
    {ℋ_25 : core.marker.Send.Trait T9}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := ((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
  Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T5}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T6}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T7}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T8}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T9}
    {ℋ_26 : axum_core.extract.FromRequest.Trait T10 (S := S) (M := M)}
    {ℋ_27 : core.marker.Send.Trait T10}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := (((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
      *
      T10)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
  Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T5}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T6}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T7}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T8}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T9}
    {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_27 : core.marker.Send.Trait T10}
    {ℋ_28 : axum_core.extract.FromRequest.Trait T11 (S := S) (M := M)}
    {ℋ_29 : core.marker.Send.Trait T11}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := ((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
      *
      T10)
      *
      T11)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
  Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T5}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T6}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T7}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T8}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T9}
    {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_27 : core.marker.Send.Trait T10}
    {ℋ_28 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_29 : core.marker.Send.Trait T11}
    {ℋ_30 : axum_core.extract.FromRequest.Trait T12 (S := S) (M := M)}
    {ℋ_31 : core.marker.Send.Trait T12}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := (((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
      *
      T10)
      *
      T11)
      *
      T12)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
  Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T5}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T6}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T7}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T8}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T9}
    {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_27 : core.marker.Send.Trait T10}
    {ℋ_28 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_29 : core.marker.Send.Trait T11}
    {ℋ_30 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_31 : core.marker.Send.Trait T12}
    {ℋ_32 : axum_core.extract.FromRequest.Trait T13 (S := S) (M := M)}
    {ℋ_33 : core.marker.Send.Trait T13}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := ((((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
  Context {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T5}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T6}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T7}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T8}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T9}
    {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_27 : core.marker.Send.Trait T10}
    {ℋ_28 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_29 : core.marker.Send.Trait T11}
    {ℋ_30 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_31 : core.marker.Send.Trait T12}
    {ℋ_32 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_33 : core.marker.Send.Trait T13}
    {ℋ_34 : axum_core.extract.FromRequest.Trait T14 (S := S) (M := M)}
    {ℋ_35 : core.marker.Send.Trait T14}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := (((((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
  Context
    {F Fut S Res M T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T5}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T6}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T7}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T8}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T9}
    {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_27 : core.marker.Send.Trait T10}
    {ℋ_28 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_29 : core.marker.Send.Trait T11}
    {ℋ_30 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_31 : core.marker.Send.Trait T12}
    {ℋ_32 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_33 : core.marker.Send.Trait T13}
    {ℋ_34 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_35 : core.marker.Send.Trait T14}
    {ℋ_36 : axum_core.extract.FromRequest.Trait T15 (S := S) (M := M)}
    {ℋ_37 : core.marker.Send.Trait T15}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := ((((((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.

Module  Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
Section Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
  Context
    {F
      Fut
      S
      Res
      M
      T1
      T2
      T3
      T4
      T5
      T6
      T7
      T8
      T9
      T10
      T11
      T12
      T13
      T14
      T15
      T16
      :
      Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Res}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T1}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T2}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T3}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T4}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T5}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T6}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T7}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T8}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T9}
    {ℋ_26 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_27 : core.marker.Send.Trait T10}
    {ℋ_28 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_29 : core.marker.Send.Trait T11}
    {ℋ_30 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_31 : core.marker.Send.Trait T12}
    {ℋ_32 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_33 : core.marker.Send.Trait T13}
    {ℋ_34 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_35 : core.marker.Send.Trait T14}
    {ℋ_36 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
    {ℋ_37 : core.marker.Send.Trait T15}
    {ℋ_38 : axum_core.extract.FromRequest.Trait T16 (S := S) (M := M)}
    {ℋ_39 : core.marker.Send.Trait T16}.
  
  Definition Self : Set := F.
  
  (*
              type Future = Pin<Box<dyn Future<Output = Response> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
              fn call(self, req: Request, state: S) -> Self::Future {
                  Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
                      let state = &state;
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let res = self($($ty,)* $last,).await;
  
                      res.into_response()
                  })
              }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := (((((((((((((((M * T1) * T2) * T3) * T4) * T5) * T6) * T7) * T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
End Impl_axum_handler_Handler_Tuple_M_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.

Module private.
  Module IntoResponseHandler.
    Inductive t : Set :=
    .
  End IntoResponseHandler.
End private.

Module IntoResponseHandler.
  Inductive t : Set :=
  .
End IntoResponseHandler.

Module  Impl_axum_handler_Handler_axum_handler_private_IntoResponseHandler_t_S_for_T.
Section Impl_axum_handler_Handler_axum_handler_private_IntoResponseHandler_t_S_for_T.
  Context {T S : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}.
  
  Definition Self : Set := T.
  
  (*
      type Future = std::future::Ready<Response>;
  *)
  Definition Future : Set :=
    core.future.ready.Ready.t
        ltac:(axum_core.response.Response
          axum_core.response.Response.Default.T).
  
  (*
      fn call(self, _req: Request, _state: S) -> Self::Future {
          std::future::ready(self.into_response())
      }
  *)
  Definition call
      (self : Self)
      (_req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (_state : S)
      : M Future :=
    let* self := M.alloc self in
    let* _req := M.alloc _req in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self
      (T := axum.handler.private.IntoResponseHandler.t)
      (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_axum_handler_private_IntoResponseHandler_t_S_for_T.
End Impl_axum_handler_Handler_axum_handler_private_IntoResponseHandler_t_S_for_T.

Module  Layered.
Section Layered.
  Context (L H T S : Set).
  
  Record t : Set := {
    layer : L;
    handler : H;
    _marker : core.marker.PhantomData.t (T * S);
  }.
  
  Definition Get_layer :=
    Ref.map (fun α => Some α.(layer)) (fun β α => Some (α <| layer := β |>)).
  Definition Get_handler :=
    Ref.map
      (fun α => Some α.(handler))
      (fun β α => Some (α <| handler := β |>)).
  Definition Get__marker :=
    Ref.map
      (fun α => Some α.(_marker))
      (fun β α => Some (α <| _marker := β |>)).
End Layered.
End Layered.

Module  Impl_core_fmt_Debug_for_axum_handler_Layered_t_L_H_T_S.
Section Impl_core_fmt_Debug_for_axum_handler_Layered_t_L_H_T_S.
  Context {L H T S : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait L}.
  
  Definition Self : Set := axum.handler.Layered.t L H T S.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("Layered")
              .field("layer", &self.layer)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_handler_Layered_t_L_H_T_S.
End Impl_core_fmt_Debug_for_axum_handler_Layered_t_L_H_T_S.

Module  Impl_core_clone_Clone_for_axum_handler_Layered_t_L_H_T_S.
Section Impl_core_clone_Clone_for_axum_handler_Layered_t_L_H_T_S.
  Context {L H T S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait L} {ℋ_1 : core.clone.Clone.Trait H}.
  
  Definition Self : Set := axum.handler.Layered.t L H T S.
  
  (*
      fn clone(&self) -> Self {
          Self {
              layer: self.layer.clone(),
              handler: self.handler.clone(),
              _marker: PhantomData,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_handler_Layered_t_L_H_T_S.
End Impl_core_clone_Clone_for_axum_handler_Layered_t_L_H_T_S.

Module  Impl_axum_handler_Handler_T_S_for_axum_handler_Layered_t_L_H_T_S.
Section Impl_axum_handler_Handler_T_S_for_axum_handler_Layered_t_L_H_T_S.
  Context {H S T L : Set}.
  
  Context
    {ℋ_0 :
      tower_layer.Layer.Trait L
        (S := axum.handler.service.HandlerService.t H T S)}
    {ℋ_1 : core.clone.Clone.Trait L}
    {ℋ_2 : core.marker.Send.Trait L}
    {ℋ_3 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_4 :
      tower_service.Service.Trait L::type["Service"].t
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_5 : core.clone.Clone.Trait L::type["Service"].t}
    {ℋ_6 : core.marker.Send.Trait L::type["Service"].t}
    {ℋ_7 :
      axum_core.response.into_response.IntoResponse.Trait
          (tower_service.Service.Response
            (Self := L::type["Service"].t)
            (Trait := ltac:(refine _)))}
    {ℋ_8 :
      core.marker.Send.Trait
          (tower_service.Service.Future
            (Self := L::type["Service"].t)
            (Trait := ltac:(refine _)))}.
  
  Definition Self : Set := axum.handler.Layered.t L H T S.
  
  (*
      type Future = future::LayeredFuture<L::Service>;
  *)
  Definition Future : Set :=
    axum.handler.future.LayeredFuture.t L::type["Service"].t.
  
  (*
      fn call(self, req: Request, state: S) -> Self::Future {
          use futures_util::future::{FutureExt, Map};
  
          let svc = self.handler.with_state(state);
          let svc = self.layer.layer(svc);
  
          let future: Map<
              _,
              fn(
                  Result<
                      <L::Service as Service<Request>>::Response,
                      <L::Service as Service<Request>>::Error,
                  >,
              ) -> _,
          > = svc.oneshot(req).map(|result| match result {
              Ok(res) => res.into_response(),
              Err(err) => match err {},
          });
  
          future::LayeredFuture::new(future)
      }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self (T := T) (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_T_S_for_axum_handler_Layered_t_L_H_T_S.
End Impl_axum_handler_Handler_T_S_for_axum_handler_Layered_t_L_H_T_S.

Module  HandlerWithoutStateExt.
Section HandlerWithoutStateExt.
  Class Trait (Self : Set) {T : Set} : Type := {
    ℒ_0 :: axum.handler.Handler.Trait Self (T := T) (S := unit);
    into_service :
      Self -> M (axum.handler.service.HandlerService.t Self T unit);
    into_make_service :
      Self ->
        M
          (axum.routing.into_make_service.IntoMakeService.t
            (axum.handler.service.HandlerService.t Self T unit));
    into_make_service_with_connect_info {C : Set} :
      Self ->
        M
          (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t
            (axum.handler.service.HandlerService.t Self T unit)
            C);
  }.
  
End HandlerWithoutStateExt.
End HandlerWithoutStateExt.

Module  Impl_axum_handler_HandlerWithoutStateExt_T_for_H.
Section Impl_axum_handler_HandlerWithoutStateExt_T_for_H.
  Context {H T : Set}.
  
  Context {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := unit)}.
  
  Definition Self : Set := H.
  
  (*
      fn into_service(self) -> HandlerService<Self, T, ()> {
          self.with_state(())
      }
  *)
  Definition into_service
      (self : Self)
      : M (axum.handler.service.HandlerService.t Self T unit) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_service :
    Notations.DoubleColon Self "into_service" := {
    Notations.double_colon := into_service;
  }.
  
  (*
      fn into_make_service(self) -> IntoMakeService<HandlerService<Self, T, ()>> {
          self.into_service().into_make_service()
      }
  *)
  Definition into_make_service
      (self : Self)
      :
        M
          (axum.routing.into_make_service.IntoMakeService.t
            (axum.handler.service.HandlerService.t Self T unit)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_make_service :
    Notations.DoubleColon Self "into_make_service" := {
    Notations.double_colon := into_make_service;
  }.
  
  (*
      fn into_make_service_with_connect_info<C>(
          self,
      ) -> IntoMakeServiceWithConnectInfo<HandlerService<Self, T, ()>, C> {
          self.into_service().into_make_service_with_connect_info()
      }
  *)
  Definition into_make_service_with_connect_info
      {C : Set}
      (self : Self)
      :
        M
          (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t
            (axum.handler.service.HandlerService.t Self T unit)
            C) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_make_service_with_connect_info
      {C : Set} :
    Notations.DoubleColon Self "into_make_service_with_connect_info" := {
    Notations.double_colon := into_make_service_with_connect_info (C := C);
  }.
  
  Global Instance ℐ :
    axum.handler.HandlerWithoutStateExt.Trait Self (T := T) := {
    axum.handler.HandlerWithoutStateExt.into_service := into_service;
    axum.handler.HandlerWithoutStateExt.into_make_service := into_make_service;
    axum.handler.HandlerWithoutStateExt.into_make_service_with_connect_info
      {C : Set} :=
      into_make_service_with_connect_info (C := C);
  }.
End Impl_axum_handler_HandlerWithoutStateExt_T_for_H.
End Impl_axum_handler_HandlerWithoutStateExt_T_for_H.

Module middleware.
  Module from_extractor.
    (*
    pub fn from_extractor<E>() -> FromExtractorLayer<E, ()> {
        from_extractor_with_state(())
    }
    *)
    Definition from_extractor
        {E : Set}
        : M (axum.middleware.from_extractor.FromExtractorLayer.t E unit) :=
      M.read foo.
    
    (*
    pub fn from_extractor_with_state<E, S>(state: S) -> FromExtractorLayer<E, S> {
        FromExtractorLayer {
            state,
            _marker: PhantomData,
        }
    }
    *)
    Definition from_extractor_with_state
        {E S : Set}
        (state : S)
        : M (axum.middleware.from_extractor.FromExtractorLayer.t E S) :=
      let* state := M.alloc state in
      M.read foo.
    
    Module  FromExtractorLayer.
    Section FromExtractorLayer.
      Context (E S : Set).
      
      Record t : Set := {
        state : S;
        _marker : core.marker.PhantomData.t E;
      }.
      
      Definition Get_state :=
        Ref.map
          (fun α => Some α.(state))
          (fun β α => Some (α <| state := β |>)).
      Definition Get__marker :=
        Ref.map
          (fun α => Some α.(_marker))
          (fun β α => Some (α <| _marker := β |>)).
    End FromExtractorLayer.
    End FromExtractorLayer.
    
    Module  Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    Section Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
      Context {E S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_extractor.FromExtractorLayer.t E S.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  state: self.state.clone(),
                  _marker: PhantomData,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    Section Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
      Context {E S : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_extractor.FromExtractorLayer.t E S.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("FromExtractorLayer")
                  .field("state", &self.state)
                  .field("extractor", &format_args!("{}", std::any::type_name::<E>()))
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    
    Module  Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    Section Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
      Context {E T S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_extractor.FromExtractorLayer.t E S.
      
      (*
          type Service = FromExtractor<T, E, S>;
      *)
      Definition Service : Set :=
        axum.middleware.from_extractor.FromExtractor.t T E S.
      
      (*
          fn layer(&self, inner: T) -> Self::Service {
              FromExtractor {
                  inner,
                  state: self.state.clone(),
                  _extractor: PhantomData,
              }
          }
      *)
      Definition layer (self : ref Self) (inner : T) : M Service :=
        let* self := M.alloc self in
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_layer :
        Notations.DoubleColon Self "layer" := {
        Notations.double_colon := layer;
      }.
      
      Global Instance ℐ : tower_layer.Layer.Trait Self (S := T) := {
        tower_layer.Layer.Service := Service;
        tower_layer.Layer.layer := layer;
      }.
    End Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    End Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    
    Module  FromExtractor.
    Section FromExtractor.
      Context (T E S : Set).
      
      Record t : Set := {
        inner : T;
        state : S;
        _extractor : core.marker.PhantomData.t E;
      }.
      
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
      Definition Get_state :=
        Ref.map
          (fun α => Some α.(state))
          (fun β α => Some (α <| state := β |>)).
      Definition Get__extractor :=
        Ref.map
          (fun α => Some α.(_extractor))
          (fun β α => Some (α <| _extractor := β |>)).
    End FromExtractor.
    End FromExtractor.
    
    Module  Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    Section Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
      Context {T E S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait T} {ℋ_1 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_extractor.FromExtractor.t T E S.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  inner: self.inner.clone(),
                  state: self.state.clone(),
                  _extractor: PhantomData,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    Section Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
      Context {T E S : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait T} {ℋ_1 : core.fmt.Debug.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_extractor.FromExtractor.t T E S.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("FromExtractor")
                  .field("inner", &self.inner)
                  .field("state", &self.state)
                  .field("extractor", &format_args!("{}", std::any::type_name::<E>()))
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
      Context {T E B S : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_1 : core.marker.Send.Trait B}
        {ℋ_2 :
          tower_service.Service.Trait T (Request := http.request.Request.t B)}
        {ℋ_3 : core.clone.Clone.Trait T}
        {ℋ_4 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_5 : core.clone.Clone.Trait S}
        {ℋ_6 : core.marker.Send.Trait S}
        {ℋ_7 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_extractor.FromExtractor.t T E S.
      
      (*
          type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
          type Error = T::Error;
      *)
      Definition Error : Set := T::type["Error"].t.
      
      (*
          type Future = ResponseFuture<B, T, E, S>;
      *)
      Definition Future : Set :=
        axum.middleware.from_extractor.ResponseFuture.t B T E S.
      
      (*
          fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              self.inner.poll_ready(cx)
          }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
          fn call(&mut self, req: Request<B>) -> Self::Future {
              let state = self.state.clone();
              let extract_future = Box::pin(async move {
                  let (mut parts, body) = req.into_parts();
                  let extracted = E::from_request_parts(&mut parts, &state).await;
                  let req = Request::from_parts(parts, body);
                  (req, extracted)
              });
      
              ResponseFuture {
                  state: State::Extracting {
                      future: extract_future,
                  },
                  svc: Some(self.inner.clone()),
              }
          }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    
    Module  ResponseFuture.
    Section ResponseFuture.
      Context (B T E S : Set).
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_1 :
          tower_service.Service.Trait T (Request := http.request.Request.t B)}.
      Record t : Set := {
        state : axum.middleware.from_extractor.State.t B T E S;
        svc : core.option.Option.t T;
      }.
      
      Definition Get_state :=
        Ref.map
          (fun α => Some α.(state))
          (fun β α => Some (α <| state := β |>)).
      Definition Get_svc :=
        Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
    End ResponseFuture.
    End ResponseFuture.
    
    Module State.
      Module Extracting.
        Record t : Set := {
          future :
            ltac:(futures_core.future.BoxFuture
              ((http.request.Request.t B)
              *
              (core.result.Result.t E E::type["Rejection"].t)));
        }.
      End Extracting.
      
      Module Call.
        Record t : Set := {
          future : T::type["Future"].t;
        }.
      End Call.
      
      Inductive t (B : Set) (T : Set) (E : Set) (S : Set) : Set :=
      | Extracting (_ : Extracting.t)
      | Call (_ : Call.t).
      
      Definition Get_Extracting_future :=
        Ref.map
          (fun α =>
            match α with
            | Extracting α => Some α.(Extracting.future)
            | _ => None
            end)
          (fun β α =>
            match α with
            | Extracting α => Some (Extracting (α <| Extracting.future := β |>))
            | _ => None
            end).
      
      Definition Get_Call_future :=
        Ref.map
          (fun α =>
            match α with | Call α => Some α.(Call.future) | _ => None end)
          (fun β α =>
            match α with
            | Call α => Some (Call (α <| Call.future := β |>))
            | _ => None
            end).
    End State.
    
    Module StateProj.
      Module Extracting.
        Record t : Set := {
          future :
            mut_ref
              ltac:(futures_core.future.BoxFuture
                ((http.request.Request.t B)
                *
                (core.result.Result.t E E::type["Rejection"].t)));
        }.
      End Extracting.
      
      Module Call.
        Record t : Set := {
          future : core.pin.Pin.t (mut_ref T::type["Future"].t);
        }.
      End Call.
      
      Inductive t (B : Set) (T : Set) (E : Set) (S : Set) : Set :=
      | Extracting (_ : Extracting.t)
      | Call (_ : Call.t).
      
      Definition Get_Extracting_future :=
        Ref.map
          (fun α =>
            match α with
            | Extracting α => Some α.(Extracting.future)
            | _ => None
            end)
          (fun β α =>
            match α with
            | Extracting α => Some (Extracting (α <| Extracting.future := β |>))
            | _ => None
            end).
      
      Definition Get_Call_future :=
        Ref.map
          (fun α =>
            match α with | Call α => Some α.(Call.future) | _ => None end)
          (fun β α =>
            match α with
            | Call α => Some (Call (α <| Call.future := β |>))
            | _ => None
            end).
    End StateProj.
    
    Module  Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
    Section Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
      Context {B T E S : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_1 :
          tower_service.Service.Trait T (Request := http.request.Request.t B)}
        {ℋ_2 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}.
      
      Definition Self : Set :=
        axum.middleware.from_extractor.ResponseFuture.t B T E S.
      
      (*
          type Output = Result<Response, T::Error>;
      *)
      Definition Output : Set :=
        core.result.Result.t
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            T::type["Error"].t.
      
      (*
          fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
              loop {
                  let mut this = self.as_mut().project();
      
                  let new_state = match this.state.as_mut().project() {
                      StateProj::Extracting { future } => {
                          let (req, extracted) = ready!(future.as_mut().poll(cx));
      
                          match extracted {
                              Ok(_) => {
                                  let mut svc = this.svc.take().expect("future polled after completion");
                                  let future = svc.call(req);
                                  State::Call { future }
                              }
                              Err(err) => {
                                  let res = err.into_response();
                                  return Poll::Ready(Ok(res));
                              }
                          }
                      }
                      StateProj::Call { future } => {
                          return future
                              .poll(cx)
                              .map(|result| result.map(IntoResponse::into_response));
                      }
                  };
      
                  this.state.set(new_state);
              }
          }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
    End Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
  End from_extractor.
  
  Module from_fn.
    (*
    pub fn from_fn<F, T>(f: F) -> FromFnLayer<F, (), T> {
        from_fn_with_state((), f)
    }
    *)
    Definition from_fn
        {F T : Set}
        (f : F)
        : M (axum.middleware.from_fn.FromFnLayer.t F unit T) :=
      let* f := M.alloc f in
      M.read foo.
    
    (*
    pub fn from_fn_with_state<F, S, T>(state: S, f: F) -> FromFnLayer<F, S, T> {
        FromFnLayer {
            f,
            state,
            _extractor: PhantomData,
        }
    }
    *)
    Definition from_fn_with_state
        {F S T : Set}
        (state : S)
        (f : F)
        : M (axum.middleware.from_fn.FromFnLayer.t F S T) :=
      let* state := M.alloc state in
      let* f := M.alloc f in
      M.read foo.
    
    Module  FromFnLayer.
    Section FromFnLayer.
      Context (F S T : Set).
      
      Record t : Set := {
        f : F;
        state : S;
        _extractor : core.marker.PhantomData.t T;
      }.
      
      Definition Get_f :=
        Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
      Definition Get_state :=
        Ref.map
          (fun α => Some α.(state))
          (fun β α => Some (α <| state := β |>)).
      Definition Get__extractor :=
        Ref.map
          (fun α => Some α.(_extractor))
          (fun β α => Some (α <| _extractor := β |>)).
    End FromFnLayer.
    End FromFnLayer.
    
    Module  Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    Section Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
      Context {F S T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
      
      Definition Self : Set := axum.middleware.from_fn.FromFnLayer.t F S T.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  f: self.f.clone(),
                  state: self.state.clone(),
                  _extractor: self._extractor,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    
    Module  Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    Section Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
      Context {S I F T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
      
      Definition Self : Set := axum.middleware.from_fn.FromFnLayer.t F S T.
      
      (*
          type Service = FromFn<F, S, I, T>;
      *)
      Definition Service : Set := axum.middleware.from_fn.FromFn.t F S I T.
      
      (*
          fn layer(&self, inner: I) -> Self::Service {
              FromFn {
                  f: self.f.clone(),
                  state: self.state.clone(),
                  inner,
                  _extractor: PhantomData,
              }
          }
      *)
      Definition layer (self : ref Self) (inner : I) : M Service :=
        let* self := M.alloc self in
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_layer :
        Notations.DoubleColon Self "layer" := {
        Notations.double_colon := layer;
      }.
      
      Global Instance ℐ : tower_layer.Layer.Trait Self (S := I) := {
        tower_layer.Layer.Service := Service;
        tower_layer.Layer.layer := layer;
      }.
    End Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    End Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
      Context {F S T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S}.
      
      Definition Self : Set := axum.middleware.from_fn.FromFnLayer.t F S T.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("FromFnLayer")
                  // Write out the type name, without quoting it as `&type_name::<F>()` would
                  .field("f", &format_args!("{}", type_name::<F>()))
                  .field("state", &self.state)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    
    Module  FromFn.
    Section FromFn.
      Context (F S I T : Set).
      
      Record t : Set := {
        f : F;
        inner : I;
        state : S;
        _extractor : core.marker.PhantomData.t T;
      }.
      
      Definition Get_f :=
        Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
      Definition Get_state :=
        Ref.map
          (fun α => Some α.(state))
          (fun β α => Some (α <| state := β |>)).
      Definition Get__extractor :=
        Ref.map
          (fun α => Some α.(_extractor))
          (fun β α => Some (α <| _extractor := β |>)).
    End FromFn.
    End FromFn.
    
    Module  Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
    Section Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
      Context {F S I T : Set}.
      
      Context
        {ℋ_0 : core.clone.Clone.Trait F}
        {ℋ_1 : core.clone.Clone.Trait I}
        {ℋ_2 : core.clone.Clone.Trait S}.
      
      Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I T.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  f: self.f.clone(),
                  inner: self.inner.clone(),
                  state: self.state.clone(),
                  _extractor: self._extractor,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
    End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.
      Context {F Fut Out S I T1 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := T1 * axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 :
          axum_core.extract.FromRequest.Trait T1
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T1)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : core.future.future.Future.Trait Fut}
        {ℋ_6 : core.marker.Send.Trait Fut}
        {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_8 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_9 : core.clone.Clone.Trait I}
        {ℋ_10 : core.marker.Send.Trait I}
        {ℋ_11 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_12 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_13 : core.clone.Clone.Trait S}
        {ℋ_14 : core.marker.Send.Trait S}
        {ℋ_15 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I T1.
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.
      Context {F Fut Out S I T1 T2 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (T1 * T2) * axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 :
          axum_core.extract.FromRequest.Trait T2
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T2)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : core.future.future.Future.Trait Fut}
        {ℋ_8 : core.marker.Send.Trait Fut}
        {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_10 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_11 : core.clone.Clone.Trait I}
        {ℋ_12 : core.marker.Send.Trait I}
        {ℋ_13 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_14 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_15 : core.clone.Clone.Trait S}
        {ℋ_16 : core.marker.Send.Trait S}
        {ℋ_17 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I (T1 * T2).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.
      Context {F Fut Out S I T1 T2 T3 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((T1 * T2) * T3) * axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 :
          axum_core.extract.FromRequest.Trait T3
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T3)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : core.future.future.Future.Trait Fut}
        {ℋ_10 : core.marker.Send.Trait Fut}
        {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_12 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_13 : core.clone.Clone.Trait I}
        {ℋ_14 : core.marker.Send.Trait I}
        {ℋ_15 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_16 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_17 : core.clone.Clone.Trait S}
        {ℋ_18 : core.marker.Send.Trait S}
        {ℋ_19 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t F S I ((T1 * T2) * T3).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.
      Context {F Fut Out S I T1 T2 T3 T4 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((T1 * T2) * T3) * T4) * axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 :
          axum_core.extract.FromRequest.Trait T4
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T4)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : core.future.future.Future.Trait Fut}
        {ℋ_12 : core.marker.Send.Trait Fut}
        {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_14 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_15 : core.clone.Clone.Trait I}
        {ℋ_16 : core.marker.Send.Trait I}
        {ℋ_17 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_18 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_19 : core.clone.Clone.Trait S}
        {ℋ_20 : core.marker.Send.Trait S}
        {ℋ_21 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t F S I (((T1 * T2) * T3) * T4).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
      Context {F Fut Out S I T1 T2 T3 T4 T5 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((T1 * T2) * T3) * T4) * T5)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 :
          axum_core.extract.FromRequest.Trait T5
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T5)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : core.future.future.Future.Trait Fut}
        {ℋ_14 : core.marker.Send.Trait Fut}
        {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_16 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_17 : core.clone.Clone.Trait I}
        {ℋ_18 : core.marker.Send.Trait I}
        {ℋ_19 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_20 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_21 : core.clone.Clone.Trait S}
        {ℋ_22 : core.marker.Send.Trait S}
        {ℋ_23 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t F S I ((((T1 * T2) * T3) * T4) * T5).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
      Context {F Fut Out S I T1 T2 T3 T4 T5 T6 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((T1 * T2) * T3) * T4) * T5) * T6)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 :
          axum_core.extract.FromRequest.Trait T6
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T6)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : core.future.future.Future.Trait Fut}
        {ℋ_16 : core.marker.Send.Trait Fut}
        {ℋ_17 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_18 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_19 : core.clone.Clone.Trait I}
        {ℋ_20 : core.marker.Send.Trait I}
        {ℋ_21 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_22 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_23 : core.clone.Clone.Trait S}
        {ℋ_24 : core.marker.Send.Trait S}
        {ℋ_25 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t
          F
          S
          I
          (((((T1 * T2) * T3) * T4) * T5) * T6).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
      Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 :
          axum_core.extract.FromRequest.Trait T7
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T7)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : core.future.future.Future.Trait Fut}
        {ℋ_18 : core.marker.Send.Trait Fut}
        {ℋ_19 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_20 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_21 : core.clone.Clone.Trait I}
        {ℋ_22 : core.marker.Send.Trait I}
        {ℋ_23 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_24 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_25 : core.clone.Clone.Trait S}
        {ℋ_26 : core.marker.Send.Trait S}
        {ℋ_27 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t
          F
          S
          I
          ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
      Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 :
          axum_core.extract.FromRequest.Trait T8
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T8)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : core.future.future.Future.Trait Fut}
        {ℋ_20 : core.marker.Send.Trait Fut}
        {ℋ_21 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_22 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_23 : core.clone.Clone.Trait I}
        {ℋ_24 : core.marker.Send.Trait I}
        {ℋ_25 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_26 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_27 : core.clone.Clone.Trait S}
        {ℋ_28 : core.marker.Send.Trait S}
        {ℋ_29 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t
          F
          S
          I
          (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
      Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 :
          axum_core.extract.FromRequest.Trait T9
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T9)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : core.future.future.Future.Trait Fut}
        {ℋ_22 : core.marker.Send.Trait Fut}
        {ℋ_23 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_24 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_25 : core.clone.Clone.Trait I}
        {ℋ_26 : core.marker.Send.Trait I}
        {ℋ_27 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_28 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_29 : core.clone.Clone.Trait S}
        {ℋ_30 : core.marker.Send.Trait S}
        {ℋ_31 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t
          F
          S
          I
          ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
      Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
            *
            T10)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 :
          axum_core.extract.FromRequest.Trait T10
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T10)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : core.future.future.Future.Trait Fut}
        {ℋ_24 : core.marker.Send.Trait Fut}
        {ℋ_25 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_26 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_27 : core.clone.Clone.Trait I}
        {ℋ_28 : core.marker.Send.Trait I}
        {ℋ_29 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_30 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_31 : core.clone.Clone.Trait S}
        {ℋ_32 : core.marker.Send.Trait S}
        {ℋ_33 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t
          F
          S
          I
          (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
      Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 :
          axum_core.extract.FromRequest.Trait T11
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T11)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : core.future.future.Future.Trait Fut}
        {ℋ_26 : core.marker.Send.Trait Fut}
        {ℋ_27 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_28 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_29 : core.clone.Clone.Trait I}
        {ℋ_30 : core.marker.Send.Trait I}
        {ℋ_31 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_32 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_33 : core.clone.Clone.Trait S}
        {ℋ_34 : core.marker.Send.Trait S}
        {ℋ_35 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t
          F
          S
          I
          ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
      Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 :
          axum_core.extract.FromRequest.Trait T12
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T12)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : core.future.future.Future.Trait Fut}
        {ℋ_28 : core.marker.Send.Trait Fut}
        {ℋ_29 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_30 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_31 : core.clone.Clone.Trait I}
        {ℋ_32 : core.marker.Send.Trait I}
        {ℋ_33 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_34 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_35 : core.clone.Clone.Trait S}
        {ℋ_36 : core.marker.Send.Trait S}
        {ℋ_37 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t
          F
          S
          I
          (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
      Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 :
          axum_core.extract.FromRequest.Trait T13
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T13)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 : core.future.future.Future.Trait Fut}
        {ℋ_30 : core.marker.Send.Trait Fut}
        {ℋ_31 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_32 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_33 : core.clone.Clone.Trait I}
        {ℋ_34 : core.marker.Send.Trait I}
        {ℋ_35 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_36 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_37 : core.clone.Clone.Trait S}
        {ℋ_38 : core.marker.Send.Trait S}
        {ℋ_39 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t
          F
          S
          I
          ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12)
          *
          T13).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
      Context
        {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)
            *
            T14)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 :
          axum_core.extract.FromRequest.Trait T14
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T14)}
        {ℋ_30 : core.marker.Send.Trait T14}
        {ℋ_31 : core.future.future.Future.Trait Fut}
        {ℋ_32 : core.marker.Send.Trait Fut}
        {ℋ_33 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_34 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_35 : core.clone.Clone.Trait I}
        {ℋ_36 : core.marker.Send.Trait I}
        {ℋ_37 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_38 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_39 : core.clone.Clone.Trait S}
        {ℋ_40 : core.marker.Send.Trait S}
        {ℋ_41 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t
          F
          S
          I
          (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
      Context
        {F
          Fut
          Out
          S
          I
          T1
          T2
          T3
          T4
          T5
          T6
          T7
          T8
          T9
          T10
          T11
          T12
          T13
          T14
          T15
          :
          Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)
            *
            T14)
            *
            T15)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_30 : core.marker.Send.Trait T14}
        {ℋ_31 :
          axum_core.extract.FromRequest.Trait T15
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T15)}
        {ℋ_32 : core.marker.Send.Trait T15}
        {ℋ_33 : core.future.future.Future.Trait Fut}
        {ℋ_34 : core.marker.Send.Trait Fut}
        {ℋ_35 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_36 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_37 : core.clone.Clone.Trait I}
        {ℋ_38 : core.marker.Send.Trait I}
        {ℋ_39 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_40 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_41 : core.clone.Clone.Trait S}
        {ℋ_42 : core.marker.Send.Trait S}
        {ℋ_43 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t
          F
          S
          I
          ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
      Context
        {F
          Fut
          Out
          S
          I
          T1
          T2
          T3
          T4
          T5
          T6
          T7
          T8
          T9
          T10
          T11
          T12
          T13
          T14
          T15
          T16
          :
          Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)
            *
            T14)
            *
            T15)
            *
            T16)
            *
            axum.middleware.from_fn.Next.t)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_30 : core.marker.Send.Trait T14}
        {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
        {ℋ_32 : core.marker.Send.Trait T15}
        {ℋ_33 :
          axum_core.extract.FromRequest.Trait T16
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T16)}
        {ℋ_34 : core.marker.Send.Trait T16}
        {ℋ_35 : core.future.future.Future.Trait Fut}
        {ℋ_36 : core.marker.Send.Trait Fut}
        {ℋ_37 : axum_core.response.into_response.IntoResponse.Trait Out}
        {ℋ_38 :
          tower_service.Service.Trait I
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_39 : core.clone.Clone.Trait I}
        {ℋ_40 : core.marker.Send.Trait I}
        {ℋ_41 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_42 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_43 : core.clone.Clone.Trait S}
        {ℋ_44 : core.marker.Send.Trait S}
        {ℋ_45 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.from_fn.FromFn.t
          F
          S
          I
          (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          T16).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          let inner = ServiceBuilder::new()
                              .boxed_clone()
                              .map_response(IntoResponse::into_response)
                              .service(ready_inner);
                          let next = Next { inner };
      
                          f($($ty,)* $last, next).await.into_response()
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
    Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
      Context {F S I T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S} {ℋ_1 : core.fmt.Debug.Trait I}.
      
      Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I T.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("FromFnLayer")
                  .field("f", &format_args!("{}", type_name::<F>()))
                  .field("inner", &self.inner)
                  .field("state", &self.state)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
    End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
    
    Module  Next.
    Section Next.
      Record t : Set := {
        inner :
          tower.util.boxed_clone.BoxCloneService.t
            ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T)
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            core.convert.Infallible.t;
      }.
      
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
    End Next.
    End Next.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.
    Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.
      Definition Self : Set := axum.middleware.from_fn.Next.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.
    End Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.
    
    Module  Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.
    Section Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.
      Definition Self : Set := axum.middleware.from_fn.Next.t.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M axum.middleware.from_fn.Next.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.
    End Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.
    
    Module  Impl_axum_middleware_from_fn_Next_t.
    Section Impl_axum_middleware_from_fn_Next_t.
      Definition Self : Set := axum.middleware.from_fn.Next.t.
      
      (*
          pub async fn run(mut self, req: Request) -> Response {
              match self.inner.call(req).await {
                  Ok(res) => res,
                  Err(err) => match err {},
              }
          }
      *)
      Definition run
          (self : Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M OpaqueDef :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_run :
        Notations.DoubleColon Self "run" := {
        Notations.double_colon := run;
      }.
    End Impl_axum_middleware_from_fn_Next_t.
    End Impl_axum_middleware_from_fn_Next_t.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.
    Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.
      Definition Self : Set := axum.middleware.from_fn.Next.t.
      
      (*
          type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
          type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
          type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;
      *)
      Definition Future : Set :=
        core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A).
      
      (*
          fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              self.inner.poll_ready(cx)
          }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
          fn call(&mut self, req: Request) -> Self::Future {
              self.inner.call(req)
          }
      *)
      Definition call
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.
    End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.
    
    Module  ResponseFuture.
    Section ResponseFuture.
      Record t : Set := {
        inner :
          ltac:(futures_core.future.BoxFuture
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T));
      }.
      
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
    End ResponseFuture.
    End ResponseFuture.
    
    Module  Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.
    Section Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.
      Definition Self : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
          type Output = Result<Response, Infallible>;
      *)
      Definition Output : Set :=
        core.result.Result.t
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            core.convert.Infallible.t.
      
      (*
          fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
              self.inner.as_mut().poll(cx).map(Ok)
          }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.
    End Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.
    Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.
      Definition Self : Set := axum.middleware.from_fn.ResponseFuture.t.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("ResponseFuture").finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.
    End Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.
  End from_fn.
  
  Module map_request.
    (*
    pub fn map_request<F, T>(f: F) -> MapRequestLayer<F, (), T> {
        map_request_with_state((), f)
    }
    *)
    Definition map_request
        {F T : Set}
        (f : F)
        : M (axum.middleware.map_request.MapRequestLayer.t F unit T) :=
      let* f := M.alloc f in
      M.read foo.
    
    (*
    pub fn map_request_with_state<F, S, T>(state: S, f: F) -> MapRequestLayer<F, S, T> {
        MapRequestLayer {
            f,
            state,
            _extractor: PhantomData,
        }
    }
    *)
    Definition map_request_with_state
        {F S T : Set}
        (state : S)
        (f : F)
        : M (axum.middleware.map_request.MapRequestLayer.t F S T) :=
      let* state := M.alloc state in
      let* f := M.alloc f in
      M.read foo.
    
    Module  MapRequestLayer.
    Section MapRequestLayer.
      Context (F S T : Set).
      
      Record t : Set := {
        f : F;
        state : S;
        _extractor : core.marker.PhantomData.t T;
      }.
      
      Definition Get_f :=
        Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
      Definition Get_state :=
        Ref.map
          (fun α => Some α.(state))
          (fun β α => Some (α <| state := β |>)).
      Definition Get__extractor :=
        Ref.map
          (fun α => Some α.(_extractor))
          (fun β α => Some (α <| _extractor := β |>)).
    End MapRequestLayer.
    End MapRequestLayer.
    
    Module  Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    Section Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
      Context {F S T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequestLayer.t F S T.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  f: self.f.clone(),
                  state: self.state.clone(),
                  _extractor: self._extractor,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    
    Module  Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    Section Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
      Context {S I F T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequestLayer.t F S T.
      
      (*
          type Service = MapRequest<F, S, I, T>;
      *)
      Definition Service : Set :=
        axum.middleware.map_request.MapRequest.t F S I T.
      
      (*
          fn layer(&self, inner: I) -> Self::Service {
              MapRequest {
                  f: self.f.clone(),
                  state: self.state.clone(),
                  inner,
                  _extractor: PhantomData,
              }
          }
      *)
      Definition layer (self : ref Self) (inner : I) : M Service :=
        let* self := M.alloc self in
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_layer :
        Notations.DoubleColon Self "layer" := {
        Notations.double_colon := layer;
      }.
      
      Global Instance ℐ : tower_layer.Layer.Trait Self (S := I) := {
        tower_layer.Layer.Service := Service;
        tower_layer.Layer.layer := layer;
      }.
    End Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    End Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    Section Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
      Context {F S T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequestLayer.t F S T.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("MapRequestLayer")
                  // Write out the type name, without quoting it as `&type_name::<F>()` would
                  .field("f", &format_args!("{}", type_name::<F>()))
                  .field("state", &self.state)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    
    Module  MapRequest.
    Section MapRequest.
      Context (F S I T : Set).
      
      Record t : Set := {
        f : F;
        inner : I;
        state : S;
        _extractor : core.marker.PhantomData.t T;
      }.
      
      Definition Get_f :=
        Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
      Definition Get_state :=
        Ref.map
          (fun α => Some α.(state))
          (fun β α => Some (α <| state := β |>)).
      Definition Get__extractor :=
        Ref.map
          (fun α => Some α.(_extractor))
          (fun β α => Some (α <| _extractor := β |>)).
    End MapRequest.
    End MapRequest.
    
    Module  Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
    Section Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
      Context {F S I T : Set}.
      
      Context
        {ℋ_0 : core.clone.Clone.Trait F}
        {ℋ_1 : core.clone.Clone.Trait I}
        {ℋ_2 : core.clone.Clone.Trait S}.
      
      Definition Self : Set := axum.middleware.map_request.MapRequest.t F S I T.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  f: self.f.clone(),
                  inner: self.inner.clone(),
                  state: self.state.clone(),
                  _extractor: self._extractor,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
    End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.
      Context {F Fut S I B T1 : Set}.
      
      Context
        {ℋ_0 : core.ops.function.FnMut.Trait F (Args := T1)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 :
          axum_core.extract.FromRequest.Trait T1
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T1)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : core.future.future.Future.Trait Fut}
        {ℋ_6 : core.marker.Send.Trait Fut}
        {ℋ_7 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_8 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_9 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_10 : core.clone.Clone.Trait I}
        {ℋ_11 : core.marker.Send.Trait I}
        {ℋ_12 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_13 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_14 : http_body.Body.Trait B}
        {ℋ_15 : core.marker.Send.Trait B}
        {ℋ_16 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_17 : core.clone.Clone.Trait S}
        {ℋ_18 : core.marker.Send.Trait S}
        {ℋ_19 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t F S I T1.
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.
      Context {F Fut S I B T1 T2 : Set}.
      
      Context
        {ℋ_0 : core.ops.function.FnMut.Trait F (Args := T1 * T2)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 :
          axum_core.extract.FromRequest.Trait T2
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T2)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : core.future.future.Future.Trait Fut}
        {ℋ_8 : core.marker.Send.Trait Fut}
        {ℋ_9 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_10 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_11 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_12 : core.clone.Clone.Trait I}
        {ℋ_13 : core.marker.Send.Trait I}
        {ℋ_14 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_15 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_16 : http_body.Body.Trait B}
        {ℋ_17 : core.marker.Send.Trait B}
        {ℋ_18 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_19 : core.clone.Clone.Trait S}
        {ℋ_20 : core.marker.Send.Trait S}
        {ℋ_21 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t F S I (T1 * T2).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.
      Context {F Fut S I B T1 T2 T3 : Set}.
      
      Context
        {ℋ_0 : core.ops.function.FnMut.Trait F (Args := (T1 * T2) * T3)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 :
          axum_core.extract.FromRequest.Trait T3
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T3)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : core.future.future.Future.Trait Fut}
        {ℋ_10 : core.marker.Send.Trait Fut}
        {ℋ_11 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_12 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_13 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_14 : core.clone.Clone.Trait I}
        {ℋ_15 : core.marker.Send.Trait I}
        {ℋ_16 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_17 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_18 : http_body.Body.Trait B}
        {ℋ_19 : core.marker.Send.Trait B}
        {ℋ_20 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_21 : core.clone.Clone.Trait S}
        {ℋ_22 : core.marker.Send.Trait S}
        {ℋ_23 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t F S I ((T1 * T2) * T3).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.
      Context {F Fut S I B T1 T2 T3 T4 : Set}.
      
      Context
        {ℋ_0 : core.ops.function.FnMut.Trait F (Args := ((T1 * T2) * T3) * T4)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 :
          axum_core.extract.FromRequest.Trait T4
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T4)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : core.future.future.Future.Trait Fut}
        {ℋ_12 : core.marker.Send.Trait Fut}
        {ℋ_13 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_14 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_15 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_16 : core.clone.Clone.Trait I}
        {ℋ_17 : core.marker.Send.Trait I}
        {ℋ_18 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_19 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_20 : http_body.Body.Trait B}
        {ℋ_21 : core.marker.Send.Trait B}
        {ℋ_22 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_23 : core.clone.Clone.Trait S}
        {ℋ_24 : core.marker.Send.Trait S}
        {ℋ_25 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t F S I (((T1 * T2) * T3) * T4).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
      Context {F Fut S I B T1 T2 T3 T4 T5 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((T1 * T2) * T3) * T4) * T5)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 :
          axum_core.extract.FromRequest.Trait T5
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T5)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : core.future.future.Future.Trait Fut}
        {ℋ_14 : core.marker.Send.Trait Fut}
        {ℋ_15 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_16 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_17 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_18 : core.clone.Clone.Trait I}
        {ℋ_19 : core.marker.Send.Trait I}
        {ℋ_20 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_21 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_22 : http_body.Body.Trait B}
        {ℋ_23 : core.marker.Send.Trait B}
        {ℋ_24 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_25 : core.clone.Clone.Trait S}
        {ℋ_26 : core.marker.Send.Trait S}
        {ℋ_27 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          ((((T1 * T2) * T3) * T4) * T5).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
      Context {F Fut S I B T1 T2 T3 T4 T5 T6 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((T1 * T2) * T3) * T4) * T5) * T6)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 :
          axum_core.extract.FromRequest.Trait T6
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T6)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : core.future.future.Future.Trait Fut}
        {ℋ_16 : core.marker.Send.Trait Fut}
        {ℋ_17 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_18 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_19 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_20 : core.clone.Clone.Trait I}
        {ℋ_21 : core.marker.Send.Trait I}
        {ℋ_22 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_23 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_24 : http_body.Body.Trait B}
        {ℋ_25 : core.marker.Send.Trait B}
        {ℋ_26 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_27 : core.clone.Clone.Trait S}
        {ℋ_28 : core.marker.Send.Trait S}
        {ℋ_29 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          (((((T1 * T2) * T3) * T4) * T5) * T6).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
      Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 :
          axum_core.extract.FromRequest.Trait T7
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T7)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : core.future.future.Future.Trait Fut}
        {ℋ_18 : core.marker.Send.Trait Fut}
        {ℋ_19 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_20 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_21 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_22 : core.clone.Clone.Trait I}
        {ℋ_23 : core.marker.Send.Trait I}
        {ℋ_24 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_25 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_26 : http_body.Body.Trait B}
        {ℋ_27 : core.marker.Send.Trait B}
        {ℋ_28 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_29 : core.clone.Clone.Trait S}
        {ℋ_30 : core.marker.Send.Trait S}
        {ℋ_31 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
      Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 :
          axum_core.extract.FromRequest.Trait T8
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T8)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : core.future.future.Future.Trait Fut}
        {ℋ_20 : core.marker.Send.Trait Fut}
        {ℋ_21 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_22 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_23 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_24 : core.clone.Clone.Trait I}
        {ℋ_25 : core.marker.Send.Trait I}
        {ℋ_26 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_27 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_28 : http_body.Body.Trait B}
        {ℋ_29 : core.marker.Send.Trait B}
        {ℋ_30 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_31 : core.clone.Clone.Trait S}
        {ℋ_32 : core.marker.Send.Trait S}
        {ℋ_33 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
      Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 :
          axum_core.extract.FromRequest.Trait T9
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T9)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : core.future.future.Future.Trait Fut}
        {ℋ_22 : core.marker.Send.Trait Fut}
        {ℋ_23 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_24 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_25 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_26 : core.clone.Clone.Trait I}
        {ℋ_27 : core.marker.Send.Trait I}
        {ℋ_28 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_29 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_30 : http_body.Body.Trait B}
        {ℋ_31 : core.marker.Send.Trait B}
        {ℋ_32 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_33 : core.clone.Clone.Trait S}
        {ℋ_34 : core.marker.Send.Trait S}
        {ℋ_35 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
      Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
            *
            T10)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 :
          axum_core.extract.FromRequest.Trait T10
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T10)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : core.future.future.Future.Trait Fut}
        {ℋ_24 : core.marker.Send.Trait Fut}
        {ℋ_25 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_26 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_27 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_28 : core.clone.Clone.Trait I}
        {ℋ_29 : core.marker.Send.Trait I}
        {ℋ_30 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_31 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_32 : http_body.Body.Trait B}
        {ℋ_33 : core.marker.Send.Trait B}
        {ℋ_34 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_35 : core.clone.Clone.Trait S}
        {ℋ_36 : core.marker.Send.Trait S}
        {ℋ_37 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
      Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
            *
            T10)
            *
            T11)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 :
          axum_core.extract.FromRequest.Trait T11
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T11)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : core.future.future.Future.Trait Fut}
        {ℋ_26 : core.marker.Send.Trait Fut}
        {ℋ_27 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_28 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_29 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_30 : core.clone.Clone.Trait I}
        {ℋ_31 : core.marker.Send.Trait I}
        {ℋ_32 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_33 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_34 : http_body.Body.Trait B}
        {ℋ_35 : core.marker.Send.Trait B}
        {ℋ_36 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_37 : core.clone.Clone.Trait S}
        {ℋ_38 : core.marker.Send.Trait S}
        {ℋ_39 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
      Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 :
          axum_core.extract.FromRequest.Trait T12
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T12)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : core.future.future.Future.Trait Fut}
        {ℋ_28 : core.marker.Send.Trait Fut}
        {ℋ_29 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_30 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_31 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_32 : core.clone.Clone.Trait I}
        {ℋ_33 : core.marker.Send.Trait I}
        {ℋ_34 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_35 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_36 : http_body.Body.Trait B}
        {ℋ_37 : core.marker.Send.Trait B}
        {ℋ_38 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_39 : core.clone.Clone.Trait S}
        {ℋ_40 : core.marker.Send.Trait S}
        {ℋ_41 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
      Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 :
          axum_core.extract.FromRequest.Trait T13
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T13)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 : core.future.future.Future.Trait Fut}
        {ℋ_30 : core.marker.Send.Trait Fut}
        {ℋ_31 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_32 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_33 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_34 : core.clone.Clone.Trait I}
        {ℋ_35 : core.marker.Send.Trait I}
        {ℋ_36 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_37 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_38 : http_body.Body.Trait B}
        {ℋ_39 : core.marker.Send.Trait B}
        {ℋ_40 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_41 : core.clone.Clone.Trait S}
        {ℋ_42 : core.marker.Send.Trait S}
        {ℋ_43 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12)
          *
          T13).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
      Context
        {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)
            *
            T14)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 :
          axum_core.extract.FromRequest.Trait T14
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T14)}
        {ℋ_30 : core.marker.Send.Trait T14}
        {ℋ_31 : core.future.future.Future.Trait Fut}
        {ℋ_32 : core.marker.Send.Trait Fut}
        {ℋ_33 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_34 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_35 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_36 : core.clone.Clone.Trait I}
        {ℋ_37 : core.marker.Send.Trait I}
        {ℋ_38 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_39 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_40 : http_body.Body.Trait B}
        {ℋ_41 : core.marker.Send.Trait B}
        {ℋ_42 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_43 : core.clone.Clone.Trait S}
        {ℋ_44 : core.marker.Send.Trait S}
        {ℋ_45 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
      Context
        {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)
            *
            T14)
            *
            T15)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_30 : core.marker.Send.Trait T14}
        {ℋ_31 :
          axum_core.extract.FromRequest.Trait T15
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T15)}
        {ℋ_32 : core.marker.Send.Trait T15}
        {ℋ_33 : core.future.future.Future.Trait Fut}
        {ℋ_34 : core.marker.Send.Trait Fut}
        {ℋ_35 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_36 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_37 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_38 : core.clone.Clone.Trait I}
        {ℋ_39 : core.marker.Send.Trait I}
        {ℋ_40 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_41 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_42 : http_body.Body.Trait B}
        {ℋ_43 : core.marker.Send.Trait B}
        {ℋ_44 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_45 : core.clone.Clone.Trait S}
        {ℋ_46 : core.marker.Send.Trait S}
        {ℋ_47 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
      Context
        {F
          Fut
          S
          I
          B
          T1
          T2
          T3
          T4
          T5
          T6
          T7
          T8
          T9
          T10
          T11
          T12
          T13
          T14
          T15
          T16
          :
          Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)
            *
            T14)
            *
            T15)
            *
            T16)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_30 : core.marker.Send.Trait T14}
        {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
        {ℋ_32 : core.marker.Send.Trait T15}
        {ℋ_33 :
          axum_core.extract.FromRequest.Trait T16
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T16)}
        {ℋ_34 : core.marker.Send.Trait T16}
        {ℋ_35 : core.future.future.Future.Trait Fut}
        {ℋ_36 : core.marker.Send.Trait Fut}
        {ℋ_37 :
          axum.middleware.map_request.IntoMapRequestResult.Trait
              Fut::type["Output"].t
            (B := B)}
        {ℋ_38 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_39 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_40 : core.clone.Clone.Trait I}
        {ℋ_41 : core.marker.Send.Trait I}
        {ℋ_42 :
          axum_core.response.into_response.IntoResponse.Trait
              I::type["Response"].t}
        {ℋ_43 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_44 : http_body.Body.Trait B}
        {ℋ_45 : core.marker.Send.Trait B}
        {ℋ_46 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        {ℋ_47 : core.clone.Clone.Trait S}
        {ℋ_48 : core.marker.Send.Trait S}
        {ℋ_49 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_request.MapRequest.t
          F
          S
          I
          (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          T16).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let req = req.map(Body::new);
      
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          let $last = match $last::from_request(req, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
      
                          match f($($ty,)* $last).await.into_map_request_result() {
                              Ok(req) => {
                                  ready_inner.call(req).await.into_response()
                              }
                              Err(res) => {
                                  res
                              }
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
    Section Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
      Context {F S I T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S} {ℋ_1 : core.fmt.Debug.Trait I}.
      
      Definition Self : Set := axum.middleware.map_request.MapRequest.t F S I T.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("MapRequest")
                  .field("f", &format_args!("{}", type_name::<F>()))
                  .field("inner", &self.inner)
                  .field("state", &self.state)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
    End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
    
    Module  ResponseFuture.
    Section ResponseFuture.
      Record t : Set := {
        inner :
          ltac:(futures_core.future.BoxFuture
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T));
      }.
      
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
    End ResponseFuture.
    End ResponseFuture.
    
    Module  Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.
    Section Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.
      Definition Self : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
          type Output = Result<Response, Infallible>;
      *)
      Definition Output : Set :=
        core.result.Result.t
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            core.convert.Infallible.t.
      
      (*
          fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
              self.inner.as_mut().poll(cx).map(Ok)
          }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.
    End Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.
    Section Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.
      Definition Self : Set := axum.middleware.map_request.ResponseFuture.t.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("ResponseFuture").finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.
    End Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.
    
    Module private.
      Module  Sealed.
      Section Sealed.
        Unset Primitive Projections.
        Class Trait (Self : Set) {B : Set} : Type := {
        }.
        Global Set Primitive Projections.
      End Sealed.
      End Sealed.
      
      Module  Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
      Section Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
        Context {B E : Set}.
        
        Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E}.
        
        Definition Self : Set :=
          core.result.Result.t (http.request.Request.t B) E.
        
        Global Instance ℐ :
          axum.middleware.map_request.private.Sealed.Trait Self (B := B) := {
        }.
      End Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
      End Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
      
      Module  Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
      Section Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
        Context {B : Set}.
        
        Definition Self : Set := http.request.Request.t B.
        
        Global Instance ℐ :
          axum.middleware.map_request.private.Sealed.Trait Self (B := B) := {
        }.
      End Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
      End Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
    End private.
    
    Module  IntoMapRequestResult.
    Section IntoMapRequestResult.
      Class Trait (Self : Set) {B : Set} : Type := {
        ℒ_0 :: axum.middleware.map_request.private.Sealed.Trait Self (B := B);
        into_map_request_result :
          Self ->
            M
              (core.result.Result.t
                (http.request.Request.t B)
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T));
      }.
      
    End IntoMapRequestResult.
    End IntoMapRequestResult.
    
    Module  Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.
    Section Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.
      Context {B E : Set}.
      
      Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E}.
      
      Definition Self : Set :=
        core.result.Result.t (http.request.Request.t B) E.
      
      (*
          fn into_map_request_result(self) -> Result<Request<B>, Response> {
              self.map_err(IntoResponse::into_response)
          }
      *)
      Definition into_map_request_result
          (self : Self)
          :
            M
              (core.result.Result.t
                (http.request.Request.t B)
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_map_request_result :
        Notations.DoubleColon Self "into_map_request_result" := {
        Notations.double_colon := into_map_request_result;
      }.
      
      Global Instance ℐ :
        axum.middleware.map_request.IntoMapRequestResult.Trait Self
          (B := B) := {
        axum.middleware.map_request.IntoMapRequestResult.into_map_request_result :=
          into_map_request_result;
      }.
    End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.
    End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.
    
    Module  Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.
    Section Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.
      Context {B : Set}.
      
      Definition Self : Set := http.request.Request.t B.
      
      (*
          fn into_map_request_result(self) -> Result<Request<B>, Response> {
              Ok(self)
          }
      *)
      Definition into_map_request_result
          (self : Self)
          :
            M
              (core.result.Result.t
                (http.request.Request.t B)
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_map_request_result :
        Notations.DoubleColon Self "into_map_request_result" := {
        Notations.double_colon := into_map_request_result;
      }.
      
      Global Instance ℐ :
        axum.middleware.map_request.IntoMapRequestResult.Trait Self
          (B := B) := {
        axum.middleware.map_request.IntoMapRequestResult.into_map_request_result :=
          into_map_request_result;
      }.
    End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.
    End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.
  End map_request.
  
  Module map_response.
    (*
    pub fn map_response<F, T>(f: F) -> MapResponseLayer<F, (), T> {
        map_response_with_state((), f)
    }
    *)
    Definition map_response
        {F T : Set}
        (f : F)
        : M (axum.middleware.map_response.MapResponseLayer.t F unit T) :=
      let* f := M.alloc f in
      M.read foo.
    
    (*
    pub fn map_response_with_state<F, S, T>(state: S, f: F) -> MapResponseLayer<F, S, T> {
        MapResponseLayer {
            f,
            state,
            _extractor: PhantomData,
        }
    }
    *)
    Definition map_response_with_state
        {F S T : Set}
        (state : S)
        (f : F)
        : M (axum.middleware.map_response.MapResponseLayer.t F S T) :=
      let* state := M.alloc state in
      let* f := M.alloc f in
      M.read foo.
    
    Module  MapResponseLayer.
    Section MapResponseLayer.
      Context (F S T : Set).
      
      Record t : Set := {
        f : F;
        state : S;
        _extractor : core.marker.PhantomData.t T;
      }.
      
      Definition Get_f :=
        Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
      Definition Get_state :=
        Ref.map
          (fun α => Some α.(state))
          (fun β α => Some (α <| state := β |>)).
      Definition Get__extractor :=
        Ref.map
          (fun α => Some α.(_extractor))
          (fun β α => Some (α <| _extractor := β |>)).
    End MapResponseLayer.
    End MapResponseLayer.
    
    Module  Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    Section Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
      Context {F S T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponseLayer.t F S T.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  f: self.f.clone(),
                  state: self.state.clone(),
                  _extractor: self._extractor,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    
    Module  Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    Section Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
      Context {S I F T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponseLayer.t F S T.
      
      (*
          type Service = MapResponse<F, S, I, T>;
      *)
      Definition Service : Set :=
        axum.middleware.map_response.MapResponse.t F S I T.
      
      (*
          fn layer(&self, inner: I) -> Self::Service {
              MapResponse {
                  f: self.f.clone(),
                  state: self.state.clone(),
                  inner,
                  _extractor: PhantomData,
              }
          }
      *)
      Definition layer (self : ref Self) (inner : I) : M Service :=
        let* self := M.alloc self in
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_layer :
        Notations.DoubleColon Self "layer" := {
        Notations.double_colon := layer;
      }.
      
      Global Instance ℐ : tower_layer.Layer.Trait Self (S := I) := {
        tower_layer.Layer.Service := Service;
        tower_layer.Layer.layer := layer;
      }.
    End Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    End Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    Section Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
      Context {F S T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponseLayer.t F S T.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("MapResponseLayer")
                  // Write out the type name, without quoting it as `&type_name::<F>()` would
                  .field("f", &format_args!("{}", type_name::<F>()))
                  .field("state", &self.state)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    
    Module  MapResponse.
    Section MapResponse.
      Context (F S I T : Set).
      
      Record t : Set := {
        f : F;
        inner : I;
        state : S;
        _extractor : core.marker.PhantomData.t T;
      }.
      
      Definition Get_f :=
        Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
      Definition Get_state :=
        Ref.map
          (fun α => Some α.(state))
          (fun β α => Some (α <| state := β |>)).
      Definition Get__extractor :=
        Ref.map
          (fun α => Some α.(_extractor))
          (fun β α => Some (α <| _extractor := β |>)).
    End MapResponse.
    End MapResponse.
    
    Module  Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
    Section Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
      Context {F S I T : Set}.
      
      Context
        {ℋ_0 : core.clone.Clone.Trait F}
        {ℋ_1 : core.clone.Clone.Trait I}
        {ℋ_2 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t F S I T.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  f: self.f.clone(),
                  inner: self.inner.clone(),
                  state: self.state.clone(),
                  _extractor: self._extractor,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
    End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.
      Context {F Fut S I B ResBody : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : core.future.future.Future.Trait Fut}
        {ℋ_4 : core.marker.Send.Trait Fut}
        {ℋ_5 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_6 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_7 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_8 : core.clone.Clone.Trait I}
        {ℋ_9 : core.marker.Send.Trait I}
        {ℋ_10 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_11 : core.marker.Send.Trait B}
        {ℋ_12 : core.marker.Send.Trait ResBody}
        {ℋ_13 : core.clone.Clone.Trait S}
        {ℋ_14 : core.marker.Send.Trait S}
        {ℋ_15 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t F S I unit.
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.
      Context {F Fut S I B ResBody T1 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := T1 * ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : core.future.future.Future.Trait Fut}
        {ℋ_6 : core.marker.Send.Trait Fut}
        {ℋ_7 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_8 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_9 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_10 : core.clone.Clone.Trait I}
        {ℋ_11 : core.marker.Send.Trait I}
        {ℋ_12 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_13 : core.marker.Send.Trait B}
        {ℋ_14 : core.marker.Send.Trait ResBody}
        {ℋ_15 : core.clone.Clone.Trait S}
        {ℋ_16 : core.marker.Send.Trait S}
        {ℋ_17 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t F S I T1.
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.
      Context {F Fut S I B ResBody T1 T2 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (T1 * T2) * ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : core.future.future.Future.Trait Fut}
        {ℋ_8 : core.marker.Send.Trait Fut}
        {ℋ_9 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_10 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_11 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_12 : core.clone.Clone.Trait I}
        {ℋ_13 : core.marker.Send.Trait I}
        {ℋ_14 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_15 : core.marker.Send.Trait B}
        {ℋ_16 : core.marker.Send.Trait ResBody}
        {ℋ_17 : core.clone.Clone.Trait S}
        {ℋ_18 : core.marker.Send.Trait S}
        {ℋ_19 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t F S I (T1 * T2).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.
      Context {F Fut S I B ResBody T1 T2 T3 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((T1 * T2) * T3)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : core.future.future.Future.Trait Fut}
        {ℋ_10 : core.marker.Send.Trait Fut}
        {ℋ_11 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_12 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_13 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_14 : core.clone.Clone.Trait I}
        {ℋ_15 : core.marker.Send.Trait I}
        {ℋ_16 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_17 : core.marker.Send.Trait B}
        {ℋ_18 : core.marker.Send.Trait ResBody}
        {ℋ_19 : core.clone.Clone.Trait S}
        {ℋ_20 : core.marker.Send.Trait S}
        {ℋ_21 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t F S I ((T1 * T2) * T3).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.
      Context {F Fut S I B ResBody T1 T2 T3 T4 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((T1 * T2) * T3) * T4)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : core.future.future.Future.Trait Fut}
        {ℋ_12 : core.marker.Send.Trait Fut}
        {ℋ_13 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_14 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_15 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_16 : core.clone.Clone.Trait I}
        {ℋ_17 : core.marker.Send.Trait I}
        {ℋ_18 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_19 : core.marker.Send.Trait B}
        {ℋ_20 : core.marker.Send.Trait ResBody}
        {ℋ_21 : core.clone.Clone.Trait S}
        {ℋ_22 : core.marker.Send.Trait S}
        {ℋ_23 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          (((T1 * T2) * T3) * T4).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
      Context {F Fut S I B ResBody T1 T2 T3 T4 T5 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((T1 * T2) * T3) * T4) * T5)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : core.future.future.Future.Trait Fut}
        {ℋ_14 : core.marker.Send.Trait Fut}
        {ℋ_15 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_16 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_17 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_18 : core.clone.Clone.Trait I}
        {ℋ_19 : core.marker.Send.Trait I}
        {ℋ_20 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_21 : core.marker.Send.Trait B}
        {ℋ_22 : core.marker.Send.Trait ResBody}
        {ℋ_23 : core.clone.Clone.Trait S}
        {ℋ_24 : core.marker.Send.Trait S}
        {ℋ_25 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          ((((T1 * T2) * T3) * T4) * T5).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
      Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((T1 * T2) * T3) * T4) * T5) * T6)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : core.future.future.Future.Trait Fut}
        {ℋ_16 : core.marker.Send.Trait Fut}
        {ℋ_17 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_18 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_19 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_20 : core.clone.Clone.Trait I}
        {ℋ_21 : core.marker.Send.Trait I}
        {ℋ_22 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_23 : core.marker.Send.Trait B}
        {ℋ_24 : core.marker.Send.Trait ResBody}
        {ℋ_25 : core.clone.Clone.Trait S}
        {ℋ_26 : core.marker.Send.Trait S}
        {ℋ_27 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          (((((T1 * T2) * T3) * T4) * T5) * T6).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
      Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : core.future.future.Future.Trait Fut}
        {ℋ_18 : core.marker.Send.Trait Fut}
        {ℋ_19 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_20 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_21 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_22 : core.clone.Clone.Trait I}
        {ℋ_23 : core.marker.Send.Trait I}
        {ℋ_24 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_25 : core.marker.Send.Trait B}
        {ℋ_26 : core.marker.Send.Trait ResBody}
        {ℋ_27 : core.clone.Clone.Trait S}
        {ℋ_28 : core.marker.Send.Trait S}
        {ℋ_29 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
      Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : core.future.future.Future.Trait Fut}
        {ℋ_20 : core.marker.Send.Trait Fut}
        {ℋ_21 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_22 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_23 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_24 : core.clone.Clone.Trait I}
        {ℋ_25 : core.marker.Send.Trait I}
        {ℋ_26 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_27 : core.marker.Send.Trait B}
        {ℋ_28 : core.marker.Send.Trait ResBody}
        {ℋ_29 : core.clone.Clone.Trait S}
        {ℋ_30 : core.marker.Send.Trait S}
        {ℋ_31 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
      Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : core.future.future.Future.Trait Fut}
        {ℋ_22 : core.marker.Send.Trait Fut}
        {ℋ_23 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_24 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_25 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_26 : core.clone.Clone.Trait I}
        {ℋ_27 : core.marker.Send.Trait I}
        {ℋ_28 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_29 : core.marker.Send.Trait B}
        {ℋ_30 : core.marker.Send.Trait ResBody}
        {ℋ_31 : core.clone.Clone.Trait S}
        {ℋ_32 : core.marker.Send.Trait S}
        {ℋ_33 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
      Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
            *
            T10)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : core.future.future.Future.Trait Fut}
        {ℋ_24 : core.marker.Send.Trait Fut}
        {ℋ_25 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_26 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_27 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_28 : core.clone.Clone.Trait I}
        {ℋ_29 : core.marker.Send.Trait I}
        {ℋ_30 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_31 : core.marker.Send.Trait B}
        {ℋ_32 : core.marker.Send.Trait ResBody}
        {ℋ_33 : core.clone.Clone.Trait S}
        {ℋ_34 : core.marker.Send.Trait S}
        {ℋ_35 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
      Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : core.future.future.Future.Trait Fut}
        {ℋ_26 : core.marker.Send.Trait Fut}
        {ℋ_27 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_28 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_29 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_30 : core.clone.Clone.Trait I}
        {ℋ_31 : core.marker.Send.Trait I}
        {ℋ_32 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_33 : core.marker.Send.Trait B}
        {ℋ_34 : core.marker.Send.Trait ResBody}
        {ℋ_35 : core.clone.Clone.Trait S}
        {ℋ_36 : core.marker.Send.Trait S}
        {ℋ_37 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
      Context
        {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : core.future.future.Future.Trait Fut}
        {ℋ_28 : core.marker.Send.Trait Fut}
        {ℋ_29 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_30 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_31 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_32 : core.clone.Clone.Trait I}
        {ℋ_33 : core.marker.Send.Trait I}
        {ℋ_34 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_35 : core.marker.Send.Trait B}
        {ℋ_36 : core.marker.Send.Trait ResBody}
        {ℋ_37 : core.clone.Clone.Trait S}
        {ℋ_38 : core.marker.Send.Trait S}
        {ℋ_39 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
      Context
        {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 : core.future.future.Future.Trait Fut}
        {ℋ_30 : core.marker.Send.Trait Fut}
        {ℋ_31 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_32 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_33 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_34 : core.clone.Clone.Trait I}
        {ℋ_35 : core.marker.Send.Trait I}
        {ℋ_36 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_37 : core.marker.Send.Trait B}
        {ℋ_38 : core.marker.Send.Trait ResBody}
        {ℋ_39 : core.clone.Clone.Trait S}
        {ℋ_40 : core.marker.Send.Trait S}
        {ℋ_41 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12)
          *
          T13).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
      Context
        {F
          Fut
          S
          I
          B
          ResBody
          T1
          T2
          T3
          T4
          T5
          T6
          T7
          T8
          T9
          T10
          T11
          T12
          T13
          T14
          :
          Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)
            *
            T14)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_30 : core.marker.Send.Trait T14}
        {ℋ_31 : core.future.future.Future.Trait Fut}
        {ℋ_32 : core.marker.Send.Trait Fut}
        {ℋ_33 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_34 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_35 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_36 : core.clone.Clone.Trait I}
        {ℋ_37 : core.marker.Send.Trait I}
        {ℋ_38 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_39 : core.marker.Send.Trait B}
        {ℋ_40 : core.marker.Send.Trait ResBody}
        {ℋ_41 : core.clone.Clone.Trait S}
        {ℋ_42 : core.marker.Send.Trait S}
        {ℋ_43 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
      Context
        {F
          Fut
          S
          I
          B
          ResBody
          T1
          T2
          T3
          T4
          T5
          T6
          T7
          T8
          T9
          T10
          T11
          T12
          T13
          T14
          T15
          :
          Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)
            *
            T14)
            *
            T15)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_30 : core.marker.Send.Trait T14}
        {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
        {ℋ_32 : core.marker.Send.Trait T15}
        {ℋ_33 : core.future.future.Future.Trait Fut}
        {ℋ_34 : core.marker.Send.Trait Fut}
        {ℋ_35 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_36 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_37 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_38 : core.clone.Clone.Trait I}
        {ℋ_39 : core.marker.Send.Trait I}
        {ℋ_40 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_41 : core.marker.Send.Trait B}
        {ℋ_42 : core.marker.Send.Trait ResBody}
        {ℋ_43 : core.clone.Clone.Trait S}
        {ℋ_44 : core.marker.Send.Trait S}
        {ℋ_45 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
      Context
        {F
          Fut
          S
          I
          B
          ResBody
          T1
          T2
          T3
          T4
          T5
          T6
          T7
          T8
          T9
          T10
          T11
          T12
          T13
          T14
          T15
          T16
          :
          Set}.
      
      Context
        {ℋ_0 :
          core.ops.function.FnMut.Trait F
            (Args := (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
            *
            T9)
            *
            T10)
            *
            T11)
            *
            T12)
            *
            T13)
            *
            T14)
            *
            T15)
            *
            T16)
            *
            ltac:(axum_core.response.Response ResBody))}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_4 : core.marker.Send.Trait T1}
        {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_6 : core.marker.Send.Trait T2}
        {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_8 : core.marker.Send.Trait T3}
        {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_10 : core.marker.Send.Trait T4}
        {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_12 : core.marker.Send.Trait T5}
        {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_14 : core.marker.Send.Trait T6}
        {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_16 : core.marker.Send.Trait T7}
        {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_18 : core.marker.Send.Trait T8}
        {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_20 : core.marker.Send.Trait T9}
        {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_22 : core.marker.Send.Trait T10}
        {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_24 : core.marker.Send.Trait T11}
        {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_26 : core.marker.Send.Trait T12}
        {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_28 : core.marker.Send.Trait T13}
        {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_30 : core.marker.Send.Trait T14}
        {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
        {ℋ_32 : core.marker.Send.Trait T15}
        {ℋ_33 : axum_core.extract.FromRequestParts.Trait T16 (S := S)}
        {ℋ_34 : core.marker.Send.Trait T16}
        {ℋ_35 : core.future.future.Future.Trait Fut}
        {ℋ_36 : core.marker.Send.Trait Fut}
        {ℋ_37 :
          axum_core.response.into_response.IntoResponse.Trait
              Fut::type["Output"].t}
        {ℋ_38 : core.marker.Send.Trait Fut::type["Output"].t}
        {ℋ_39 :
          tower_service.Service.Trait I (Request := http.request.Request.t B)}
        {ℋ_40 : core.clone.Clone.Trait I}
        {ℋ_41 : core.marker.Send.Trait I}
        {ℋ_42 : core.marker.Send.Trait I::type["Future"].t}
        {ℋ_43 : core.marker.Send.Trait B}
        {ℋ_44 : core.marker.Send.Trait ResBody}
        {ℋ_45 : core.clone.Clone.Trait S}
        {ℋ_46 : core.marker.Send.Trait S}
        {ℋ_47 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t
          F
          S
          I
          (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          T16).
      
      (*
                  type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
                  type Future = ResponseFuture;
      *)
      Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
                  fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                      self.inner.poll_ready(cx)
                  }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
                  fn call(&mut self, req: Request<B>) -> Self::Future {
                      let not_ready_inner = self.inner.clone();
                      let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
      
                      let mut f = self.f.clone();
                      let _state = self.state.clone();
      
                      let future = Box::pin(async move {
                          let (mut parts, body) = req.into_parts();
      
                          $(
                              let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                  Ok(value) => value,
                                  Err(rejection) => return rejection.into_response(),
                              };
                          )*
      
                          let req = Request::from_parts(parts, body);
      
                          match ready_inner.call(req).await {
                              Ok(res) => {
                                  f($($ty,)* res).await.into_response()
                              }
                              Err(err) => match err {}
                          }
                      });
      
                      ResponseFuture {
                          inner: future
                      }
                  }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
    Section Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
      Context {F S I T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S} {ℋ_1 : core.fmt.Debug.Trait I}.
      
      Definition Self : Set :=
        axum.middleware.map_response.MapResponse.t F S I T.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("MapResponse")
                  .field("f", &format_args!("{}", type_name::<F>()))
                  .field("inner", &self.inner)
                  .field("state", &self.state)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
    End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
    
    Module  ResponseFuture.
    Section ResponseFuture.
      Record t : Set := {
        inner :
          ltac:(futures_core.future.BoxFuture
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T));
      }.
      
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
    End ResponseFuture.
    End ResponseFuture.
    
    Module  Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.
    Section Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.
      Definition Self : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
          type Output = Result<Response, Infallible>;
      *)
      Definition Output : Set :=
        core.result.Result.t
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            core.convert.Infallible.t.
      
      (*
          fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
              self.inner.as_mut().poll(cx).map(Ok)
          }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.
    End Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.
    
    Module  Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.
    Section Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.
      Definition Self : Set := axum.middleware.map_response.ResponseFuture.t.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("ResponseFuture").finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.
    End Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.
  End map_response.
End middleware.

Module from_extractor.
  (*
  pub fn from_extractor<E>() -> FromExtractorLayer<E, ()> {
      from_extractor_with_state(())
  }
  *)
  Definition from_extractor
      {E : Set}
      : M (axum.middleware.from_extractor.FromExtractorLayer.t E unit) :=
    M.read foo.
  
  (*
  pub fn from_extractor_with_state<E, S>(state: S) -> FromExtractorLayer<E, S> {
      FromExtractorLayer {
          state,
          _marker: PhantomData,
      }
  }
  *)
  Definition from_extractor_with_state
      {E S : Set}
      (state : S)
      : M (axum.middleware.from_extractor.FromExtractorLayer.t E S) :=
    let* state := M.alloc state in
    M.read foo.
  
  Module  FromExtractorLayer.
  Section FromExtractorLayer.
    Context (E S : Set).
    
    Record t : Set := {
      state : S;
      _marker : core.marker.PhantomData.t E;
    }.
    
    Definition Get_state :=
      Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
    Definition Get__marker :=
      Ref.map
        (fun α => Some α.(_marker))
        (fun β α => Some (α <| _marker := β |>)).
  End FromExtractorLayer.
  End FromExtractorLayer.
  
  Module  Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  Section Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    Context {E S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_extractor.FromExtractorLayer.t E S.
    
    (*
        fn clone(&self) -> Self {
            Self {
                state: self.state.clone(),
                _marker: PhantomData,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  Section Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    Context {E S : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_extractor.FromExtractorLayer.t E S.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("FromExtractorLayer")
                .field("state", &self.state)
                .field("extractor", &format_args!("{}", std::any::type_name::<E>()))
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  
  Module  Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  Section Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
    Context {E T S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_extractor.FromExtractorLayer.t E S.
    
    (*
        type Service = FromExtractor<T, E, S>;
    *)
    Definition Service : Set :=
      axum.middleware.from_extractor.FromExtractor.t T E S.
    
    (*
        fn layer(&self, inner: T) -> Self::Service {
            FromExtractor {
                inner,
                state: self.state.clone(),
                _extractor: PhantomData,
            }
        }
    *)
    Definition layer (self : ref Self) (inner : T) : M Service :=
      let* self := M.alloc self in
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_layer :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer;
    }.
    
    Global Instance ℐ : tower_layer.Layer.Trait Self (S := T) := {
      tower_layer.Layer.Service := Service;
      tower_layer.Layer.layer := layer;
    }.
  End Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  End Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  
  Module  FromExtractor.
  Section FromExtractor.
    Context (T E S : Set).
    
    Record t : Set := {
      inner : T;
      state : S;
      _extractor : core.marker.PhantomData.t E;
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Definition Get_state :=
      Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
    Definition Get__extractor :=
      Ref.map
        (fun α => Some α.(_extractor))
        (fun β α => Some (α <| _extractor := β |>)).
  End FromExtractor.
  End FromExtractor.
  
  Module  Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  Section Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    Context {T E S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T} {ℋ_1 : core.clone.Clone.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_extractor.FromExtractor.t T E S.
    
    (*
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
                state: self.state.clone(),
                _extractor: PhantomData,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  Section Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    Context {T E S : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T} {ℋ_1 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_extractor.FromExtractor.t T E S.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("FromExtractor")
                .field("inner", &self.inner)
                .field("state", &self.state)
                .field("extractor", &format_args!("{}", std::any::type_name::<E>()))
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
    Context {T E B S : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_1 : core.marker.Send.Trait B}
      {ℋ_2 :
        tower_service.Service.Trait T (Request := http.request.Request.t B)}
      {ℋ_3 : core.clone.Clone.Trait T}
      {ℋ_4 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_5 : core.clone.Clone.Trait S}
      {ℋ_6 : core.marker.Send.Trait S}
      {ℋ_7 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_extractor.FromExtractor.t T E S.
    
    (*
        type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        type Error = T::Error;
    *)
    Definition Error : Set := T::type["Error"].t.
    
    (*
        type Future = ResponseFuture<B, T, E, S>;
    *)
    Definition Future : Set :=
      axum.middleware.from_extractor.ResponseFuture.t B T E S.
    
    (*
        fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            self.inner.poll_ready(cx)
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, req: Request<B>) -> Self::Future {
            let state = self.state.clone();
            let extract_future = Box::pin(async move {
                let (mut parts, body) = req.into_parts();
                let extracted = E::from_request_parts(&mut parts, &state).await;
                let req = Request::from_parts(parts, body);
                (req, extracted)
            });
    
            ResponseFuture {
                state: State::Extracting {
                    future: extract_future,
                },
                svc: Some(self.inner.clone()),
            }
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  
  Module  ResponseFuture.
  Section ResponseFuture.
    Context (B T E S : Set).
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_1 :
        tower_service.Service.Trait T (Request := http.request.Request.t B)}.
    Record t : Set := {
      state : axum.middleware.from_extractor.State.t B T E S;
      svc : core.option.Option.t T;
    }.
    
    Definition Get_state :=
      Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
    Definition Get_svc :=
      Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
  End ResponseFuture.
  End ResponseFuture.
  
  Module State.
    Module Extracting.
      Record t : Set := {
        future :
          ltac:(futures_core.future.BoxFuture
            ((http.request.Request.t B)
            *
            (core.result.Result.t E E::type["Rejection"].t)));
      }.
    End Extracting.
    
    Module Call.
      Record t : Set := {
        future : T::type["Future"].t;
      }.
    End Call.
    
    Inductive t (B : Set) (T : Set) (E : Set) (S : Set) : Set :=
    | Extracting (_ : Extracting.t)
    | Call (_ : Call.t).
    
    Definition Get_Extracting_future :=
      Ref.map
        (fun α =>
          match α with
          | Extracting α => Some α.(Extracting.future)
          | _ => None
          end)
        (fun β α =>
          match α with
          | Extracting α => Some (Extracting (α <| Extracting.future := β |>))
          | _ => None
          end).
    
    Definition Get_Call_future :=
      Ref.map
        (fun α => match α with | Call α => Some α.(Call.future) | _ => None end)
        (fun β α =>
          match α with
          | Call α => Some (Call (α <| Call.future := β |>))
          | _ => None
          end).
  End State.
  
  Module StateProj.
    Module Extracting.
      Record t : Set := {
        future :
          mut_ref
            ltac:(futures_core.future.BoxFuture
              ((http.request.Request.t B)
              *
              (core.result.Result.t E E::type["Rejection"].t)));
      }.
    End Extracting.
    
    Module Call.
      Record t : Set := {
        future : core.pin.Pin.t (mut_ref T::type["Future"].t);
      }.
    End Call.
    
    Inductive t (B : Set) (T : Set) (E : Set) (S : Set) : Set :=
    | Extracting (_ : Extracting.t)
    | Call (_ : Call.t).
    
    Definition Get_Extracting_future :=
      Ref.map
        (fun α =>
          match α with
          | Extracting α => Some α.(Extracting.future)
          | _ => None
          end)
        (fun β α =>
          match α with
          | Extracting α => Some (Extracting (α <| Extracting.future := β |>))
          | _ => None
          end).
    
    Definition Get_Call_future :=
      Ref.map
        (fun α => match α with | Call α => Some α.(Call.future) | _ => None end)
        (fun β α =>
          match α with
          | Call α => Some (Call (α <| Call.future := β |>))
          | _ => None
          end).
  End StateProj.
  
  Module  Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
  Section Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
    Context {B T E S : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_1 :
        tower_service.Service.Trait T (Request := http.request.Request.t B)}
      {ℋ_2 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}.
    
    Definition Self : Set :=
      axum.middleware.from_extractor.ResponseFuture.t B T E S.
    
    (*
        type Output = Result<Response, T::Error>;
    *)
    Definition Output : Set :=
      core.result.Result.t
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          T::type["Error"].t.
    
    (*
        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            loop {
                let mut this = self.as_mut().project();
    
                let new_state = match this.state.as_mut().project() {
                    StateProj::Extracting { future } => {
                        let (req, extracted) = ready!(future.as_mut().poll(cx));
    
                        match extracted {
                            Ok(_) => {
                                let mut svc = this.svc.take().expect("future polled after completion");
                                let future = svc.call(req);
                                State::Call { future }
                            }
                            Err(err) => {
                                let res = err.into_response();
                                return Poll::Ready(Ok(res));
                            }
                        }
                    }
                    StateProj::Call { future } => {
                        return future
                            .poll(cx)
                            .map(|result| result.map(IntoResponse::into_response));
                    }
                };
    
                this.state.set(new_state);
            }
        }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
  End Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
End from_extractor.

(*
pub fn from_extractor<E>() -> FromExtractorLayer<E, ()> {
    from_extractor_with_state(())
}
*)
Definition from_extractor
    {E : Set}
    : M (axum.middleware.from_extractor.FromExtractorLayer.t E unit) :=
  M.read foo.

(*
pub fn from_extractor_with_state<E, S>(state: S) -> FromExtractorLayer<E, S> {
    FromExtractorLayer {
        state,
        _marker: PhantomData,
    }
}
*)
Definition from_extractor_with_state
    {E S : Set}
    (state : S)
    : M (axum.middleware.from_extractor.FromExtractorLayer.t E S) :=
  let* state := M.alloc state in
  M.read foo.

Module  FromExtractorLayer.
Section FromExtractorLayer.
  Context (E S : Set).
  
  Record t : Set := {
    state : S;
    _marker : core.marker.PhantomData.t E;
  }.
  
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get__marker :=
    Ref.map
      (fun α => Some α.(_marker))
      (fun β α => Some (α <| _marker := β |>)).
End FromExtractorLayer.
End FromExtractorLayer.

Module  Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
Section Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  Context {E S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_extractor.FromExtractorLayer.t E S.
  
  (*
      fn clone(&self) -> Self {
          Self {
              state: self.state.clone(),
              _marker: PhantomData,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.

Module  Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
Section Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  Context {E S : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_extractor.FromExtractorLayer.t E S.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("FromExtractorLayer")
              .field("state", &self.state)
              .field("extractor", &format_args!("{}", std::any::type_name::<E>()))
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.

Module  Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
Section Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
  Context {E T S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_extractor.FromExtractorLayer.t E S.
  
  (*
      type Service = FromExtractor<T, E, S>;
  *)
  Definition Service : Set :=
    axum.middleware.from_extractor.FromExtractor.t T E S.
  
  (*
      fn layer(&self, inner: T) -> Self::Service {
          FromExtractor {
              inner,
              state: self.state.clone(),
              _extractor: PhantomData,
          }
      }
  *)
  Definition layer (self : ref Self) (inner : T) : M Service :=
    let* self := M.alloc self in
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_layer :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer;
  }.
  
  Global Instance ℐ : tower_layer.Layer.Trait Self (S := T) := {
    tower_layer.Layer.Service := Service;
    tower_layer.Layer.layer := layer;
  }.
End Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.
End Impl_tower_layer_Layer_T_for_axum_middleware_from_extractor_FromExtractorLayer_t_E_S.

Module  FromExtractor.
Section FromExtractor.
  Context (T E S : Set).
  
  Record t : Set := {
    inner : T;
    state : S;
    _extractor : core.marker.PhantomData.t E;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get__extractor :=
    Ref.map
      (fun α => Some α.(_extractor))
      (fun β α => Some (α <| _extractor := β |>)).
End FromExtractor.
End FromExtractor.

Module  Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
Section Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  Context {T E S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T} {ℋ_1 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.middleware.from_extractor.FromExtractor.t T E S.
  
  (*
      fn clone(&self) -> Self {
          Self {
              inner: self.inner.clone(),
              state: self.state.clone(),
              _extractor: PhantomData,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
End Impl_core_clone_Clone_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.

Module  Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
Section Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  Context {T E S : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T} {ℋ_1 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set := axum.middleware.from_extractor.FromExtractor.t T E S.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("FromExtractor")
              .field("inner", &self.inner)
              .field("state", &self.state)
              .field("extractor", &format_args!("{}", std::any::type_name::<E>()))
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
End Impl_core_fmt_Debug_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
  Context {T E B S : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_1 : core.marker.Send.Trait B}
    {ℋ_2 : tower_service.Service.Trait T (Request := http.request.Request.t B)}
    {ℋ_3 : core.clone.Clone.Trait T}
    {ℋ_4 :
      axum_core.response.into_response.IntoResponse.Trait T::type["Response"].t}
    {ℋ_5 : core.clone.Clone.Trait S}
    {ℋ_6 : core.marker.Send.Trait S}
    {ℋ_7 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.middleware.from_extractor.FromExtractor.t T E S.
  
  (*
      type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      type Error = T::Error;
  *)
  Definition Error : Set := T::type["Error"].t.
  
  (*
      type Future = ResponseFuture<B, T, E, S>;
  *)
  Definition Future : Set :=
    axum.middleware.from_extractor.ResponseFuture.t B T E S.
  
  (*
      fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          self.inner.poll_ready(cx)
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, req: Request<B>) -> Self::Future {
          let state = self.state.clone();
          let extract_future = Box::pin(async move {
              let (mut parts, body) = req.into_parts();
              let extracted = E::from_request_parts(&mut parts, &state).await;
              let req = Request::from_parts(parts, body);
              (req, extracted)
          });
  
          ResponseFuture {
              state: State::Extracting {
                  future: extract_future,
              },
              svc: Some(self.inner.clone()),
          }
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_from_extractor_FromExtractor_t_T_E_S.

Module  ResponseFuture.
Section ResponseFuture.
  Context (B T E S : Set).
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_1 : tower_service.Service.Trait T (Request := http.request.Request.t B)}.
  Record t : Set := {
    state : axum.middleware.from_extractor.State.t B T E S;
    svc : core.option.Option.t T;
  }.
  
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get_svc :=
    Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
End ResponseFuture.
End ResponseFuture.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Context (B T E S : Set).
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_1 : tower_service.Service.Trait T (Request := http.request.Request.t B)}.
  Record t : Set := {
    state :
      core.pin.Pin.t (mut_ref (axum.middleware.from_extractor.State.t B T E S));
    svc : mut_ref (core.option.Option.t T);
  }.
  
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get_svc :=
    Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Context (B T E S : Set).
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_1 : tower_service.Service.Trait T (Request := http.request.Request.t B)}.
  Record t : Set := {
    state :
      core.pin.Pin.t (ref (axum.middleware.from_extractor.State.t B T E S));
    svc : ref (core.option.Option.t T);
  }.
  
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get_svc :=
    Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
Section Impl_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
  Context {B T E S : Set}.
  
  Definition Self : Set :=
    axum.middleware.from_extractor.ResponseFuture.t B T E S.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum.middleware.from_extractor._.Projection.t B T E S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M (axum.middleware.from_extractor._.ProjectionRef.t B T E S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
End Impl_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.

Module  __Origin.
Section __Origin.
  Context (B T E S : Set).
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_1 : tower_service.Service.Trait T (Request := http.request.Request.t B)}.
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    state : axum.middleware.from_extractor.State.t B T E S;
    svc : pin_project_lite.__private.AlwaysUnpin.t (core.option.Option.t T);
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get_svc :=
    Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
Section Impl_core_marker_Unpin_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
  Context {B T E S : Set}.
  
  Context
    {ℋ_0 :
      core.marker.Unpin.Trait
          (axum.middleware.from_extractor._.__Origin.t B T E S)}
    {ℋ_1 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_2 : tower_service.Service.Trait T (Request := http.request.Request.t B)}.
  
  Definition Self : Set :=
    axum.middleware.from_extractor.ResponseFuture.t B T E S.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
End Impl_core_marker_Unpin_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.

Module  Impl_axum_middleware_from_extractor___MustNotImplDrop_for_T.
Section Impl_axum_middleware_from_extractor___MustNotImplDrop_for_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.ops.drop.Drop.Trait T}.
  
  Definition Self : Set := T.
  
  Global Instance ℐ :
    axum.middleware.from_extractor._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_middleware_from_extractor___MustNotImplDrop_for_T.
End Impl_axum_middleware_from_extractor___MustNotImplDrop_for_T.

Module  Impl_axum_middleware_from_extractor___MustNotImplDrop_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
Section Impl_axum_middleware_from_extractor___MustNotImplDrop_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
  Context {B T E S : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_1 : tower_service.Service.Trait T (Request := http.request.Request.t B)}.
  
  Definition Self : Set :=
    axum.middleware.from_extractor.ResponseFuture.t B T E S.
  
  Global Instance ℐ :
    axum.middleware.from_extractor._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_middleware_from_extractor___MustNotImplDrop_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
End Impl_axum_middleware_from_extractor___MustNotImplDrop_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    {B T E S : Set}
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_1 : tower_service.Service.Trait T (Request := http.request.Request.t B)}
    (this : ref (axum.middleware.from_extractor.ResponseFuture.t B T E S))
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module State.
  Module Extracting.
    Record t : Set := {
      future :
        ltac:(futures_core.future.BoxFuture
          ((http.request.Request.t B)
          *
          (core.result.Result.t E E::type["Rejection"].t)));
    }.
  End Extracting.
  
  Module Call.
    Record t : Set := {
      future : T::type["Future"].t;
    }.
  End Call.
  
  Inductive t (B : Set) (T : Set) (E : Set) (S : Set) : Set :=
  | Extracting (_ : Extracting.t)
  | Call (_ : Call.t).
  
  Definition Get_Extracting_future :=
    Ref.map
      (fun α =>
        match α with
        | Extracting α => Some α.(Extracting.future)
        | _ => None
        end)
      (fun β α =>
        match α with
        | Extracting α => Some (Extracting (α <| Extracting.future := β |>))
        | _ => None
        end).
  
  Definition Get_Call_future :=
    Ref.map
      (fun α => match α with | Call α => Some α.(Call.future) | _ => None end)
      (fun β α =>
        match α with
        | Call α => Some (Call (α <| Call.future := β |>))
        | _ => None
        end).
End State.

Module StateProj.
  Module Extracting.
    Record t : Set := {
      future :
        mut_ref
          ltac:(futures_core.future.BoxFuture
            ((http.request.Request.t B)
            *
            (core.result.Result.t E E::type["Rejection"].t)));
    }.
  End Extracting.
  
  Module Call.
    Record t : Set := {
      future : core.pin.Pin.t (mut_ref T::type["Future"].t);
    }.
  End Call.
  
  Inductive t (B : Set) (T : Set) (E : Set) (S : Set) : Set :=
  | Extracting (_ : Extracting.t)
  | Call (_ : Call.t).
  
  Definition Get_Extracting_future :=
    Ref.map
      (fun α =>
        match α with
        | Extracting α => Some α.(Extracting.future)
        | _ => None
        end)
      (fun β α =>
        match α with
        | Extracting α => Some (Extracting (α <| Extracting.future := β |>))
        | _ => None
        end).
  
  Definition Get_Call_future :=
    Ref.map
      (fun α => match α with | Call α => Some α.(Call.future) | _ => None end)
      (fun β α =>
        match α with
        | Call α => Some (Call (α <| Call.future := β |>))
        | _ => None
        end).
End StateProj.

Module  Impl_axum_middleware_from_extractor_State_t_B_T_E_S.
Section Impl_axum_middleware_from_extractor_State_t_B_T_E_S.
  Context {B T E S : Set}.
  
  Definition Self : Set := axum.middleware.from_extractor.State.t B T E S.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  match self.$get_method() {
                      $(
                          Self::$variant $({
                              $($field),+
                          })? => {
                              $proj_ty_ident::$variant $({
                                  $(
                                      $field: $crate::__pin_project_make_unsafe_field_proj!(
                                          $(#[$pin])? $field
                                      )
                                  ),+
                              })?
                          }
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum.middleware.from_extractor.StateProj.t B T E S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
End Impl_axum_middleware_from_extractor_State_t_B_T_E_S.
End Impl_axum_middleware_from_extractor_State_t_B_T_E_S.

Module  __Origin.
Section __Origin.
  Context (B T E S : Set).
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_1 : tower_service.Service.Trait T (Request := http.request.Request.t B)}.
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    Extracting :
      pin_project_lite.__private.AlwaysUnpin.t
        ltac:(futures_core.future.BoxFuture
          ((http.request.Request.t B)
          *
          (core.result.Result.t E E::type["Rejection"].t)));
    Call : T::type["Future"].t;
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_Extracting :=
    Ref.map
      (fun α => Some α.(Extracting))
      (fun β α => Some (α <| Extracting := β |>)).
  Definition Get_Call :=
    Ref.map (fun α => Some α.(Call)) (fun β α => Some (α <| Call := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_middleware_from_extractor_State_t_B_T_E_S.
Section Impl_core_marker_Unpin_for_axum_middleware_from_extractor_State_t_B_T_E_S.
  Context {B T E S : Set}.
  
  Context
    {ℋ_0 :
      core.marker.Unpin.Trait
          (axum.middleware.from_extractor._.__Origin.t B T E S)}
    {ℋ_1 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_2 : tower_service.Service.Trait T (Request := http.request.Request.t B)}.
  
  Definition Self : Set := axum.middleware.from_extractor.State.t B T E S.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_middleware_from_extractor_State_t_B_T_E_S.
End Impl_core_marker_Unpin_for_axum_middleware_from_extractor_State_t_B_T_E_S.

Module  Impl_axum_middleware_from_extractor___MustNotImplDrop_for_axum_middleware_from_extractor_State_t_B_T_E_S.
Section Impl_axum_middleware_from_extractor___MustNotImplDrop_for_axum_middleware_from_extractor_State_t_B_T_E_S.
  Context {B T E S : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_1 : tower_service.Service.Trait T (Request := http.request.Request.t B)}.
  
  Definition Self : Set := axum.middleware.from_extractor.State.t B T E S.
  
  Global Instance ℐ :
    axum.middleware.from_extractor._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_middleware_from_extractor___MustNotImplDrop_for_axum_middleware_from_extractor_State_t_B_T_E_S.
End Impl_axum_middleware_from_extractor___MustNotImplDrop_for_axum_middleware_from_extractor_State_t_B_T_E_S.

Module  Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
Section Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
  Context {B T E S : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_1 : tower_service.Service.Trait T (Request := http.request.Request.t B)}
    {ℋ_2 :
      axum_core.response.into_response.IntoResponse.Trait
          T::type["Response"].t}.
  
  Definition Self : Set :=
    axum.middleware.from_extractor.ResponseFuture.t B T E S.
  
  (*
      type Output = Result<Response, T::Error>;
  *)
  Definition Output : Set :=
    core.result.Result.t
        ltac:(axum_core.response.Response axum_core.response.Response.Default.T)
        T::type["Error"].t.
  
  (*
      fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
          loop {
              let mut this = self.as_mut().project();
  
              let new_state = match this.state.as_mut().project() {
                  StateProj::Extracting { future } => {
                      let (req, extracted) = ready!(future.as_mut().poll(cx));
  
                      match extracted {
                          Ok(_) => {
                              let mut svc = this.svc.take().expect("future polled after completion");
                              let future = svc.call(req);
                              State::Call { future }
                          }
                          Err(err) => {
                              let res = err.into_response();
                              return Poll::Ready(Ok(res));
                          }
                      }
                  }
                  StateProj::Call { future } => {
                      return future
                          .poll(cx)
                          .map(|result| result.map(IntoResponse::into_response));
                  }
              };
  
              this.state.set(new_state);
          }
      }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.
End Impl_core_future_future_Future_for_axum_middleware_from_extractor_ResponseFuture_t_B_T_E_S.

Module from_fn.
  (*
  pub fn from_fn<F, T>(f: F) -> FromFnLayer<F, (), T> {
      from_fn_with_state((), f)
  }
  *)
  Definition from_fn
      {F T : Set}
      (f : F)
      : M (axum.middleware.from_fn.FromFnLayer.t F unit T) :=
    let* f := M.alloc f in
    M.read foo.
  
  (*
  pub fn from_fn_with_state<F, S, T>(state: S, f: F) -> FromFnLayer<F, S, T> {
      FromFnLayer {
          f,
          state,
          _extractor: PhantomData,
      }
  }
  *)
  Definition from_fn_with_state
      {F S T : Set}
      (state : S)
      (f : F)
      : M (axum.middleware.from_fn.FromFnLayer.t F S T) :=
    let* state := M.alloc state in
    let* f := M.alloc f in
    M.read foo.
  
  Module  FromFnLayer.
  Section FromFnLayer.
    Context (F S T : Set).
    
    Record t : Set := {
      f : F;
      state : S;
      _extractor : core.marker.PhantomData.t T;
    }.
    
    Definition Get_f :=
      Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
    Definition Get_state :=
      Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
    Definition Get__extractor :=
      Ref.map
        (fun α => Some α.(_extractor))
        (fun β α => Some (α <| _extractor := β |>)).
  End FromFnLayer.
  End FromFnLayer.
  
  Module  Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  Section Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    Context {F S T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.middleware.from_fn.FromFnLayer.t F S T.
    
    (*
        fn clone(&self) -> Self {
            Self {
                f: self.f.clone(),
                state: self.state.clone(),
                _extractor: self._extractor,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  
  Module  Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  Section Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    Context {S I F T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.middleware.from_fn.FromFnLayer.t F S T.
    
    (*
        type Service = FromFn<F, S, I, T>;
    *)
    Definition Service : Set := axum.middleware.from_fn.FromFn.t F S I T.
    
    (*
        fn layer(&self, inner: I) -> Self::Service {
            FromFn {
                f: self.f.clone(),
                state: self.state.clone(),
                inner,
                _extractor: PhantomData,
            }
        }
    *)
    Definition layer (self : ref Self) (inner : I) : M Service :=
      let* self := M.alloc self in
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_layer :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer;
    }.
    
    Global Instance ℐ : tower_layer.Layer.Trait Self (S := I) := {
      tower_layer.Layer.Service := Service;
      tower_layer.Layer.layer := layer;
    }.
  End Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  End Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
    Context {F S T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set := axum.middleware.from_fn.FromFnLayer.t F S T.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("FromFnLayer")
                // Write out the type name, without quoting it as `&type_name::<F>()` would
                .field("f", &format_args!("{}", type_name::<F>()))
                .field("state", &self.state)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  
  Module  FromFn.
  Section FromFn.
    Context (F S I T : Set).
    
    Record t : Set := {
      f : F;
      inner : I;
      state : S;
      _extractor : core.marker.PhantomData.t T;
    }.
    
    Definition Get_f :=
      Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Definition Get_state :=
      Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
    Definition Get__extractor :=
      Ref.map
        (fun α => Some α.(_extractor))
        (fun β α => Some (α <| _extractor := β |>)).
  End FromFn.
  End FromFn.
  
  Module  Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
  Section Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
    Context {F S I T : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait F}
      {ℋ_1 : core.clone.Clone.Trait I}
      {ℋ_2 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I T.
    
    (*
        fn clone(&self) -> Self {
            Self {
                f: self.f.clone(),
                inner: self.inner.clone(),
                state: self.state.clone(),
                _extractor: self._extractor,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
  End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.
    Context {F Fut Out S I T1 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := T1 * axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 :
        axum_core.extract.FromRequest.Trait T1
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T1)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : core.future.future.Future.Trait Fut}
      {ℋ_6 : core.marker.Send.Trait Fut}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_8 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_9 : core.clone.Clone.Trait I}
      {ℋ_10 : core.marker.Send.Trait I}
      {ℋ_11 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_12 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_13 : core.clone.Clone.Trait S}
      {ℋ_14 : core.marker.Send.Trait S}
      {ℋ_15 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I T1.
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.
    Context {F Fut Out S I T1 T2 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (T1 * T2) * axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 :
        axum_core.extract.FromRequest.Trait T2
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T2)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : core.future.future.Future.Trait Fut}
      {ℋ_8 : core.marker.Send.Trait Fut}
      {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_10 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_11 : core.clone.Clone.Trait I}
      {ℋ_12 : core.marker.Send.Trait I}
      {ℋ_13 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_14 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_15 : core.clone.Clone.Trait S}
      {ℋ_16 : core.marker.Send.Trait S}
      {ℋ_17 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I (T1 * T2).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.
    Context {F Fut Out S I T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((T1 * T2) * T3) * axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 :
        axum_core.extract.FromRequest.Trait T3
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T3)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : core.future.future.Future.Trait Fut}
      {ℋ_10 : core.marker.Send.Trait Fut}
      {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_12 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_13 : core.clone.Clone.Trait I}
      {ℋ_14 : core.marker.Send.Trait I}
      {ℋ_15 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_16 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_17 : core.clone.Clone.Trait S}
      {ℋ_18 : core.marker.Send.Trait S}
      {ℋ_19 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t F S I ((T1 * T2) * T3).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.
    Context {F Fut Out S I T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((T1 * T2) * T3) * T4) * axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 :
        axum_core.extract.FromRequest.Trait T4
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T4)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : core.future.future.Future.Trait Fut}
      {ℋ_12 : core.marker.Send.Trait Fut}
      {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_14 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_15 : core.clone.Clone.Trait I}
      {ℋ_16 : core.marker.Send.Trait I}
      {ℋ_17 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_18 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_19 : core.clone.Clone.Trait S}
      {ℋ_20 : core.marker.Send.Trait S}
      {ℋ_21 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t F S I (((T1 * T2) * T3) * T4).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    Context {F Fut Out S I T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((T1 * T2) * T3) * T4) * T5)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 :
        axum_core.extract.FromRequest.Trait T5
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T5)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : core.future.future.Future.Trait Fut}
      {ℋ_14 : core.marker.Send.Trait Fut}
      {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_16 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_17 : core.clone.Clone.Trait I}
      {ℋ_18 : core.marker.Send.Trait I}
      {ℋ_19 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_20 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_21 : core.clone.Clone.Trait S}
      {ℋ_22 : core.marker.Send.Trait S}
      {ℋ_23 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t F S I ((((T1 * T2) * T3) * T4) * T5).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    Context {F Fut Out S I T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((T1 * T2) * T3) * T4) * T5) * T6)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 :
        axum_core.extract.FromRequest.Trait T6
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T6)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : core.future.future.Future.Trait Fut}
      {ℋ_16 : core.marker.Send.Trait Fut}
      {ℋ_17 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_18 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_19 : core.clone.Clone.Trait I}
      {ℋ_20 : core.marker.Send.Trait I}
      {ℋ_21 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_22 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_23 : core.clone.Clone.Trait S}
      {ℋ_24 : core.marker.Send.Trait S}
      {ℋ_25 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t
        F
        S
        I
        (((((T1 * T2) * T3) * T4) * T5) * T6).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 :
        axum_core.extract.FromRequest.Trait T7
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T7)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : core.future.future.Future.Trait Fut}
      {ℋ_18 : core.marker.Send.Trait Fut}
      {ℋ_19 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_20 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_21 : core.clone.Clone.Trait I}
      {ℋ_22 : core.marker.Send.Trait I}
      {ℋ_23 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_24 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_25 : core.clone.Clone.Trait S}
      {ℋ_26 : core.marker.Send.Trait S}
      {ℋ_27 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t
        F
        S
        I
        ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 :
        axum_core.extract.FromRequest.Trait T8
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T8)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : core.future.future.Future.Trait Fut}
      {ℋ_20 : core.marker.Send.Trait Fut}
      {ℋ_21 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_22 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_23 : core.clone.Clone.Trait I}
      {ℋ_24 : core.marker.Send.Trait I}
      {ℋ_25 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_26 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_27 : core.clone.Clone.Trait S}
      {ℋ_28 : core.marker.Send.Trait S}
      {ℋ_29 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t
        F
        S
        I
        (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 :
        axum_core.extract.FromRequest.Trait T9
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T9)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : core.future.future.Future.Trait Fut}
      {ℋ_22 : core.marker.Send.Trait Fut}
      {ℋ_23 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_24 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_25 : core.clone.Clone.Trait I}
      {ℋ_26 : core.marker.Send.Trait I}
      {ℋ_27 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_28 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_29 : core.clone.Clone.Trait S}
      {ℋ_30 : core.marker.Send.Trait S}
      {ℋ_31 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t
        F
        S
        I
        ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 :
        axum_core.extract.FromRequest.Trait T10
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T10)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : core.future.future.Future.Trait Fut}
      {ℋ_24 : core.marker.Send.Trait Fut}
      {ℋ_25 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_26 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_27 : core.clone.Clone.Trait I}
      {ℋ_28 : core.marker.Send.Trait I}
      {ℋ_29 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_30 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_31 : core.clone.Clone.Trait S}
      {ℋ_32 : core.marker.Send.Trait S}
      {ℋ_33 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t
        F
        S
        I
        (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 :
        axum_core.extract.FromRequest.Trait T11
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T11)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : core.future.future.Future.Trait Fut}
      {ℋ_26 : core.marker.Send.Trait Fut}
      {ℋ_27 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_28 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_29 : core.clone.Clone.Trait I}
      {ℋ_30 : core.marker.Send.Trait I}
      {ℋ_31 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_32 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_33 : core.clone.Clone.Trait S}
      {ℋ_34 : core.marker.Send.Trait S}
      {ℋ_35 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t
        F
        S
        I
        ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 :
        axum_core.extract.FromRequest.Trait T12
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T12)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : core.future.future.Future.Trait Fut}
      {ℋ_28 : core.marker.Send.Trait Fut}
      {ℋ_29 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_30 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_31 : core.clone.Clone.Trait I}
      {ℋ_32 : core.marker.Send.Trait I}
      {ℋ_33 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_34 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_35 : core.clone.Clone.Trait S}
      {ℋ_36 : core.marker.Send.Trait S}
      {ℋ_37 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t
        F
        S
        I
        (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 :
        axum_core.extract.FromRequest.Trait T13
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T13)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 : core.future.future.Future.Trait Fut}
      {ℋ_30 : core.marker.Send.Trait Fut}
      {ℋ_31 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_32 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_33 : core.clone.Clone.Trait I}
      {ℋ_34 : core.marker.Send.Trait I}
      {ℋ_35 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_36 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_37 : core.clone.Clone.Trait S}
      {ℋ_38 : core.marker.Send.Trait S}
      {ℋ_39 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t
        F
        S
        I
        ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Context
      {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 :
        axum_core.extract.FromRequest.Trait T14
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T14)}
      {ℋ_30 : core.marker.Send.Trait T14}
      {ℋ_31 : core.future.future.Future.Trait Fut}
      {ℋ_32 : core.marker.Send.Trait Fut}
      {ℋ_33 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_34 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_35 : core.clone.Clone.Trait I}
      {ℋ_36 : core.marker.Send.Trait I}
      {ℋ_37 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_38 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_39 : core.clone.Clone.Trait S}
      {ℋ_40 : core.marker.Send.Trait S}
      {ℋ_41 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t
        F
        S
        I
        (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Context
      {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_30 : core.marker.Send.Trait T14}
      {ℋ_31 :
        axum_core.extract.FromRequest.Trait T15
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T15)}
      {ℋ_32 : core.marker.Send.Trait T15}
      {ℋ_33 : core.future.future.Future.Trait Fut}
      {ℋ_34 : core.marker.Send.Trait Fut}
      {ℋ_35 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_36 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_37 : core.clone.Clone.Trait I}
      {ℋ_38 : core.marker.Send.Trait I}
      {ℋ_39 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_40 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_41 : core.clone.Clone.Trait S}
      {ℋ_42 : core.marker.Send.Trait S}
      {ℋ_43 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t
        F
        S
        I
        ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Context
      {F
        Fut
        Out
        S
        I
        T1
        T2
        T3
        T4
        T5
        T6
        T7
        T8
        T9
        T10
        T11
        T12
        T13
        T14
        T15
        T16
        :
        Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          T16)
          *
          axum.middleware.from_fn.Next.t)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_30 : core.marker.Send.Trait T14}
      {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
      {ℋ_32 : core.marker.Send.Trait T15}
      {ℋ_33 :
        axum_core.extract.FromRequest.Trait T16
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T16)}
      {ℋ_34 : core.marker.Send.Trait T16}
      {ℋ_35 : core.future.future.Future.Trait Fut}
      {ℋ_36 : core.marker.Send.Trait Fut}
      {ℋ_37 : axum_core.response.into_response.IntoResponse.Trait Out}
      {ℋ_38 :
        tower_service.Service.Trait I
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_39 : core.clone.Clone.Trait I}
      {ℋ_40 : core.marker.Send.Trait I}
      {ℋ_41 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_42 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_43 : core.clone.Clone.Trait S}
      {ℋ_44 : core.marker.Send.Trait S}
      {ℋ_45 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.from_fn.FromFn.t
        F
        S
        I
        (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        let inner = ServiceBuilder::new()
                            .boxed_clone()
                            .map_response(IntoResponse::into_response)
                            .service(ready_inner);
                        let next = Next { inner };
    
                        f($($ty,)* $last, next).await.into_response()
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
  Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
    Context {F S I T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S} {ℋ_1 : core.fmt.Debug.Trait I}.
    
    Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I T.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("FromFnLayer")
                .field("f", &format_args!("{}", type_name::<F>()))
                .field("inner", &self.inner)
                .field("state", &self.state)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
  End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
  
  Module  Next.
  Section Next.
    Record t : Set := {
      inner :
        tower.util.boxed_clone.BoxCloneService.t
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T)
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          core.convert.Infallible.t;
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  End Next.
  End Next.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.
  Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.
    Definition Self : Set := axum.middleware.from_fn.Next.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.
  End Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.
  
  Module  Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.
  Section Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.
    Definition Self : Set := axum.middleware.from_fn.Next.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum.middleware.from_fn.Next.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.
  End Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.
  
  Module  Impl_axum_middleware_from_fn_Next_t_2.
  Section Impl_axum_middleware_from_fn_Next_t_2.
    Definition Self : Set := axum.middleware.from_fn.Next.t.
    
    (*
        pub async fn run(mut self, req: Request) -> Response {
            match self.inner.call(req).await {
                Ok(res) => res,
                Err(err) => match err {},
            }
        }
    *)
    Definition run
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M OpaqueDef :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_run :
      Notations.DoubleColon Self "run" := {
      Notations.double_colon := run;
    }.
  End Impl_axum_middleware_from_fn_Next_t_2.
  End Impl_axum_middleware_from_fn_Next_t_2.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.
  Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.
    Definition Self : Set := axum.middleware.from_fn.Next.t.
    
    (*
        type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;
    *)
    Definition Future : Set :=
      core.pin.Pin.t
          (alloc.boxed.Box.t
            (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
            alloc.boxed.Box.Default.A).
    
    (*
        fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            self.inner.poll_ready(cx)
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, req: Request) -> Self::Future {
            self.inner.call(req)
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.
  End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.
  
  Module  ResponseFuture.
  Section ResponseFuture.
    Record t : Set := {
      inner :
        ltac:(futures_core.future.BoxFuture
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T));
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  End ResponseFuture.
  End ResponseFuture.
  
  Module  Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.
  Section Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.
    Definition Self : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
        type Output = Result<Response, Infallible>;
    *)
    Definition Output : Set :=
      core.result.Result.t
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          core.convert.Infallible.t.
    
    (*
        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            self.inner.as_mut().poll(cx).map(Ok)
        }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.
  End Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.
  Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.
    Definition Self : Set := axum.middleware.from_fn.ResponseFuture.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("ResponseFuture").finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.
  End Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.
End from_fn.

(*
pub fn from_fn<F, T>(f: F) -> FromFnLayer<F, (), T> {
    from_fn_with_state((), f)
}
*)
Definition from_fn
    {F T : Set}
    (f : F)
    : M (axum.middleware.from_fn.FromFnLayer.t F unit T) :=
  let* f := M.alloc f in
  M.read foo.

(*
pub fn from_fn_with_state<F, S, T>(state: S, f: F) -> FromFnLayer<F, S, T> {
    FromFnLayer {
        f,
        state,
        _extractor: PhantomData,
    }
}
*)
Definition from_fn_with_state
    {F S T : Set}
    (state : S)
    (f : F)
    : M (axum.middleware.from_fn.FromFnLayer.t F S T) :=
  let* state := M.alloc state in
  let* f := M.alloc f in
  M.read foo.

Module  FromFnLayer.
Section FromFnLayer.
  Context (F S T : Set).
  
  Record t : Set := {
    f : F;
    state : S;
    _extractor : core.marker.PhantomData.t T;
  }.
  
  Definition Get_f :=
    Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get__extractor :=
    Ref.map
      (fun α => Some α.(_extractor))
      (fun β α => Some (α <| _extractor := β |>)).
End FromFnLayer.
End FromFnLayer.

Module  Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
Section Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  Context {F S T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.middleware.from_fn.FromFnLayer.t F S T.
  
  (*
      fn clone(&self) -> Self {
          Self {
              f: self.f.clone(),
              state: self.state.clone(),
              _extractor: self._extractor,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.

Module  Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
Section Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  Context {S I F T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.middleware.from_fn.FromFnLayer.t F S T.
  
  (*
      type Service = FromFn<F, S, I, T>;
  *)
  Definition Service : Set := axum.middleware.from_fn.FromFn.t F S I T.
  
  (*
      fn layer(&self, inner: I) -> Self::Service {
          FromFn {
              f: self.f.clone(),
              state: self.state.clone(),
              inner,
              _extractor: PhantomData,
          }
      }
  *)
  Definition layer (self : ref Self) (inner : I) : M Service :=
    let* self := M.alloc self in
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_layer :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer;
  }.
  
  Global Instance ℐ : tower_layer.Layer.Trait Self (S := I) := {
    tower_layer.Layer.Service := Service;
    tower_layer.Layer.layer := layer;
  }.
End Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
End Impl_tower_layer_Layer_I_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.

Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
  Context {F S T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set := axum.middleware.from_fn.FromFnLayer.t F S T.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("FromFnLayer")
              // Write out the type name, without quoting it as `&type_name::<F>()` would
              .field("f", &format_args!("{}", type_name::<F>()))
              .field("state", &self.state)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.
End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFnLayer_t_F_S_T.

Module  FromFn.
Section FromFn.
  Context (F S I T : Set).
  
  Record t : Set := {
    f : F;
    inner : I;
    state : S;
    _extractor : core.marker.PhantomData.t T;
  }.
  
  Definition Get_f :=
    Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get__extractor :=
    Ref.map
      (fun α => Some α.(_extractor))
      (fun β α => Some (α <| _extractor := β |>)).
End FromFn.
End FromFn.

Module  Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
Section Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
  Context {F S I T : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait F}
    {ℋ_1 : core.clone.Clone.Trait I}
    {ℋ_2 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I T.
  
  (*
      fn clone(&self) -> Self {
          Self {
              f: self.f.clone(),
              inner: self.inner.clone(),
              state: self.state.clone(),
              _extractor: self._extractor,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
End Impl_core_clone_Clone_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.
  Context {F Fut Out S I T1 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := T1 * axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 :
      axum_core.extract.FromRequest.Trait T1
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T1)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : core.future.future.Future.Trait Fut}
    {ℋ_6 : core.marker.Send.Trait Fut}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_8 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_9 : core.clone.Clone.Trait I}
    {ℋ_10 : core.marker.Send.Trait I}
    {ℋ_11 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_12 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_13 : core.clone.Clone.Trait S}
    {ℋ_14 : core.marker.Send.Trait S}
    {ℋ_15 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I T1.
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.
  Context {F Fut Out S I T1 T2 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (T1 * T2) * axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 :
      axum_core.extract.FromRequest.Trait T2
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T2)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : core.future.future.Future.Trait Fut}
    {ℋ_8 : core.marker.Send.Trait Fut}
    {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_10 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_11 : core.clone.Clone.Trait I}
    {ℋ_12 : core.marker.Send.Trait I}
    {ℋ_13 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_14 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_15 : core.clone.Clone.Trait S}
    {ℋ_16 : core.marker.Send.Trait S}
    {ℋ_17 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I (T1 * T2).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.
  Context {F Fut Out S I T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((T1 * T2) * T3) * axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 :
      axum_core.extract.FromRequest.Trait T3
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T3)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : core.future.future.Future.Trait Fut}
    {ℋ_10 : core.marker.Send.Trait Fut}
    {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_12 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_13 : core.clone.Clone.Trait I}
    {ℋ_14 : core.marker.Send.Trait I}
    {ℋ_15 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_16 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_17 : core.clone.Clone.Trait S}
    {ℋ_18 : core.marker.Send.Trait S}
    {ℋ_19 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t F S I ((T1 * T2) * T3).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.
  Context {F Fut Out S I T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((T1 * T2) * T3) * T4) * axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 :
      axum_core.extract.FromRequest.Trait T4
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T4)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : core.future.future.Future.Trait Fut}
    {ℋ_12 : core.marker.Send.Trait Fut}
    {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_14 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_15 : core.clone.Clone.Trait I}
    {ℋ_16 : core.marker.Send.Trait I}
    {ℋ_17 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_18 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_19 : core.clone.Clone.Trait S}
    {ℋ_20 : core.marker.Send.Trait S}
    {ℋ_21 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t F S I (((T1 * T2) * T3) * T4).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  Context {F Fut Out S I T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((T1 * T2) * T3) * T4) * T5)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 :
      axum_core.extract.FromRequest.Trait T5
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T5)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : core.future.future.Future.Trait Fut}
    {ℋ_14 : core.marker.Send.Trait Fut}
    {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_16 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_17 : core.clone.Clone.Trait I}
    {ℋ_18 : core.marker.Send.Trait I}
    {ℋ_19 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_20 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_21 : core.clone.Clone.Trait S}
    {ℋ_22 : core.marker.Send.Trait S}
    {ℋ_23 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t F S I ((((T1 * T2) * T3) * T4) * T5).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  Context {F Fut Out S I T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((T1 * T2) * T3) * T4) * T5) * T6)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 :
      axum_core.extract.FromRequest.Trait T6
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T6)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : core.future.future.Future.Trait Fut}
    {ℋ_16 : core.marker.Send.Trait Fut}
    {ℋ_17 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_18 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_19 : core.clone.Clone.Trait I}
    {ℋ_20 : core.marker.Send.Trait I}
    {ℋ_21 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_22 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_23 : core.clone.Clone.Trait S}
    {ℋ_24 : core.marker.Send.Trait S}
    {ℋ_25 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t
      F
      S
      I
      (((((T1 * T2) * T3) * T4) * T5) * T6).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 :
      axum_core.extract.FromRequest.Trait T7
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T7)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : core.future.future.Future.Trait Fut}
    {ℋ_18 : core.marker.Send.Trait Fut}
    {ℋ_19 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_20 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_21 : core.clone.Clone.Trait I}
    {ℋ_22 : core.marker.Send.Trait I}
    {ℋ_23 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_24 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_25 : core.clone.Clone.Trait S}
    {ℋ_26 : core.marker.Send.Trait S}
    {ℋ_27 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t
      F
      S
      I
      ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 :
      axum_core.extract.FromRequest.Trait T8
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T8)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : core.future.future.Future.Trait Fut}
    {ℋ_20 : core.marker.Send.Trait Fut}
    {ℋ_21 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_22 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_23 : core.clone.Clone.Trait I}
    {ℋ_24 : core.marker.Send.Trait I}
    {ℋ_25 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_26 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_27 : core.clone.Clone.Trait S}
    {ℋ_28 : core.marker.Send.Trait S}
    {ℋ_29 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t
      F
      S
      I
      (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 :
      axum_core.extract.FromRequest.Trait T9
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T9)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : core.future.future.Future.Trait Fut}
    {ℋ_22 : core.marker.Send.Trait Fut}
    {ℋ_23 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_24 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_25 : core.clone.Clone.Trait I}
    {ℋ_26 : core.marker.Send.Trait I}
    {ℋ_27 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_28 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_29 : core.clone.Clone.Trait S}
    {ℋ_30 : core.marker.Send.Trait S}
    {ℋ_31 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t
      F
      S
      I
      ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 :
      axum_core.extract.FromRequest.Trait T10
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T10)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : core.future.future.Future.Trait Fut}
    {ℋ_24 : core.marker.Send.Trait Fut}
    {ℋ_25 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_26 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_27 : core.clone.Clone.Trait I}
    {ℋ_28 : core.marker.Send.Trait I}
    {ℋ_29 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_30 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_31 : core.clone.Clone.Trait S}
    {ℋ_32 : core.marker.Send.Trait S}
    {ℋ_33 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t
      F
      S
      I
      (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 :
      axum_core.extract.FromRequest.Trait T11
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T11)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : core.future.future.Future.Trait Fut}
    {ℋ_26 : core.marker.Send.Trait Fut}
    {ℋ_27 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_28 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_29 : core.clone.Clone.Trait I}
    {ℋ_30 : core.marker.Send.Trait I}
    {ℋ_31 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_32 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_33 : core.clone.Clone.Trait S}
    {ℋ_34 : core.marker.Send.Trait S}
    {ℋ_35 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t
      F
      S
      I
      ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 :
      axum_core.extract.FromRequest.Trait T12
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T12)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : core.future.future.Future.Trait Fut}
    {ℋ_28 : core.marker.Send.Trait Fut}
    {ℋ_29 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_30 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_31 : core.clone.Clone.Trait I}
    {ℋ_32 : core.marker.Send.Trait I}
    {ℋ_33 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_34 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_35 : core.clone.Clone.Trait S}
    {ℋ_36 : core.marker.Send.Trait S}
    {ℋ_37 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t
      F
      S
      I
      (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 :
      axum_core.extract.FromRequest.Trait T13
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T13)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 : core.future.future.Future.Trait Fut}
    {ℋ_30 : core.marker.Send.Trait Fut}
    {ℋ_31 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_32 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_33 : core.clone.Clone.Trait I}
    {ℋ_34 : core.marker.Send.Trait I}
    {ℋ_35 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_36 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_37 : core.clone.Clone.Trait S}
    {ℋ_38 : core.marker.Send.Trait S}
    {ℋ_39 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t
      F
      S
      I
      ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Context {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 :
      axum_core.extract.FromRequest.Trait T14
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T14)}
    {ℋ_30 : core.marker.Send.Trait T14}
    {ℋ_31 : core.future.future.Future.Trait Fut}
    {ℋ_32 : core.marker.Send.Trait Fut}
    {ℋ_33 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_34 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_35 : core.clone.Clone.Trait I}
    {ℋ_36 : core.marker.Send.Trait I}
    {ℋ_37 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_38 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_39 : core.clone.Clone.Trait S}
    {ℋ_40 : core.marker.Send.Trait S}
    {ℋ_41 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t
      F
      S
      I
      (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Context
    {F Fut Out S I T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_30 : core.marker.Send.Trait T14}
    {ℋ_31 :
      axum_core.extract.FromRequest.Trait T15
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T15)}
    {ℋ_32 : core.marker.Send.Trait T15}
    {ℋ_33 : core.future.future.Future.Trait Fut}
    {ℋ_34 : core.marker.Send.Trait Fut}
    {ℋ_35 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_36 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_37 : core.clone.Clone.Trait I}
    {ℋ_38 : core.marker.Send.Trait I}
    {ℋ_39 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_40 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_41 : core.clone.Clone.Trait S}
    {ℋ_42 : core.marker.Send.Trait S}
    {ℋ_43 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t
      F
      S
      I
      ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Context
    {F
      Fut
      Out
      S
      I
      T1
      T2
      T3
      T4
      T5
      T6
      T7
      T8
      T9
      T10
      T11
      T12
      T13
      T14
      T15
      T16
      :
      Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)
        *
        axum.middleware.from_fn.Next.t)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_30 : core.marker.Send.Trait T14}
    {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
    {ℋ_32 : core.marker.Send.Trait T15}
    {ℋ_33 :
      axum_core.extract.FromRequest.Trait T16
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T16)}
    {ℋ_34 : core.marker.Send.Trait T16}
    {ℋ_35 : core.future.future.Future.Trait Fut}
    {ℋ_36 : core.marker.Send.Trait Fut}
    {ℋ_37 : axum_core.response.into_response.IntoResponse.Trait Out}
    {ℋ_38 :
      tower_service.Service.Trait I
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_39 : core.clone.Clone.Trait I}
    {ℋ_40 : core.marker.Send.Trait I}
    {ℋ_41 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_42 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_43 : core.clone.Clone.Trait S}
    {ℋ_44 : core.marker.Send.Trait S}
    {ℋ_45 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.from_fn.FromFn.t
      F
      S
      I
      (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      let inner = ServiceBuilder::new()
                          .boxed_clone()
                          .map_response(IntoResponse::into_response)
                          .service(ready_inner);
                      let next = Next { inner };
  
                      f($($ty,)* $last, next).await.into_response()
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_FromFn_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.

Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
  Context {F S I T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S} {ℋ_1 : core.fmt.Debug.Trait I}.
  
  Definition Self : Set := axum.middleware.from_fn.FromFn.t F S I T.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("FromFnLayer")
              .field("f", &format_args!("{}", type_name::<F>()))
              .field("inner", &self.inner)
              .field("state", &self.state)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.
End Impl_core_fmt_Debug_for_axum_middleware_from_fn_FromFn_t_F_S_I_T.

Module  Next.
Section Next.
  Record t : Set := {
    inner :
      tower.util.boxed_clone.BoxCloneService.t
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T)
        ltac:(axum_core.response.Response axum_core.response.Response.Default.T)
        core.convert.Infallible.t;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
End Next.
End Next.

Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.
Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.
  Definition Self : Set := axum.middleware.from_fn.Next.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.
End Impl_core_fmt_Debug_for_axum_middleware_from_fn_Next_t.

Module  Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.
Section Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.
  Definition Self : Set := axum.middleware.from_fn.Next.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.middleware.from_fn.Next.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.
End Impl_core_clone_Clone_for_axum_middleware_from_fn_Next_t.

Module  Impl_axum_middleware_from_fn_Next_t_3.
Section Impl_axum_middleware_from_fn_Next_t_3.
  Definition Self : Set := axum.middleware.from_fn.Next.t.
  
  (*
      pub async fn run(mut self, req: Request) -> Response {
          match self.inner.call(req).await {
              Ok(res) => res,
              Err(err) => match err {},
          }
      }
  *)
  Definition run
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M OpaqueDef :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_run : Notations.DoubleColon Self "run" := {
    Notations.double_colon := run;
  }.
End Impl_axum_middleware_from_fn_Next_t_3.
End Impl_axum_middleware_from_fn_Next_t_3.

Module  Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.
Section Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.
  Definition Self : Set := axum.middleware.from_fn.Next.t.
  
  (*
      type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;
  *)
  Definition Future : Set :=
    core.pin.Pin.t
        (alloc.boxed.Box.t
          (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
          alloc.boxed.Box.Default.A).
  
  (*
      fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          self.inner.poll_ready(cx)
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, req: Request) -> Self::Future {
          self.inner.call(req)
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        axum_core.extract.Request.Default.T)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.
End Impl_tower_service_Service_axum_core_extract_Request_axum_core_extract_Request_Default_T_for_axum_middleware_from_fn_Next_t.

Module  ResponseFuture.
Section ResponseFuture.
  Record t : Set := {
    inner :
      ltac:(futures_core.future.BoxFuture
        ltac:(axum_core.response.Response
          axum_core.response.Response.Default.T));
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
End ResponseFuture.
End ResponseFuture.

Module  Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.
Section Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.
  Definition Self : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
      type Output = Result<Response, Infallible>;
  *)
  Definition Output : Set :=
    core.result.Result.t
        ltac:(axum_core.response.Response axum_core.response.Response.Default.T)
        core.convert.Infallible.t.
  
  (*
      fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
          self.inner.as_mut().poll(cx).map(Ok)
      }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.
End Impl_core_future_future_Future_for_axum_middleware_from_fn_ResponseFuture_t.

Module  Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.
Section Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.
  Definition Self : Set := axum.middleware.from_fn.ResponseFuture.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("ResponseFuture").finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.
End Impl_core_fmt_Debug_for_axum_middleware_from_fn_ResponseFuture_t.

Module map_request.
  (*
  pub fn map_request<F, T>(f: F) -> MapRequestLayer<F, (), T> {
      map_request_with_state((), f)
  }
  *)
  Definition map_request
      {F T : Set}
      (f : F)
      : M (axum.middleware.map_request.MapRequestLayer.t F unit T) :=
    let* f := M.alloc f in
    M.read foo.
  
  (*
  pub fn map_request_with_state<F, S, T>(state: S, f: F) -> MapRequestLayer<F, S, T> {
      MapRequestLayer {
          f,
          state,
          _extractor: PhantomData,
      }
  }
  *)
  Definition map_request_with_state
      {F S T : Set}
      (state : S)
      (f : F)
      : M (axum.middleware.map_request.MapRequestLayer.t F S T) :=
    let* state := M.alloc state in
    let* f := M.alloc f in
    M.read foo.
  
  Module  MapRequestLayer.
  Section MapRequestLayer.
    Context (F S T : Set).
    
    Record t : Set := {
      f : F;
      state : S;
      _extractor : core.marker.PhantomData.t T;
    }.
    
    Definition Get_f :=
      Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
    Definition Get_state :=
      Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
    Definition Get__extractor :=
      Ref.map
        (fun α => Some α.(_extractor))
        (fun β α => Some (α <| _extractor := β |>)).
  End MapRequestLayer.
  End MapRequestLayer.
  
  Module  Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  Section Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    Context {F S T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequestLayer.t F S T.
    
    (*
        fn clone(&self) -> Self {
            Self {
                f: self.f.clone(),
                state: self.state.clone(),
                _extractor: self._extractor,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  
  Module  Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  Section Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    Context {S I F T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequestLayer.t F S T.
    
    (*
        type Service = MapRequest<F, S, I, T>;
    *)
    Definition Service : Set :=
      axum.middleware.map_request.MapRequest.t F S I T.
    
    (*
        fn layer(&self, inner: I) -> Self::Service {
            MapRequest {
                f: self.f.clone(),
                state: self.state.clone(),
                inner,
                _extractor: PhantomData,
            }
        }
    *)
    Definition layer (self : ref Self) (inner : I) : M Service :=
      let* self := M.alloc self in
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_layer :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer;
    }.
    
    Global Instance ℐ : tower_layer.Layer.Trait Self (S := I) := {
      tower_layer.Layer.Service := Service;
      tower_layer.Layer.layer := layer;
    }.
  End Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  End Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  Section Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
    Context {F S T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequestLayer.t F S T.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("MapRequestLayer")
                // Write out the type name, without quoting it as `&type_name::<F>()` would
                .field("f", &format_args!("{}", type_name::<F>()))
                .field("state", &self.state)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  
  Module  MapRequest.
  Section MapRequest.
    Context (F S I T : Set).
    
    Record t : Set := {
      f : F;
      inner : I;
      state : S;
      _extractor : core.marker.PhantomData.t T;
    }.
    
    Definition Get_f :=
      Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Definition Get_state :=
      Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
    Definition Get__extractor :=
      Ref.map
        (fun α => Some α.(_extractor))
        (fun β α => Some (α <| _extractor := β |>)).
  End MapRequest.
  End MapRequest.
  
  Module  Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
  Section Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
    Context {F S I T : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait F}
      {ℋ_1 : core.clone.Clone.Trait I}
      {ℋ_2 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.middleware.map_request.MapRequest.t F S I T.
    
    (*
        fn clone(&self) -> Self {
            Self {
                f: self.f.clone(),
                inner: self.inner.clone(),
                state: self.state.clone(),
                _extractor: self._extractor,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
  End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.
    Context {F Fut S I B T1 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnMut.Trait F (Args := T1)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 :
        axum_core.extract.FromRequest.Trait T1
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T1)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : core.future.future.Future.Trait Fut}
      {ℋ_6 : core.marker.Send.Trait Fut}
      {ℋ_7 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_8 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_9 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_10 : core.clone.Clone.Trait I}
      {ℋ_11 : core.marker.Send.Trait I}
      {ℋ_12 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_13 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_14 : http_body.Body.Trait B}
      {ℋ_15 : core.marker.Send.Trait B}
      {ℋ_16 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_17 : core.clone.Clone.Trait S}
      {ℋ_18 : core.marker.Send.Trait S}
      {ℋ_19 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.middleware.map_request.MapRequest.t F S I T1.
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.
    Context {F Fut S I B T1 T2 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnMut.Trait F (Args := T1 * T2)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 :
        axum_core.extract.FromRequest.Trait T2
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T2)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : core.future.future.Future.Trait Fut}
      {ℋ_8 : core.marker.Send.Trait Fut}
      {ℋ_9 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_10 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_11 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_12 : core.clone.Clone.Trait I}
      {ℋ_13 : core.marker.Send.Trait I}
      {ℋ_14 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_15 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_16 : http_body.Body.Trait B}
      {ℋ_17 : core.marker.Send.Trait B}
      {ℋ_18 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_19 : core.clone.Clone.Trait S}
      {ℋ_20 : core.marker.Send.Trait S}
      {ℋ_21 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t F S I (T1 * T2).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.
    Context {F Fut S I B T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnMut.Trait F (Args := (T1 * T2) * T3)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 :
        axum_core.extract.FromRequest.Trait T3
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T3)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : core.future.future.Future.Trait Fut}
      {ℋ_10 : core.marker.Send.Trait Fut}
      {ℋ_11 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_12 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_13 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_14 : core.clone.Clone.Trait I}
      {ℋ_15 : core.marker.Send.Trait I}
      {ℋ_16 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_17 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_18 : http_body.Body.Trait B}
      {ℋ_19 : core.marker.Send.Trait B}
      {ℋ_20 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_21 : core.clone.Clone.Trait S}
      {ℋ_22 : core.marker.Send.Trait S}
      {ℋ_23 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t F S I ((T1 * T2) * T3).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.
    Context {F Fut S I B T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnMut.Trait F (Args := ((T1 * T2) * T3) * T4)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 :
        axum_core.extract.FromRequest.Trait T4
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T4)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : core.future.future.Future.Trait Fut}
      {ℋ_12 : core.marker.Send.Trait Fut}
      {ℋ_13 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_14 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_15 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_16 : core.clone.Clone.Trait I}
      {ℋ_17 : core.marker.Send.Trait I}
      {ℋ_18 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_19 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_20 : http_body.Body.Trait B}
      {ℋ_21 : core.marker.Send.Trait B}
      {ℋ_22 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_23 : core.clone.Clone.Trait S}
      {ℋ_24 : core.marker.Send.Trait S}
      {ℋ_25 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t F S I (((T1 * T2) * T3) * T4).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    Context {F Fut S I B T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F (Args := (((T1 * T2) * T3) * T4) * T5)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 :
        axum_core.extract.FromRequest.Trait T5
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T5)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : core.future.future.Future.Trait Fut}
      {ℋ_14 : core.marker.Send.Trait Fut}
      {ℋ_15 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_16 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_17 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_18 : core.clone.Clone.Trait I}
      {ℋ_19 : core.marker.Send.Trait I}
      {ℋ_20 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_21 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_22 : http_body.Body.Trait B}
      {ℋ_23 : core.marker.Send.Trait B}
      {ℋ_24 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_25 : core.clone.Clone.Trait S}
      {ℋ_26 : core.marker.Send.Trait S}
      {ℋ_27 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        ((((T1 * T2) * T3) * T4) * T5).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    Context {F Fut S I B T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((T1 * T2) * T3) * T4) * T5) * T6)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 :
        axum_core.extract.FromRequest.Trait T6
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T6)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : core.future.future.Future.Trait Fut}
      {ℋ_16 : core.marker.Send.Trait Fut}
      {ℋ_17 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_18 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_19 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_20 : core.clone.Clone.Trait I}
      {ℋ_21 : core.marker.Send.Trait I}
      {ℋ_22 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_23 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_24 : http_body.Body.Trait B}
      {ℋ_25 : core.marker.Send.Trait B}
      {ℋ_26 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_27 : core.clone.Clone.Trait S}
      {ℋ_28 : core.marker.Send.Trait S}
      {ℋ_29 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        (((((T1 * T2) * T3) * T4) * T5) * T6).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 :
        axum_core.extract.FromRequest.Trait T7
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T7)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : core.future.future.Future.Trait Fut}
      {ℋ_18 : core.marker.Send.Trait Fut}
      {ℋ_19 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_20 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_21 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_22 : core.clone.Clone.Trait I}
      {ℋ_23 : core.marker.Send.Trait I}
      {ℋ_24 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_25 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_26 : http_body.Body.Trait B}
      {ℋ_27 : core.marker.Send.Trait B}
      {ℋ_28 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_29 : core.clone.Clone.Trait S}
      {ℋ_30 : core.marker.Send.Trait S}
      {ℋ_31 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 :
        axum_core.extract.FromRequest.Trait T8
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T8)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : core.future.future.Future.Trait Fut}
      {ℋ_20 : core.marker.Send.Trait Fut}
      {ℋ_21 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_22 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_23 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_24 : core.clone.Clone.Trait I}
      {ℋ_25 : core.marker.Send.Trait I}
      {ℋ_26 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_27 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_28 : http_body.Body.Trait B}
      {ℋ_29 : core.marker.Send.Trait B}
      {ℋ_30 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_31 : core.clone.Clone.Trait S}
      {ℋ_32 : core.marker.Send.Trait S}
      {ℋ_33 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 :
        axum_core.extract.FromRequest.Trait T9
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T9)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : core.future.future.Future.Trait Fut}
      {ℋ_22 : core.marker.Send.Trait Fut}
      {ℋ_23 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_24 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_25 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_26 : core.clone.Clone.Trait I}
      {ℋ_27 : core.marker.Send.Trait I}
      {ℋ_28 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_29 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_30 : http_body.Body.Trait B}
      {ℋ_31 : core.marker.Send.Trait B}
      {ℋ_32 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_33 : core.clone.Clone.Trait S}
      {ℋ_34 : core.marker.Send.Trait S}
      {ℋ_35 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 :
        axum_core.extract.FromRequest.Trait T10
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T10)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : core.future.future.Future.Trait Fut}
      {ℋ_24 : core.marker.Send.Trait Fut}
      {ℋ_25 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_26 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_27 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_28 : core.clone.Clone.Trait I}
      {ℋ_29 : core.marker.Send.Trait I}
      {ℋ_30 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_31 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_32 : http_body.Body.Trait B}
      {ℋ_33 : core.marker.Send.Trait B}
      {ℋ_34 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_35 : core.clone.Clone.Trait S}
      {ℋ_36 : core.marker.Send.Trait S}
      {ℋ_37 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 :
        axum_core.extract.FromRequest.Trait T11
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T11)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : core.future.future.Future.Trait Fut}
      {ℋ_26 : core.marker.Send.Trait Fut}
      {ℋ_27 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_28 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_29 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_30 : core.clone.Clone.Trait I}
      {ℋ_31 : core.marker.Send.Trait I}
      {ℋ_32 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_33 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_34 : http_body.Body.Trait B}
      {ℋ_35 : core.marker.Send.Trait B}
      {ℋ_36 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_37 : core.clone.Clone.Trait S}
      {ℋ_38 : core.marker.Send.Trait S}
      {ℋ_39 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 :
        axum_core.extract.FromRequest.Trait T12
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T12)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : core.future.future.Future.Trait Fut}
      {ℋ_28 : core.marker.Send.Trait Fut}
      {ℋ_29 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_30 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_31 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_32 : core.clone.Clone.Trait I}
      {ℋ_33 : core.marker.Send.Trait I}
      {ℋ_34 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_35 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_36 : http_body.Body.Trait B}
      {ℋ_37 : core.marker.Send.Trait B}
      {ℋ_38 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_39 : core.clone.Clone.Trait S}
      {ℋ_40 : core.marker.Send.Trait S}
      {ℋ_41 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 :
        axum_core.extract.FromRequest.Trait T13
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T13)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 : core.future.future.Future.Trait Fut}
      {ℋ_30 : core.marker.Send.Trait Fut}
      {ℋ_31 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_32 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_33 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_34 : core.clone.Clone.Trait I}
      {ℋ_35 : core.marker.Send.Trait I}
      {ℋ_36 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_37 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_38 : http_body.Body.Trait B}
      {ℋ_39 : core.marker.Send.Trait B}
      {ℋ_40 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_41 : core.clone.Clone.Trait S}
      {ℋ_42 : core.marker.Send.Trait S}
      {ℋ_43 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 :
        axum_core.extract.FromRequest.Trait T14
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T14)}
      {ℋ_30 : core.marker.Send.Trait T14}
      {ℋ_31 : core.future.future.Future.Trait Fut}
      {ℋ_32 : core.marker.Send.Trait Fut}
      {ℋ_33 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_34 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_35 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_36 : core.clone.Clone.Trait I}
      {ℋ_37 : core.marker.Send.Trait I}
      {ℋ_38 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_39 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_40 : http_body.Body.Trait B}
      {ℋ_41 : core.marker.Send.Trait B}
      {ℋ_42 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_43 : core.clone.Clone.Trait S}
      {ℋ_44 : core.marker.Send.Trait S}
      {ℋ_45 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Context
      {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_30 : core.marker.Send.Trait T14}
      {ℋ_31 :
        axum_core.extract.FromRequest.Trait T15
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T15)}
      {ℋ_32 : core.marker.Send.Trait T15}
      {ℋ_33 : core.future.future.Future.Trait Fut}
      {ℋ_34 : core.marker.Send.Trait Fut}
      {ℋ_35 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_36 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_37 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_38 : core.clone.Clone.Trait I}
      {ℋ_39 : core.marker.Send.Trait I}
      {ℋ_40 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_41 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_42 : http_body.Body.Trait B}
      {ℋ_43 : core.marker.Send.Trait B}
      {ℋ_44 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_45 : core.clone.Clone.Trait S}
      {ℋ_46 : core.marker.Send.Trait S}
      {ℋ_47 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Context
      {F
        Fut
        S
        I
        B
        T1
        T2
        T3
        T4
        T5
        T6
        T7
        T8
        T9
        T10
        T11
        T12
        T13
        T14
        T15
        T16
        :
        Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          T16)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_30 : core.marker.Send.Trait T14}
      {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
      {ℋ_32 : core.marker.Send.Trait T15}
      {ℋ_33 :
        axum_core.extract.FromRequest.Trait T16
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T16)}
      {ℋ_34 : core.marker.Send.Trait T16}
      {ℋ_35 : core.future.future.Future.Trait Fut}
      {ℋ_36 : core.marker.Send.Trait Fut}
      {ℋ_37 :
        axum.middleware.map_request.IntoMapRequestResult.Trait
            Fut::type["Output"].t
          (B := B)}
      {ℋ_38 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_39 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_40 : core.clone.Clone.Trait I}
      {ℋ_41 : core.marker.Send.Trait I}
      {ℋ_42 :
        axum_core.response.into_response.IntoResponse.Trait
            I::type["Response"].t}
      {ℋ_43 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_44 : http_body.Body.Trait B}
      {ℋ_45 : core.marker.Send.Trait B}
      {ℋ_46 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      {ℋ_47 : core.clone.Clone.Trait S}
      {ℋ_48 : core.marker.Send.Trait S}
      {ℋ_49 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_request.MapRequest.t
        F
        S
        I
        (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let req = req.map(Body::new);
    
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        let $last = match $last::from_request(req, &state).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
    
                        match f($($ty,)* $last).await.into_map_request_result() {
                            Ok(req) => {
                                ready_inner.call(req).await.into_response()
                            }
                            Err(res) => {
                                res
                            }
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
  Section Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
    Context {F S I T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S} {ℋ_1 : core.fmt.Debug.Trait I}.
    
    Definition Self : Set := axum.middleware.map_request.MapRequest.t F S I T.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("MapRequest")
                .field("f", &format_args!("{}", type_name::<F>()))
                .field("inner", &self.inner)
                .field("state", &self.state)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
  End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
  
  Module  ResponseFuture.
  Section ResponseFuture.
    Record t : Set := {
      inner :
        ltac:(futures_core.future.BoxFuture
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T));
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  End ResponseFuture.
  End ResponseFuture.
  
  Module  Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.
  Section Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.
    Definition Self : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
        type Output = Result<Response, Infallible>;
    *)
    Definition Output : Set :=
      core.result.Result.t
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          core.convert.Infallible.t.
    
    (*
        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            self.inner.as_mut().poll(cx).map(Ok)
        }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.
  End Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.
  Section Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.
    Definition Self : Set := axum.middleware.map_request.ResponseFuture.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("ResponseFuture").finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.
  End Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.
  
  Module private.
    Module  Sealed.
    Section Sealed.
      Unset Primitive Projections.
      Class Trait (Self : Set) {B : Set} : Type := {
      }.
      Global Set Primitive Projections.
    End Sealed.
    End Sealed.
    
    Module  Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
    Section Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
      Context {B E : Set}.
      
      Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E}.
      
      Definition Self : Set :=
        core.result.Result.t (http.request.Request.t B) E.
      
      Global Instance ℐ :
        axum.middleware.map_request.private.Sealed.Trait Self (B := B) := {
      }.
    End Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
    End Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
    
    Module  Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
    Section Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
      Context {B : Set}.
      
      Definition Self : Set := http.request.Request.t B.
      
      Global Instance ℐ :
        axum.middleware.map_request.private.Sealed.Trait Self (B := B) := {
      }.
    End Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
    End Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
  End private.
  
  Module  IntoMapRequestResult.
  Section IntoMapRequestResult.
    Class Trait (Self : Set) {B : Set} : Type := {
      ℒ_0 :: axum.middleware.map_request.private.Sealed.Trait Self (B := B);
      into_map_request_result :
        Self ->
          M
            (core.result.Result.t
              (http.request.Request.t B)
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T));
    }.
    
  End IntoMapRequestResult.
  End IntoMapRequestResult.
  
  Module  Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.
  Section Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.
    Context {B E : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E}.
    
    Definition Self : Set := core.result.Result.t (http.request.Request.t B) E.
    
    (*
        fn into_map_request_result(self) -> Result<Request<B>, Response> {
            self.map_err(IntoResponse::into_response)
        }
    *)
    Definition into_map_request_result
        (self : Self)
        :
          M
            (core.result.Result.t
              (http.request.Request.t B)
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_map_request_result :
      Notations.DoubleColon Self "into_map_request_result" := {
      Notations.double_colon := into_map_request_result;
    }.
    
    Global Instance ℐ :
      axum.middleware.map_request.IntoMapRequestResult.Trait Self (B := B) := {
      axum.middleware.map_request.IntoMapRequestResult.into_map_request_result :=
        into_map_request_result;
    }.
  End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.
  End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.
  
  Module  Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.
  Section Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.
    Context {B : Set}.
    
    Definition Self : Set := http.request.Request.t B.
    
    (*
        fn into_map_request_result(self) -> Result<Request<B>, Response> {
            Ok(self)
        }
    *)
    Definition into_map_request_result
        (self : Self)
        :
          M
            (core.result.Result.t
              (http.request.Request.t B)
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_map_request_result :
      Notations.DoubleColon Self "into_map_request_result" := {
      Notations.double_colon := into_map_request_result;
    }.
    
    Global Instance ℐ :
      axum.middleware.map_request.IntoMapRequestResult.Trait Self (B := B) := {
      axum.middleware.map_request.IntoMapRequestResult.into_map_request_result :=
        into_map_request_result;
    }.
  End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.
  End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.
End map_request.

(*
pub fn map_request<F, T>(f: F) -> MapRequestLayer<F, (), T> {
    map_request_with_state((), f)
}
*)
Definition map_request
    {F T : Set}
    (f : F)
    : M (axum.middleware.map_request.MapRequestLayer.t F unit T) :=
  let* f := M.alloc f in
  M.read foo.

(*
pub fn map_request_with_state<F, S, T>(state: S, f: F) -> MapRequestLayer<F, S, T> {
    MapRequestLayer {
        f,
        state,
        _extractor: PhantomData,
    }
}
*)
Definition map_request_with_state
    {F S T : Set}
    (state : S)
    (f : F)
    : M (axum.middleware.map_request.MapRequestLayer.t F S T) :=
  let* state := M.alloc state in
  let* f := M.alloc f in
  M.read foo.

Module  MapRequestLayer.
Section MapRequestLayer.
  Context (F S T : Set).
  
  Record t : Set := {
    f : F;
    state : S;
    _extractor : core.marker.PhantomData.t T;
  }.
  
  Definition Get_f :=
    Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get__extractor :=
    Ref.map
      (fun α => Some α.(_extractor))
      (fun β α => Some (α <| _extractor := β |>)).
End MapRequestLayer.
End MapRequestLayer.

Module  Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
Section Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  Context {F S T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.middleware.map_request.MapRequestLayer.t F S T.
  
  (*
      fn clone(&self) -> Self {
          Self {
              f: self.f.clone(),
              state: self.state.clone(),
              _extractor: self._extractor,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.

Module  Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
Section Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  Context {S I F T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.middleware.map_request.MapRequestLayer.t F S T.
  
  (*
      type Service = MapRequest<F, S, I, T>;
  *)
  Definition Service : Set := axum.middleware.map_request.MapRequest.t F S I T.
  
  (*
      fn layer(&self, inner: I) -> Self::Service {
          MapRequest {
              f: self.f.clone(),
              state: self.state.clone(),
              inner,
              _extractor: PhantomData,
          }
      }
  *)
  Definition layer (self : ref Self) (inner : I) : M Service :=
    let* self := M.alloc self in
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_layer :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer;
  }.
  
  Global Instance ℐ : tower_layer.Layer.Trait Self (S := I) := {
    tower_layer.Layer.Service := Service;
    tower_layer.Layer.layer := layer;
  }.
End Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
End Impl_tower_layer_Layer_I_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.

Module  Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
Section Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
  Context {F S T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set := axum.middleware.map_request.MapRequestLayer.t F S T.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("MapRequestLayer")
              // Write out the type name, without quoting it as `&type_name::<F>()` would
              .field("f", &format_args!("{}", type_name::<F>()))
              .field("state", &self.state)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.
End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequestLayer_t_F_S_T.

Module  MapRequest.
Section MapRequest.
  Context (F S I T : Set).
  
  Record t : Set := {
    f : F;
    inner : I;
    state : S;
    _extractor : core.marker.PhantomData.t T;
  }.
  
  Definition Get_f :=
    Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get__extractor :=
    Ref.map
      (fun α => Some α.(_extractor))
      (fun β α => Some (α <| _extractor := β |>)).
End MapRequest.
End MapRequest.

Module  Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
Section Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
  Context {F S I T : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait F}
    {ℋ_1 : core.clone.Clone.Trait I}
    {ℋ_2 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.middleware.map_request.MapRequest.t F S I T.
  
  (*
      fn clone(&self) -> Self {
          Self {
              f: self.f.clone(),
              inner: self.inner.clone(),
              state: self.state.clone(),
              _extractor: self._extractor,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
End Impl_core_clone_Clone_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.
  Context {F Fut S I B T1 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnMut.Trait F (Args := T1)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 :
      axum_core.extract.FromRequest.Trait T1
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T1)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : core.future.future.Future.Trait Fut}
    {ℋ_6 : core.marker.Send.Trait Fut}
    {ℋ_7 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_8 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_9 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_10 : core.clone.Clone.Trait I}
    {ℋ_11 : core.marker.Send.Trait I}
    {ℋ_12 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_13 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_14 : http_body.Body.Trait B}
    {ℋ_15 : core.marker.Send.Trait B}
    {ℋ_16 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_17 : core.clone.Clone.Trait S}
    {ℋ_18 : core.marker.Send.Trait S}
    {ℋ_19 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.middleware.map_request.MapRequest.t F S I T1.
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.
  Context {F Fut S I B T1 T2 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnMut.Trait F (Args := T1 * T2)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 :
      axum_core.extract.FromRequest.Trait T2
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T2)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : core.future.future.Future.Trait Fut}
    {ℋ_8 : core.marker.Send.Trait Fut}
    {ℋ_9 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_10 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_11 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_12 : core.clone.Clone.Trait I}
    {ℋ_13 : core.marker.Send.Trait I}
    {ℋ_14 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_15 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_16 : http_body.Body.Trait B}
    {ℋ_17 : core.marker.Send.Trait B}
    {ℋ_18 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_19 : core.clone.Clone.Trait S}
    {ℋ_20 : core.marker.Send.Trait S}
    {ℋ_21 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t F S I (T1 * T2).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.
  Context {F Fut S I B T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnMut.Trait F (Args := (T1 * T2) * T3)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 :
      axum_core.extract.FromRequest.Trait T3
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T3)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : core.future.future.Future.Trait Fut}
    {ℋ_10 : core.marker.Send.Trait Fut}
    {ℋ_11 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_12 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_13 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_14 : core.clone.Clone.Trait I}
    {ℋ_15 : core.marker.Send.Trait I}
    {ℋ_16 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_17 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_18 : http_body.Body.Trait B}
    {ℋ_19 : core.marker.Send.Trait B}
    {ℋ_20 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_21 : core.clone.Clone.Trait S}
    {ℋ_22 : core.marker.Send.Trait S}
    {ℋ_23 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t F S I ((T1 * T2) * T3).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.
  Context {F Fut S I B T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnMut.Trait F (Args := ((T1 * T2) * T3) * T4)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 :
      axum_core.extract.FromRequest.Trait T4
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T4)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : core.future.future.Future.Trait Fut}
    {ℋ_12 : core.marker.Send.Trait Fut}
    {ℋ_13 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_14 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_15 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_16 : core.clone.Clone.Trait I}
    {ℋ_17 : core.marker.Send.Trait I}
    {ℋ_18 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_19 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_20 : http_body.Body.Trait B}
    {ℋ_21 : core.marker.Send.Trait B}
    {ℋ_22 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_23 : core.clone.Clone.Trait S}
    {ℋ_24 : core.marker.Send.Trait S}
    {ℋ_25 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t F S I (((T1 * T2) * T3) * T4).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  Context {F Fut S I B T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F (Args := (((T1 * T2) * T3) * T4) * T5)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 :
      axum_core.extract.FromRequest.Trait T5
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T5)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : core.future.future.Future.Trait Fut}
    {ℋ_14 : core.marker.Send.Trait Fut}
    {ℋ_15 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_16 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_17 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_18 : core.clone.Clone.Trait I}
    {ℋ_19 : core.marker.Send.Trait I}
    {ℋ_20 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_21 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_22 : http_body.Body.Trait B}
    {ℋ_23 : core.marker.Send.Trait B}
    {ℋ_24 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_25 : core.clone.Clone.Trait S}
    {ℋ_26 : core.marker.Send.Trait S}
    {ℋ_27 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      ((((T1 * T2) * T3) * T4) * T5).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  Context {F Fut S I B T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((T1 * T2) * T3) * T4) * T5) * T6)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 :
      axum_core.extract.FromRequest.Trait T6
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T6)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : core.future.future.Future.Trait Fut}
    {ℋ_16 : core.marker.Send.Trait Fut}
    {ℋ_17 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_18 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_19 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_20 : core.clone.Clone.Trait I}
    {ℋ_21 : core.marker.Send.Trait I}
    {ℋ_22 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_23 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_24 : http_body.Body.Trait B}
    {ℋ_25 : core.marker.Send.Trait B}
    {ℋ_26 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_27 : core.clone.Clone.Trait S}
    {ℋ_28 : core.marker.Send.Trait S}
    {ℋ_29 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      (((((T1 * T2) * T3) * T4) * T5) * T6).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 :
      axum_core.extract.FromRequest.Trait T7
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T7)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : core.future.future.Future.Trait Fut}
    {ℋ_18 : core.marker.Send.Trait Fut}
    {ℋ_19 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_20 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_21 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_22 : core.clone.Clone.Trait I}
    {ℋ_23 : core.marker.Send.Trait I}
    {ℋ_24 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_25 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_26 : http_body.Body.Trait B}
    {ℋ_27 : core.marker.Send.Trait B}
    {ℋ_28 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_29 : core.clone.Clone.Trait S}
    {ℋ_30 : core.marker.Send.Trait S}
    {ℋ_31 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 :
      axum_core.extract.FromRequest.Trait T8
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T8)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : core.future.future.Future.Trait Fut}
    {ℋ_20 : core.marker.Send.Trait Fut}
    {ℋ_21 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_22 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_23 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_24 : core.clone.Clone.Trait I}
    {ℋ_25 : core.marker.Send.Trait I}
    {ℋ_26 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_27 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_28 : http_body.Body.Trait B}
    {ℋ_29 : core.marker.Send.Trait B}
    {ℋ_30 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_31 : core.clone.Clone.Trait S}
    {ℋ_32 : core.marker.Send.Trait S}
    {ℋ_33 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 :
      axum_core.extract.FromRequest.Trait T9
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T9)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : core.future.future.Future.Trait Fut}
    {ℋ_22 : core.marker.Send.Trait Fut}
    {ℋ_23 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_24 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_25 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_26 : core.clone.Clone.Trait I}
    {ℋ_27 : core.marker.Send.Trait I}
    {ℋ_28 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_29 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_30 : http_body.Body.Trait B}
    {ℋ_31 : core.marker.Send.Trait B}
    {ℋ_32 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_33 : core.clone.Clone.Trait S}
    {ℋ_34 : core.marker.Send.Trait S}
    {ℋ_35 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 :
      axum_core.extract.FromRequest.Trait T10
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T10)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : core.future.future.Future.Trait Fut}
    {ℋ_24 : core.marker.Send.Trait Fut}
    {ℋ_25 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_26 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_27 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_28 : core.clone.Clone.Trait I}
    {ℋ_29 : core.marker.Send.Trait I}
    {ℋ_30 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_31 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_32 : http_body.Body.Trait B}
    {ℋ_33 : core.marker.Send.Trait B}
    {ℋ_34 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_35 : core.clone.Clone.Trait S}
    {ℋ_36 : core.marker.Send.Trait S}
    {ℋ_37 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 :
      axum_core.extract.FromRequest.Trait T11
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T11)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : core.future.future.Future.Trait Fut}
    {ℋ_26 : core.marker.Send.Trait Fut}
    {ℋ_27 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_28 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_29 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_30 : core.clone.Clone.Trait I}
    {ℋ_31 : core.marker.Send.Trait I}
    {ℋ_32 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_33 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_34 : http_body.Body.Trait B}
    {ℋ_35 : core.marker.Send.Trait B}
    {ℋ_36 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_37 : core.clone.Clone.Trait S}
    {ℋ_38 : core.marker.Send.Trait S}
    {ℋ_39 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 :
      axum_core.extract.FromRequest.Trait T12
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T12)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : core.future.future.Future.Trait Fut}
    {ℋ_28 : core.marker.Send.Trait Fut}
    {ℋ_29 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_30 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_31 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_32 : core.clone.Clone.Trait I}
    {ℋ_33 : core.marker.Send.Trait I}
    {ℋ_34 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_35 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_36 : http_body.Body.Trait B}
    {ℋ_37 : core.marker.Send.Trait B}
    {ℋ_38 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_39 : core.clone.Clone.Trait S}
    {ℋ_40 : core.marker.Send.Trait S}
    {ℋ_41 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 :
      axum_core.extract.FromRequest.Trait T13
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T13)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 : core.future.future.Future.Trait Fut}
    {ℋ_30 : core.marker.Send.Trait Fut}
    {ℋ_31 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_32 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_33 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_34 : core.clone.Clone.Trait I}
    {ℋ_35 : core.marker.Send.Trait I}
    {ℋ_36 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_37 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_38 : http_body.Body.Trait B}
    {ℋ_39 : core.marker.Send.Trait B}
    {ℋ_40 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_41 : core.clone.Clone.Trait S}
    {ℋ_42 : core.marker.Send.Trait S}
    {ℋ_43 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Context {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 :
      axum_core.extract.FromRequest.Trait T14
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T14)}
    {ℋ_30 : core.marker.Send.Trait T14}
    {ℋ_31 : core.future.future.Future.Trait Fut}
    {ℋ_32 : core.marker.Send.Trait Fut}
    {ℋ_33 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_34 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_35 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_36 : core.clone.Clone.Trait I}
    {ℋ_37 : core.marker.Send.Trait I}
    {ℋ_38 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_39 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_40 : http_body.Body.Trait B}
    {ℋ_41 : core.marker.Send.Trait B}
    {ℋ_42 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_43 : core.clone.Clone.Trait S}
    {ℋ_44 : core.marker.Send.Trait S}
    {ℋ_45 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Context
    {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_30 : core.marker.Send.Trait T14}
    {ℋ_31 :
      axum_core.extract.FromRequest.Trait T15
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T15)}
    {ℋ_32 : core.marker.Send.Trait T15}
    {ℋ_33 : core.future.future.Future.Trait Fut}
    {ℋ_34 : core.marker.Send.Trait Fut}
    {ℋ_35 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_36 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_37 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_38 : core.clone.Clone.Trait I}
    {ℋ_39 : core.marker.Send.Trait I}
    {ℋ_40 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_41 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_42 : http_body.Body.Trait B}
    {ℋ_43 : core.marker.Send.Trait B}
    {ℋ_44 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_45 : core.clone.Clone.Trait S}
    {ℋ_46 : core.marker.Send.Trait S}
    {ℋ_47 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Context
    {F Fut S I B T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_30 : core.marker.Send.Trait T14}
    {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
    {ℋ_32 : core.marker.Send.Trait T15}
    {ℋ_33 :
      axum_core.extract.FromRequest.Trait T16
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T16)}
    {ℋ_34 : core.marker.Send.Trait T16}
    {ℋ_35 : core.future.future.Future.Trait Fut}
    {ℋ_36 : core.marker.Send.Trait Fut}
    {ℋ_37 :
      axum.middleware.map_request.IntoMapRequestResult.Trait
          Fut::type["Output"].t
        (B := B)}
    {ℋ_38 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_39 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_40 : core.clone.Clone.Trait I}
    {ℋ_41 : core.marker.Send.Trait I}
    {ℋ_42 :
      axum_core.response.into_response.IntoResponse.Trait I::type["Response"].t}
    {ℋ_43 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_44 : http_body.Body.Trait B}
    {ℋ_45 : core.marker.Send.Trait B}
    {ℋ_46 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    {ℋ_47 : core.clone.Clone.Trait S}
    {ℋ_48 : core.marker.Send.Trait S}
    {ℋ_49 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_request.MapRequest.t
      F
      S
      I
      (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let req = req.map(Body::new);
  
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      let $last = match $last::from_request(req, &state).await {
                          Ok(value) => value,
                          Err(rejection) => return rejection.into_response(),
                      };
  
                      match f($($ty,)* $last).await.into_map_request_result() {
                          Ok(req) => {
                              ready_inner.call(req).await.into_response()
                          }
                          Err(res) => {
                              res
                          }
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_request_MapRequest_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.

Module  Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
Section Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
  Context {F S I T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S} {ℋ_1 : core.fmt.Debug.Trait I}.
  
  Definition Self : Set := axum.middleware.map_request.MapRequest.t F S I T.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("MapRequest")
              .field("f", &format_args!("{}", type_name::<F>()))
              .field("inner", &self.inner)
              .field("state", &self.state)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.
End Impl_core_fmt_Debug_for_axum_middleware_map_request_MapRequest_t_F_S_I_T.

Module  Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.
Section Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.
  Definition Self : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
      type Output = Result<Response, Infallible>;
  *)
  Definition Output : Set :=
    core.result.Result.t
        ltac:(axum_core.response.Response axum_core.response.Response.Default.T)
        core.convert.Infallible.t.
  
  (*
      fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
          self.inner.as_mut().poll(cx).map(Ok)
      }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.
End Impl_core_future_future_Future_for_axum_middleware_map_request_ResponseFuture_t.

Module  Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.
Section Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.
  Definition Self : Set := axum.middleware.map_request.ResponseFuture.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("ResponseFuture").finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.
End Impl_core_fmt_Debug_for_axum_middleware_map_request_ResponseFuture_t.

Module Wrap_private_1.
Module private.
  Module  Sealed.
  Section Sealed.
    Unset Primitive Projections.
    Class Trait (Self : Set) {B : Set} : Type := {
    }.
    Global Set Primitive Projections.
  End Sealed.
  End Sealed.
  
  Module  Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
  Section Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
    Context {B E : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E}.
    
    Definition Self : Set := core.result.Result.t (http.request.Request.t B) E.
    
    Global Instance ℐ :
      axum.middleware.map_request.private.Sealed.Trait Self (B := B) := {
    }.
  End Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
  End Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
  
  Module  Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
  Section Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
    Context {B : Set}.
    
    Definition Self : Set := http.request.Request.t B.
    
    Global Instance ℐ :
      axum.middleware.map_request.private.Sealed.Trait Self (B := B) := {
    }.
  End Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
  End Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
End private.
End Wrap_private_1.
Import Wrap_private_1.

Module  Sealed.
Section Sealed.
  Unset Primitive Projections.
  Class Trait (Self : Set) {B : Set} : Type := {
  }.
  Global Set Primitive Projections.
End Sealed.
End Sealed.

Module  Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
Section Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
  Context {B E : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E}.
  
  Definition Self : Set := core.result.Result.t (http.request.Request.t B) E.
  
  Global Instance ℐ :
    axum.middleware.map_request.private.Sealed.Trait Self (B := B) := {
  }.
End Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.
End Impl_axum_middleware_map_request_private_Sealed_B_for_core_result_Result_t_http_request_Request_t_B_E.

Module  Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
Section Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
  Context {B : Set}.
  
  Definition Self : Set := http.request.Request.t B.
  
  Global Instance ℐ :
    axum.middleware.map_request.private.Sealed.Trait Self (B := B) := {
  }.
End Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.
End Impl_axum_middleware_map_request_private_Sealed_B_for_http_request_Request_t_B.

Module  IntoMapRequestResult.
Section IntoMapRequestResult.
  Class Trait (Self : Set) {B : Set} : Type := {
    ℒ_0 :: axum.middleware.map_request.private.Sealed.Trait Self (B := B);
    into_map_request_result :
      Self ->
        M
          (core.result.Result.t
            (http.request.Request.t B)
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T));
  }.
  
End IntoMapRequestResult.
End IntoMapRequestResult.

Module  Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.
Section Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.
  Context {B E : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E}.
  
  Definition Self : Set := core.result.Result.t (http.request.Request.t B) E.
  
  (*
      fn into_map_request_result(self) -> Result<Request<B>, Response> {
          self.map_err(IntoResponse::into_response)
      }
  *)
  Definition into_map_request_result
      (self : Self)
      :
        M
          (core.result.Result.t
            (http.request.Request.t B)
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_map_request_result :
    Notations.DoubleColon Self "into_map_request_result" := {
    Notations.double_colon := into_map_request_result;
  }.
  
  Global Instance ℐ :
    axum.middleware.map_request.IntoMapRequestResult.Trait Self (B := B) := {
    axum.middleware.map_request.IntoMapRequestResult.into_map_request_result :=
      into_map_request_result;
  }.
End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.
End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_core_result_Result_t_http_request_Request_t_B_E.

Module  Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.
Section Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.
  Context {B : Set}.
  
  Definition Self : Set := http.request.Request.t B.
  
  (*
      fn into_map_request_result(self) -> Result<Request<B>, Response> {
          Ok(self)
      }
  *)
  Definition into_map_request_result
      (self : Self)
      :
        M
          (core.result.Result.t
            (http.request.Request.t B)
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_map_request_result :
    Notations.DoubleColon Self "into_map_request_result" := {
    Notations.double_colon := into_map_request_result;
  }.
  
  Global Instance ℐ :
    axum.middleware.map_request.IntoMapRequestResult.Trait Self (B := B) := {
    axum.middleware.map_request.IntoMapRequestResult.into_map_request_result :=
      into_map_request_result;
  }.
End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.
End Impl_axum_middleware_map_request_IntoMapRequestResult_B_for_http_request_Request_t_B.

Module map_response.
  (*
  pub fn map_response<F, T>(f: F) -> MapResponseLayer<F, (), T> {
      map_response_with_state((), f)
  }
  *)
  Definition map_response
      {F T : Set}
      (f : F)
      : M (axum.middleware.map_response.MapResponseLayer.t F unit T) :=
    let* f := M.alloc f in
    M.read foo.
  
  (*
  pub fn map_response_with_state<F, S, T>(state: S, f: F) -> MapResponseLayer<F, S, T> {
      MapResponseLayer {
          f,
          state,
          _extractor: PhantomData,
      }
  }
  *)
  Definition map_response_with_state
      {F S T : Set}
      (state : S)
      (f : F)
      : M (axum.middleware.map_response.MapResponseLayer.t F S T) :=
    let* state := M.alloc state in
    let* f := M.alloc f in
    M.read foo.
  
  Module  MapResponseLayer.
  Section MapResponseLayer.
    Context (F S T : Set).
    
    Record t : Set := {
      f : F;
      state : S;
      _extractor : core.marker.PhantomData.t T;
    }.
    
    Definition Get_f :=
      Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
    Definition Get_state :=
      Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
    Definition Get__extractor :=
      Ref.map
        (fun α => Some α.(_extractor))
        (fun β α => Some (α <| _extractor := β |>)).
  End MapResponseLayer.
  End MapResponseLayer.
  
  Module  Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  Section Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    Context {F S T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponseLayer.t F S T.
    
    (*
        fn clone(&self) -> Self {
            Self {
                f: self.f.clone(),
                state: self.state.clone(),
                _extractor: self._extractor,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  
  Module  Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  Section Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    Context {S I F T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponseLayer.t F S T.
    
    (*
        type Service = MapResponse<F, S, I, T>;
    *)
    Definition Service : Set :=
      axum.middleware.map_response.MapResponse.t F S I T.
    
    (*
        fn layer(&self, inner: I) -> Self::Service {
            MapResponse {
                f: self.f.clone(),
                state: self.state.clone(),
                inner,
                _extractor: PhantomData,
            }
        }
    *)
    Definition layer (self : ref Self) (inner : I) : M Service :=
      let* self := M.alloc self in
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_layer :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer;
    }.
    
    Global Instance ℐ : tower_layer.Layer.Trait Self (S := I) := {
      tower_layer.Layer.Service := Service;
      tower_layer.Layer.layer := layer;
    }.
  End Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  End Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  Section Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
    Context {F S T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponseLayer.t F S T.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("MapResponseLayer")
                // Write out the type name, without quoting it as `&type_name::<F>()` would
                .field("f", &format_args!("{}", type_name::<F>()))
                .field("state", &self.state)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  
  Module  MapResponse.
  Section MapResponse.
    Context (F S I T : Set).
    
    Record t : Set := {
      f : F;
      inner : I;
      state : S;
      _extractor : core.marker.PhantomData.t T;
    }.
    
    Definition Get_f :=
      Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Definition Get_state :=
      Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
    Definition Get__extractor :=
      Ref.map
        (fun α => Some α.(_extractor))
        (fun β α => Some (α <| _extractor := β |>)).
  End MapResponse.
  End MapResponse.
  
  Module  Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
  Section Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
    Context {F S I T : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait F}
      {ℋ_1 : core.clone.Clone.Trait I}
      {ℋ_2 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.middleware.map_response.MapResponse.t F S I T.
    
    (*
        fn clone(&self) -> Self {
            Self {
                f: self.f.clone(),
                inner: self.inner.clone(),
                state: self.state.clone(),
                _extractor: self._extractor,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
  End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.
    Context {F Fut S I B ResBody : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : core.future.future.Future.Trait Fut}
      {ℋ_4 : core.marker.Send.Trait Fut}
      {ℋ_5 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_6 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_7 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_8 : core.clone.Clone.Trait I}
      {ℋ_9 : core.marker.Send.Trait I}
      {ℋ_10 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_11 : core.marker.Send.Trait B}
      {ℋ_12 : core.marker.Send.Trait ResBody}
      {ℋ_13 : core.clone.Clone.Trait S}
      {ℋ_14 : core.marker.Send.Trait S}
      {ℋ_15 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t F S I unit.
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.
    Context {F Fut S I B ResBody T1 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := T1 * ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : core.future.future.Future.Trait Fut}
      {ℋ_6 : core.marker.Send.Trait Fut}
      {ℋ_7 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_8 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_9 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_10 : core.clone.Clone.Trait I}
      {ℋ_11 : core.marker.Send.Trait I}
      {ℋ_12 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_13 : core.marker.Send.Trait B}
      {ℋ_14 : core.marker.Send.Trait ResBody}
      {ℋ_15 : core.clone.Clone.Trait S}
      {ℋ_16 : core.marker.Send.Trait S}
      {ℋ_17 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t F S I T1.
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.
    Context {F Fut S I B ResBody T1 T2 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (T1 * T2) * ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : core.future.future.Future.Trait Fut}
      {ℋ_8 : core.marker.Send.Trait Fut}
      {ℋ_9 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_10 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_11 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_12 : core.clone.Clone.Trait I}
      {ℋ_13 : core.marker.Send.Trait I}
      {ℋ_14 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_15 : core.marker.Send.Trait B}
      {ℋ_16 : core.marker.Send.Trait ResBody}
      {ℋ_17 : core.clone.Clone.Trait S}
      {ℋ_18 : core.marker.Send.Trait S}
      {ℋ_19 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t F S I (T1 * T2).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.
    Context {F Fut S I B ResBody T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((T1 * T2) * T3)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : core.future.future.Future.Trait Fut}
      {ℋ_10 : core.marker.Send.Trait Fut}
      {ℋ_11 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_12 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_13 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_14 : core.clone.Clone.Trait I}
      {ℋ_15 : core.marker.Send.Trait I}
      {ℋ_16 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_17 : core.marker.Send.Trait B}
      {ℋ_18 : core.marker.Send.Trait ResBody}
      {ℋ_19 : core.clone.Clone.Trait S}
      {ℋ_20 : core.marker.Send.Trait S}
      {ℋ_21 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t F S I ((T1 * T2) * T3).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.
    Context {F Fut S I B ResBody T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((T1 * T2) * T3) * T4)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : core.future.future.Future.Trait Fut}
      {ℋ_12 : core.marker.Send.Trait Fut}
      {ℋ_13 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_14 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_15 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_16 : core.clone.Clone.Trait I}
      {ℋ_17 : core.marker.Send.Trait I}
      {ℋ_18 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_19 : core.marker.Send.Trait B}
      {ℋ_20 : core.marker.Send.Trait ResBody}
      {ℋ_21 : core.clone.Clone.Trait S}
      {ℋ_22 : core.marker.Send.Trait S}
      {ℋ_23 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t F S I (((T1 * T2) * T3) * T4).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
    Context {F Fut S I B ResBody T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((T1 * T2) * T3) * T4) * T5)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : core.future.future.Future.Trait Fut}
      {ℋ_14 : core.marker.Send.Trait Fut}
      {ℋ_15 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_16 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_17 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_18 : core.clone.Clone.Trait I}
      {ℋ_19 : core.marker.Send.Trait I}
      {ℋ_20 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_21 : core.marker.Send.Trait B}
      {ℋ_22 : core.marker.Send.Trait ResBody}
      {ℋ_23 : core.clone.Clone.Trait S}
      {ℋ_24 : core.marker.Send.Trait S}
      {ℋ_25 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        ((((T1 * T2) * T3) * T4) * T5).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
    Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((T1 * T2) * T3) * T4) * T5) * T6)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : core.future.future.Future.Trait Fut}
      {ℋ_16 : core.marker.Send.Trait Fut}
      {ℋ_17 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_18 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_19 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_20 : core.clone.Clone.Trait I}
      {ℋ_21 : core.marker.Send.Trait I}
      {ℋ_22 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_23 : core.marker.Send.Trait B}
      {ℋ_24 : core.marker.Send.Trait ResBody}
      {ℋ_25 : core.clone.Clone.Trait S}
      {ℋ_26 : core.marker.Send.Trait S}
      {ℋ_27 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        (((((T1 * T2) * T3) * T4) * T5) * T6).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : core.future.future.Future.Trait Fut}
      {ℋ_18 : core.marker.Send.Trait Fut}
      {ℋ_19 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_20 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_21 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_22 : core.clone.Clone.Trait I}
      {ℋ_23 : core.marker.Send.Trait I}
      {ℋ_24 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_25 : core.marker.Send.Trait B}
      {ℋ_26 : core.marker.Send.Trait ResBody}
      {ℋ_27 : core.clone.Clone.Trait S}
      {ℋ_28 : core.marker.Send.Trait S}
      {ℋ_29 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : core.future.future.Future.Trait Fut}
      {ℋ_20 : core.marker.Send.Trait Fut}
      {ℋ_21 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_22 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_23 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_24 : core.clone.Clone.Trait I}
      {ℋ_25 : core.marker.Send.Trait I}
      {ℋ_26 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_27 : core.marker.Send.Trait B}
      {ℋ_28 : core.marker.Send.Trait ResBody}
      {ℋ_29 : core.clone.Clone.Trait S}
      {ℋ_30 : core.marker.Send.Trait S}
      {ℋ_31 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : core.future.future.Future.Trait Fut}
      {ℋ_22 : core.marker.Send.Trait Fut}
      {ℋ_23 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_24 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_25 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_26 : core.clone.Clone.Trait I}
      {ℋ_27 : core.marker.Send.Trait I}
      {ℋ_28 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_29 : core.marker.Send.Trait B}
      {ℋ_30 : core.marker.Send.Trait ResBody}
      {ℋ_31 : core.clone.Clone.Trait S}
      {ℋ_32 : core.marker.Send.Trait S}
      {ℋ_33 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : core.future.future.Future.Trait Fut}
      {ℋ_24 : core.marker.Send.Trait Fut}
      {ℋ_25 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_26 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_27 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_28 : core.clone.Clone.Trait I}
      {ℋ_29 : core.marker.Send.Trait I}
      {ℋ_30 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_31 : core.marker.Send.Trait B}
      {ℋ_32 : core.marker.Send.Trait ResBody}
      {ℋ_33 : core.clone.Clone.Trait S}
      {ℋ_34 : core.marker.Send.Trait S}
      {ℋ_35 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : core.future.future.Future.Trait Fut}
      {ℋ_26 : core.marker.Send.Trait Fut}
      {ℋ_27 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_28 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_29 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_30 : core.clone.Clone.Trait I}
      {ℋ_31 : core.marker.Send.Trait I}
      {ℋ_32 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_33 : core.marker.Send.Trait B}
      {ℋ_34 : core.marker.Send.Trait ResBody}
      {ℋ_35 : core.clone.Clone.Trait S}
      {ℋ_36 : core.marker.Send.Trait S}
      {ℋ_37 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : core.future.future.Future.Trait Fut}
      {ℋ_28 : core.marker.Send.Trait Fut}
      {ℋ_29 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_30 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_31 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_32 : core.clone.Clone.Trait I}
      {ℋ_33 : core.marker.Send.Trait I}
      {ℋ_34 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_35 : core.marker.Send.Trait B}
      {ℋ_36 : core.marker.Send.Trait ResBody}
      {ℋ_37 : core.clone.Clone.Trait S}
      {ℋ_38 : core.marker.Send.Trait S}
      {ℋ_39 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Context
      {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 : core.future.future.Future.Trait Fut}
      {ℋ_30 : core.marker.Send.Trait Fut}
      {ℋ_31 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_32 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_33 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_34 : core.clone.Clone.Trait I}
      {ℋ_35 : core.marker.Send.Trait I}
      {ℋ_36 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_37 : core.marker.Send.Trait B}
      {ℋ_38 : core.marker.Send.Trait ResBody}
      {ℋ_39 : core.clone.Clone.Trait S}
      {ℋ_40 : core.marker.Send.Trait S}
      {ℋ_41 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Context
      {F
        Fut
        S
        I
        B
        ResBody
        T1
        T2
        T3
        T4
        T5
        T6
        T7
        T8
        T9
        T10
        T11
        T12
        T13
        T14
        :
        Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_30 : core.marker.Send.Trait T14}
      {ℋ_31 : core.future.future.Future.Trait Fut}
      {ℋ_32 : core.marker.Send.Trait Fut}
      {ℋ_33 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_34 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_35 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_36 : core.clone.Clone.Trait I}
      {ℋ_37 : core.marker.Send.Trait I}
      {ℋ_38 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_39 : core.marker.Send.Trait B}
      {ℋ_40 : core.marker.Send.Trait ResBody}
      {ℋ_41 : core.clone.Clone.Trait S}
      {ℋ_42 : core.marker.Send.Trait S}
      {ℋ_43 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Context
      {F
        Fut
        S
        I
        B
        ResBody
        T1
        T2
        T3
        T4
        T5
        T6
        T7
        T8
        T9
        T10
        T11
        T12
        T13
        T14
        T15
        :
        Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_30 : core.marker.Send.Trait T14}
      {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
      {ℋ_32 : core.marker.Send.Trait T15}
      {ℋ_33 : core.future.future.Future.Trait Fut}
      {ℋ_34 : core.marker.Send.Trait Fut}
      {ℋ_35 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_36 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_37 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_38 : core.clone.Clone.Trait I}
      {ℋ_39 : core.marker.Send.Trait I}
      {ℋ_40 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_41 : core.marker.Send.Trait B}
      {ℋ_42 : core.marker.Send.Trait ResBody}
      {ℋ_43 : core.clone.Clone.Trait S}
      {ℋ_44 : core.marker.Send.Trait S}
      {ℋ_45 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Context
      {F
        Fut
        S
        I
        B
        ResBody
        T1
        T2
        T3
        T4
        T5
        T6
        T7
        T8
        T9
        T10
        T11
        T12
        T13
        T14
        T15
        T16
        :
        Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnMut.Trait F
          (Args := (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          T16)
          *
          ltac:(axum_core.response.Response ResBody))}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_4 : core.marker.Send.Trait T1}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_6 : core.marker.Send.Trait T2}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_8 : core.marker.Send.Trait T3}
      {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_10 : core.marker.Send.Trait T4}
      {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_12 : core.marker.Send.Trait T5}
      {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_14 : core.marker.Send.Trait T6}
      {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_16 : core.marker.Send.Trait T7}
      {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_18 : core.marker.Send.Trait T8}
      {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_20 : core.marker.Send.Trait T9}
      {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_22 : core.marker.Send.Trait T10}
      {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_24 : core.marker.Send.Trait T11}
      {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_26 : core.marker.Send.Trait T12}
      {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_28 : core.marker.Send.Trait T13}
      {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_30 : core.marker.Send.Trait T14}
      {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
      {ℋ_32 : core.marker.Send.Trait T15}
      {ℋ_33 : axum_core.extract.FromRequestParts.Trait T16 (S := S)}
      {ℋ_34 : core.marker.Send.Trait T16}
      {ℋ_35 : core.future.future.Future.Trait Fut}
      {ℋ_36 : core.marker.Send.Trait Fut}
      {ℋ_37 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}
      {ℋ_38 : core.marker.Send.Trait Fut::type["Output"].t}
      {ℋ_39 :
        tower_service.Service.Trait I (Request := http.request.Request.t B)}
      {ℋ_40 : core.clone.Clone.Trait I}
      {ℋ_41 : core.marker.Send.Trait I}
      {ℋ_42 : core.marker.Send.Trait I::type["Future"].t}
      {ℋ_43 : core.marker.Send.Trait B}
      {ℋ_44 : core.marker.Send.Trait ResBody}
      {ℋ_45 : core.clone.Clone.Trait S}
      {ℋ_46 : core.marker.Send.Trait S}
      {ℋ_47 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum.middleware.map_response.MapResponse.t
        F
        S
        I
        (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16).
    
    (*
                type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
                type Future = ResponseFuture;
    *)
    Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
                fn call(&mut self, req: Request<B>) -> Self::Future {
                    let not_ready_inner = self.inner.clone();
                    let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
    
                    let mut f = self.f.clone();
                    let _state = self.state.clone();
    
                    let future = Box::pin(async move {
                        let (mut parts, body) = req.into_parts();
    
                        $(
                            let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                                Ok(value) => value,
                                Err(rejection) => return rejection.into_response(),
                            };
                        )*
    
                        let req = Request::from_parts(parts, body);
    
                        match ready_inner.call(req).await {
                            Ok(res) => {
                                f($($ty,)* res).await.into_response()
                            }
                            Err(err) => match err {}
                        }
                    });
    
                    ResponseFuture {
                        inner: future
                    }
                }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
  Section Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
    Context {F S I T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S} {ℋ_1 : core.fmt.Debug.Trait I}.
    
    Definition Self : Set := axum.middleware.map_response.MapResponse.t F S I T.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("MapResponse")
                .field("f", &format_args!("{}", type_name::<F>()))
                .field("inner", &self.inner)
                .field("state", &self.state)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
  End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
  
  Module  ResponseFuture.
  Section ResponseFuture.
    Record t : Set := {
      inner :
        ltac:(futures_core.future.BoxFuture
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T));
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  End ResponseFuture.
  End ResponseFuture.
  
  Module  Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.
  Section Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.
    Definition Self : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
        type Output = Result<Response, Infallible>;
    *)
    Definition Output : Set :=
      core.result.Result.t
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          core.convert.Infallible.t.
    
    (*
        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            self.inner.as_mut().poll(cx).map(Ok)
        }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.
  End Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.
  
  Module  Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.
  Section Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.
    Definition Self : Set := axum.middleware.map_response.ResponseFuture.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("ResponseFuture").finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.
  End Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.
End map_response.

(*
pub fn map_response<F, T>(f: F) -> MapResponseLayer<F, (), T> {
    map_response_with_state((), f)
}
*)
Definition map_response
    {F T : Set}
    (f : F)
    : M (axum.middleware.map_response.MapResponseLayer.t F unit T) :=
  let* f := M.alloc f in
  M.read foo.

(*
pub fn map_response_with_state<F, S, T>(state: S, f: F) -> MapResponseLayer<F, S, T> {
    MapResponseLayer {
        f,
        state,
        _extractor: PhantomData,
    }
}
*)
Definition map_response_with_state
    {F S T : Set}
    (state : S)
    (f : F)
    : M (axum.middleware.map_response.MapResponseLayer.t F S T) :=
  let* state := M.alloc state in
  let* f := M.alloc f in
  M.read foo.

Module  MapResponseLayer.
Section MapResponseLayer.
  Context (F S T : Set).
  
  Record t : Set := {
    f : F;
    state : S;
    _extractor : core.marker.PhantomData.t T;
  }.
  
  Definition Get_f :=
    Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get__extractor :=
    Ref.map
      (fun α => Some α.(_extractor))
      (fun β α => Some (α <| _extractor := β |>)).
End MapResponseLayer.
End MapResponseLayer.

Module  Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
Section Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  Context {F S T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponseLayer.t F S T.
  
  (*
      fn clone(&self) -> Self {
          Self {
              f: self.f.clone(),
              state: self.state.clone(),
              _extractor: self._extractor,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.

Module  Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
Section Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  Context {S I F T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait F} {ℋ_1 : core.clone.Clone.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponseLayer.t F S T.
  
  (*
      type Service = MapResponse<F, S, I, T>;
  *)
  Definition Service : Set :=
    axum.middleware.map_response.MapResponse.t F S I T.
  
  (*
      fn layer(&self, inner: I) -> Self::Service {
          MapResponse {
              f: self.f.clone(),
              state: self.state.clone(),
              inner,
              _extractor: PhantomData,
          }
      }
  *)
  Definition layer (self : ref Self) (inner : I) : M Service :=
    let* self := M.alloc self in
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_layer :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer;
  }.
  
  Global Instance ℐ : tower_layer.Layer.Trait Self (S := I) := {
    tower_layer.Layer.Service := Service;
    tower_layer.Layer.layer := layer;
  }.
End Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
End Impl_tower_layer_Layer_I_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.

Module  Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
Section Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
  Context {F S T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponseLayer.t F S T.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("MapResponseLayer")
              // Write out the type name, without quoting it as `&type_name::<F>()` would
              .field("f", &format_args!("{}", type_name::<F>()))
              .field("state", &self.state)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.
End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponseLayer_t_F_S_T.

Module  MapResponse.
Section MapResponse.
  Context (F S I T : Set).
  
  Record t : Set := {
    f : F;
    inner : I;
    state : S;
    _extractor : core.marker.PhantomData.t T;
  }.
  
  Definition Get_f :=
    Ref.map (fun α => Some α.(f)) (fun β α => Some (α <| f := β |>)).
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  Definition Get__extractor :=
    Ref.map
      (fun α => Some α.(_extractor))
      (fun β α => Some (α <| _extractor := β |>)).
End MapResponse.
End MapResponse.

Module  Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
Section Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
  Context {F S I T : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait F}
    {ℋ_1 : core.clone.Clone.Trait I}
    {ℋ_2 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.middleware.map_response.MapResponse.t F S I T.
  
  (*
      fn clone(&self) -> Self {
          Self {
              f: self.f.clone(),
              inner: self.inner.clone(),
              state: self.state.clone(),
              _extractor: self._extractor,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
End Impl_core_clone_Clone_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.
  Context {F Fut S I B ResBody : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : core.future.future.Future.Trait Fut}
    {ℋ_4 : core.marker.Send.Trait Fut}
    {ℋ_5 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_6 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_7 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_8 : core.clone.Clone.Trait I}
    {ℋ_9 : core.marker.Send.Trait I}
    {ℋ_10 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_11 : core.marker.Send.Trait B}
    {ℋ_12 : core.marker.Send.Trait ResBody}
    {ℋ_13 : core.clone.Clone.Trait S}
    {ℋ_14 : core.marker.Send.Trait S}
    {ℋ_15 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t F S I unit.
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.
  Context {F Fut S I B ResBody T1 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := T1 * ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : core.future.future.Future.Trait Fut}
    {ℋ_6 : core.marker.Send.Trait Fut}
    {ℋ_7 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_8 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_9 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_10 : core.clone.Clone.Trait I}
    {ℋ_11 : core.marker.Send.Trait I}
    {ℋ_12 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_13 : core.marker.Send.Trait B}
    {ℋ_14 : core.marker.Send.Trait ResBody}
    {ℋ_15 : core.clone.Clone.Trait S}
    {ℋ_16 : core.marker.Send.Trait S}
    {ℋ_17 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.middleware.map_response.MapResponse.t F S I T1.
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.
  Context {F Fut S I B ResBody T1 T2 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (T1 * T2) * ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : core.future.future.Future.Trait Fut}
    {ℋ_8 : core.marker.Send.Trait Fut}
    {ℋ_9 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_10 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_11 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_12 : core.clone.Clone.Trait I}
    {ℋ_13 : core.marker.Send.Trait I}
    {ℋ_14 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_15 : core.marker.Send.Trait B}
    {ℋ_16 : core.marker.Send.Trait ResBody}
    {ℋ_17 : core.clone.Clone.Trait S}
    {ℋ_18 : core.marker.Send.Trait S}
    {ℋ_19 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t F S I (T1 * T2).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.
  Context {F Fut S I B ResBody T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((T1 * T2) * T3) * ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : core.future.future.Future.Trait Fut}
    {ℋ_10 : core.marker.Send.Trait Fut}
    {ℋ_11 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_12 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_13 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_14 : core.clone.Clone.Trait I}
    {ℋ_15 : core.marker.Send.Trait I}
    {ℋ_16 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_17 : core.marker.Send.Trait B}
    {ℋ_18 : core.marker.Send.Trait ResBody}
    {ℋ_19 : core.clone.Clone.Trait S}
    {ℋ_20 : core.marker.Send.Trait S}
    {ℋ_21 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t F S I ((T1 * T2) * T3).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.
  Context {F Fut S I B ResBody T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((T1 * T2) * T3) * T4)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : core.future.future.Future.Trait Fut}
    {ℋ_12 : core.marker.Send.Trait Fut}
    {ℋ_13 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_14 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_15 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_16 : core.clone.Clone.Trait I}
    {ℋ_17 : core.marker.Send.Trait I}
    {ℋ_18 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_19 : core.marker.Send.Trait B}
    {ℋ_20 : core.marker.Send.Trait ResBody}
    {ℋ_21 : core.clone.Clone.Trait S}
    {ℋ_22 : core.marker.Send.Trait S}
    {ℋ_23 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t F S I (((T1 * T2) * T3) * T4).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
  Context {F Fut S I B ResBody T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((T1 * T2) * T3) * T4) * T5)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : core.future.future.Future.Trait Fut}
    {ℋ_14 : core.marker.Send.Trait Fut}
    {ℋ_15 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_16 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_17 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_18 : core.clone.Clone.Trait I}
    {ℋ_19 : core.marker.Send.Trait I}
    {ℋ_20 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_21 : core.marker.Send.Trait B}
    {ℋ_22 : core.marker.Send.Trait ResBody}
    {ℋ_23 : core.clone.Clone.Trait S}
    {ℋ_24 : core.marker.Send.Trait S}
    {ℋ_25 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      ((((T1 * T2) * T3) * T4) * T5).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
  Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((T1 * T2) * T3) * T4) * T5) * T6)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : core.future.future.Future.Trait Fut}
    {ℋ_16 : core.marker.Send.Trait Fut}
    {ℋ_17 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_18 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_19 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_20 : core.clone.Clone.Trait I}
    {ℋ_21 : core.marker.Send.Trait I}
    {ℋ_22 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_23 : core.marker.Send.Trait B}
    {ℋ_24 : core.marker.Send.Trait ResBody}
    {ℋ_25 : core.clone.Clone.Trait S}
    {ℋ_26 : core.marker.Send.Trait S}
    {ℋ_27 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      (((((T1 * T2) * T3) * T4) * T5) * T6).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : core.future.future.Future.Trait Fut}
    {ℋ_18 : core.marker.Send.Trait Fut}
    {ℋ_19 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_20 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_21 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_22 : core.clone.Clone.Trait I}
    {ℋ_23 : core.marker.Send.Trait I}
    {ℋ_24 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_25 : core.marker.Send.Trait B}
    {ℋ_26 : core.marker.Send.Trait ResBody}
    {ℋ_27 : core.clone.Clone.Trait S}
    {ℋ_28 : core.marker.Send.Trait S}
    {ℋ_29 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : core.future.future.Future.Trait Fut}
    {ℋ_20 : core.marker.Send.Trait Fut}
    {ℋ_21 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_22 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_23 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_24 : core.clone.Clone.Trait I}
    {ℋ_25 : core.marker.Send.Trait I}
    {ℋ_26 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_27 : core.marker.Send.Trait B}
    {ℋ_28 : core.marker.Send.Trait ResBody}
    {ℋ_29 : core.clone.Clone.Trait S}
    {ℋ_30 : core.marker.Send.Trait S}
    {ℋ_31 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : core.future.future.Future.Trait Fut}
    {ℋ_22 : core.marker.Send.Trait Fut}
    {ℋ_23 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_24 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_25 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_26 : core.clone.Clone.Trait I}
    {ℋ_27 : core.marker.Send.Trait I}
    {ℋ_28 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_29 : core.marker.Send.Trait B}
    {ℋ_30 : core.marker.Send.Trait ResBody}
    {ℋ_31 : core.clone.Clone.Trait S}
    {ℋ_32 : core.marker.Send.Trait S}
    {ℋ_33 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : core.future.future.Future.Trait Fut}
    {ℋ_24 : core.marker.Send.Trait Fut}
    {ℋ_25 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_26 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_27 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_28 : core.clone.Clone.Trait I}
    {ℋ_29 : core.marker.Send.Trait I}
    {ℋ_30 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_31 : core.marker.Send.Trait B}
    {ℋ_32 : core.marker.Send.Trait ResBody}
    {ℋ_33 : core.clone.Clone.Trait S}
    {ℋ_34 : core.marker.Send.Trait S}
    {ℋ_35 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : core.future.future.Future.Trait Fut}
    {ℋ_26 : core.marker.Send.Trait Fut}
    {ℋ_27 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_28 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_29 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_30 : core.clone.Clone.Trait I}
    {ℋ_31 : core.marker.Send.Trait I}
    {ℋ_32 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_33 : core.marker.Send.Trait B}
    {ℋ_34 : core.marker.Send.Trait ResBody}
    {ℋ_35 : core.clone.Clone.Trait S}
    {ℋ_36 : core.marker.Send.Trait S}
    {ℋ_37 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Context {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : core.future.future.Future.Trait Fut}
    {ℋ_28 : core.marker.Send.Trait Fut}
    {ℋ_29 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_30 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_31 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_32 : core.clone.Clone.Trait I}
    {ℋ_33 : core.marker.Send.Trait I}
    {ℋ_34 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_35 : core.marker.Send.Trait B}
    {ℋ_36 : core.marker.Send.Trait ResBody}
    {ℋ_37 : core.clone.Clone.Trait S}
    {ℋ_38 : core.marker.Send.Trait S}
    {ℋ_39 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Context
    {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 : core.future.future.Future.Trait Fut}
    {ℋ_30 : core.marker.Send.Trait Fut}
    {ℋ_31 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_32 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_33 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_34 : core.clone.Clone.Trait I}
    {ℋ_35 : core.marker.Send.Trait I}
    {ℋ_36 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_37 : core.marker.Send.Trait B}
    {ℋ_38 : core.marker.Send.Trait ResBody}
    {ℋ_39 : core.clone.Clone.Trait S}
    {ℋ_40 : core.marker.Send.Trait S}
    {ℋ_41 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Context
    {F Fut S I B ResBody T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_30 : core.marker.Send.Trait T14}
    {ℋ_31 : core.future.future.Future.Trait Fut}
    {ℋ_32 : core.marker.Send.Trait Fut}
    {ℋ_33 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_34 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_35 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_36 : core.clone.Clone.Trait I}
    {ℋ_37 : core.marker.Send.Trait I}
    {ℋ_38 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_39 : core.marker.Send.Trait B}
    {ℋ_40 : core.marker.Send.Trait ResBody}
    {ℋ_41 : core.clone.Clone.Trait S}
    {ℋ_42 : core.marker.Send.Trait S}
    {ℋ_43 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Context
    {F
      Fut
      S
      I
      B
      ResBody
      T1
      T2
      T3
      T4
      T5
      T6
      T7
      T8
      T9
      T10
      T11
      T12
      T13
      T14
      T15
      :
      Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_30 : core.marker.Send.Trait T14}
    {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
    {ℋ_32 : core.marker.Send.Trait T15}
    {ℋ_33 : core.future.future.Future.Trait Fut}
    {ℋ_34 : core.marker.Send.Trait Fut}
    {ℋ_35 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_36 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_37 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_38 : core.clone.Clone.Trait I}
    {ℋ_39 : core.marker.Send.Trait I}
    {ℋ_40 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_41 : core.marker.Send.Trait B}
    {ℋ_42 : core.marker.Send.Trait ResBody}
    {ℋ_43 : core.clone.Clone.Trait S}
    {ℋ_44 : core.marker.Send.Trait S}
    {ℋ_45 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Context
    {F
      Fut
      S
      I
      B
      ResBody
      T1
      T2
      T3
      T4
      T5
      T6
      T7
      T8
      T9
      T10
      T11
      T12
      T13
      T14
      T15
      T16
      :
      Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnMut.Trait F
        (Args := (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)
        *
        ltac:(axum_core.response.Response ResBody))}
    {ℋ_1 : core.clone.Clone.Trait F}
    {ℋ_2 : core.marker.Send.Trait F}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_4 : core.marker.Send.Trait T1}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_6 : core.marker.Send.Trait T2}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_8 : core.marker.Send.Trait T3}
    {ℋ_9 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_10 : core.marker.Send.Trait T4}
    {ℋ_11 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_12 : core.marker.Send.Trait T5}
    {ℋ_13 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_14 : core.marker.Send.Trait T6}
    {ℋ_15 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_16 : core.marker.Send.Trait T7}
    {ℋ_17 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_18 : core.marker.Send.Trait T8}
    {ℋ_19 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_20 : core.marker.Send.Trait T9}
    {ℋ_21 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_22 : core.marker.Send.Trait T10}
    {ℋ_23 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_24 : core.marker.Send.Trait T11}
    {ℋ_25 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_26 : core.marker.Send.Trait T12}
    {ℋ_27 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_28 : core.marker.Send.Trait T13}
    {ℋ_29 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_30 : core.marker.Send.Trait T14}
    {ℋ_31 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
    {ℋ_32 : core.marker.Send.Trait T15}
    {ℋ_33 : axum_core.extract.FromRequestParts.Trait T16 (S := S)}
    {ℋ_34 : core.marker.Send.Trait T16}
    {ℋ_35 : core.future.future.Future.Trait Fut}
    {ℋ_36 : core.marker.Send.Trait Fut}
    {ℋ_37 :
      axum_core.response.into_response.IntoResponse.Trait Fut::type["Output"].t}
    {ℋ_38 : core.marker.Send.Trait Fut::type["Output"].t}
    {ℋ_39 : tower_service.Service.Trait I (Request := http.request.Request.t B)}
    {ℋ_40 : core.clone.Clone.Trait I}
    {ℋ_41 : core.marker.Send.Trait I}
    {ℋ_42 : core.marker.Send.Trait I::type["Future"].t}
    {ℋ_43 : core.marker.Send.Trait B}
    {ℋ_44 : core.marker.Send.Trait ResBody}
    {ℋ_45 : core.clone.Clone.Trait S}
    {ℋ_46 : core.marker.Send.Trait S}
    {ℋ_47 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    axum.middleware.map_response.MapResponse.t
      F
      S
      I
      (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16).
  
  (*
              type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
              type Future = ResponseFuture;
  *)
  Definition Future : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
              fn call(&mut self, req: Request<B>) -> Self::Future {
                  let not_ready_inner = self.inner.clone();
                  let mut ready_inner = std::mem::replace(&mut self.inner, not_ready_inner);
  
                  let mut f = self.f.clone();
                  let _state = self.state.clone();
  
                  let future = Box::pin(async move {
                      let (mut parts, body) = req.into_parts();
  
                      $(
                          let $ty = match $ty::from_request_parts(&mut parts, &_state).await {
                              Ok(value) => value,
                              Err(rejection) => return rejection.into_response(),
                          };
                      )*
  
                      let req = Request::from_parts(parts, body);
  
                      match ready_inner.call(req).await {
                          Ok(res) => {
                              f($($ty,)* res).await.into_response()
                          }
                          Err(err) => match err {}
                      }
                  });
  
                  ResponseFuture {
                      inner: future
                  }
              }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_middleware_map_response_MapResponse_t_F_S_I_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.

Module  Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
Section Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
  Context {F S I T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S} {ℋ_1 : core.fmt.Debug.Trait I}.
  
  Definition Self : Set := axum.middleware.map_response.MapResponse.t F S I T.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("MapResponse")
              .field("f", &format_args!("{}", type_name::<F>()))
              .field("inner", &self.inner)
              .field("state", &self.state)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.
End Impl_core_fmt_Debug_for_axum_middleware_map_response_MapResponse_t_F_S_I_T.

Module  Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.
Section Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.
  Definition Self : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
      type Output = Result<Response, Infallible>;
  *)
  Definition Output : Set :=
    core.result.Result.t
        ltac:(axum_core.response.Response axum_core.response.Response.Default.T)
        core.convert.Infallible.t.
  
  (*
      fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
          self.inner.as_mut().poll(cx).map(Ok)
      }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.
End Impl_core_future_future_Future_for_axum_middleware_map_response_ResponseFuture_t.

Module  Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.
Section Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.
  Definition Self : Set := axum.middleware.map_response.ResponseFuture.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("ResponseFuture").finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.
End Impl_core_fmt_Debug_for_axum_middleware_map_response_ResponseFuture_t.

Module response.
  Module redirect.
    Module  Redirect.
    Section Redirect.
      Record t : Set := {
        status_code : http.status.StatusCode.t;
        location : http.header.value.HeaderValue.t;
      }.
      
      Definition Get_status_code :=
        Ref.map
          (fun α => Some α.(status_code))
          (fun β α => Some (α <| status_code := β |>)).
      Definition Get_location :=
        Ref.map
          (fun α => Some α.(location))
          (fun β α => Some (α <| location := β |>)).
    End Redirect.
    End Redirect.
    
    Module  Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.
    Section Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.
      Definition Self : Set := axum.response.redirect.Redirect.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.
    End Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.
    
    Module  Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.
    Section Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.
      Definition Self : Set := axum.response.redirect.Redirect.t.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum.response.redirect.Redirect.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.
    End Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.
    
    Module  Impl_axum_response_redirect_Redirect_t.
    Section Impl_axum_response_redirect_Redirect_t.
      Definition Self : Set := axum.response.redirect.Redirect.t.
      
      (*
          pub fn to(uri: &str) -> Self {
              Self::with_status_code(StatusCode::SEE_OTHER, uri)
          }
      *)
      Definition to (uri : ref str.t) : M Self :=
        let* uri := M.alloc uri in
        M.read foo.
      
      Global Instance AssociatedFunction_to :
        Notations.DoubleColon Self "to" := {
        Notations.double_colon := to;
      }.
      
      (*
          pub fn temporary(uri: &str) -> Self {
              Self::with_status_code(StatusCode::TEMPORARY_REDIRECT, uri)
          }
      *)
      Definition temporary (uri : ref str.t) : M Self :=
        let* uri := M.alloc uri in
        M.read foo.
      
      Global Instance AssociatedFunction_temporary :
        Notations.DoubleColon Self "temporary" := {
        Notations.double_colon := temporary;
      }.
      
      (*
          pub fn permanent(uri: &str) -> Self {
              Self::with_status_code(StatusCode::PERMANENT_REDIRECT, uri)
          }
      *)
      Definition permanent (uri : ref str.t) : M Self :=
        let* uri := M.alloc uri in
        M.read foo.
      
      Global Instance AssociatedFunction_permanent :
        Notations.DoubleColon Self "permanent" := {
        Notations.double_colon := permanent;
      }.
      
      (*
          fn with_status_code(status_code: StatusCode, uri: &str) -> Self {
              assert!(
                  status_code.is_redirection(),
                  "not a redirection status code"
              );
      
              Self {
                  status_code,
                  location: HeaderValue::try_from(uri).expect("URI isn't a valid header value"),
              }
          }
      *)
      Definition with_status_code
          (status_code : http.status.StatusCode.t)
          (uri : ref str.t)
          : M Self :=
        let* status_code := M.alloc status_code in
        let* uri := M.alloc uri in
        M.read foo.
      
      Global Instance AssociatedFunction_with_status_code :
        Notations.DoubleColon Self "with_status_code" := {
        Notations.double_colon := with_status_code;
      }.
    End Impl_axum_response_redirect_Redirect_t.
    End Impl_axum_response_redirect_Redirect_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.
      Definition Self : Set := axum.response.redirect.Redirect.t.
      
      (*
          fn into_response(self) -> Response {
              (self.status_code, [(LOCATION, self.location)]).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.
  End redirect.
  
  Module sse.
    Module  Sse.
    Section Sse.
      Context (S : Set).
      
      Record t : Set := {
        stream : S;
        keep_alive : core.option.Option.t axum.response.sse.KeepAlive.t;
      }.
      
      Definition Get_stream :=
        Ref.map
          (fun α => Some α.(stream))
          (fun β α => Some (α <| stream := β |>)).
      Definition Get_keep_alive :=
        Ref.map
          (fun α => Some α.(keep_alive))
          (fun β α => Some (α <| keep_alive := β |>)).
    End Sse.
    End Sse.
    
    Module  Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.
    Section Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set := axum.response.sse.Sse.t S.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M (axum.response.sse.Sse.t S) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.
    End Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.
    
    Module  Impl_axum_response_sse_Sse_t_S.
    Section Impl_axum_response_sse_Sse_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.response.sse.Sse.t S.
      
      (*
          pub fn new(stream: S) -> Self
          where
              S: TryStream<Ok = Event> + Send + 'static,
              S::Error: Into<BoxError>,
          {
              Sse {
                  stream,
                  keep_alive: None,
              }
          }
      *)
      Definition new
          {ℋ_0 : futures_core.stream.TryStream.Trait S}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 :
            core.convert.Into.Trait S::type["Error"].t
              (T := ltac:(axum_core.BoxError))}
          (stream : S)
          : M Self :=
        let* stream := M.alloc stream in
        M.read foo.
      
      Global Instance AssociatedFunction_new
          {ℋ_0 : futures_core.stream.TryStream.Trait S}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 :
            core.convert.Into.Trait S::type["Error"].t
              (T := ltac:(axum_core.BoxError))} :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
      
      (*
          pub fn keep_alive(mut self, keep_alive: KeepAlive) -> Self {
              self.keep_alive = Some(keep_alive);
              self
          }
      *)
      Definition keep_alive
          (self : Self)
          (keep_alive : axum.response.sse.KeepAlive.t)
          : M Self :=
        let* self := M.alloc self in
        let* keep_alive := M.alloc keep_alive in
        M.read foo.
      
      Global Instance AssociatedFunction_keep_alive :
        Notations.DoubleColon Self "keep_alive" := {
        Notations.double_colon := keep_alive;
      }.
    End Impl_axum_response_sse_Sse_t_S.
    End Impl_axum_response_sse_Sse_t_S.
    
    Module  Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.
    Section Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.response.sse.Sse.t S.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("Sse")
                  .field("stream", &format_args!("{}", std::any::type_name::<S>()))
                  .field("keep_alive", &self.keep_alive)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.
    End Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.
      Context {S E : Set}.
      
      Context
        {ℋ_0 : futures_core.stream.Stream.Trait S}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}.
      
      Definition Self : Set := axum.response.sse.Sse.t S.
      
      (*
          fn into_response(self) -> Response {
              (
                  [
                      (http::header::CONTENT_TYPE, mime::TEXT_EVENT_STREAM.as_ref()),
                      (http::header::CACHE_CONTROL, "no-cache"),
                  ],
                  Body::new(SseBody {
                      event_stream: SyncWrapper::new(self.stream),
                      keep_alive: self.keep_alive.map(KeepAliveStream::new),
                  }),
              )
                  .into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.
    
    Module  SseBody.
    Section SseBody.
      Context (S : Set).
      
      Record t : Set := {
        event_stream : sync_wrapper.SyncWrapper.t S;
        keep_alive : core.option.Option.t axum.response.sse.KeepAliveStream.t;
      }.
      
      Definition Get_event_stream :=
        Ref.map
          (fun α => Some α.(event_stream))
          (fun β α => Some (α <| event_stream := β |>)).
      Definition Get_keep_alive :=
        Ref.map
          (fun α => Some α.(keep_alive))
          (fun β α => Some (α <| keep_alive := β |>)).
    End SseBody.
    End SseBody.
    
    Module  Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.
    Section Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.
      Context {S E : Set}.
      
      Context {ℋ_0 : futures_core.stream.Stream.Trait S}.
      
      Definition Self : Set := axum.response.sse.SseBody.t S.
      
      (*
          type Data = Bytes;
      *)
      Definition Data : Set := bytes.bytes.Bytes.t.
      
      (*
          type Error = E;
      *)
      Definition Error : Set := E.
      
      (*
          fn poll_frame(
              self: Pin<&mut Self>,
              cx: &mut Context<'_>,
          ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
              let this = self.project();
      
              match this.event_stream.get_pin_mut().poll_next(cx) {
                  Poll::Pending => {
                      if let Some(keep_alive) = this.keep_alive.as_pin_mut() {
                          keep_alive.poll_event(cx).map(|e| Some(Ok(Frame::data(e))))
                      } else {
                          Poll::Pending
                      }
                  }
                  Poll::Ready(Some(Ok(event))) => {
                      if let Some(keep_alive) = this.keep_alive.as_pin_mut() {
                          keep_alive.reset();
                      }
                      Poll::Ready(Some(Ok(Frame::data(event.finalize()))))
                  }
                  Poll::Ready(Some(Err(error))) => Poll::Ready(Some(Err(error))),
                  Poll::Ready(None) => Poll::Ready(None),
              }
          }
      *)
      Definition poll_frame
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          :
            M
              (core.task.poll.Poll.t
                (core.option.Option.t
                  (core.result.Result.t
                    (http_body.frame.Frame.t Data)
                    Error))) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_frame :
        Notations.DoubleColon Self "poll_frame" := {
        Notations.double_colon := poll_frame;
      }.
      
      Global Instance ℐ : http_body.Body.Required.Trait Self := {
        http_body.Body.Data := Data;
        http_body.Body.Error := Error;
        http_body.Body.poll_frame := poll_frame;
        http_body.Body.is_end_stream := Datatypes.None;
        http_body.Body.size_hint := Datatypes.None;
      }.
    End Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.
    End Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.
    
    Module  Event.
    Section Event.
      Record t : Set := {
        buffer : bytes.bytes_mut.BytesMut.t;
        flags : axum.response.sse.EventFlags.t;
      }.
      
      Definition Get_buffer :=
        Ref.map
          (fun α => Some α.(buffer))
          (fun β α => Some (α <| buffer := β |>)).
      Definition Get_flags :=
        Ref.map
          (fun α => Some α.(flags))
          (fun β α => Some (α <| flags := β |>)).
    End Event.
    End Event.
    
    Module  Impl_core_fmt_Debug_for_axum_response_sse_Event_t.
    Section Impl_core_fmt_Debug_for_axum_response_sse_Event_t.
      Definition Self : Set := axum.response.sse.Event.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_response_sse_Event_t.
    End Impl_core_fmt_Debug_for_axum_response_sse_Event_t.
    
    Module  Impl_core_default_Default_for_axum_response_sse_Event_t.
    Section Impl_core_default_Default_for_axum_response_sse_Event_t.
      Definition Self : Set := axum.response.sse.Event.t.
      
      (*
      Default
      *)
      Definition default : M axum.response.sse.Event.t := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_response_sse_Event_t.
    End Impl_core_default_Default_for_axum_response_sse_Event_t.
    
    Module  Impl_core_clone_Clone_for_axum_response_sse_Event_t.
    Section Impl_core_clone_Clone_for_axum_response_sse_Event_t.
      Definition Self : Set := axum.response.sse.Event.t.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M axum.response.sse.Event.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_response_sse_Event_t.
    End Impl_core_clone_Clone_for_axum_response_sse_Event_t.
    
    Module  Impl_axum_response_sse_Event_t.
    Section Impl_axum_response_sse_Event_t.
      Definition Self : Set := axum.response.sse.Event.t.
      
      (*
          pub fn data<T>(mut self, data: T) -> Event
          where
              T: AsRef<str>,
          {
              if self.flags.contains(EventFlags::HAS_DATA) {
                  panic!("Called `EventBuilder::data` multiple times");
              }
      
              for line in memchr_split(b'\n', data.as_ref().as_bytes()) {
                  self.field("data", line);
              }
      
              self.flags.insert(EventFlags::HAS_DATA);
      
              self
          }
      *)
      Definition data
          {T : Set}
          {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
          (self : Self)
          (data : T)
          : M axum.response.sse.Event.t :=
        let* self := M.alloc self in
        let* data := M.alloc data in
        M.read foo.
      
      Global Instance AssociatedFunction_data
          {T : Set}
          {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
        Notations.DoubleColon Self "data" := {
        Notations.double_colon := data (T := T);
      }.
      
      (*
          pub fn json_data<T>(mut self, data: T) -> Result<Event, axum_core::Error>
          where
              T: serde::Serialize,
          {
              if self.flags.contains(EventFlags::HAS_DATA) {
                  panic!("Called `EventBuilder::json_data` multiple times");
              }
      
              self.buffer.extend_from_slice(b"data: ");
              serde_json::to_writer((&mut self.buffer).writer(), &data).map_err(axum_core::Error::new)?;
              self.buffer.put_u8(b'\n');
      
              self.flags.insert(EventFlags::HAS_DATA);
      
              Ok(self)
          }
      *)
      Definition json_data
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T}
          (self : Self)
          (data : T)
          :
            M
              (core.result.Result.t
                axum.response.sse.Event.t
                axum_core.error.Error.t) :=
        let* self := M.alloc self in
        let* data := M.alloc data in
        M.read foo.
      
      Global Instance AssociatedFunction_json_data
          {T : Set}
          {ℋ_0 : serde.ser.Serialize.Trait T} :
        Notations.DoubleColon Self "json_data" := {
        Notations.double_colon := json_data (T := T);
      }.
      
      (*
          pub fn comment<T>(mut self, comment: T) -> Event
          where
              T: AsRef<str>,
          {
              self.field("", comment.as_ref());
              self
          }
      *)
      Definition comment
          {T : Set}
          {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
          (self : Self)
          (comment : T)
          : M axum.response.sse.Event.t :=
        let* self := M.alloc self in
        let* comment := M.alloc comment in
        M.read foo.
      
      Global Instance AssociatedFunction_comment
          {T : Set}
          {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
        Notations.DoubleColon Self "comment" := {
        Notations.double_colon := comment (T := T);
      }.
      
      (*
          pub fn event<T>(mut self, event: T) -> Event
          where
              T: AsRef<str>,
          {
              if self.flags.contains(EventFlags::HAS_EVENT) {
                  panic!("Called `EventBuilder::event` multiple times");
              }
              self.flags.insert(EventFlags::HAS_EVENT);
      
              self.field("event", event.as_ref());
      
              self
          }
      *)
      Definition event
          {T : Set}
          {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
          (self : Self)
          (event : T)
          : M axum.response.sse.Event.t :=
        let* self := M.alloc self in
        let* event := M.alloc event in
        M.read foo.
      
      Global Instance AssociatedFunction_event
          {T : Set}
          {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
        Notations.DoubleColon Self "event" := {
        Notations.double_colon := event (T := T);
      }.
      
      (*
          pub fn retry(mut self, duration: Duration) -> Event {
              if self.flags.contains(EventFlags::HAS_RETRY) {
                  panic!("Called `EventBuilder::retry` multiple times");
              }
              self.flags.insert(EventFlags::HAS_RETRY);
      
              self.buffer.extend_from_slice(b"retry:");
      
              let secs = duration.as_secs();
              let millis = duration.subsec_millis();
      
              if secs > 0 {
                  // format seconds
                  self.buffer
                      .extend_from_slice(itoa::Buffer::new().format(secs).as_bytes());
      
                  // pad milliseconds
                  if millis < 10 {
                      self.buffer.extend_from_slice(b"00");
                  } else if millis < 100 {
                      self.buffer.extend_from_slice(b"0");
                  }
              }
      
              // format milliseconds
              self.buffer
                  .extend_from_slice(itoa::Buffer::new().format(millis).as_bytes());
      
              self.buffer.put_u8(b'\n');
      
              self
          }
      *)
      Definition retry
          (self : Self)
          (duration : core.time.Duration.t)
          : M axum.response.sse.Event.t :=
        let* self := M.alloc self in
        let* duration := M.alloc duration in
        M.read foo.
      
      Global Instance AssociatedFunction_retry :
        Notations.DoubleColon Self "retry" := {
        Notations.double_colon := retry;
      }.
      
      (*
          pub fn id<T>(mut self, id: T) -> Event
          where
              T: AsRef<str>,
          {
              if self.flags.contains(EventFlags::HAS_ID) {
                  panic!("Called `EventBuilder::id` multiple times");
              }
              self.flags.insert(EventFlags::HAS_ID);
      
              let id = id.as_ref().as_bytes();
              assert_eq!(
                  memchr::memchr(b'\0', id),
                  None,
                  "Event ID cannot contain null characters",
              );
      
              self.field("id", id);
              self
          }
      *)
      Definition id
          {T : Set}
          {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
          (self : Self)
          (id : T)
          : M axum.response.sse.Event.t :=
        let* self := M.alloc self in
        let* id := M.alloc id in
        M.read foo.
      
      Global Instance AssociatedFunction_id
          {T : Set}
          {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
        Notations.DoubleColon Self "id" := {
        Notations.double_colon := id (T := T);
      }.
      
      (*
          fn field(&mut self, name: &str, value: impl AsRef<[u8]>) {
              let value = value.as_ref();
              assert_eq!(
                  memchr::memchr2(b'\r', b'\n', value),
                  None,
                  "SSE field value cannot contain newlines or carriage returns",
              );
              self.buffer.extend_from_slice(name.as_bytes());
              self.buffer.put_u8(b':');
              self.buffer.put_u8(b' ');
              self.buffer.extend_from_slice(value);
              self.buffer.put_u8(b'\n');
          }
      *)
      Definition field
          {impl AsRef<[u8]> : Set}
          {ℋ_0 : core.convert.AsRef.Trait impl AsRef<[u8]> (T := slice u8.t)}
          (self : mut_ref Self)
          (name : ref str.t)
          (value : impl AsRef<[u8]>)
          : M unit :=
        let* self := M.alloc self in
        let* name := M.alloc name in
        let* value := M.alloc value in
        M.read foo.
      
      Global Instance AssociatedFunction_field
          {impl AsRef<[u8]> : Set}
          {ℋ_0 : core.convert.AsRef.Trait impl AsRef<[u8]> (T := slice u8.t)} :
        Notations.DoubleColon Self "field" := {
        Notations.double_colon := field (impl AsRef<[u8]> := impl AsRef<[u8]>);
      }.
      
      (*
          fn finalize(mut self) -> Bytes {
              self.buffer.put_u8(b'\n');
              self.buffer.freeze()
          }
      *)
      Definition finalize (self : Self) : M bytes.bytes.Bytes.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_finalize :
        Notations.DoubleColon Self "finalize" := {
        Notations.double_colon := finalize;
      }.
    End Impl_axum_response_sse_Event_t.
    End Impl_axum_response_sse_Event_t.
    
    Module  EventFlags.
    Section EventFlags.
      Record t : Set := {
        x0 : u8.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End EventFlags.
    End EventFlags.
    
    Module  Impl_core_default_Default_for_axum_response_sse_EventFlags_t.
    Section Impl_core_default_Default_for_axum_response_sse_EventFlags_t.
      Definition Self : Set := axum.response.sse.EventFlags.t.
      
      (*
      Default
      *)
      Definition default : M axum.response.sse.EventFlags.t := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_response_sse_EventFlags_t.
    End Impl_core_default_Default_for_axum_response_sse_EventFlags_t.
    
    Module  Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.
    Section Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.
      Definition Self : Set := axum.response.sse.EventFlags.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.
    End Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.
    
    Module  Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.
    Section Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.
      Definition Self : Set := axum.response.sse.EventFlags.t.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.
    End Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.
    
    Module  Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.
    Section Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.
      Definition Self : Set := axum.response.sse.EventFlags.t.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M axum.response.sse.EventFlags.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.
    End Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.
    
    Module  Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.
    Section Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.
      Definition Self : Set := axum.response.sse.EventFlags.t.
      
      Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.
    End Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.
    
    Module  Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.
    Section Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.
      Definition Self : Set := axum.response.sse.EventFlags.t.
      
      (*
      PartialEq
      *)
      Definition eq
          (self : ref Self)
          (other : ref axum.response.sse.EventFlags.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.
    End Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.
    
    Module  Impl_axum_response_sse_EventFlags_t.
    Section Impl_axum_response_sse_EventFlags_t.
      Definition Self : Set := axum.response.sse.EventFlags.t.
      
      (*
          const HAS_DATA: Self = Self::from_bits(0b0001);
      *)
      
      Definition HAS_DATA : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_HAS_DATA :
        Notations.DoubleColon Self "HAS_DATA" := {
        Notations.double_colon := HAS_DATA;
      }.
      
      (*
          const HAS_EVENT: Self = Self::from_bits(0b0010);
      *)
      
      Definition HAS_EVENT : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_HAS_EVENT :
        Notations.DoubleColon Self "HAS_EVENT" := {
        Notations.double_colon := HAS_EVENT;
      }.
      
      (*
          const HAS_RETRY: Self = Self::from_bits(0b0100);
      *)
      
      Definition HAS_RETRY : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_HAS_RETRY :
        Notations.DoubleColon Self "HAS_RETRY" := {
        Notations.double_colon := HAS_RETRY;
      }.
      
      (*
          const HAS_ID: Self = Self::from_bits(0b1000);
      *)
      
      Definition HAS_ID : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_HAS_ID :
        Notations.DoubleColon Self "HAS_ID" := {
        Notations.double_colon := HAS_ID;
      }.
      
      (*
          const fn bits(&self) -> u8 {
              self.0
          }
      *)
      Definition bits (self : ref Self) : M u8.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_bits :
        Notations.DoubleColon Self "bits" := {
        Notations.double_colon := bits;
      }.
      
      (*
          const fn from_bits(bits: u8) -> Self {
              Self(bits)
          }
      *)
      Definition from_bits (bits : u8.t) : M Self :=
        let* bits := M.alloc bits in
        M.read foo.
      
      Global Instance AssociatedFunction_from_bits :
        Notations.DoubleColon Self "from_bits" := {
        Notations.double_colon := from_bits;
      }.
      
      (*
          const fn contains(&self, other: Self) -> bool {
              self.bits() & other.bits() == other.bits()
          }
      *)
      Definition contains (self : ref Self) (other : Self) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_contains :
        Notations.DoubleColon Self "contains" := {
        Notations.double_colon := contains;
      }.
      
      (*
          fn insert(&mut self, other: Self) {
              *self = Self::from_bits(self.bits() | other.bits());
          }
      *)
      Definition insert (self : mut_ref Self) (other : Self) : M unit :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_insert :
        Notations.DoubleColon Self "insert" := {
        Notations.double_colon := insert;
      }.
    End Impl_axum_response_sse_EventFlags_t.
    End Impl_axum_response_sse_EventFlags_t.
    
    Module  KeepAlive.
    Section KeepAlive.
      Record t : Set := {
        event : bytes.bytes.Bytes.t;
        max_interval : core.time.Duration.t;
      }.
      
      Definition Get_event :=
        Ref.map
          (fun α => Some α.(event))
          (fun β α => Some (α <| event := β |>)).
      Definition Get_max_interval :=
        Ref.map
          (fun α => Some α.(max_interval))
          (fun β α => Some (α <| max_interval := β |>)).
    End KeepAlive.
    End KeepAlive.
    
    Module  Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.
    Section Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.
      Definition Self : Set := axum.response.sse.KeepAlive.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.
    End Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.
    
    Module  Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.
    Section Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.
      Definition Self : Set := axum.response.sse.KeepAlive.t.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M axum.response.sse.KeepAlive.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.
    End Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.
    
    Module  Impl_axum_response_sse_KeepAlive_t.
    Section Impl_axum_response_sse_KeepAlive_t.
      Definition Self : Set := axum.response.sse.KeepAlive.t.
      
      (*
          pub fn new() -> Self {
              Self {
                  event: Bytes::from_static(b":\n\n"),
                  max_interval: Duration::from_secs(15),
              }
          }
      *)
      Definition new : M Self := M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
      
      (*
          pub fn interval(mut self, time: Duration) -> Self {
              self.max_interval = time;
              self
          }
      *)
      Definition interval
          (self : Self)
          (time : core.time.Duration.t)
          : M Self :=
        let* self := M.alloc self in
        let* time := M.alloc time in
        M.read foo.
      
      Global Instance AssociatedFunction_interval :
        Notations.DoubleColon Self "interval" := {
        Notations.double_colon := interval;
      }.
      
      (*
          pub fn text<I>(self, text: I) -> Self
          where
              I: AsRef<str>,
          {
              self.event(Event::default().comment(text))
          }
      *)
      Definition text
          {I : Set}
          {ℋ_0 : core.convert.AsRef.Trait I (T := str.t)}
          (self : Self)
          (text : I)
          : M Self :=
        let* self := M.alloc self in
        let* text := M.alloc text in
        M.read foo.
      
      Global Instance AssociatedFunction_text
          {I : Set}
          {ℋ_0 : core.convert.AsRef.Trait I (T := str.t)} :
        Notations.DoubleColon Self "text" := {
        Notations.double_colon := text (I := I);
      }.
      
      (*
          pub fn event(mut self, event: Event) -> Self {
              self.event = event.finalize();
              self
          }
      *)
      Definition event
          (self : Self)
          (event : axum.response.sse.Event.t)
          : M Self :=
        let* self := M.alloc self in
        let* event := M.alloc event in
        M.read foo.
      
      Global Instance AssociatedFunction_event :
        Notations.DoubleColon Self "event" := {
        Notations.double_colon := event;
      }.
    End Impl_axum_response_sse_KeepAlive_t.
    End Impl_axum_response_sse_KeepAlive_t.
    
    Module  Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.
    Section Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.
      Definition Self : Set := axum.response.sse.KeepAlive.t.
      
      (*
          fn default() -> Self {
              Self::new()
          }
      *)
      Definition default : M Self := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.
    End Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.
    
    Module  KeepAliveStream.
    Section KeepAliveStream.
      Record t : Set := {
        keep_alive : axum.response.sse.KeepAlive.t;
        alive_timer : tokio.time.sleep.Sleep.t;
      }.
      
      Definition Get_keep_alive :=
        Ref.map
          (fun α => Some α.(keep_alive))
          (fun β α => Some (α <| keep_alive := β |>)).
      Definition Get_alive_timer :=
        Ref.map
          (fun α => Some α.(alive_timer))
          (fun β α => Some (α <| alive_timer := β |>)).
    End KeepAliveStream.
    End KeepAliveStream.
    
    Module  Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.
    Section Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.
      Definition Self : Set := axum.response.sse.KeepAliveStream.t.
      
      (*
          Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.
    End Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.
    
    Module  Impl_axum_response_sse_KeepAliveStream_t.
    Section Impl_axum_response_sse_KeepAliveStream_t.
      Definition Self : Set := axum.response.sse.KeepAliveStream.t.
      
      (*
          fn new(keep_alive: KeepAlive) -> Self {
              Self {
                  alive_timer: tokio::time::sleep(keep_alive.max_interval),
                  keep_alive,
              }
          }
      *)
      Definition new (keep_alive : axum.response.sse.KeepAlive.t) : M Self :=
        let* keep_alive := M.alloc keep_alive in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
      
      (*
          fn reset(self: Pin<&mut Self>) {
              let this = self.project();
              this.alive_timer
                  .reset(tokio::time::Instant::now() + this.keep_alive.max_interval);
          }
      *)
      Definition reset (self : core.pin.Pin.t (mut_ref Self)) : M unit :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_reset :
        Notations.DoubleColon Self "reset" := {
        Notations.double_colon := reset;
      }.
      
      (*
          fn poll_event(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Bytes> {
              let this = self.as_mut().project();
      
              ready!(this.alive_timer.poll(cx));
      
              let event = this.keep_alive.event.clone();
      
              self.reset();
      
              Poll::Ready(event)
          }
      *)
      Definition poll_event
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t bytes.bytes.Bytes.t) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_event :
        Notations.DoubleColon Self "poll_event" := {
        Notations.double_colon := poll_event;
      }.
    End Impl_axum_response_sse_KeepAliveStream_t.
    End Impl_axum_response_sse_KeepAliveStream_t.
    
    (*
    fn memchr_split(needle: u8, haystack: &[u8]) -> MemchrSplit<'_> {
        MemchrSplit {
            needle,
            haystack: Some(haystack),
        }
    }
    *)
    Definition memchr_split
        (needle : u8.t)
        (haystack : ref (slice u8.t))
        : M axum.response.sse.MemchrSplit.t :=
      let* needle := M.alloc needle in
      let* haystack := M.alloc haystack in
      M.read foo.
    
    Module  MemchrSplit.
    Section MemchrSplit.
      Record t : Set := {
        needle : u8.t;
        haystack : core.option.Option.t (ref (slice u8.t));
      }.
      
      Definition Get_needle :=
        Ref.map
          (fun α => Some α.(needle))
          (fun β α => Some (α <| needle := β |>)).
      Definition Get_haystack :=
        Ref.map
          (fun α => Some α.(haystack))
          (fun β α => Some (α <| haystack := β |>)).
    End MemchrSplit.
    End MemchrSplit.
    
    Module  Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.
    Section Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.
      Definition Self : Set := axum.response.sse.MemchrSplit.t.
      
      (*
          type Item = &'a [u8];
      *)
      Definition Item : Set := ref (slice u8.t).
      
      (*
          fn next(&mut self) -> Option<Self::Item> {
              let haystack = self.haystack?;
              if let Some(pos) = memchr::memchr(self.needle, haystack) {
                  let (front, back) = haystack.split_at(pos);
                  self.haystack = Some(&back[1..]);
                  Some(front)
              } else {
                  self.haystack.take()
              }
          }
      *)
      Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_next :
        Notations.DoubleColon Self "next" := {
        Notations.double_colon := next;
      }.
      
      Global Instance ℐ :
        core.iter.traits.iterator.Iterator.Required.Trait Self := {
        core.iter.traits.iterator.Iterator.Item := Item;
        core.iter.traits.iterator.Iterator.next := next;
        core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
        core.iter.traits.iterator.Iterator.size_hint := Datatypes.None;
        core.iter.traits.iterator.Iterator.count := Datatypes.None;
        core.iter.traits.iterator.Iterator.last := Datatypes.None;
        core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.nth := Datatypes.None;
        core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.chain := Datatypes.None;
        core.iter.traits.iterator.Iterator.zip := Datatypes.None;
        core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
        core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
        core.iter.traits.iterator.Iterator.map := Datatypes.None;
        core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
        core.iter.traits.iterator.Iterator.filter := Datatypes.None;
        core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
        core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
        core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
        core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
        core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
        core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
        core.iter.traits.iterator.Iterator.skip := Datatypes.None;
        core.iter.traits.iterator.Iterator.take := Datatypes.None;
        core.iter.traits.iterator.Iterator.scan := Datatypes.None;
        core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
        core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
        core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
        core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
        core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
        core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
        core.iter.traits.iterator.Iterator.collect := Datatypes.None;
        core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
        core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
        core.iter.traits.iterator.Iterator.partition := Datatypes.None;
        core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
        core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
        core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
        core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
        core.iter.traits.iterator.Iterator.fold := Datatypes.None;
        core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
        core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
        core.iter.traits.iterator.Iterator.all := Datatypes.None;
        core.iter.traits.iterator.Iterator.any := Datatypes.None;
        core.iter.traits.iterator.Iterator.find := Datatypes.None;
        core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
        core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
        core.iter.traits.iterator.Iterator.position := Datatypes.None;
        core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
        core.iter.traits.iterator.Iterator.max := Datatypes.None;
        core.iter.traits.iterator.Iterator.min := Datatypes.None;
        core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
        core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
        core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.rev := Datatypes.None;
        core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
        core.iter.traits.iterator.Iterator.copied := Datatypes.None;
        core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
        core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
        core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
        core.iter.traits.iterator.Iterator.sum := Datatypes.None;
        core.iter.traits.iterator.Iterator.product := Datatypes.None;
        core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
        core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
        core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.eq := Datatypes.None;
        core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.ne := Datatypes.None;
        core.iter.traits.iterator.Iterator.lt := Datatypes.None;
        core.iter.traits.iterator.Iterator.le := Datatypes.None;
        core.iter.traits.iterator.Iterator.gt := Datatypes.None;
        core.iter.traits.iterator.Iterator.ge := Datatypes.None;
        core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
        core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
        core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
        core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
          Datatypes.None;
      }.
    End Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.
    End Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.
  End sse.
  
  Module  Html.
  Section Html.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Html.
  End Html.
  
  Module  Impl_core_clone_Clone_for_axum_response_Html_t_T.
  Section Impl_core_clone_Clone_for_axum_response_Html_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum.response.Html.t T.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M (axum.response.Html.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_response_Html_t_T.
  End Impl_core_clone_Clone_for_axum_response_Html_t_T.
  
  Module  Impl_core_marker_Copy_for_axum_response_Html_t_T.
  Section Impl_core_marker_Copy_for_axum_response_Html_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum.response.Html.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_response_Html_t_T.
  End Impl_core_marker_Copy_for_axum_response_Html_t_T.
  
  Module  Impl_core_fmt_Debug_for_axum_response_Html_t_T.
  Section Impl_core_fmt_Debug_for_axum_response_Html_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum.response.Html.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_response_Html_t_T.
  End Impl_core_fmt_Debug_for_axum_response_Html_t_T.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_response_Html_t_T.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_response_Html_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.convert.Into.Trait T (T := axum_core.body.Body.t)}.
    
    Definition Self : Set := axum.response.Html.t T.
    
    (*
        fn into_response(self) -> Response {
            (
                [(
                    header::CONTENT_TYPE,
                    HeaderValue::from_static(mime::TEXT_HTML_UTF_8.as_ref()),
                )],
                self.0.into(),
            )
                .into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_Html_t_T.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_Html_t_T.
  
  Module  Impl_core_convert_From_T_for_axum_response_Html_t_T.
  Section Impl_core_convert_From_T_for_axum_response_Html_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum.response.Html.t T.
    
    (*
        fn from(inner: T) -> Self {
            Self(inner)
        }
    *)
    Definition from (inner : T) : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_T_for_axum_response_Html_t_T.
  End Impl_core_convert_From_T_for_axum_response_Html_t_T.
End response.

Module redirect.
  Module  Redirect.
  Section Redirect.
    Record t : Set := {
      status_code : http.status.StatusCode.t;
      location : http.header.value.HeaderValue.t;
    }.
    
    Definition Get_status_code :=
      Ref.map
        (fun α => Some α.(status_code))
        (fun β α => Some (α <| status_code := β |>)).
    Definition Get_location :=
      Ref.map
        (fun α => Some α.(location))
        (fun β α => Some (α <| location := β |>)).
  End Redirect.
  End Redirect.
  
  Module  Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.
  Section Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.
    Definition Self : Set := axum.response.redirect.Redirect.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.
  End Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.
  
  Module  Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.
  Section Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.
    Definition Self : Set := axum.response.redirect.Redirect.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum.response.redirect.Redirect.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.
  End Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.
  
  Module  Impl_axum_response_redirect_Redirect_t_2.
  Section Impl_axum_response_redirect_Redirect_t_2.
    Definition Self : Set := axum.response.redirect.Redirect.t.
    
    (*
        pub fn to(uri: &str) -> Self {
            Self::with_status_code(StatusCode::SEE_OTHER, uri)
        }
    *)
    Definition to (uri : ref str.t) : M Self :=
      let* uri := M.alloc uri in
      M.read foo.
    
    Global Instance AssociatedFunction_to : Notations.DoubleColon Self "to" := {
      Notations.double_colon := to;
    }.
    
    (*
        pub fn temporary(uri: &str) -> Self {
            Self::with_status_code(StatusCode::TEMPORARY_REDIRECT, uri)
        }
    *)
    Definition temporary (uri : ref str.t) : M Self :=
      let* uri := M.alloc uri in
      M.read foo.
    
    Global Instance AssociatedFunction_temporary :
      Notations.DoubleColon Self "temporary" := {
      Notations.double_colon := temporary;
    }.
    
    (*
        pub fn permanent(uri: &str) -> Self {
            Self::with_status_code(StatusCode::PERMANENT_REDIRECT, uri)
        }
    *)
    Definition permanent (uri : ref str.t) : M Self :=
      let* uri := M.alloc uri in
      M.read foo.
    
    Global Instance AssociatedFunction_permanent :
      Notations.DoubleColon Self "permanent" := {
      Notations.double_colon := permanent;
    }.
    
    (*
        fn with_status_code(status_code: StatusCode, uri: &str) -> Self {
            assert!(
                status_code.is_redirection(),
                "not a redirection status code"
            );
    
            Self {
                status_code,
                location: HeaderValue::try_from(uri).expect("URI isn't a valid header value"),
            }
        }
    *)
    Definition with_status_code
        (status_code : http.status.StatusCode.t)
        (uri : ref str.t)
        : M Self :=
      let* status_code := M.alloc status_code in
      let* uri := M.alloc uri in
      M.read foo.
    
    Global Instance AssociatedFunction_with_status_code :
      Notations.DoubleColon Self "with_status_code" := {
      Notations.double_colon := with_status_code;
    }.
  End Impl_axum_response_redirect_Redirect_t_2.
  End Impl_axum_response_redirect_Redirect_t_2.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.
    Definition Self : Set := axum.response.redirect.Redirect.t.
    
    (*
        fn into_response(self) -> Response {
            (self.status_code, [(LOCATION, self.location)]).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.
End redirect.

Module  Redirect.
Section Redirect.
  Record t : Set := {
    status_code : http.status.StatusCode.t;
    location : http.header.value.HeaderValue.t;
  }.
  
  Definition Get_status_code :=
    Ref.map
      (fun α => Some α.(status_code))
      (fun β α => Some (α <| status_code := β |>)).
  Definition Get_location :=
    Ref.map
      (fun α => Some α.(location))
      (fun β α => Some (α <| location := β |>)).
End Redirect.
End Redirect.

Module  Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.
Section Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.
  Definition Self : Set := axum.response.redirect.Redirect.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.
End Impl_core_fmt_Debug_for_axum_response_redirect_Redirect_t.

Module  Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.
Section Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.
  Definition Self : Set := axum.response.redirect.Redirect.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.response.redirect.Redirect.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.
End Impl_core_clone_Clone_for_axum_response_redirect_Redirect_t.

Module  Impl_axum_response_redirect_Redirect_t_3.
Section Impl_axum_response_redirect_Redirect_t_3.
  Definition Self : Set := axum.response.redirect.Redirect.t.
  
  (*
      pub fn to(uri: &str) -> Self {
          Self::with_status_code(StatusCode::SEE_OTHER, uri)
      }
  *)
  Definition to (uri : ref str.t) : M Self :=
    let* uri := M.alloc uri in
    M.read foo.
  
  Global Instance AssociatedFunction_to : Notations.DoubleColon Self "to" := {
    Notations.double_colon := to;
  }.
  
  (*
      pub fn temporary(uri: &str) -> Self {
          Self::with_status_code(StatusCode::TEMPORARY_REDIRECT, uri)
      }
  *)
  Definition temporary (uri : ref str.t) : M Self :=
    let* uri := M.alloc uri in
    M.read foo.
  
  Global Instance AssociatedFunction_temporary :
    Notations.DoubleColon Self "temporary" := {
    Notations.double_colon := temporary;
  }.
  
  (*
      pub fn permanent(uri: &str) -> Self {
          Self::with_status_code(StatusCode::PERMANENT_REDIRECT, uri)
      }
  *)
  Definition permanent (uri : ref str.t) : M Self :=
    let* uri := M.alloc uri in
    M.read foo.
  
  Global Instance AssociatedFunction_permanent :
    Notations.DoubleColon Self "permanent" := {
    Notations.double_colon := permanent;
  }.
  
  (*
      fn with_status_code(status_code: StatusCode, uri: &str) -> Self {
          assert!(
              status_code.is_redirection(),
              "not a redirection status code"
          );
  
          Self {
              status_code,
              location: HeaderValue::try_from(uri).expect("URI isn't a valid header value"),
          }
      }
  *)
  Definition with_status_code
      (status_code : http.status.StatusCode.t)
      (uri : ref str.t)
      : M Self :=
    let* status_code := M.alloc status_code in
    let* uri := M.alloc uri in
    M.read foo.
  
  Global Instance AssociatedFunction_with_status_code :
    Notations.DoubleColon Self "with_status_code" := {
    Notations.double_colon := with_status_code;
  }.
End Impl_axum_response_redirect_Redirect_t_3.
End Impl_axum_response_redirect_Redirect_t_3.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.
  Definition Self : Set := axum.response.redirect.Redirect.t.
  
  (*
      fn into_response(self) -> Response {
          (self.status_code, [(LOCATION, self.location)]).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_redirect_Redirect_t.

Module sse.
  Module  Sse.
  Section Sse.
    Context (S : Set).
    
    Record t : Set := {
      stream : S;
      keep_alive : core.option.Option.t axum.response.sse.KeepAlive.t;
    }.
    
    Definition Get_stream :=
      Ref.map
        (fun α => Some α.(stream))
        (fun β α => Some (α <| stream := β |>)).
    Definition Get_keep_alive :=
      Ref.map
        (fun α => Some α.(keep_alive))
        (fun β α => Some (α <| keep_alive := β |>)).
  End Sse.
  End Sse.
  
  Module  Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.
  Section Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.response.sse.Sse.t S.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M (axum.response.sse.Sse.t S) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.
  End Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.
  
  Module  Impl_axum_response_sse_Sse_t_S_2.
  Section Impl_axum_response_sse_Sse_t_S_2.
    Context {S : Set}.
    
    Definition Self : Set := axum.response.sse.Sse.t S.
    
    (*
        pub fn new(stream: S) -> Self
        where
            S: TryStream<Ok = Event> + Send + 'static,
            S::Error: Into<BoxError>,
        {
            Sse {
                stream,
                keep_alive: None,
            }
        }
    *)
    Definition new
        {ℋ_0 : futures_core.stream.TryStream.Trait S}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 :
          core.convert.Into.Trait S::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        (stream : S)
        : M Self :=
      let* stream := M.alloc stream in
      M.read foo.
    
    Global Instance AssociatedFunction_new
        {ℋ_0 : futures_core.stream.TryStream.Trait S}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 :
          core.convert.Into.Trait S::type["Error"].t
            (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
    
    (*
        pub fn keep_alive(mut self, keep_alive: KeepAlive) -> Self {
            self.keep_alive = Some(keep_alive);
            self
        }
    *)
    Definition keep_alive
        (self : Self)
        (keep_alive : axum.response.sse.KeepAlive.t)
        : M Self :=
      let* self := M.alloc self in
      let* keep_alive := M.alloc keep_alive in
      M.read foo.
    
    Global Instance AssociatedFunction_keep_alive :
      Notations.DoubleColon Self "keep_alive" := {
      Notations.double_colon := keep_alive;
    }.
  End Impl_axum_response_sse_Sse_t_S_2.
  End Impl_axum_response_sse_Sse_t_S_2.
  
  Module  Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.
  Section Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.response.sse.Sse.t S.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Sse")
                .field("stream", &format_args!("{}", std::any::type_name::<S>()))
                .field("keep_alive", &self.keep_alive)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.
  End Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.
    Context {S E : Set}.
    
    Context
      {ℋ_0 : futures_core.stream.Stream.Trait S}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}.
    
    Definition Self : Set := axum.response.sse.Sse.t S.
    
    (*
        fn into_response(self) -> Response {
            (
                [
                    (http::header::CONTENT_TYPE, mime::TEXT_EVENT_STREAM.as_ref()),
                    (http::header::CACHE_CONTROL, "no-cache"),
                ],
                Body::new(SseBody {
                    event_stream: SyncWrapper::new(self.stream),
                    keep_alive: self.keep_alive.map(KeepAliveStream::new),
                }),
            )
                .into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.
  
  Module  SseBody.
  Section SseBody.
    Context (S : Set).
    
    Record t : Set := {
      event_stream : sync_wrapper.SyncWrapper.t S;
      keep_alive : core.option.Option.t axum.response.sse.KeepAliveStream.t;
    }.
    
    Definition Get_event_stream :=
      Ref.map
        (fun α => Some α.(event_stream))
        (fun β α => Some (α <| event_stream := β |>)).
    Definition Get_keep_alive :=
      Ref.map
        (fun α => Some α.(keep_alive))
        (fun β α => Some (α <| keep_alive := β |>)).
  End SseBody.
  End SseBody.
  
  Module  Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.
  Section Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.
    Context {S E : Set}.
    
    Context {ℋ_0 : futures_core.stream.Stream.Trait S}.
    
    Definition Self : Set := axum.response.sse.SseBody.t S.
    
    (*
        type Data = Bytes;
    *)
    Definition Data : Set := bytes.bytes.Bytes.t.
    
    (*
        type Error = E;
    *)
    Definition Error : Set := E.
    
    (*
        fn poll_frame(
            self: Pin<&mut Self>,
            cx: &mut Context<'_>,
        ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
            let this = self.project();
    
            match this.event_stream.get_pin_mut().poll_next(cx) {
                Poll::Pending => {
                    if let Some(keep_alive) = this.keep_alive.as_pin_mut() {
                        keep_alive.poll_event(cx).map(|e| Some(Ok(Frame::data(e))))
                    } else {
                        Poll::Pending
                    }
                }
                Poll::Ready(Some(Ok(event))) => {
                    if let Some(keep_alive) = this.keep_alive.as_pin_mut() {
                        keep_alive.reset();
                    }
                    Poll::Ready(Some(Ok(Frame::data(event.finalize()))))
                }
                Poll::Ready(Some(Err(error))) => Poll::Ready(Some(Err(error))),
                Poll::Ready(None) => Poll::Ready(None),
            }
        }
    *)
    Definition poll_frame
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        :
          M
            (core.task.poll.Poll.t
              (core.option.Option.t
                (core.result.Result.t (http_body.frame.Frame.t Data) Error))) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_frame :
      Notations.DoubleColon Self "poll_frame" := {
      Notations.double_colon := poll_frame;
    }.
    
    Global Instance ℐ : http_body.Body.Required.Trait Self := {
      http_body.Body.Data := Data;
      http_body.Body.Error := Error;
      http_body.Body.poll_frame := poll_frame;
      http_body.Body.is_end_stream := Datatypes.None;
      http_body.Body.size_hint := Datatypes.None;
    }.
  End Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.
  End Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.
  
  Module  Event.
  Section Event.
    Record t : Set := {
      buffer : bytes.bytes_mut.BytesMut.t;
      flags : axum.response.sse.EventFlags.t;
    }.
    
    Definition Get_buffer :=
      Ref.map
        (fun α => Some α.(buffer))
        (fun β α => Some (α <| buffer := β |>)).
    Definition Get_flags :=
      Ref.map (fun α => Some α.(flags)) (fun β α => Some (α <| flags := β |>)).
  End Event.
  End Event.
  
  Module  Impl_core_fmt_Debug_for_axum_response_sse_Event_t.
  Section Impl_core_fmt_Debug_for_axum_response_sse_Event_t.
    Definition Self : Set := axum.response.sse.Event.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_response_sse_Event_t.
  End Impl_core_fmt_Debug_for_axum_response_sse_Event_t.
  
  Module  Impl_core_default_Default_for_axum_response_sse_Event_t.
  Section Impl_core_default_Default_for_axum_response_sse_Event_t.
    Definition Self : Set := axum.response.sse.Event.t.
    
    (*
    Default
    *)
    Definition default : M axum.response.sse.Event.t := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_response_sse_Event_t.
  End Impl_core_default_Default_for_axum_response_sse_Event_t.
  
  Module  Impl_core_clone_Clone_for_axum_response_sse_Event_t.
  Section Impl_core_clone_Clone_for_axum_response_sse_Event_t.
    Definition Self : Set := axum.response.sse.Event.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum.response.sse.Event.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_response_sse_Event_t.
  End Impl_core_clone_Clone_for_axum_response_sse_Event_t.
  
  Module  Impl_axum_response_sse_Event_t_2.
  Section Impl_axum_response_sse_Event_t_2.
    Definition Self : Set := axum.response.sse.Event.t.
    
    (*
        pub fn data<T>(mut self, data: T) -> Event
        where
            T: AsRef<str>,
        {
            if self.flags.contains(EventFlags::HAS_DATA) {
                panic!("Called `EventBuilder::data` multiple times");
            }
    
            for line in memchr_split(b'\n', data.as_ref().as_bytes()) {
                self.field("data", line);
            }
    
            self.flags.insert(EventFlags::HAS_DATA);
    
            self
        }
    *)
    Definition data
        {T : Set}
        {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
        (self : Self)
        (data : T)
        : M axum.response.sse.Event.t :=
      let* self := M.alloc self in
      let* data := M.alloc data in
      M.read foo.
    
    Global Instance AssociatedFunction_data
        {T : Set}
        {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
      Notations.DoubleColon Self "data" := {
      Notations.double_colon := data (T := T);
    }.
    
    (*
        pub fn json_data<T>(mut self, data: T) -> Result<Event, axum_core::Error>
        where
            T: serde::Serialize,
        {
            if self.flags.contains(EventFlags::HAS_DATA) {
                panic!("Called `EventBuilder::json_data` multiple times");
            }
    
            self.buffer.extend_from_slice(b"data: ");
            serde_json::to_writer((&mut self.buffer).writer(), &data).map_err(axum_core::Error::new)?;
            self.buffer.put_u8(b'\n');
    
            self.flags.insert(EventFlags::HAS_DATA);
    
            Ok(self)
        }
    *)
    Definition json_data
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T}
        (self : Self)
        (data : T)
        :
          M
            (core.result.Result.t
              axum.response.sse.Event.t
              axum_core.error.Error.t) :=
      let* self := M.alloc self in
      let* data := M.alloc data in
      M.read foo.
    
    Global Instance AssociatedFunction_json_data
        {T : Set}
        {ℋ_0 : serde.ser.Serialize.Trait T} :
      Notations.DoubleColon Self "json_data" := {
      Notations.double_colon := json_data (T := T);
    }.
    
    (*
        pub fn comment<T>(mut self, comment: T) -> Event
        where
            T: AsRef<str>,
        {
            self.field("", comment.as_ref());
            self
        }
    *)
    Definition comment
        {T : Set}
        {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
        (self : Self)
        (comment : T)
        : M axum.response.sse.Event.t :=
      let* self := M.alloc self in
      let* comment := M.alloc comment in
      M.read foo.
    
    Global Instance AssociatedFunction_comment
        {T : Set}
        {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
      Notations.DoubleColon Self "comment" := {
      Notations.double_colon := comment (T := T);
    }.
    
    (*
        pub fn event<T>(mut self, event: T) -> Event
        where
            T: AsRef<str>,
        {
            if self.flags.contains(EventFlags::HAS_EVENT) {
                panic!("Called `EventBuilder::event` multiple times");
            }
            self.flags.insert(EventFlags::HAS_EVENT);
    
            self.field("event", event.as_ref());
    
            self
        }
    *)
    Definition event
        {T : Set}
        {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
        (self : Self)
        (event : T)
        : M axum.response.sse.Event.t :=
      let* self := M.alloc self in
      let* event := M.alloc event in
      M.read foo.
    
    Global Instance AssociatedFunction_event
        {T : Set}
        {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
      Notations.DoubleColon Self "event" := {
      Notations.double_colon := event (T := T);
    }.
    
    (*
        pub fn retry(mut self, duration: Duration) -> Event {
            if self.flags.contains(EventFlags::HAS_RETRY) {
                panic!("Called `EventBuilder::retry` multiple times");
            }
            self.flags.insert(EventFlags::HAS_RETRY);
    
            self.buffer.extend_from_slice(b"retry:");
    
            let secs = duration.as_secs();
            let millis = duration.subsec_millis();
    
            if secs > 0 {
                // format seconds
                self.buffer
                    .extend_from_slice(itoa::Buffer::new().format(secs).as_bytes());
    
                // pad milliseconds
                if millis < 10 {
                    self.buffer.extend_from_slice(b"00");
                } else if millis < 100 {
                    self.buffer.extend_from_slice(b"0");
                }
            }
    
            // format milliseconds
            self.buffer
                .extend_from_slice(itoa::Buffer::new().format(millis).as_bytes());
    
            self.buffer.put_u8(b'\n');
    
            self
        }
    *)
    Definition retry
        (self : Self)
        (duration : core.time.Duration.t)
        : M axum.response.sse.Event.t :=
      let* self := M.alloc self in
      let* duration := M.alloc duration in
      M.read foo.
    
    Global Instance AssociatedFunction_retry :
      Notations.DoubleColon Self "retry" := {
      Notations.double_colon := retry;
    }.
    
    (*
        pub fn id<T>(mut self, id: T) -> Event
        where
            T: AsRef<str>,
        {
            if self.flags.contains(EventFlags::HAS_ID) {
                panic!("Called `EventBuilder::id` multiple times");
            }
            self.flags.insert(EventFlags::HAS_ID);
    
            let id = id.as_ref().as_bytes();
            assert_eq!(
                memchr::memchr(b'\0', id),
                None,
                "Event ID cannot contain null characters",
            );
    
            self.field("id", id);
            self
        }
    *)
    Definition id
        {T : Set}
        {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
        (self : Self)
        (id : T)
        : M axum.response.sse.Event.t :=
      let* self := M.alloc self in
      let* id := M.alloc id in
      M.read foo.
    
    Global Instance AssociatedFunction_id
        {T : Set}
        {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
      Notations.DoubleColon Self "id" := {
      Notations.double_colon := id (T := T);
    }.
    
    (*
        fn field(&mut self, name: &str, value: impl AsRef<[u8]>) {
            let value = value.as_ref();
            assert_eq!(
                memchr::memchr2(b'\r', b'\n', value),
                None,
                "SSE field value cannot contain newlines or carriage returns",
            );
            self.buffer.extend_from_slice(name.as_bytes());
            self.buffer.put_u8(b':');
            self.buffer.put_u8(b' ');
            self.buffer.extend_from_slice(value);
            self.buffer.put_u8(b'\n');
        }
    *)
    Definition field
        {impl AsRef<[u8]> : Set}
        {ℋ_0 : core.convert.AsRef.Trait impl AsRef<[u8]> (T := slice u8.t)}
        (self : mut_ref Self)
        (name : ref str.t)
        (value : impl AsRef<[u8]>)
        : M unit :=
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_field
        {impl AsRef<[u8]> : Set}
        {ℋ_0 : core.convert.AsRef.Trait impl AsRef<[u8]> (T := slice u8.t)} :
      Notations.DoubleColon Self "field" := {
      Notations.double_colon := field (impl AsRef<[u8]> := impl AsRef<[u8]>);
    }.
    
    (*
        fn finalize(mut self) -> Bytes {
            self.buffer.put_u8(b'\n');
            self.buffer.freeze()
        }
    *)
    Definition finalize (self : Self) : M bytes.bytes.Bytes.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_finalize :
      Notations.DoubleColon Self "finalize" := {
      Notations.double_colon := finalize;
    }.
  End Impl_axum_response_sse_Event_t_2.
  End Impl_axum_response_sse_Event_t_2.
  
  Module  EventFlags.
  Section EventFlags.
    Record t : Set := {
      x0 : u8.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End EventFlags.
  End EventFlags.
  
  Module  Impl_core_default_Default_for_axum_response_sse_EventFlags_t.
  Section Impl_core_default_Default_for_axum_response_sse_EventFlags_t.
    Definition Self : Set := axum.response.sse.EventFlags.t.
    
    (*
    Default
    *)
    Definition default : M axum.response.sse.EventFlags.t := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_response_sse_EventFlags_t.
  End Impl_core_default_Default_for_axum_response_sse_EventFlags_t.
  
  Module  Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.
  Section Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.
    Definition Self : Set := axum.response.sse.EventFlags.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.
  End Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.
  
  Module  Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.
  Section Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.
    Definition Self : Set := axum.response.sse.EventFlags.t.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.
  End Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.
  
  Module  Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.
  Section Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.
    Definition Self : Set := axum.response.sse.EventFlags.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum.response.sse.EventFlags.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.
  End Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.
  
  Module  Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.
  Section Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.
    Definition Self : Set := axum.response.sse.EventFlags.t.
    
    Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.
  End Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.
  
  Module  Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.
  Section Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.
    Definition Self : Set := axum.response.sse.EventFlags.t.
    
    (*
    PartialEq
    *)
    Definition eq
        (self : ref Self)
        (other : ref axum.response.sse.EventFlags.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.
  End Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.
  
  Module  Impl_axum_response_sse_EventFlags_t_2.
  Section Impl_axum_response_sse_EventFlags_t_2.
    Definition Self : Set := axum.response.sse.EventFlags.t.
    
    (*
        const HAS_DATA: Self = Self::from_bits(0b0001);
    *)
    
    Definition HAS_DATA : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_HAS_DATA :
      Notations.DoubleColon Self "HAS_DATA" := {
      Notations.double_colon := HAS_DATA;
    }.
    
    (*
        const HAS_EVENT: Self = Self::from_bits(0b0010);
    *)
    
    Definition HAS_EVENT : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_HAS_EVENT :
      Notations.DoubleColon Self "HAS_EVENT" := {
      Notations.double_colon := HAS_EVENT;
    }.
    
    (*
        const HAS_RETRY: Self = Self::from_bits(0b0100);
    *)
    
    Definition HAS_RETRY : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_HAS_RETRY :
      Notations.DoubleColon Self "HAS_RETRY" := {
      Notations.double_colon := HAS_RETRY;
    }.
    
    (*
        const HAS_ID: Self = Self::from_bits(0b1000);
    *)
    
    Definition HAS_ID : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_HAS_ID :
      Notations.DoubleColon Self "HAS_ID" := {
      Notations.double_colon := HAS_ID;
    }.
    
    (*
        const fn bits(&self) -> u8 {
            self.0
        }
    *)
    Definition bits (self : ref Self) : M u8.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_bits :
      Notations.DoubleColon Self "bits" := {
      Notations.double_colon := bits;
    }.
    
    (*
        const fn from_bits(bits: u8) -> Self {
            Self(bits)
        }
    *)
    Definition from_bits (bits : u8.t) : M Self :=
      let* bits := M.alloc bits in
      M.read foo.
    
    Global Instance AssociatedFunction_from_bits :
      Notations.DoubleColon Self "from_bits" := {
      Notations.double_colon := from_bits;
    }.
    
    (*
        const fn contains(&self, other: Self) -> bool {
            self.bits() & other.bits() == other.bits()
        }
    *)
    Definition contains (self : ref Self) (other : Self) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_contains :
      Notations.DoubleColon Self "contains" := {
      Notations.double_colon := contains;
    }.
    
    (*
        fn insert(&mut self, other: Self) {
            *self = Self::from_bits(self.bits() | other.bits());
        }
    *)
    Definition insert (self : mut_ref Self) (other : Self) : M unit :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_insert :
      Notations.DoubleColon Self "insert" := {
      Notations.double_colon := insert;
    }.
  End Impl_axum_response_sse_EventFlags_t_2.
  End Impl_axum_response_sse_EventFlags_t_2.
  
  Module  KeepAlive.
  Section KeepAlive.
    Record t : Set := {
      event : bytes.bytes.Bytes.t;
      max_interval : core.time.Duration.t;
    }.
    
    Definition Get_event :=
      Ref.map (fun α => Some α.(event)) (fun β α => Some (α <| event := β |>)).
    Definition Get_max_interval :=
      Ref.map
        (fun α => Some α.(max_interval))
        (fun β α => Some (α <| max_interval := β |>)).
  End KeepAlive.
  End KeepAlive.
  
  Module  Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.
  Section Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.
    Definition Self : Set := axum.response.sse.KeepAlive.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.
  End Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.
  
  Module  Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.
  Section Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.
    Definition Self : Set := axum.response.sse.KeepAlive.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum.response.sse.KeepAlive.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.
  End Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.
  
  Module  Impl_axum_response_sse_KeepAlive_t_2.
  Section Impl_axum_response_sse_KeepAlive_t_2.
    Definition Self : Set := axum.response.sse.KeepAlive.t.
    
    (*
        pub fn new() -> Self {
            Self {
                event: Bytes::from_static(b":\n\n"),
                max_interval: Duration::from_secs(15),
            }
        }
    *)
    Definition new : M Self := M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
    
    (*
        pub fn interval(mut self, time: Duration) -> Self {
            self.max_interval = time;
            self
        }
    *)
    Definition interval (self : Self) (time : core.time.Duration.t) : M Self :=
      let* self := M.alloc self in
      let* time := M.alloc time in
      M.read foo.
    
    Global Instance AssociatedFunction_interval :
      Notations.DoubleColon Self "interval" := {
      Notations.double_colon := interval;
    }.
    
    (*
        pub fn text<I>(self, text: I) -> Self
        where
            I: AsRef<str>,
        {
            self.event(Event::default().comment(text))
        }
    *)
    Definition text
        {I : Set}
        {ℋ_0 : core.convert.AsRef.Trait I (T := str.t)}
        (self : Self)
        (text : I)
        : M Self :=
      let* self := M.alloc self in
      let* text := M.alloc text in
      M.read foo.
    
    Global Instance AssociatedFunction_text
        {I : Set}
        {ℋ_0 : core.convert.AsRef.Trait I (T := str.t)} :
      Notations.DoubleColon Self "text" := {
      Notations.double_colon := text (I := I);
    }.
    
    (*
        pub fn event(mut self, event: Event) -> Self {
            self.event = event.finalize();
            self
        }
    *)
    Definition event
        (self : Self)
        (event : axum.response.sse.Event.t)
        : M Self :=
      let* self := M.alloc self in
      let* event := M.alloc event in
      M.read foo.
    
    Global Instance AssociatedFunction_event :
      Notations.DoubleColon Self "event" := {
      Notations.double_colon := event;
    }.
  End Impl_axum_response_sse_KeepAlive_t_2.
  End Impl_axum_response_sse_KeepAlive_t_2.
  
  Module  Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.
  Section Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.
    Definition Self : Set := axum.response.sse.KeepAlive.t.
    
    (*
        fn default() -> Self {
            Self::new()
        }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.
  End Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.
  
  Module  KeepAliveStream.
  Section KeepAliveStream.
    Record t : Set := {
      keep_alive : axum.response.sse.KeepAlive.t;
      alive_timer : tokio.time.sleep.Sleep.t;
    }.
    
    Definition Get_keep_alive :=
      Ref.map
        (fun α => Some α.(keep_alive))
        (fun β α => Some (α <| keep_alive := β |>)).
    Definition Get_alive_timer :=
      Ref.map
        (fun α => Some α.(alive_timer))
        (fun β α => Some (α <| alive_timer := β |>)).
  End KeepAliveStream.
  End KeepAliveStream.
  
  Module  Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.
  Section Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.
    Definition Self : Set := axum.response.sse.KeepAliveStream.t.
    
    (*
        Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.
  End Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.
  
  Module  Impl_axum_response_sse_KeepAliveStream_t_2.
  Section Impl_axum_response_sse_KeepAliveStream_t_2.
    Definition Self : Set := axum.response.sse.KeepAliveStream.t.
    
    (*
        fn new(keep_alive: KeepAlive) -> Self {
            Self {
                alive_timer: tokio::time::sleep(keep_alive.max_interval),
                keep_alive,
            }
        }
    *)
    Definition new (keep_alive : axum.response.sse.KeepAlive.t) : M Self :=
      let* keep_alive := M.alloc keep_alive in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
    
    (*
        fn reset(self: Pin<&mut Self>) {
            let this = self.project();
            this.alive_timer
                .reset(tokio::time::Instant::now() + this.keep_alive.max_interval);
        }
    *)
    Definition reset (self : core.pin.Pin.t (mut_ref Self)) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_reset :
      Notations.DoubleColon Self "reset" := {
      Notations.double_colon := reset;
    }.
    
    (*
        fn poll_event(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Bytes> {
            let this = self.as_mut().project();
    
            ready!(this.alive_timer.poll(cx));
    
            let event = this.keep_alive.event.clone();
    
            self.reset();
    
            Poll::Ready(event)
        }
    *)
    Definition poll_event
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t bytes.bytes.Bytes.t) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_event :
      Notations.DoubleColon Self "poll_event" := {
      Notations.double_colon := poll_event;
    }.
  End Impl_axum_response_sse_KeepAliveStream_t_2.
  End Impl_axum_response_sse_KeepAliveStream_t_2.
  
  (*
  fn memchr_split(needle: u8, haystack: &[u8]) -> MemchrSplit<'_> {
      MemchrSplit {
          needle,
          haystack: Some(haystack),
      }
  }
  *)
  Definition memchr_split
      (needle : u8.t)
      (haystack : ref (slice u8.t))
      : M axum.response.sse.MemchrSplit.t :=
    let* needle := M.alloc needle in
    let* haystack := M.alloc haystack in
    M.read foo.
  
  Module  MemchrSplit.
  Section MemchrSplit.
    Record t : Set := {
      needle : u8.t;
      haystack : core.option.Option.t (ref (slice u8.t));
    }.
    
    Definition Get_needle :=
      Ref.map
        (fun α => Some α.(needle))
        (fun β α => Some (α <| needle := β |>)).
    Definition Get_haystack :=
      Ref.map
        (fun α => Some α.(haystack))
        (fun β α => Some (α <| haystack := β |>)).
  End MemchrSplit.
  End MemchrSplit.
  
  Module  Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.
  Section Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.
    Definition Self : Set := axum.response.sse.MemchrSplit.t.
    
    (*
        type Item = &'a [u8];
    *)
    Definition Item : Set := ref (slice u8.t).
    
    (*
        fn next(&mut self) -> Option<Self::Item> {
            let haystack = self.haystack?;
            if let Some(pos) = memchr::memchr(self.needle, haystack) {
                let (front, back) = haystack.split_at(pos);
                self.haystack = Some(&back[1..]);
                Some(front)
            } else {
                self.haystack.take()
            }
        }
    *)
    Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    Global Instance ℐ :
      core.iter.traits.iterator.Iterator.Required.Trait Self := {
      core.iter.traits.iterator.Iterator.Item := Item;
      core.iter.traits.iterator.Iterator.next := next;
      core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
      core.iter.traits.iterator.Iterator.size_hint := Datatypes.None;
      core.iter.traits.iterator.Iterator.count := Datatypes.None;
      core.iter.traits.iterator.Iterator.last := Datatypes.None;
      core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.nth := Datatypes.None;
      core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.chain := Datatypes.None;
      core.iter.traits.iterator.Iterator.zip := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
      core.iter.traits.iterator.Iterator.map := Datatypes.None;
      core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
      core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip := Datatypes.None;
      core.iter.traits.iterator.Iterator.take := Datatypes.None;
      core.iter.traits.iterator.Iterator.scan := Datatypes.None;
      core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
      core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
      core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
      core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.all := Datatypes.None;
      core.iter.traits.iterator.Iterator.any := Datatypes.None;
      core.iter.traits.iterator.Iterator.find := Datatypes.None;
      core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
      core.iter.traits.iterator.Iterator.position := Datatypes.None;
      core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
      core.iter.traits.iterator.Iterator.max := Datatypes.None;
      core.iter.traits.iterator.Iterator.min := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.rev := Datatypes.None;
      core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
      core.iter.traits.iterator.Iterator.copied := Datatypes.None;
      core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
      core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
      core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
      core.iter.traits.iterator.Iterator.sum := Datatypes.None;
      core.iter.traits.iterator.Iterator.product := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.ne := Datatypes.None;
      core.iter.traits.iterator.Iterator.lt := Datatypes.None;
      core.iter.traits.iterator.Iterator.le := Datatypes.None;
      core.iter.traits.iterator.Iterator.gt := Datatypes.None;
      core.iter.traits.iterator.Iterator.ge := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
        Datatypes.None;
    }.
  End Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.
  End Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.
End sse.

Module  Sse.
Section Sse.
  Context (S : Set).
  
  Record t : Set := {
    stream : S;
    keep_alive : core.option.Option.t axum.response.sse.KeepAlive.t;
  }.
  
  Definition Get_stream :=
    Ref.map (fun α => Some α.(stream)) (fun β α => Some (α <| stream := β |>)).
  Definition Get_keep_alive :=
    Ref.map
      (fun α => Some α.(keep_alive))
      (fun β α => Some (α <| keep_alive := β |>)).
End Sse.
End Sse.

Module  Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.
Section Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.response.sse.Sse.t S.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M (axum.response.sse.Sse.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.
End Impl_core_clone_Clone_for_axum_response_sse_Sse_t_S.

Module  Impl_axum_response_sse_Sse_t_S_3.
Section Impl_axum_response_sse_Sse_t_S_3.
  Context {S : Set}.
  
  Definition Self : Set := axum.response.sse.Sse.t S.
  
  (*
      pub fn new(stream: S) -> Self
      where
          S: TryStream<Ok = Event> + Send + 'static,
          S::Error: Into<BoxError>,
      {
          Sse {
              stream,
              keep_alive: None,
          }
      }
  *)
  Definition new
      {ℋ_0 : futures_core.stream.TryStream.Trait S}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 :
        core.convert.Into.Trait S::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      (stream : S)
      : M Self :=
    let* stream := M.alloc stream in
    M.read foo.
  
  Global Instance AssociatedFunction_new
      {ℋ_0 : futures_core.stream.TryStream.Trait S}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 :
        core.convert.Into.Trait S::type["Error"].t
          (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn keep_alive(mut self, keep_alive: KeepAlive) -> Self {
          self.keep_alive = Some(keep_alive);
          self
      }
  *)
  Definition keep_alive
      (self : Self)
      (keep_alive : axum.response.sse.KeepAlive.t)
      : M Self :=
    let* self := M.alloc self in
    let* keep_alive := M.alloc keep_alive in
    M.read foo.
  
  Global Instance AssociatedFunction_keep_alive :
    Notations.DoubleColon Self "keep_alive" := {
    Notations.double_colon := keep_alive;
  }.
End Impl_axum_response_sse_Sse_t_S_3.
End Impl_axum_response_sse_Sse_t_S_3.

Module  Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.
Section Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.response.sse.Sse.t S.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("Sse")
              .field("stream", &format_args!("{}", std::any::type_name::<S>()))
              .field("keep_alive", &self.keep_alive)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.
End Impl_core_fmt_Debug_for_axum_response_sse_Sse_t_S.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.
  Context {S E : Set}.
  
  Context
    {ℋ_0 : futures_core.stream.Stream.Trait S}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}.
  
  Definition Self : Set := axum.response.sse.Sse.t S.
  
  (*
      fn into_response(self) -> Response {
          (
              [
                  (http::header::CONTENT_TYPE, mime::TEXT_EVENT_STREAM.as_ref()),
                  (http::header::CACHE_CONTROL, "no-cache"),
              ],
              Body::new(SseBody {
                  event_stream: SyncWrapper::new(self.stream),
                  keep_alive: self.keep_alive.map(KeepAliveStream::new),
              }),
          )
              .into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_sse_Sse_t_S.

Module  SseBody.
Section SseBody.
  Context (S : Set).
  
  Record t : Set := {
    event_stream : sync_wrapper.SyncWrapper.t S;
    keep_alive : core.option.Option.t axum.response.sse.KeepAliveStream.t;
  }.
  
  Definition Get_event_stream :=
    Ref.map
      (fun α => Some α.(event_stream))
      (fun β α => Some (α <| event_stream := β |>)).
  Definition Get_keep_alive :=
    Ref.map
      (fun α => Some α.(keep_alive))
      (fun β α => Some (α <| keep_alive := β |>)).
End SseBody.
End SseBody.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Context (S : Set).
  
  Record t : Set := {
    event_stream : core.pin.Pin.t (mut_ref (sync_wrapper.SyncWrapper.t S));
    keep_alive :
      core.pin.Pin.t
        (mut_ref (core.option.Option.t axum.response.sse.KeepAliveStream.t));
  }.
  
  Definition Get_event_stream :=
    Ref.map
      (fun α => Some α.(event_stream))
      (fun β α => Some (α <| event_stream := β |>)).
  Definition Get_keep_alive :=
    Ref.map
      (fun α => Some α.(keep_alive))
      (fun β α => Some (α <| keep_alive := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Context (S : Set).
  
  Record t : Set := {
    event_stream : core.pin.Pin.t (ref (sync_wrapper.SyncWrapper.t S));
    keep_alive :
      core.pin.Pin.t
        (ref (core.option.Option.t axum.response.sse.KeepAliveStream.t));
  }.
  
  Definition Get_event_stream :=
    Ref.map
      (fun α => Some α.(event_stream))
      (fun β α => Some (α <| event_stream := β |>)).
  Definition Get_keep_alive :=
    Ref.map
      (fun α => Some α.(keep_alive))
      (fun β α => Some (α <| keep_alive := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_response_sse_SseBody_t_S.
Section Impl_axum_response_sse_SseBody_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.response.sse.SseBody.t S.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum.response.sse._.Projection.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M (axum.response.sse._.ProjectionRef.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_response_sse_SseBody_t_S.
End Impl_axum_response_sse_SseBody_t_S.

Module  __Origin.
Section __Origin.
  Context (S : Set).
  
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    event_stream : sync_wrapper.SyncWrapper.t S;
    keep_alive : core.option.Option.t axum.response.sse.KeepAliveStream.t;
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_event_stream :=
    Ref.map
      (fun α => Some α.(event_stream))
      (fun β α => Some (α <| event_stream := β |>)).
  Definition Get_keep_alive :=
    Ref.map
      (fun α => Some α.(keep_alive))
      (fun β α => Some (α <| keep_alive := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_response_sse_SseBody_t_S.
Section Impl_core_marker_Unpin_for_axum_response_sse_SseBody_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Unpin.Trait (axum.response.sse._.__Origin.t S)}.
  
  Definition Self : Set := axum.response.sse.SseBody.t S.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_response_sse_SseBody_t_S.
End Impl_core_marker_Unpin_for_axum_response_sse_SseBody_t_S.

Module  Impl_axum_response_sse___MustNotImplDrop_for_T.
Section Impl_axum_response_sse___MustNotImplDrop_for_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.ops.drop.Drop.Trait T}.
  
  Definition Self : Set := T.
  
  Global Instance ℐ : axum.response.sse._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_response_sse___MustNotImplDrop_for_T.
End Impl_axum_response_sse___MustNotImplDrop_for_T.

Module  Impl_axum_response_sse___MustNotImplDrop_for_axum_response_sse_SseBody_t_S.
Section Impl_axum_response_sse___MustNotImplDrop_for_axum_response_sse_SseBody_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.response.sse.SseBody.t S.
  
  Global Instance ℐ : axum.response.sse._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_response_sse___MustNotImplDrop_for_axum_response_sse_SseBody_t_S.
End Impl_axum_response_sse___MustNotImplDrop_for_axum_response_sse_SseBody_t_S.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    {S : Set}
    (this : ref (axum.response.sse.SseBody.t S))
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module  Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.
Section Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.
  Context {S E : Set}.
  
  Context {ℋ_0 : futures_core.stream.Stream.Trait S}.
  
  Definition Self : Set := axum.response.sse.SseBody.t S.
  
  (*
      type Data = Bytes;
  *)
  Definition Data : Set := bytes.bytes.Bytes.t.
  
  (*
      type Error = E;
  *)
  Definition Error : Set := E.
  
  (*
      fn poll_frame(
          self: Pin<&mut Self>,
          cx: &mut Context<'_>,
      ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
          let this = self.project();
  
          match this.event_stream.get_pin_mut().poll_next(cx) {
              Poll::Pending => {
                  if let Some(keep_alive) = this.keep_alive.as_pin_mut() {
                      keep_alive.poll_event(cx).map(|e| Some(Ok(Frame::data(e))))
                  } else {
                      Poll::Pending
                  }
              }
              Poll::Ready(Some(Ok(event))) => {
                  if let Some(keep_alive) = this.keep_alive.as_pin_mut() {
                      keep_alive.reset();
                  }
                  Poll::Ready(Some(Ok(Frame::data(event.finalize()))))
              }
              Poll::Ready(Some(Err(error))) => Poll::Ready(Some(Err(error))),
              Poll::Ready(None) => Poll::Ready(None),
          }
      }
  *)
  Definition poll_frame
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      :
        M
          (core.task.poll.Poll.t
            (core.option.Option.t
              (core.result.Result.t (http_body.frame.Frame.t Data) Error))) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_frame :
    Notations.DoubleColon Self "poll_frame" := {
    Notations.double_colon := poll_frame;
  }.
  
  Global Instance ℐ : http_body.Body.Required.Trait Self := {
    http_body.Body.Data := Data;
    http_body.Body.Error := Error;
    http_body.Body.poll_frame := poll_frame;
    http_body.Body.is_end_stream := Datatypes.None;
    http_body.Body.size_hint := Datatypes.None;
  }.
End Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.
End Impl_http_body_Body_for_axum_response_sse_SseBody_t_S.

Module  Event.
Section Event.
  Record t : Set := {
    buffer : bytes.bytes_mut.BytesMut.t;
    flags : axum.response.sse.EventFlags.t;
  }.
  
  Definition Get_buffer :=
    Ref.map (fun α => Some α.(buffer)) (fun β α => Some (α <| buffer := β |>)).
  Definition Get_flags :=
    Ref.map (fun α => Some α.(flags)) (fun β α => Some (α <| flags := β |>)).
End Event.
End Event.

Module  Impl_core_fmt_Debug_for_axum_response_sse_Event_t.
Section Impl_core_fmt_Debug_for_axum_response_sse_Event_t.
  Definition Self : Set := axum.response.sse.Event.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_response_sse_Event_t.
End Impl_core_fmt_Debug_for_axum_response_sse_Event_t.

Module  Impl_core_default_Default_for_axum_response_sse_Event_t.
Section Impl_core_default_Default_for_axum_response_sse_Event_t.
  Definition Self : Set := axum.response.sse.Event.t.
  
  (*
  Default
  *)
  Definition default : M axum.response.sse.Event.t := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_response_sse_Event_t.
End Impl_core_default_Default_for_axum_response_sse_Event_t.

Module  Impl_core_clone_Clone_for_axum_response_sse_Event_t.
Section Impl_core_clone_Clone_for_axum_response_sse_Event_t.
  Definition Self : Set := axum.response.sse.Event.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.response.sse.Event.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_response_sse_Event_t.
End Impl_core_clone_Clone_for_axum_response_sse_Event_t.

Module  Impl_axum_response_sse_Event_t_3.
Section Impl_axum_response_sse_Event_t_3.
  Definition Self : Set := axum.response.sse.Event.t.
  
  (*
      pub fn data<T>(mut self, data: T) -> Event
      where
          T: AsRef<str>,
      {
          if self.flags.contains(EventFlags::HAS_DATA) {
              panic!("Called `EventBuilder::data` multiple times");
          }
  
          for line in memchr_split(b'\n', data.as_ref().as_bytes()) {
              self.field("data", line);
          }
  
          self.flags.insert(EventFlags::HAS_DATA);
  
          self
      }
  *)
  Definition data
      {T : Set}
      {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
      (self : Self)
      (data : T)
      : M axum.response.sse.Event.t :=
    let* self := M.alloc self in
    let* data := M.alloc data in
    M.read foo.
  
  Global Instance AssociatedFunction_data
      {T : Set}
      {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
    Notations.DoubleColon Self "data" := {
    Notations.double_colon := data (T := T);
  }.
  
  (*
      pub fn json_data<T>(mut self, data: T) -> Result<Event, axum_core::Error>
      where
          T: serde::Serialize,
      {
          if self.flags.contains(EventFlags::HAS_DATA) {
              panic!("Called `EventBuilder::json_data` multiple times");
          }
  
          self.buffer.extend_from_slice(b"data: ");
          serde_json::to_writer((&mut self.buffer).writer(), &data).map_err(axum_core::Error::new)?;
          self.buffer.put_u8(b'\n');
  
          self.flags.insert(EventFlags::HAS_DATA);
  
          Ok(self)
      }
  *)
  Definition json_data
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T}
      (self : Self)
      (data : T)
      :
        M
          (core.result.Result.t
            axum.response.sse.Event.t
            axum_core.error.Error.t) :=
    let* self := M.alloc self in
    let* data := M.alloc data in
    M.read foo.
  
  Global Instance AssociatedFunction_json_data
      {T : Set}
      {ℋ_0 : serde.ser.Serialize.Trait T} :
    Notations.DoubleColon Self "json_data" := {
    Notations.double_colon := json_data (T := T);
  }.
  
  (*
      pub fn comment<T>(mut self, comment: T) -> Event
      where
          T: AsRef<str>,
      {
          self.field("", comment.as_ref());
          self
      }
  *)
  Definition comment
      {T : Set}
      {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
      (self : Self)
      (comment : T)
      : M axum.response.sse.Event.t :=
    let* self := M.alloc self in
    let* comment := M.alloc comment in
    M.read foo.
  
  Global Instance AssociatedFunction_comment
      {T : Set}
      {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
    Notations.DoubleColon Self "comment" := {
    Notations.double_colon := comment (T := T);
  }.
  
  (*
      pub fn event<T>(mut self, event: T) -> Event
      where
          T: AsRef<str>,
      {
          if self.flags.contains(EventFlags::HAS_EVENT) {
              panic!("Called `EventBuilder::event` multiple times");
          }
          self.flags.insert(EventFlags::HAS_EVENT);
  
          self.field("event", event.as_ref());
  
          self
      }
  *)
  Definition event
      {T : Set}
      {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
      (self : Self)
      (event : T)
      : M axum.response.sse.Event.t :=
    let* self := M.alloc self in
    let* event := M.alloc event in
    M.read foo.
  
  Global Instance AssociatedFunction_event
      {T : Set}
      {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
    Notations.DoubleColon Self "event" := {
    Notations.double_colon := event (T := T);
  }.
  
  (*
      pub fn retry(mut self, duration: Duration) -> Event {
          if self.flags.contains(EventFlags::HAS_RETRY) {
              panic!("Called `EventBuilder::retry` multiple times");
          }
          self.flags.insert(EventFlags::HAS_RETRY);
  
          self.buffer.extend_from_slice(b"retry:");
  
          let secs = duration.as_secs();
          let millis = duration.subsec_millis();
  
          if secs > 0 {
              // format seconds
              self.buffer
                  .extend_from_slice(itoa::Buffer::new().format(secs).as_bytes());
  
              // pad milliseconds
              if millis < 10 {
                  self.buffer.extend_from_slice(b"00");
              } else if millis < 100 {
                  self.buffer.extend_from_slice(b"0");
              }
          }
  
          // format milliseconds
          self.buffer
              .extend_from_slice(itoa::Buffer::new().format(millis).as_bytes());
  
          self.buffer.put_u8(b'\n');
  
          self
      }
  *)
  Definition retry
      (self : Self)
      (duration : core.time.Duration.t)
      : M axum.response.sse.Event.t :=
    let* self := M.alloc self in
    let* duration := M.alloc duration in
    M.read foo.
  
  Global Instance AssociatedFunction_retry :
    Notations.DoubleColon Self "retry" := {
    Notations.double_colon := retry;
  }.
  
  (*
      pub fn id<T>(mut self, id: T) -> Event
      where
          T: AsRef<str>,
      {
          if self.flags.contains(EventFlags::HAS_ID) {
              panic!("Called `EventBuilder::id` multiple times");
          }
          self.flags.insert(EventFlags::HAS_ID);
  
          let id = id.as_ref().as_bytes();
          assert_eq!(
              memchr::memchr(b'\0', id),
              None,
              "Event ID cannot contain null characters",
          );
  
          self.field("id", id);
          self
      }
  *)
  Definition id
      {T : Set}
      {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)}
      (self : Self)
      (id : T)
      : M axum.response.sse.Event.t :=
    let* self := M.alloc self in
    let* id := M.alloc id in
    M.read foo.
  
  Global Instance AssociatedFunction_id
      {T : Set}
      {ℋ_0 : core.convert.AsRef.Trait T (T := str.t)} :
    Notations.DoubleColon Self "id" := {
    Notations.double_colon := id (T := T);
  }.
  
  (*
      fn field(&mut self, name: &str, value: impl AsRef<[u8]>) {
          let value = value.as_ref();
          assert_eq!(
              memchr::memchr2(b'\r', b'\n', value),
              None,
              "SSE field value cannot contain newlines or carriage returns",
          );
          self.buffer.extend_from_slice(name.as_bytes());
          self.buffer.put_u8(b':');
          self.buffer.put_u8(b' ');
          self.buffer.extend_from_slice(value);
          self.buffer.put_u8(b'\n');
      }
  *)
  Definition field
      {impl AsRef<[u8]> : Set}
      {ℋ_0 : core.convert.AsRef.Trait impl AsRef<[u8]> (T := slice u8.t)}
      (self : mut_ref Self)
      (name : ref str.t)
      (value : impl AsRef<[u8]>)
      : M unit :=
    let* self := M.alloc self in
    let* name := M.alloc name in
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_field
      {impl AsRef<[u8]> : Set}
      {ℋ_0 : core.convert.AsRef.Trait impl AsRef<[u8]> (T := slice u8.t)} :
    Notations.DoubleColon Self "field" := {
    Notations.double_colon := field (impl AsRef<[u8]> := impl AsRef<[u8]>);
  }.
  
  (*
      fn finalize(mut self) -> Bytes {
          self.buffer.put_u8(b'\n');
          self.buffer.freeze()
      }
  *)
  Definition finalize (self : Self) : M bytes.bytes.Bytes.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_finalize :
    Notations.DoubleColon Self "finalize" := {
    Notations.double_colon := finalize;
  }.
End Impl_axum_response_sse_Event_t_3.
End Impl_axum_response_sse_Event_t_3.

Module  EventFlags.
Section EventFlags.
  Record t : Set := {
    x0 : u8.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End EventFlags.
End EventFlags.

Module  Impl_core_default_Default_for_axum_response_sse_EventFlags_t.
Section Impl_core_default_Default_for_axum_response_sse_EventFlags_t.
  Definition Self : Set := axum.response.sse.EventFlags.t.
  
  (*
  Default
  *)
  Definition default : M axum.response.sse.EventFlags.t := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_response_sse_EventFlags_t.
End Impl_core_default_Default_for_axum_response_sse_EventFlags_t.

Module  Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.
Section Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.
  Definition Self : Set := axum.response.sse.EventFlags.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.
End Impl_core_fmt_Debug_for_axum_response_sse_EventFlags_t.

Module  Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.
Section Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.
  Definition Self : Set := axum.response.sse.EventFlags.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.
End Impl_core_marker_Copy_for_axum_response_sse_EventFlags_t.

Module  Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.
Section Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.
  Definition Self : Set := axum.response.sse.EventFlags.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.response.sse.EventFlags.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.
End Impl_core_clone_Clone_for_axum_response_sse_EventFlags_t.

Module  Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.
Section Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.
  Definition Self : Set := axum.response.sse.EventFlags.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.
End Impl_core_marker_StructuralPartialEq_for_axum_response_sse_EventFlags_t.

Module  Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.
Section Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.
  Definition Self : Set := axum.response.sse.EventFlags.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref axum.response.sse.EventFlags.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.
End Impl_core_cmp_PartialEq_for_axum_response_sse_EventFlags_t.

Module  Impl_axum_response_sse_EventFlags_t_3.
Section Impl_axum_response_sse_EventFlags_t_3.
  Definition Self : Set := axum.response.sse.EventFlags.t.
  
  (*
      const HAS_DATA: Self = Self::from_bits(0b0001);
  *)
  
  Definition HAS_DATA : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_HAS_DATA :
    Notations.DoubleColon Self "HAS_DATA" := {
    Notations.double_colon := HAS_DATA;
  }.
  
  (*
      const HAS_EVENT: Self = Self::from_bits(0b0010);
  *)
  
  Definition HAS_EVENT : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_HAS_EVENT :
    Notations.DoubleColon Self "HAS_EVENT" := {
    Notations.double_colon := HAS_EVENT;
  }.
  
  (*
      const HAS_RETRY: Self = Self::from_bits(0b0100);
  *)
  
  Definition HAS_RETRY : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_HAS_RETRY :
    Notations.DoubleColon Self "HAS_RETRY" := {
    Notations.double_colon := HAS_RETRY;
  }.
  
  (*
      const HAS_ID: Self = Self::from_bits(0b1000);
  *)
  
  Definition HAS_ID : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_HAS_ID :
    Notations.DoubleColon Self "HAS_ID" := {
    Notations.double_colon := HAS_ID;
  }.
  
  (*
      const fn bits(&self) -> u8 {
          self.0
      }
  *)
  Definition bits (self : ref Self) : M u8.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_bits :
    Notations.DoubleColon Self "bits" := {
    Notations.double_colon := bits;
  }.
  
  (*
      const fn from_bits(bits: u8) -> Self {
          Self(bits)
      }
  *)
  Definition from_bits (bits : u8.t) : M Self :=
    let* bits := M.alloc bits in
    M.read foo.
  
  Global Instance AssociatedFunction_from_bits :
    Notations.DoubleColon Self "from_bits" := {
    Notations.double_colon := from_bits;
  }.
  
  (*
      const fn contains(&self, other: Self) -> bool {
          self.bits() & other.bits() == other.bits()
      }
  *)
  Definition contains (self : ref Self) (other : Self) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn insert(&mut self, other: Self) {
          *self = Self::from_bits(self.bits() | other.bits());
      }
  *)
  Definition insert (self : mut_ref Self) (other : Self) : M unit :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
End Impl_axum_response_sse_EventFlags_t_3.
End Impl_axum_response_sse_EventFlags_t_3.

Module  KeepAlive.
Section KeepAlive.
  Record t : Set := {
    event : bytes.bytes.Bytes.t;
    max_interval : core.time.Duration.t;
  }.
  
  Definition Get_event :=
    Ref.map (fun α => Some α.(event)) (fun β α => Some (α <| event := β |>)).
  Definition Get_max_interval :=
    Ref.map
      (fun α => Some α.(max_interval))
      (fun β α => Some (α <| max_interval := β |>)).
End KeepAlive.
End KeepAlive.

Module  Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.
Section Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.
  Definition Self : Set := axum.response.sse.KeepAlive.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.
End Impl_core_fmt_Debug_for_axum_response_sse_KeepAlive_t.

Module  Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.
Section Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.
  Definition Self : Set := axum.response.sse.KeepAlive.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.response.sse.KeepAlive.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.
End Impl_core_clone_Clone_for_axum_response_sse_KeepAlive_t.

Module  Impl_axum_response_sse_KeepAlive_t_3.
Section Impl_axum_response_sse_KeepAlive_t_3.
  Definition Self : Set := axum.response.sse.KeepAlive.t.
  
  (*
      pub fn new() -> Self {
          Self {
              event: Bytes::from_static(b":\n\n"),
              max_interval: Duration::from_secs(15),
          }
      }
  *)
  Definition new : M Self := M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn interval(mut self, time: Duration) -> Self {
          self.max_interval = time;
          self
      }
  *)
  Definition interval (self : Self) (time : core.time.Duration.t) : M Self :=
    let* self := M.alloc self in
    let* time := M.alloc time in
    M.read foo.
  
  Global Instance AssociatedFunction_interval :
    Notations.DoubleColon Self "interval" := {
    Notations.double_colon := interval;
  }.
  
  (*
      pub fn text<I>(self, text: I) -> Self
      where
          I: AsRef<str>,
      {
          self.event(Event::default().comment(text))
      }
  *)
  Definition text
      {I : Set}
      {ℋ_0 : core.convert.AsRef.Trait I (T := str.t)}
      (self : Self)
      (text : I)
      : M Self :=
    let* self := M.alloc self in
    let* text := M.alloc text in
    M.read foo.
  
  Global Instance AssociatedFunction_text
      {I : Set}
      {ℋ_0 : core.convert.AsRef.Trait I (T := str.t)} :
    Notations.DoubleColon Self "text" := {
    Notations.double_colon := text (I := I);
  }.
  
  (*
      pub fn event(mut self, event: Event) -> Self {
          self.event = event.finalize();
          self
      }
  *)
  Definition event (self : Self) (event : axum.response.sse.Event.t) : M Self :=
    let* self := M.alloc self in
    let* event := M.alloc event in
    M.read foo.
  
  Global Instance AssociatedFunction_event :
    Notations.DoubleColon Self "event" := {
    Notations.double_colon := event;
  }.
End Impl_axum_response_sse_KeepAlive_t_3.
End Impl_axum_response_sse_KeepAlive_t_3.

Module  Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.
Section Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.
  Definition Self : Set := axum.response.sse.KeepAlive.t.
  
  (*
      fn default() -> Self {
          Self::new()
      }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.
End Impl_core_default_Default_for_axum_response_sse_KeepAlive_t.

Module  KeepAliveStream.
Section KeepAliveStream.
  Record t : Set := {
    keep_alive : axum.response.sse.KeepAlive.t;
    alive_timer : tokio.time.sleep.Sleep.t;
  }.
  
  Definition Get_keep_alive :=
    Ref.map
      (fun α => Some α.(keep_alive))
      (fun β α => Some (α <| keep_alive := β |>)).
  Definition Get_alive_timer :=
    Ref.map
      (fun α => Some α.(alive_timer))
      (fun β α => Some (α <| alive_timer := β |>)).
End KeepAliveStream.
End KeepAliveStream.

Module  Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.
Section Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.
  Definition Self : Set := axum.response.sse.KeepAliveStream.t.
  
  (*
      Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.
End Impl_core_fmt_Debug_for_axum_response_sse_KeepAliveStream_t.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Record t : Set := {
    keep_alive : mut_ref axum.response.sse.KeepAlive.t;
    alive_timer : core.pin.Pin.t (mut_ref tokio.time.sleep.Sleep.t);
  }.
  
  Definition Get_keep_alive :=
    Ref.map
      (fun α => Some α.(keep_alive))
      (fun β α => Some (α <| keep_alive := β |>)).
  Definition Get_alive_timer :=
    Ref.map
      (fun α => Some α.(alive_timer))
      (fun β α => Some (α <| alive_timer := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Record t : Set := {
    keep_alive : ref axum.response.sse.KeepAlive.t;
    alive_timer : core.pin.Pin.t (ref tokio.time.sleep.Sleep.t);
  }.
  
  Definition Get_keep_alive :=
    Ref.map
      (fun α => Some α.(keep_alive))
      (fun β α => Some (α <| keep_alive := β |>)).
  Definition Get_alive_timer :=
    Ref.map
      (fun α => Some α.(alive_timer))
      (fun β α => Some (α <| alive_timer := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_response_sse_KeepAliveStream_t_3.
Section Impl_axum_response_sse_KeepAliveStream_t_3.
  Definition Self : Set := axum.response.sse.KeepAliveStream.t.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M axum.response.sse._.Projection.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M axum.response.sse._.ProjectionRef.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_response_sse_KeepAliveStream_t_3.
End Impl_axum_response_sse_KeepAliveStream_t_3.

Module  __Origin.
Section __Origin.
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    keep_alive :
      pin_project_lite.__private.AlwaysUnpin.t axum.response.sse.KeepAlive.t;
    alive_timer : tokio.time.sleep.Sleep.t;
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_keep_alive :=
    Ref.map
      (fun α => Some α.(keep_alive))
      (fun β α => Some (α <| keep_alive := β |>)).
  Definition Get_alive_timer :=
    Ref.map
      (fun α => Some α.(alive_timer))
      (fun β α => Some (α <| alive_timer := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_response_sse_KeepAliveStream_t.
Section Impl_core_marker_Unpin_for_axum_response_sse_KeepAliveStream_t.
  Context {ℋ_0 : core.marker.Unpin.Trait axum.response.sse._.__Origin.t}.
  
  Definition Self : Set := axum.response.sse.KeepAliveStream.t.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_response_sse_KeepAliveStream_t.
End Impl_core_marker_Unpin_for_axum_response_sse_KeepAliveStream_t.

Module  Impl_axum_response_sse___MustNotImplDrop_for_axum_response_sse_KeepAliveStream_t.
Section Impl_axum_response_sse___MustNotImplDrop_for_axum_response_sse_KeepAliveStream_t.
  Definition Self : Set := axum.response.sse.KeepAliveStream.t.
  
  Global Instance ℐ : axum.response.sse._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_response_sse___MustNotImplDrop_for_axum_response_sse_KeepAliveStream_t.
End Impl_axum_response_sse___MustNotImplDrop_for_axum_response_sse_KeepAliveStream_t.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    (this : ref axum.response.sse.KeepAliveStream.t)
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module  Impl_axum_response_sse_KeepAliveStream_t_4.
Section Impl_axum_response_sse_KeepAliveStream_t_4.
  Definition Self : Set := axum.response.sse.KeepAliveStream.t.
  
  (*
      fn new(keep_alive: KeepAlive) -> Self {
          Self {
              alive_timer: tokio::time::sleep(keep_alive.max_interval),
              keep_alive,
          }
      }
  *)
  Definition new (keep_alive : axum.response.sse.KeepAlive.t) : M Self :=
    let* keep_alive := M.alloc keep_alive in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      fn reset(self: Pin<&mut Self>) {
          let this = self.project();
          this.alive_timer
              .reset(tokio::time::Instant::now() + this.keep_alive.max_interval);
      }
  *)
  Definition reset (self : core.pin.Pin.t (mut_ref Self)) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_reset :
    Notations.DoubleColon Self "reset" := {
    Notations.double_colon := reset;
  }.
  
  (*
      fn poll_event(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Bytes> {
          let this = self.as_mut().project();
  
          ready!(this.alive_timer.poll(cx));
  
          let event = this.keep_alive.event.clone();
  
          self.reset();
  
          Poll::Ready(event)
      }
  *)
  Definition poll_event
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t bytes.bytes.Bytes.t) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_event :
    Notations.DoubleColon Self "poll_event" := {
    Notations.double_colon := poll_event;
  }.
End Impl_axum_response_sse_KeepAliveStream_t_4.
End Impl_axum_response_sse_KeepAliveStream_t_4.

(*
fn memchr_split(needle: u8, haystack: &[u8]) -> MemchrSplit<'_> {
    MemchrSplit {
        needle,
        haystack: Some(haystack),
    }
}
*)
Definition memchr_split
    (needle : u8.t)
    (haystack : ref (slice u8.t))
    : M axum.response.sse.MemchrSplit.t :=
  let* needle := M.alloc needle in
  let* haystack := M.alloc haystack in
  M.read foo.

Module  MemchrSplit.
Section MemchrSplit.
  Record t : Set := {
    needle : u8.t;
    haystack : core.option.Option.t (ref (slice u8.t));
  }.
  
  Definition Get_needle :=
    Ref.map (fun α => Some α.(needle)) (fun β α => Some (α <| needle := β |>)).
  Definition Get_haystack :=
    Ref.map
      (fun α => Some α.(haystack))
      (fun β α => Some (α <| haystack := β |>)).
End MemchrSplit.
End MemchrSplit.

Module  Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.
Section Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.
  Definition Self : Set := axum.response.sse.MemchrSplit.t.
  
  (*
      type Item = &'a [u8];
  *)
  Definition Item : Set := ref (slice u8.t).
  
  (*
      fn next(&mut self) -> Option<Self::Item> {
          let haystack = self.haystack?;
          if let Some(pos) = memchr::memchr(self.needle, haystack) {
              let (front, back) = haystack.split_at(pos);
              self.haystack = Some(&back[1..]);
              Some(front)
          } else {
              self.haystack.take()
          }
      }
  *)
  Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  Global Instance ℐ :
    core.iter.traits.iterator.Iterator.Required.Trait Self := {
    core.iter.traits.iterator.Iterator.Item := Item;
    core.iter.traits.iterator.Iterator.next := next;
    core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
    core.iter.traits.iterator.Iterator.size_hint := Datatypes.None;
    core.iter.traits.iterator.Iterator.count := Datatypes.None;
    core.iter.traits.iterator.Iterator.last := Datatypes.None;
    core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.nth := Datatypes.None;
    core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.chain := Datatypes.None;
    core.iter.traits.iterator.Iterator.zip := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
    core.iter.traits.iterator.Iterator.map := Datatypes.None;
    core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
    core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip := Datatypes.None;
    core.iter.traits.iterator.Iterator.take := Datatypes.None;
    core.iter.traits.iterator.Iterator.scan := Datatypes.None;
    core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
    core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
    core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
    core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.all := Datatypes.None;
    core.iter.traits.iterator.Iterator.any := Datatypes.None;
    core.iter.traits.iterator.Iterator.find := Datatypes.None;
    core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
    core.iter.traits.iterator.Iterator.position := Datatypes.None;
    core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
    core.iter.traits.iterator.Iterator.max := Datatypes.None;
    core.iter.traits.iterator.Iterator.min := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.rev := Datatypes.None;
    core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
    core.iter.traits.iterator.Iterator.copied := Datatypes.None;
    core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
    core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
    core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
    core.iter.traits.iterator.Iterator.sum := Datatypes.None;
    core.iter.traits.iterator.Iterator.product := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.ne := Datatypes.None;
    core.iter.traits.iterator.Iterator.lt := Datatypes.None;
    core.iter.traits.iterator.Iterator.le := Datatypes.None;
    core.iter.traits.iterator.Iterator.gt := Datatypes.None;
    core.iter.traits.iterator.Iterator.ge := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
      Datatypes.None;
  }.
End Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.
End Impl_core_iter_traits_iterator_Iterator_for_axum_response_sse_MemchrSplit_t.

Module  Html.
Section Html.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Html.
End Html.

Module  Impl_core_clone_Clone_for_axum_response_Html_t_T.
Section Impl_core_clone_Clone_for_axum_response_Html_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum.response.Html.t T.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M (axum.response.Html.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_response_Html_t_T.
End Impl_core_clone_Clone_for_axum_response_Html_t_T.

Module  Impl_core_marker_Copy_for_axum_response_Html_t_T.
Section Impl_core_marker_Copy_for_axum_response_Html_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum.response.Html.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_response_Html_t_T.
End Impl_core_marker_Copy_for_axum_response_Html_t_T.

Module  Impl_core_fmt_Debug_for_axum_response_Html_t_T.
Section Impl_core_fmt_Debug_for_axum_response_Html_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum.response.Html.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_response_Html_t_T.
End Impl_core_fmt_Debug_for_axum_response_Html_t_T.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_response_Html_t_T.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_response_Html_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.convert.Into.Trait T (T := axum_core.body.Body.t)}.
  
  Definition Self : Set := axum.response.Html.t T.
  
  (*
      fn into_response(self) -> Response {
          (
              [(
                  header::CONTENT_TYPE,
                  HeaderValue::from_static(mime::TEXT_HTML_UTF_8.as_ref()),
              )],
              self.0.into(),
          )
              .into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_Html_t_T.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_response_Html_t_T.

Module  Impl_core_convert_From_T_for_axum_response_Html_t_T.
Section Impl_core_convert_From_T_for_axum_response_Html_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum.response.Html.t T.
  
  (*
      fn from(inner: T) -> Self {
          Self(inner)
      }
  *)
  Definition from (inner : T) : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_T_for_axum_response_Html_t_T.
End Impl_core_convert_From_T_for_axum_response_Html_t_T.

Module routing.
  Module method_routing.
    (*
            pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
            where
                T: Service<Request> + Clone + Send + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
                S: Clone,
            {
                on_service(MethodFilter::$method, svc)
            }
    *)
    Definition delete_service
        {T S : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        {ℋ_5 : core.clone.Clone.Trait S}
        (svc : T)
        : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
      let* svc := M.alloc svc in
      M.read foo.
    
    (*
            pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
            where
                T: Service<Request> + Clone + Send + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
                S: Clone,
            {
                on_service(MethodFilter::$method, svc)
            }
    *)
    Definition get_service
        {T S : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        {ℋ_5 : core.clone.Clone.Trait S}
        (svc : T)
        : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
      let* svc := M.alloc svc in
      M.read foo.
    
    (*
            pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
            where
                T: Service<Request> + Clone + Send + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
                S: Clone,
            {
                on_service(MethodFilter::$method, svc)
            }
    *)
    Definition head_service
        {T S : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        {ℋ_5 : core.clone.Clone.Trait S}
        (svc : T)
        : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
      let* svc := M.alloc svc in
      M.read foo.
    
    (*
            pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
            where
                T: Service<Request> + Clone + Send + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
                S: Clone,
            {
                on_service(MethodFilter::$method, svc)
            }
    *)
    Definition options_service
        {T S : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        {ℋ_5 : core.clone.Clone.Trait S}
        (svc : T)
        : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
      let* svc := M.alloc svc in
      M.read foo.
    
    (*
            pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
            where
                T: Service<Request> + Clone + Send + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
                S: Clone,
            {
                on_service(MethodFilter::$method, svc)
            }
    *)
    Definition patch_service
        {T S : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        {ℋ_5 : core.clone.Clone.Trait S}
        (svc : T)
        : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
      let* svc := M.alloc svc in
      M.read foo.
    
    (*
            pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
            where
                T: Service<Request> + Clone + Send + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
                S: Clone,
            {
                on_service(MethodFilter::$method, svc)
            }
    *)
    Definition post_service
        {T S : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        {ℋ_5 : core.clone.Clone.Trait S}
        (svc : T)
        : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
      let* svc := M.alloc svc in
      M.read foo.
    
    (*
            pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
            where
                T: Service<Request> + Clone + Send + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
                S: Clone,
            {
                on_service(MethodFilter::$method, svc)
            }
    *)
    Definition put_service
        {T S : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        {ℋ_5 : core.clone.Clone.Trait S}
        (svc : T)
        : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
      let* svc := M.alloc svc in
      M.read foo.
    
    (*
            pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
            where
                T: Service<Request> + Clone + Send + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
                S: Clone,
            {
                on_service(MethodFilter::$method, svc)
            }
    *)
    Definition trace_service
        {T S : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        {ℋ_5 : core.clone.Clone.Trait S}
        (svc : T)
        : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
      let* svc := M.alloc svc in
      M.read foo.
    
    (*
    pub fn on_service<T, S>(filter: MethodFilter, svc: T) -> MethodRouter<S, T::Error>
    where
        T: Service<Request> + Clone + Send + 'static,
        T::Response: IntoResponse + 'static,
        T::Future: Send + 'static,
        S: Clone,
    {
        MethodRouter::new().on_service(filter, svc)
    }
    *)
    Definition on_service
        {T S : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        {ℋ_5 : core.clone.Clone.Trait S}
        (filter : axum.routing.method_filter.MethodFilter.t)
        (svc : T)
        : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
      let* filter := M.alloc filter in
      let* svc := M.alloc svc in
      M.read foo.
    
    (*
    pub fn any_service<T, S>(svc: T) -> MethodRouter<S, T::Error>
    where
        T: Service<Request> + Clone + Send + 'static,
        T::Response: IntoResponse + 'static,
        T::Future: Send + 'static,
        S: Clone,
    {
        MethodRouter::new()
            .fallback_service(svc)
            .skip_allow_header()
    }
    *)
    Definition any_service
        {T S : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        {ℋ_5 : core.clone.Clone.Trait S}
        (svc : T)
        : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
      let* svc := M.alloc svc in
      M.read foo.
    
    (*
            pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
            where
                H: Handler<T, S>,
                T: 'static,
                S: Clone + Send + Sync + 'static,
            {
                on(MethodFilter::$method, handler)
            }
    *)
    Definition delete
        {H T S : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.clone.Clone.Trait S}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}
        (handler : H)
        :
          M
            (axum.routing.method_routing.MethodRouter.t
              S
              core.convert.Infallible.t) :=
      let* handler := M.alloc handler in
      M.read foo.
    
    (*
            pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
            where
                H: Handler<T, S>,
                T: 'static,
                S: Clone + Send + Sync + 'static,
            {
                on(MethodFilter::$method, handler)
            }
    *)
    Definition get
        {H T S : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.clone.Clone.Trait S}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}
        (handler : H)
        :
          M
            (axum.routing.method_routing.MethodRouter.t
              S
              core.convert.Infallible.t) :=
      let* handler := M.alloc handler in
      M.read foo.
    
    (*
            pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
            where
                H: Handler<T, S>,
                T: 'static,
                S: Clone + Send + Sync + 'static,
            {
                on(MethodFilter::$method, handler)
            }
    *)
    Definition head
        {H T S : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.clone.Clone.Trait S}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}
        (handler : H)
        :
          M
            (axum.routing.method_routing.MethodRouter.t
              S
              core.convert.Infallible.t) :=
      let* handler := M.alloc handler in
      M.read foo.
    
    (*
            pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
            where
                H: Handler<T, S>,
                T: 'static,
                S: Clone + Send + Sync + 'static,
            {
                on(MethodFilter::$method, handler)
            }
    *)
    Definition options
        {H T S : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.clone.Clone.Trait S}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}
        (handler : H)
        :
          M
            (axum.routing.method_routing.MethodRouter.t
              S
              core.convert.Infallible.t) :=
      let* handler := M.alloc handler in
      M.read foo.
    
    (*
            pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
            where
                H: Handler<T, S>,
                T: 'static,
                S: Clone + Send + Sync + 'static,
            {
                on(MethodFilter::$method, handler)
            }
    *)
    Definition patch
        {H T S : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.clone.Clone.Trait S}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}
        (handler : H)
        :
          M
            (axum.routing.method_routing.MethodRouter.t
              S
              core.convert.Infallible.t) :=
      let* handler := M.alloc handler in
      M.read foo.
    
    (*
            pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
            where
                H: Handler<T, S>,
                T: 'static,
                S: Clone + Send + Sync + 'static,
            {
                on(MethodFilter::$method, handler)
            }
    *)
    Definition post
        {H T S : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.clone.Clone.Trait S}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}
        (handler : H)
        :
          M
            (axum.routing.method_routing.MethodRouter.t
              S
              core.convert.Infallible.t) :=
      let* handler := M.alloc handler in
      M.read foo.
    
    (*
            pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
            where
                H: Handler<T, S>,
                T: 'static,
                S: Clone + Send + Sync + 'static,
            {
                on(MethodFilter::$method, handler)
            }
    *)
    Definition put
        {H T S : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.clone.Clone.Trait S}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}
        (handler : H)
        :
          M
            (axum.routing.method_routing.MethodRouter.t
              S
              core.convert.Infallible.t) :=
      let* handler := M.alloc handler in
      M.read foo.
    
    (*
            pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
            where
                H: Handler<T, S>,
                T: 'static,
                S: Clone + Send + Sync + 'static,
            {
                on(MethodFilter::$method, handler)
            }
    *)
    Definition trace
        {H T S : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.clone.Clone.Trait S}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}
        (handler : H)
        :
          M
            (axum.routing.method_routing.MethodRouter.t
              S
              core.convert.Infallible.t) :=
      let* handler := M.alloc handler in
      M.read foo.
    
    (*
    pub fn on<H, T, S>(filter: MethodFilter, handler: H) -> MethodRouter<S, Infallible>
    where
        H: Handler<T, S>,
        T: 'static,
        S: Clone + Send + Sync + 'static,
    {
        MethodRouter::new().on(filter, handler)
    }
    *)
    Definition on
        {H T S : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.clone.Clone.Trait S}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}
        (filter : axum.routing.method_filter.MethodFilter.t)
        (handler : H)
        :
          M
            (axum.routing.method_routing.MethodRouter.t
              S
              core.convert.Infallible.t) :=
      let* filter := M.alloc filter in
      let* handler := M.alloc handler in
      M.read foo.
    
    (*
    pub fn any<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
    where
        H: Handler<T, S>,
        T: 'static,
        S: Clone + Send + Sync + 'static,
    {
        MethodRouter::new().fallback(handler).skip_allow_header()
    }
    *)
    Definition any
        {H T S : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.clone.Clone.Trait S}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}
        (handler : H)
        :
          M
            (axum.routing.method_routing.MethodRouter.t
              S
              core.convert.Infallible.t) :=
      let* handler := M.alloc handler in
      M.read foo.
    
    Module  MethodRouter.
    Section MethodRouter.
      Context (S E : Set).
      
      Record t : Set := {
        get : axum.routing.method_routing.MethodEndpoint.t S E;
        head : axum.routing.method_routing.MethodEndpoint.t S E;
        delete : axum.routing.method_routing.MethodEndpoint.t S E;
        options : axum.routing.method_routing.MethodEndpoint.t S E;
        patch : axum.routing.method_routing.MethodEndpoint.t S E;
        post : axum.routing.method_routing.MethodEndpoint.t S E;
        put : axum.routing.method_routing.MethodEndpoint.t S E;
        trace : axum.routing.method_routing.MethodEndpoint.t S E;
        fallback : axum.routing.Fallback.t S E;
        allow_header : axum.routing.method_routing.AllowHeader.t;
      }.
      
      Definition Get_get :=
        Ref.map (fun α => Some α.(get)) (fun β α => Some (α <| get := β |>)).
      Definition Get_head :=
        Ref.map (fun α => Some α.(head)) (fun β α => Some (α <| head := β |>)).
      Definition Get_delete :=
        Ref.map
          (fun α => Some α.(delete))
          (fun β α => Some (α <| delete := β |>)).
      Definition Get_options :=
        Ref.map
          (fun α => Some α.(options))
          (fun β α => Some (α <| options := β |>)).
      Definition Get_patch :=
        Ref.map
          (fun α => Some α.(patch))
          (fun β α => Some (α <| patch := β |>)).
      Definition Get_post :=
        Ref.map (fun α => Some α.(post)) (fun β α => Some (α <| post := β |>)).
      Definition Get_put :=
        Ref.map (fun α => Some α.(put)) (fun β α => Some (α <| put := β |>)).
      Definition Get_trace :=
        Ref.map
          (fun α => Some α.(trace))
          (fun β α => Some (α <| trace := β |>)).
      Definition Get_fallback :=
        Ref.map
          (fun α => Some α.(fallback))
          (fun β α => Some (α <| fallback := β |>)).
      Definition Get_allow_header :=
        Ref.map
          (fun α => Some α.(allow_header))
          (fun β α => Some (α <| allow_header := β |>)).
      Module Default.
        Definition S := unit.
        Definition E := core.convert.Infallible.t.
      End Default.
    End MethodRouter.
    End MethodRouter.
    
    Module AllowHeader.
      Inductive t : Set :=
      | None
      | Skip
      | Bytes (_ : bytes.bytes_mut.BytesMut.t).
      
      Definition Get_Bytes_0 :=
        Ref.map
          (fun α => match α with | Bytes α0 => Some α0 | _ => None end)
          (fun β α => match α with | Bytes _ => Some (Bytes β) | _ => None end).
    End AllowHeader.
    
    Module  Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.
    Section Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.
      Definition Self : Set := axum.routing.method_routing.AllowHeader.t.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum.routing.method_routing.AllowHeader.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.
    End Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.
    Section Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.
      Definition Self : Set := axum.routing.method_routing.AllowHeader.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.
    End Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.
    
    Module  Impl_axum_routing_method_routing_AllowHeader_t.
    Section Impl_axum_routing_method_routing_AllowHeader_t.
      Definition Self : Set := axum.routing.method_routing.AllowHeader.t.
      
      (*
          fn merge(self, other: Self) -> Self {
              match (self, other) {
                  (AllowHeader::Skip, _) | (_, AllowHeader::Skip) => AllowHeader::Skip,
                  (AllowHeader::None, AllowHeader::None) => AllowHeader::None,
                  (AllowHeader::None, AllowHeader::Bytes(pick)) => AllowHeader::Bytes(pick),
                  (AllowHeader::Bytes(pick), AllowHeader::None) => AllowHeader::Bytes(pick),
                  (AllowHeader::Bytes(mut a), AllowHeader::Bytes(b)) => {
                      a.extend_from_slice(b",");
                      a.extend_from_slice(&b);
                      AllowHeader::Bytes(a)
                  }
              }
          }
      *)
      Definition merge (self : Self) (other : Self) : M Self :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_merge :
        Notations.DoubleColon Self "merge" := {
        Notations.double_colon := merge;
      }.
    End Impl_axum_routing_method_routing_AllowHeader_t.
    End Impl_axum_routing_method_routing_AllowHeader_t.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.
    Section Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.
      Context {S E : Set}.
      
      Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("MethodRouter")
                  .field("get", &self.get)
                  .field("head", &self.head)
                  .field("delete", &self.delete)
                  .field("options", &self.options)
                  .field("patch", &self.patch)
                  .field("post", &self.post)
                  .field("put", &self.put)
                  .field("trace", &self.trace)
                  .field("fallback", &self.fallback)
                  .field("allow_header", &self.allow_header)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.
    End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.
    
    Module  Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t.
    Section Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t.
      Context {S : Set}.
      
      Definition Self : Set :=
        axum.routing.method_routing.MethodRouter.t S core.convert.Infallible.t.
      
      (*
          pub fn on<H, T>(self, filter: MethodFilter, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
              S: Send + Sync + 'static,
          {
              self.on_endpoint(
                  filter,
                  MethodEndpoint::BoxedHandler(BoxedIntoRoute::from_handler(handler)),
              )
          }
      *)
      Definition on
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : Self)
          (filter : axum.routing.method_filter.MethodFilter.t)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* filter := M.alloc filter in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_on
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "on" := {
        Notations.double_colon := on (H := H) (T := T);
      }.
      
      (*
              pub fn $name<H, T>(self, handler: H) -> Self
              where
                  H: Handler<T, S>,
                  T: 'static,
                  S: Send + Sync + 'static,
              {
                  self.on(MethodFilter::$method, handler)
              }
      *)
      Definition delete
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_delete
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "delete" := {
        Notations.double_colon := delete (H := H) (T := T);
      }.
      
      (*
              pub fn $name<H, T>(self, handler: H) -> Self
              where
                  H: Handler<T, S>,
                  T: 'static,
                  S: Send + Sync + 'static,
              {
                  self.on(MethodFilter::$method, handler)
              }
      *)
      Definition get
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_get
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "get" := {
        Notations.double_colon := get (H := H) (T := T);
      }.
      
      (*
              pub fn $name<H, T>(self, handler: H) -> Self
              where
                  H: Handler<T, S>,
                  T: 'static,
                  S: Send + Sync + 'static,
              {
                  self.on(MethodFilter::$method, handler)
              }
      *)
      Definition head
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_head
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "head" := {
        Notations.double_colon := head (H := H) (T := T);
      }.
      
      (*
              pub fn $name<H, T>(self, handler: H) -> Self
              where
                  H: Handler<T, S>,
                  T: 'static,
                  S: Send + Sync + 'static,
              {
                  self.on(MethodFilter::$method, handler)
              }
      *)
      Definition options
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_options
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "options" := {
        Notations.double_colon := options (H := H) (T := T);
      }.
      
      (*
              pub fn $name<H, T>(self, handler: H) -> Self
              where
                  H: Handler<T, S>,
                  T: 'static,
                  S: Send + Sync + 'static,
              {
                  self.on(MethodFilter::$method, handler)
              }
      *)
      Definition patch
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_patch
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "patch" := {
        Notations.double_colon := patch (H := H) (T := T);
      }.
      
      (*
              pub fn $name<H, T>(self, handler: H) -> Self
              where
                  H: Handler<T, S>,
                  T: 'static,
                  S: Send + Sync + 'static,
              {
                  self.on(MethodFilter::$method, handler)
              }
      *)
      Definition post
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_post
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "post" := {
        Notations.double_colon := post (H := H) (T := T);
      }.
      
      (*
              pub fn $name<H, T>(self, handler: H) -> Self
              where
                  H: Handler<T, S>,
                  T: 'static,
                  S: Send + Sync + 'static,
              {
                  self.on(MethodFilter::$method, handler)
              }
      *)
      Definition put
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_put
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "put" := {
        Notations.double_colon := put (H := H) (T := T);
      }.
      
      (*
              pub fn $name<H, T>(self, handler: H) -> Self
              where
                  H: Handler<T, S>,
                  T: 'static,
                  S: Send + Sync + 'static,
              {
                  self.on(MethodFilter::$method, handler)
              }
      *)
      Definition trace
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_trace
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "trace" := {
        Notations.double_colon := trace (H := H) (T := T);
      }.
      
      (*
          pub fn fallback<H, T>(mut self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
              S: Send + Sync + 'static,
          {
              self.fallback = Fallback::BoxedHandler(BoxedIntoRoute::from_handler(handler));
              self
          }
      *)
      Definition fallback
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_fallback
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "fallback" := {
        Notations.double_colon := fallback (H := H) (T := T);
      }.
    End Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t.
    End Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t.
    
    Module  Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t.
    Section Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t.
      Definition Self : Set :=
        axum.routing.method_routing.MethodRouter.t
          unit
          core.convert.Infallible.t.
      
      (*
          pub fn into_make_service(self) -> IntoMakeService<Self> {
              IntoMakeService::new(self.with_state(()))
          }
      *)
      Definition into_make_service
          (self : Self)
          : M (axum.routing.into_make_service.IntoMakeService.t Self) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_make_service :
        Notations.DoubleColon Self "into_make_service" := {
        Notations.double_colon := into_make_service;
      }.
      
      (*
          pub fn into_make_service_with_connect_info<C>(self) -> IntoMakeServiceWithConnectInfo<Self, C> {
              IntoMakeServiceWithConnectInfo::new(self.with_state(()))
          }
      *)
      Definition into_make_service_with_connect_info
          {C : Set}
          (self : Self)
          :
            M
              (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t
                Self
                C) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_make_service_with_connect_info
          {C : Set} :
        Notations.DoubleColon Self "into_make_service_with_connect_info" := {
        Notations.double_colon := into_make_service_with_connect_info (C := C);
      }.
    End Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t.
    End Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t.
    
    Module  Impl_axum_routing_method_routing_MethodRouter_t_S_E.
    Section Impl_axum_routing_method_routing_MethodRouter_t_S_E.
      Context {S E : Set}.
      
      Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
      
      (*
          pub fn new() -> Self {
              let fallback = Route::new(service_fn(|_: Request| async {
                  Ok(StatusCode::METHOD_NOT_ALLOWED.into_response())
              }));
      
              Self {
                  get: MethodEndpoint::None,
                  head: MethodEndpoint::None,
                  delete: MethodEndpoint::None,
                  options: MethodEndpoint::None,
                  patch: MethodEndpoint::None,
                  post: MethodEndpoint::None,
                  put: MethodEndpoint::None,
                  trace: MethodEndpoint::None,
                  allow_header: AllowHeader::None,
                  fallback: Fallback::Default(fallback),
              }
          }
      *)
      Definition new : M Self := M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
      
      (*
          pub fn with_state<S2>(self, state: S) -> MethodRouter<S2, E> {
              MethodRouter {
                  get: self.get.with_state(&state),
                  head: self.head.with_state(&state),
                  delete: self.delete.with_state(&state),
                  options: self.options.with_state(&state),
                  patch: self.patch.with_state(&state),
                  post: self.post.with_state(&state),
                  put: self.put.with_state(&state),
                  trace: self.trace.with_state(&state),
                  allow_header: self.allow_header,
                  fallback: self.fallback.with_state(state),
              }
          }
      *)
      Definition with_state
          {S2 : Set}
          (self : Self)
          (state : S)
          : M (axum.routing.method_routing.MethodRouter.t S2 E) :=
        let* self := M.alloc self in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_with_state {S2 : Set} :
        Notations.DoubleColon Self "with_state" := {
        Notations.double_colon := with_state (S2 := S2);
      }.
      
      (*
          pub fn on_service<T>(self, filter: MethodFilter, svc: T) -> Self
          where
              T: Service<Request, Error = E> + Clone + Send + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
          {
              self.on_endpoint(filter, MethodEndpoint::Route(Route::new(svc)))
          }
      *)
      Definition on_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : Self)
          (filter : axum.routing.method_filter.MethodFilter.t)
          (svc : T)
          : M Self :=
        let* self := M.alloc self in
        let* filter := M.alloc filter in
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_on_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "on_service" := {
        Notations.double_colon := on_service (T := T);
      }.
      
      (*
          fn on_endpoint(mut self, filter: MethodFilter, endpoint: MethodEndpoint<S, E>) -> Self {
              // written as a separate function to generate less IR
              #[track_caller]
              fn set_endpoint<S, E>(
                  method_name: &str,
                  out: &mut MethodEndpoint<S, E>,
                  endpoint: &MethodEndpoint<S, E>,
                  endpoint_filter: MethodFilter,
                  filter: MethodFilter,
                  allow_header: &mut AllowHeader,
                  methods: &[&'static str],
              ) where
                  MethodEndpoint<S, E>: Clone,
                  S: Clone,
              {
                  if endpoint_filter.contains(filter) {
                      if out.is_some() {
                          panic!(
                              "Overlapping method route. Cannot add two method routes that both handle \
                               `{method_name}`",
                          )
                      }
                      *out = endpoint.clone();
                      for method in methods {
                          append_allow_header(allow_header, method);
                      }
                  }
              }
      
              set_endpoint(
                  "GET",
                  &mut self.get,
                  &endpoint,
                  filter,
                  MethodFilter::GET,
                  &mut self.allow_header,
                  &["GET", "HEAD"],
              );
      
              set_endpoint(
                  "HEAD",
                  &mut self.head,
                  &endpoint,
                  filter,
                  MethodFilter::HEAD,
                  &mut self.allow_header,
                  &["HEAD"],
              );
      
              set_endpoint(
                  "TRACE",
                  &mut self.trace,
                  &endpoint,
                  filter,
                  MethodFilter::TRACE,
                  &mut self.allow_header,
                  &["TRACE"],
              );
      
              set_endpoint(
                  "PUT",
                  &mut self.put,
                  &endpoint,
                  filter,
                  MethodFilter::PUT,
                  &mut self.allow_header,
                  &["PUT"],
              );
      
              set_endpoint(
                  "POST",
                  &mut self.post,
                  &endpoint,
                  filter,
                  MethodFilter::POST,
                  &mut self.allow_header,
                  &["POST"],
              );
      
              set_endpoint(
                  "PATCH",
                  &mut self.patch,
                  &endpoint,
                  filter,
                  MethodFilter::PATCH,
                  &mut self.allow_header,
                  &["PATCH"],
              );
      
              set_endpoint(
                  "OPTIONS",
                  &mut self.options,
                  &endpoint,
                  filter,
                  MethodFilter::OPTIONS,
                  &mut self.allow_header,
                  &["OPTIONS"],
              );
      
              set_endpoint(
                  "DELETE",
                  &mut self.delete,
                  &endpoint,
                  filter,
                  MethodFilter::DELETE,
                  &mut self.allow_header,
                  &["DELETE"],
              );
      
              self
          }
      *)
      Definition on_endpoint
          (self : Self)
          (filter : axum.routing.method_filter.MethodFilter.t)
          (endpoint : axum.routing.method_routing.MethodEndpoint.t S E)
          : M Self :=
        let* self := M.alloc self in
        let* filter := M.alloc filter in
        let* endpoint := M.alloc endpoint in
        M.read foo.
      
      Global Instance AssociatedFunction_on_endpoint :
        Notations.DoubleColon Self "on_endpoint" := {
        Notations.double_colon := on_endpoint;
      }.
      
      (*
              pub fn $name<T>(self, svc: T) -> Self
              where
                  T: Service<Request, Error = E>
                      + Clone
                      + Send
                      + 'static,
                  T::Response: IntoResponse + 'static,
                  T::Future: Send + 'static,
              {
                  self.on_service(MethodFilter::$method, svc)
              }
      *)
      Definition delete_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : Self)
          (svc : T)
          : M Self :=
        let* self := M.alloc self in
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_delete_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "delete_service" := {
        Notations.double_colon := delete_service (T := T);
      }.
      
      (*
              pub fn $name<T>(self, svc: T) -> Self
              where
                  T: Service<Request, Error = E>
                      + Clone
                      + Send
                      + 'static,
                  T::Response: IntoResponse + 'static,
                  T::Future: Send + 'static,
              {
                  self.on_service(MethodFilter::$method, svc)
              }
      *)
      Definition get_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : Self)
          (svc : T)
          : M Self :=
        let* self := M.alloc self in
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_get_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "get_service" := {
        Notations.double_colon := get_service (T := T);
      }.
      
      (*
              pub fn $name<T>(self, svc: T) -> Self
              where
                  T: Service<Request, Error = E>
                      + Clone
                      + Send
                      + 'static,
                  T::Response: IntoResponse + 'static,
                  T::Future: Send + 'static,
              {
                  self.on_service(MethodFilter::$method, svc)
              }
      *)
      Definition head_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : Self)
          (svc : T)
          : M Self :=
        let* self := M.alloc self in
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_head_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "head_service" := {
        Notations.double_colon := head_service (T := T);
      }.
      
      (*
              pub fn $name<T>(self, svc: T) -> Self
              where
                  T: Service<Request, Error = E>
                      + Clone
                      + Send
                      + 'static,
                  T::Response: IntoResponse + 'static,
                  T::Future: Send + 'static,
              {
                  self.on_service(MethodFilter::$method, svc)
              }
      *)
      Definition options_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : Self)
          (svc : T)
          : M Self :=
        let* self := M.alloc self in
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_options_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "options_service" := {
        Notations.double_colon := options_service (T := T);
      }.
      
      (*
              pub fn $name<T>(self, svc: T) -> Self
              where
                  T: Service<Request, Error = E>
                      + Clone
                      + Send
                      + 'static,
                  T::Response: IntoResponse + 'static,
                  T::Future: Send + 'static,
              {
                  self.on_service(MethodFilter::$method, svc)
              }
      *)
      Definition patch_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : Self)
          (svc : T)
          : M Self :=
        let* self := M.alloc self in
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_patch_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "patch_service" := {
        Notations.double_colon := patch_service (T := T);
      }.
      
      (*
              pub fn $name<T>(self, svc: T) -> Self
              where
                  T: Service<Request, Error = E>
                      + Clone
                      + Send
                      + 'static,
                  T::Response: IntoResponse + 'static,
                  T::Future: Send + 'static,
              {
                  self.on_service(MethodFilter::$method, svc)
              }
      *)
      Definition post_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : Self)
          (svc : T)
          : M Self :=
        let* self := M.alloc self in
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_post_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "post_service" := {
        Notations.double_colon := post_service (T := T);
      }.
      
      (*
              pub fn $name<T>(self, svc: T) -> Self
              where
                  T: Service<Request, Error = E>
                      + Clone
                      + Send
                      + 'static,
                  T::Response: IntoResponse + 'static,
                  T::Future: Send + 'static,
              {
                  self.on_service(MethodFilter::$method, svc)
              }
      *)
      Definition put_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : Self)
          (svc : T)
          : M Self :=
        let* self := M.alloc self in
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_put_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "put_service" := {
        Notations.double_colon := put_service (T := T);
      }.
      
      (*
              pub fn $name<T>(self, svc: T) -> Self
              where
                  T: Service<Request, Error = E>
                      + Clone
                      + Send
                      + 'static,
                  T::Response: IntoResponse + 'static,
                  T::Future: Send + 'static,
              {
                  self.on_service(MethodFilter::$method, svc)
              }
      *)
      Definition trace_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : Self)
          (svc : T)
          : M Self :=
        let* self := M.alloc self in
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_trace_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "trace_service" := {
        Notations.double_colon := trace_service (T := T);
      }.
      
      (*
          pub fn fallback_service<T>(mut self, svc: T) -> Self
          where
              T: Service<Request, Error = E> + Clone + Send + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
          {
              self.fallback = Fallback::Service(Route::new(svc));
              self
          }
      *)
      Definition fallback_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : Self)
          (svc : T)
          : M Self :=
        let* self := M.alloc self in
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_fallback_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "fallback_service" := {
        Notations.double_colon := fallback_service (T := T);
      }.
      
      (*
          pub fn layer<L, NewError>(self, layer: L) -> MethodRouter<S, NewError>
          where
              L: Layer<Route<E>> + Clone + Send + 'static,
              L::Service: Service<Request> + Clone + Send + 'static,
              <L::Service as Service<Request>>::Response: IntoResponse + 'static,
              <L::Service as Service<Request>>::Error: Into<NewError> + 'static,
              <L::Service as Service<Request>>::Future: Send + 'static,
              E: 'static,
              S: 'static,
              NewError: 'static,
          {
              let layer_fn = move |route: Route<E>| route.layer(layer.clone());
      
              MethodRouter {
                  get: self.get.map(layer_fn.clone()),
                  head: self.head.map(layer_fn.clone()),
                  delete: self.delete.map(layer_fn.clone()),
                  options: self.options.map(layer_fn.clone()),
                  patch: self.patch.map(layer_fn.clone()),
                  post: self.post.map(layer_fn.clone()),
                  put: self.put.map(layer_fn.clone()),
                  trace: self.trace.map(layer_fn.clone()),
                  fallback: self.fallback.map(layer_fn),
                  allow_header: self.allow_header,
              }
          }
      *)
      Definition layer
          {L NewError : Set}
          {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
          {ℋ_1 : core.clone.Clone.Trait L}
          {ℋ_2 : core.marker.Send.Trait L}
          {ℋ_3 :
            tower_service.Service.Trait L::type["Service"].t
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
          {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
          {ℋ_6 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          {ℋ_7 :
            core.convert.Into.Trait
                (tower_service.Service.Error
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))
              (T := NewError)}
          {ℋ_8 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          (self : Self)
          (layer : L)
          : M (axum.routing.method_routing.MethodRouter.t S NewError) :=
        let* self := M.alloc self in
        let* layer := M.alloc layer in
        M.read foo.
      
      Global Instance AssociatedFunction_layer
          {L NewError : Set}
          {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
          {ℋ_1 : core.clone.Clone.Trait L}
          {ℋ_2 : core.marker.Send.Trait L}
          {ℋ_3 :
            tower_service.Service.Trait L::type["Service"].t
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
          {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
          {ℋ_6 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          {ℋ_7 :
            core.convert.Into.Trait
                (tower_service.Service.Error
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))
              (T := NewError)}
          {ℋ_8 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))} :
        Notations.DoubleColon Self "layer" := {
        Notations.double_colon := layer (L := L) (NewError := NewError);
      }.
      
      (*
          pub fn route_layer<L>(mut self, layer: L) -> MethodRouter<S, E>
          where
              L: Layer<Route<E>> + Clone + Send + 'static,
              L::Service: Service<Request, Error = E> + Clone + Send + 'static,
              <L::Service as Service<Request>>::Response: IntoResponse + 'static,
              <L::Service as Service<Request>>::Future: Send + 'static,
              E: 'static,
              S: 'static,
          {
              if self.get.is_none()
                  && self.head.is_none()
                  && self.delete.is_none()
                  && self.options.is_none()
                  && self.patch.is_none()
                  && self.post.is_none()
                  && self.put.is_none()
                  && self.trace.is_none()
              {
                  panic!(
                      "Adding a route_layer before any routes is a no-op. \
                       Add the routes you want the layer to apply to first."
                  );
              }
      
              let layer_fn = move |svc| {
                  let svc = layer.layer(svc);
                  let svc = MapResponseLayer::new(IntoResponse::into_response).layer(svc);
                  Route::new(svc)
              };
      
              self.get = self.get.map(layer_fn.clone());
              self.head = self.head.map(layer_fn.clone());
              self.delete = self.delete.map(layer_fn.clone());
              self.options = self.options.map(layer_fn.clone());
              self.patch = self.patch.map(layer_fn.clone());
              self.post = self.post.map(layer_fn.clone());
              self.put = self.put.map(layer_fn.clone());
              self.trace = self.trace.map(layer_fn);
      
              self
          }
      *)
      Definition route_layer
          {L : Set}
          {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
          {ℋ_1 : core.clone.Clone.Trait L}
          {ℋ_2 : core.marker.Send.Trait L}
          {ℋ_3 :
            tower_service.Service.Trait L::type["Service"].t
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
          {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
          {ℋ_6 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          {ℋ_7 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          (self : Self)
          (layer : L)
          : M (axum.routing.method_routing.MethodRouter.t S E) :=
        let* self := M.alloc self in
        let* layer := M.alloc layer in
        M.read foo.
      
      Global Instance AssociatedFunction_route_layer
          {L : Set}
          {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
          {ℋ_1 : core.clone.Clone.Trait L}
          {ℋ_2 : core.marker.Send.Trait L}
          {ℋ_3 :
            tower_service.Service.Trait L::type["Service"].t
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
          {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
          {ℋ_6 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          {ℋ_7 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))} :
        Notations.DoubleColon Self "route_layer" := {
        Notations.double_colon := route_layer (L := L);
      }.
      
      (*
          pub(crate) fn merge_for_path(mut self, path: Option<&str>, other: MethodRouter<S, E>) -> Self {
              // written using inner functions to generate less IR
              #[track_caller]
              fn merge_inner<S, E>(
                  path: Option<&str>,
                  name: &str,
                  first: MethodEndpoint<S, E>,
                  second: MethodEndpoint<S, E>,
              ) -> MethodEndpoint<S, E> {
                  match (first, second) {
                      (MethodEndpoint::None, MethodEndpoint::None) => MethodEndpoint::None,
                      (pick, MethodEndpoint::None) | (MethodEndpoint::None, pick) => pick,
                      _ => {
                          if let Some(path) = path {
                              panic!(
                                  "Overlapping method route. Handler for `{name} {path}` already exists"
                              );
                          } else {
                              panic!(
                                  "Overlapping method route. Cannot merge two method routes that both \
                                   define `{name}`"
                              );
                          }
                      }
                  }
              }
      
              self.get = merge_inner(path, "GET", self.get, other.get);
              self.head = merge_inner(path, "HEAD", self.head, other.head);
              self.delete = merge_inner(path, "DELETE", self.delete, other.delete);
              self.options = merge_inner(path, "OPTIONS", self.options, other.options);
              self.patch = merge_inner(path, "PATCH", self.patch, other.patch);
              self.post = merge_inner(path, "POST", self.post, other.post);
              self.put = merge_inner(path, "PUT", self.put, other.put);
              self.trace = merge_inner(path, "TRACE", self.trace, other.trace);
      
              self.fallback = self
                  .fallback
                  .merge(other.fallback)
                  .expect("Cannot merge two `MethodRouter`s that both have a fallback");
      
              self.allow_header = self.allow_header.merge(other.allow_header);
      
              self
          }
      *)
      Definition merge_for_path
          (self : Self)
          (path : core.option.Option.t (ref str.t))
          (other : axum.routing.method_routing.MethodRouter.t S E)
          : M Self :=
        let* self := M.alloc self in
        let* path := M.alloc path in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_merge_for_path :
        Notations.DoubleColon Self "merge_for_path" := {
        Notations.double_colon := merge_for_path;
      }.
      
      (*
          pub fn merge(self, other: MethodRouter<S, E>) -> Self {
              self.merge_for_path(None, other)
          }
      *)
      Definition merge
          (self : Self)
          (other : axum.routing.method_routing.MethodRouter.t S E)
          : M Self :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_merge :
        Notations.DoubleColon Self "merge" := {
        Notations.double_colon := merge;
      }.
      
      (*
          pub fn handle_error<F, T>(self, f: F) -> MethodRouter<S, Infallible>
          where
              F: Clone + Send + Sync + 'static,
              HandleError<Route<E>, F, T>: Service<Request, Error = Infallible>,
              <HandleError<Route<E>, F, T> as Service<Request>>::Future: Send,
              <HandleError<Route<E>, F, T> as Service<Request>>::Response: IntoResponse + Send,
              T: 'static,
              E: 'static,
              S: 'static,
          {
              self.layer(HandleErrorLayer::new(f))
          }
      *)
      Definition handle_error
          {F T : Set}
          {ℋ_0 : core.clone.Clone.Trait F}
          {ℋ_1 : core.marker.Send.Trait F}
          {ℋ_2 : core.marker.Sync.Trait F}
          {ℋ_3 :
            tower_service.Service.Trait
                (axum.error_handling.HandleError.t
                  (axum.routing.route.Route.t E)
                  F
                  T)
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := axum.error_handling.HandleError.t
                    (axum.routing.route.Route.t E)
                    F
                    T)
                  (Trait := ltac:(refine _)))}
          {ℋ_5 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := axum.error_handling.HandleError.t
                    (axum.routing.route.Route.t E)
                    F
                    T)
                  (Trait := ltac:(refine _)))}
          {ℋ_6 :
            core.marker.Send.Trait
                (tower_service.Service.Response
                  (Self := axum.error_handling.HandleError.t
                    (axum.routing.route.Route.t E)
                    F
                    T)
                  (Trait := ltac:(refine _)))}
          (self : Self)
          (f : F)
          :
            M
              (axum.routing.method_routing.MethodRouter.t
                S
                core.convert.Infallible.t) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_handle_error
          {F T : Set}
          {ℋ_0 : core.clone.Clone.Trait F}
          {ℋ_1 : core.marker.Send.Trait F}
          {ℋ_2 : core.marker.Sync.Trait F}
          {ℋ_3 :
            tower_service.Service.Trait
                (axum.error_handling.HandleError.t
                  (axum.routing.route.Route.t E)
                  F
                  T)
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := axum.error_handling.HandleError.t
                    (axum.routing.route.Route.t E)
                    F
                    T)
                  (Trait := ltac:(refine _)))}
          {ℋ_5 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := axum.error_handling.HandleError.t
                    (axum.routing.route.Route.t E)
                    F
                    T)
                  (Trait := ltac:(refine _)))}
          {ℋ_6 :
            core.marker.Send.Trait
                (tower_service.Service.Response
                  (Self := axum.error_handling.HandleError.t
                    (axum.routing.route.Route.t E)
                    F
                    T)
                  (Trait := ltac:(refine _)))} :
        Notations.DoubleColon Self "handle_error" := {
        Notations.double_colon := handle_error (F := F) (T := T);
      }.
      
      (*
          fn skip_allow_header(mut self) -> Self {
              self.allow_header = AllowHeader::Skip;
              self
          }
      *)
      Definition skip_allow_header (self : Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_skip_allow_header :
        Notations.DoubleColon Self "skip_allow_header" := {
        Notations.double_colon := skip_allow_header;
      }.
      
      (*
          pub(crate) fn call_with_state(&self, req: Request, state: S) -> RouteFuture<E> {
              macro_rules! call {
                  (
                      $req:expr,
                      $method:expr,
                      $method_variant:ident,
                      $svc:expr
                  ) => {
                      if $method == Method::$method_variant {
                          match $svc {
                              MethodEndpoint::None => {}
                              MethodEndpoint::Route(route) => {
                                  return RouteFuture::from_future(route.clone().oneshot_inner($req))
                                      .strip_body($method == Method::HEAD);
                              }
                              MethodEndpoint::BoxedHandler(handler) => {
                                  let route = handler.clone().into_route(state);
                                  return RouteFuture::from_future(route.clone().oneshot_inner($req))
                                      .strip_body($method == Method::HEAD);
                              }
                          }
                      }
                  };
              }
      
              let method = req.method().clone();
      
              // written with a pattern match like this to ensure we call all routes
              let Self {
                  get,
                  head,
                  delete,
                  options,
                  patch,
                  post,
                  put,
                  trace,
                  fallback,
                  allow_header,
              } = self;
      
              call!(req, method, HEAD, head);
              call!(req, method, HEAD, get);
              call!(req, method, GET, get);
              call!(req, method, POST, post);
              call!(req, method, OPTIONS, options);
              call!(req, method, PATCH, patch);
              call!(req, method, PUT, put);
              call!(req, method, DELETE, delete);
              call!(req, method, TRACE, trace);
      
              let future = fallback.clone().call_with_state(req, state);
      
              match allow_header {
                  AllowHeader::None => future.allow_header(Bytes::new()),
                  AllowHeader::Skip => future,
                  AllowHeader::Bytes(allow_header) => future.allow_header(allow_header.clone().freeze()),
              }
          }
      *)
      Definition call_with_state
          (self : ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : S)
          : M (axum.routing.route.RouteFuture.t E) :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_call_with_state :
        Notations.DoubleColon Self "call_with_state" := {
        Notations.double_colon := call_with_state;
      }.
    End Impl_axum_routing_method_routing_MethodRouter_t_S_E.
    End Impl_axum_routing_method_routing_MethodRouter_t_S_E.
    
    (*
    fn append_allow_header(allow_header: &mut AllowHeader, method: &'static str) {
        match allow_header {
            AllowHeader::None => {
                *allow_header = AllowHeader::Bytes(BytesMut::from(method));
            }
            AllowHeader::Skip => {}
            AllowHeader::Bytes(allow_header) => {
                if let Ok(s) = std::str::from_utf8(allow_header) {
                    if !s.contains(method) {
                        allow_header.extend_from_slice(b",");
                        allow_header.extend_from_slice(method.as_bytes());
                    }
                } else {
                    #[cfg(debug_assertions)]
                    panic!("`allow_header` contained invalid uft-8. This should never happen")
                }
            }
        }
    }
    *)
    Definition append_allow_header
        (allow_header : mut_ref axum.routing.method_routing.AllowHeader.t)
        (method : ref str.t)
        : M unit :=
      let* allow_header := M.alloc allow_header in
      let* method := M.alloc method in
      M.read foo.
    
    Module  Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.
    Section Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.
      Context {S E : Set}.
      
      Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  get: self.get.clone(),
                  head: self.head.clone(),
                  delete: self.delete.clone(),
                  options: self.options.clone(),
                  patch: self.patch.clone(),
                  post: self.post.clone(),
                  put: self.put.clone(),
                  trace: self.trace.clone(),
                  fallback: self.fallback.clone(),
                  allow_header: self.allow_header.clone(),
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.
    End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.
    
    Module  Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.
    Section Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.
      Context {S E : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
      
      (*
          fn default() -> Self {
              Self::new()
          }
      *)
      Definition default : M Self := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.
    End Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.
    
    Module MethodEndpoint.
      Inductive t (S : Set) (E : Set) : Set :=
      | None
      | Route (_ : axum.routing.route.Route.t E)
      | BoxedHandler (_ : axum.boxed.BoxedIntoRoute.t S E).
      
      Definition Get_Route_0 :=
        Ref.map
          (fun α => match α with | Route α0 => Some α0 | _ => None end)
          (fun β α => match α with | Route _ => Some (Route β) | _ => None end).
      
      Definition Get_BoxedHandler_0 :=
        Ref.map
          (fun α => match α with | BoxedHandler α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | BoxedHandler _ => Some (BoxedHandler β)
            | _ => None
            end).
    End MethodEndpoint.
    
    Module  Impl_axum_routing_method_routing_MethodEndpoint_t_S_E.
    Section Impl_axum_routing_method_routing_MethodEndpoint_t_S_E.
      Context {S E : Set}.
      
      Definition Self : Set := axum.routing.method_routing.MethodEndpoint.t S E.
      
      (*
          fn is_some(&self) -> bool {
              matches!(self, Self::Route(_) | Self::BoxedHandler(_))
          }
      *)
      Definition is_some (self : ref Self) : M bool.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_is_some :
        Notations.DoubleColon Self "is_some" := {
        Notations.double_colon := is_some;
      }.
      
      (*
          fn is_none(&self) -> bool {
              matches!(self, Self::None)
          }
      *)
      Definition is_none (self : ref Self) : M bool.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_is_none :
        Notations.DoubleColon Self "is_none" := {
        Notations.double_colon := is_none;
      }.
      
      (*
          fn map<F, E2>(self, f: F) -> MethodEndpoint<S, E2>
          where
              S: 'static,
              E: 'static,
              F: FnOnce(Route<E>) -> Route<E2> + Clone + Send + 'static,
              E2: 'static,
          {
              match self {
                  Self::None => MethodEndpoint::None,
                  Self::Route(route) => MethodEndpoint::Route(f(route)),
                  Self::BoxedHandler(handler) => MethodEndpoint::BoxedHandler(handler.map(f)),
              }
          }
      *)
      Definition map
          {F E2 : Set}
          {ℋ_0 :
            core.ops.function.FnOnce.Trait F
              (Args := axum.routing.route.Route.t E)}
          {ℋ_1 : core.clone.Clone.Trait F}
          {ℋ_2 : core.marker.Send.Trait F}
          (self : Self)
          (f : F)
          : M (axum.routing.method_routing.MethodEndpoint.t S E2) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_map
          {F E2 : Set}
          {ℋ_0 :
            core.ops.function.FnOnce.Trait F
              (Args := axum.routing.route.Route.t E)}
          {ℋ_1 : core.clone.Clone.Trait F}
          {ℋ_2 : core.marker.Send.Trait F} :
        Notations.DoubleColon Self "map" := {
        Notations.double_colon := map (F := F) (E2 := E2);
      }.
      
      (*
          fn with_state<S2>(self, state: &S) -> MethodEndpoint<S2, E> {
              match self {
                  MethodEndpoint::None => MethodEndpoint::None,
                  MethodEndpoint::Route(route) => MethodEndpoint::Route(route),
                  MethodEndpoint::BoxedHandler(handler) => {
                      MethodEndpoint::Route(handler.into_route(state.clone()))
                  }
              }
          }
      *)
      Definition with_state
          {S2 : Set}
          (self : Self)
          (state : ref S)
          : M (axum.routing.method_routing.MethodEndpoint.t S2 E) :=
        let* self := M.alloc self in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_with_state {S2 : Set} :
        Notations.DoubleColon Self "with_state" := {
        Notations.double_colon := with_state (S2 := S2);
      }.
    End Impl_axum_routing_method_routing_MethodEndpoint_t_S_E.
    End Impl_axum_routing_method_routing_MethodEndpoint_t_S_E.
    
    Module  Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
    Section Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
      Context {S E : Set}.
      
      Definition Self : Set := axum.routing.method_routing.MethodEndpoint.t S E.
      
      (*
          fn clone(&self) -> Self {
              match self {
                  Self::None => Self::None,
                  Self::Route(inner) => Self::Route(inner.clone()),
                  Self::BoxedHandler(inner) => Self::BoxedHandler(inner.clone()),
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
    End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
    Section Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
      Context {S E : Set}.
      
      Definition Self : Set := axum.routing.method_routing.MethodEndpoint.t S E.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              match self {
                  Self::None => f.debug_tuple("None").finish(),
                  Self::Route(inner) => inner.fmt(f),
                  Self::BoxedHandler(_) => f.debug_tuple("BoxedHandler").finish(),
              }
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
    End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.
    Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.
      Context {B E : Set}.
      
      Context
        {ℋ_0 : http_body.Body.Trait B}
        {ℋ_1 : core.marker.Send.Trait B}
        {ℋ_2 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}.
      
      Definition Self : Set :=
        axum.routing.method_routing.MethodRouter.t unit E.
      
      (*
          type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
          type Error = E;
      *)
      Definition Error : Set := E.
      
      (*
          type Future = RouteFuture<E>;
      *)
      Definition Future : Set := axum.routing.route.RouteFuture.t E.
      
      (*
          fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              Poll::Ready(Ok(()))
          }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (_cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* _cx := M.alloc _cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
          fn call(&mut self, req: Request<B>) -> Self::Future {
              let req = req.map(Body::new);
              self.call_with_state(req, ())
          }
      *)
      Definition call
          (self : mut_ref Self)
          (req : ltac:(axum_core.extract.Request B))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request B)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.
    End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.
    
    Module  Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.
    Section Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.
      Context {S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.routing.method_routing.MethodRouter.t
          S
          axum.routing.method_routing.MethodRouter.Default.E.
      
      (*
          type Future = InfallibleRouteFuture;
      *)
      Definition Future : Set := axum.routing.route.InfallibleRouteFuture.t.
      
      (*
          fn call(self, req: Request, state: S) -> Self::Future {
              InfallibleRouteFuture::new(self.call_with_state(req, state))
          }
      *)
      Definition call
          (self : Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : S)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        axum.handler.Handler.Required.Trait Self (T := unit) (S := S) := {
        axum.handler.Handler.Future := Future;
        axum.handler.Handler.call := call;
        axum.handler.Handler.layer := Datatypes.None;
        axum.handler.Handler.with_state := Datatypes.None;
      }.
    End Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.
    End Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.
  End method_routing.
  
  Module into_make_service.
    Module  IntoMakeService.
    Section IntoMakeService.
      Context (S : Set).
      
      Record t : Set := {
        svc : S;
      }.
      
      Definition Get_svc :=
        Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
    End IntoMakeService.
    End IntoMakeService.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.
    Section Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S}.
      
      Definition Self : Set :=
        axum.routing.into_make_service.IntoMakeService.t S.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.
    End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.
    
    Module  Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.
    Section Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.routing.into_make_service.IntoMakeService.t S.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M (axum.routing.into_make_service.IntoMakeService.t S) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.
    End Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.
    
    Module  Impl_axum_routing_into_make_service_IntoMakeService_t_S.
    Section Impl_axum_routing_into_make_service_IntoMakeService_t_S.
      Context {S : Set}.
      
      Definition Self : Set :=
        axum.routing.into_make_service.IntoMakeService.t S.
      
      (*
          pub(crate) fn new(svc: S) -> Self {
              Self { svc }
          }
      *)
      Definition new (svc : S) : M Self :=
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_axum_routing_into_make_service_IntoMakeService_t_S.
    End Impl_axum_routing_into_make_service_IntoMakeService_t_S.
    
    Module  Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.
    Section Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.
      Context {S T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum.routing.into_make_service.IntoMakeService.t S.
      
      (*
          type Response = S;
      *)
      Definition Response : Set := S.
      
      (*
          type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
          type Future = IntoMakeServiceFuture<S>;
      *)
      Definition Future : Set :=
        axum.routing.into_make_service.IntoMakeServiceFuture.t S.
      
      (*
          fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              Poll::Ready(Ok(()))
          }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (_cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* _cx := M.alloc _cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
          fn call(&mut self, _target: T) -> Self::Future {
              IntoMakeServiceFuture::new(ready(Ok(self.svc.clone())))
          }
      *)
      Definition call (self : mut_ref Self) (_target : T) : M Future :=
        let* self := M.alloc self in
        let* _target := M.alloc _target in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ : tower_service.Service.Trait Self (Request := T) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.
    End Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.
    
    Module  IntoMakeServiceFuture.
    Section IntoMakeServiceFuture.
      Context (S : Set).
      
      Record t : Set := {
        future :
          core.future.ready.Ready.t
            (core.result.Result.t S core.convert.Infallible.t);
      }.
      
      Definition Get_future :=
        Ref.map
          (fun α => Some α.(future))
          (fun β α => Some (α <| future := β |>)).
    End IntoMakeServiceFuture.
    End IntoMakeServiceFuture.
    
    Module  Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
    Section Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
      Context {S : Set}.
      
      Definition Self : Set :=
        axum.routing.into_make_service.IntoMakeServiceFuture.t S.
      
      (*
                  pub(crate) fn new(future: $actual) -> Self {
                      Self { future }
                  }
      *)
      Definition new
          (future
            :
            core.future.ready.Ready.t
              (core.result.Result.t S core.convert.Infallible.t))
          : M Self :=
        let* future := M.alloc future in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
    End Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
    Section Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
      Context {S : Set}.
      
      Definition Self : Set :=
        axum.routing.into_make_service.IntoMakeServiceFuture.t S.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      f.debug_struct(stringify!($name)).finish_non_exhaustive()
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
    End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
    
    Module  Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
    Section Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
      Context {S : Set}.
      
      Context
        {ℋ_0 :
          core.future.future.Future.Trait
              (core.future.ready.Ready.t
                (core.result.Result.t S core.convert.Infallible.t))}.
      
      Definition Self : Set :=
        axum.routing.into_make_service.IntoMakeServiceFuture.t S.
      
      (*
                  type Output = <$actual as std::future::Future>::Output;
      *)
      Definition Output : Set :=
        core.future.future.Future.Output
            (Self := core.future.ready.Ready.t
              (core.result.Result.t S core.convert.Infallible.t))
            (Trait := ltac:(refine _)).
      
      (*
                  fn poll(
                      self: std::pin::Pin<&mut Self>,
                      cx: &mut std::task::Context<'_>,
                  ) -> std::task::Poll<Self::Output> {
                      self.project().future.poll(cx)
                  }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
    End Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
  End into_make_service.
  
  Module method_filter.
    Module  MethodFilter.
    Section MethodFilter.
      Record t : Set := {
        x0 : u16.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End MethodFilter.
    End MethodFilter.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.
    Section Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.
      Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.
    End Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.
    
    Module  Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.
    Section Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.
      Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.
    End Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.
    
    Module  Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.
    Section Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.
      Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum.routing.method_filter.MethodFilter.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.
    End Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.
    
    Module  Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.
    Section Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.
      Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
      
      Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.
    End Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.
    
    Module  Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.
    Section Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.
      Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
      
      (*
      PartialEq
      *)
      Definition eq
          (self : ref Self)
          (other : ref axum.routing.method_filter.MethodFilter.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.
    End Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.
    
    Module  Impl_axum_routing_method_filter_MethodFilter_t.
    Section Impl_axum_routing_method_filter_MethodFilter_t.
      Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
      
      (*
          pub const DELETE: Self = Self::from_bits(0b0_0000_0010);
      *)
      
      Definition DELETE : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_DELETE :
        Notations.DoubleColon Self "DELETE" := {
        Notations.double_colon := DELETE;
      }.
      
      (*
          pub const GET: Self = Self::from_bits(0b0_0000_0100);
      *)
      
      Definition GET : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_GET :
        Notations.DoubleColon Self "GET" := {
        Notations.double_colon := GET;
      }.
      
      (*
          pub const HEAD: Self = Self::from_bits(0b0_0000_1000);
      *)
      
      Definition HEAD : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_HEAD :
        Notations.DoubleColon Self "HEAD" := {
        Notations.double_colon := HEAD;
      }.
      
      (*
          pub const OPTIONS: Self = Self::from_bits(0b0_0001_0000);
      *)
      
      Definition OPTIONS : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_OPTIONS :
        Notations.DoubleColon Self "OPTIONS" := {
        Notations.double_colon := OPTIONS;
      }.
      
      (*
          pub const PATCH: Self = Self::from_bits(0b0_0010_0000);
      *)
      
      Definition PATCH : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_PATCH :
        Notations.DoubleColon Self "PATCH" := {
        Notations.double_colon := PATCH;
      }.
      
      (*
          pub const POST: Self = Self::from_bits(0b0_0100_0000);
      *)
      
      Definition POST : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_POST :
        Notations.DoubleColon Self "POST" := {
        Notations.double_colon := POST;
      }.
      
      (*
          pub const PUT: Self = Self::from_bits(0b0_1000_0000);
      *)
      
      Definition PUT : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_PUT :
        Notations.DoubleColon Self "PUT" := {
        Notations.double_colon := PUT;
      }.
      
      (*
          pub const TRACE: Self = Self::from_bits(0b1_0000_0000);
      *)
      
      Definition TRACE : Self := M.run (M.pure foo).
      
      Global Instance AssociatedFunction_TRACE :
        Notations.DoubleColon Self "TRACE" := {
        Notations.double_colon := TRACE;
      }.
      
      (*
          const fn bits(&self) -> u16 {
              let bits = self;
              bits.0
          }
      *)
      Definition bits (self : ref Self) : M u16.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_bits :
        Notations.DoubleColon Self "bits" := {
        Notations.double_colon := bits;
      }.
      
      (*
          const fn from_bits(bits: u16) -> Self {
              Self(bits)
          }
      *)
      Definition from_bits (bits : u16.t) : M Self :=
        let* bits := M.alloc bits in
        M.read foo.
      
      Global Instance AssociatedFunction_from_bits :
        Notations.DoubleColon Self "from_bits" := {
        Notations.double_colon := from_bits;
      }.
      
      (*
          pub(crate) const fn contains(&self, other: Self) -> bool {
              self.bits() & other.bits() == other.bits()
          }
      *)
      Definition contains (self : ref Self) (other : Self) : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_contains :
        Notations.DoubleColon Self "contains" := {
        Notations.double_colon := contains;
      }.
      
      (*
          pub const fn or(self, other: Self) -> Self {
              Self(self.0 | other.0)
          }
      *)
      Definition or (self : Self) (other : Self) : M Self :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_or :
        Notations.DoubleColon Self "or" := {
        Notations.double_colon := or;
      }.
    End Impl_axum_routing_method_filter_MethodFilter_t.
    End Impl_axum_routing_method_filter_MethodFilter_t.
    
    Module  NoMatchingMethodFilter.
    Section NoMatchingMethodFilter.
      Record t : Set := {
        method : http.method.Method.t;
      }.
      
      Definition Get_method :=
        Ref.map
          (fun α => Some α.(method))
          (fun β α => Some (α <| method := β |>)).
    End NoMatchingMethodFilter.
    End NoMatchingMethodFilter.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    Section Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
      Definition Self : Set :=
        axum.routing.method_filter.NoMatchingMethodFilter.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    End Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    
    Module  Impl_axum_routing_method_filter_NoMatchingMethodFilter_t.
    Section Impl_axum_routing_method_filter_NoMatchingMethodFilter_t.
      Definition Self : Set :=
        axum.routing.method_filter.NoMatchingMethodFilter.t.
      
      (*
          pub fn method(&self) -> &Method {
              &self.method
          }
      *)
      Definition method (self : ref Self) : M (ref http.method.Method.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_method :
        Notations.DoubleColon Self "method" := {
        Notations.double_colon := method;
      }.
    End Impl_axum_routing_method_filter_NoMatchingMethodFilter_t.
    End Impl_axum_routing_method_filter_NoMatchingMethodFilter_t.
    
    Module  Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    Section Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
      Definition Self : Set :=
        axum.routing.method_filter.NoMatchingMethodFilter.t.
      
      (*
          fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
              write!(f, "no `MethodFilter` for `{}`", self.method.as_str())
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    End Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    
    Module  Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    Section Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
      Definition Self : Set :=
        axum.routing.method_filter.NoMatchingMethodFilter.t.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.None;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    End Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    
    Module  Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.
    Section Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.
      Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
      
      (*
          type Error = NoMatchingMethodFilter;
      *)
      Definition Error : Set :=
        axum.routing.method_filter.NoMatchingMethodFilter.t.
      
      (*
          fn try_from(m: Method) -> Result<Self, NoMatchingMethodFilter> {
              match m {
                  Method::DELETE => Ok(MethodFilter::DELETE),
                  Method::GET => Ok(MethodFilter::GET),
                  Method::HEAD => Ok(MethodFilter::HEAD),
                  Method::OPTIONS => Ok(MethodFilter::OPTIONS),
                  Method::PATCH => Ok(MethodFilter::PATCH),
                  Method::POST => Ok(MethodFilter::POST),
                  Method::PUT => Ok(MethodFilter::PUT),
                  Method::TRACE => Ok(MethodFilter::TRACE),
                  other => Err(NoMatchingMethodFilter { method: other }),
              }
          }
      *)
      Definition try_from
          (m : http.method.Method.t)
          :
            M
              (core.result.Result.t
                Self
                axum.routing.method_filter.NoMatchingMethodFilter.t) :=
        let* m := M.alloc m in
        M.read foo.
      
      Global Instance AssociatedFunction_try_from :
        Notations.DoubleColon Self "try_from" := {
        Notations.double_colon := try_from;
      }.
      
      Global Instance ℐ :
        core.convert.TryFrom.Trait Self (T := http.method.Method.t) := {
        core.convert.TryFrom.Error := Error;
        core.convert.TryFrom.try_from := try_from;
      }.
    End Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.
    End Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.
  End method_filter.
  
  Module not_found.
    Module  NotFound.
    Section NotFound.
      Inductive t : Set := Build.
    End NotFound.
    End NotFound.
    
    Module  Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.
    Section Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.
      Definition Self : Set := axum.routing.not_found.NotFound.t.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum.routing.not_found.NotFound.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.
    End Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.
    
    Module  Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.
    Section Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.
      Definition Self : Set := axum.routing.not_found.NotFound.t.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.
    End Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.
    Section Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.
      Definition Self : Set := axum.routing.not_found.NotFound.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.
    End Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.
      Context {B : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait B}.
      
      Definition Self : Set := axum.routing.not_found.NotFound.t.
      
      (*
          type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
          type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
          type Future = std::future::Ready<Result<Response, Self::Error>>;
      *)
      Definition Future : Set :=
        core.future.ready.Ready.t
            (core.result.Result.t
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              Error).
      
      (*
          fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              Poll::Ready(Ok(()))
          }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (_cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* _cx := M.alloc _cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
          fn call(&mut self, _req: Request<B>) -> Self::Future {
              ready(Ok(StatusCode::NOT_FOUND.into_response()))
          }
      *)
      Definition call
          (self : mut_ref Self)
          (_req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* _req := M.alloc _req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.
  End not_found.
  
  Module path_router.
    Module  PathRouter.
    Section PathRouter.
      Context (S : Set).
      
      Record t : Set := {
        routes :
          std.collections.hash.map.HashMap.t
            axum.routing.RouteId.t
            (axum.routing.Endpoint.t S)
            std.collections.hash.map.HashMap.Default.S;
        node :
          alloc.sync.Arc.t
            axum.routing.path_router.Node.t
            alloc.sync.Arc.Default.A;
        prev_route_id : axum.routing.RouteId.t;
      }.
      
      Definition Get_routes :=
        Ref.map
          (fun α => Some α.(routes))
          (fun β α => Some (α <| routes := β |>)).
      Definition Get_node :=
        Ref.map (fun α => Some α.(node)) (fun β α => Some (α <| node := β |>)).
      Definition Get_prev_route_id :=
        Ref.map
          (fun α => Some α.(prev_route_id))
          (fun β α => Some (α <| prev_route_id := β |>)).
    End PathRouter.
    End PathRouter.
    
    Module  Impl_axum_routing_path_router_PathRouter_t_S.
    Section Impl_axum_routing_path_router_PathRouter_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.routing.path_router.PathRouter.t S.
      
      (*
          pub(super) fn new_fallback() -> Self {
              let mut this = Self::default();
              this.set_fallback(Endpoint::Route(Route::new(NotFound)));
              this
          }
      *)
      Definition new_fallback : M Self := M.read foo.
      
      Global Instance AssociatedFunction_new_fallback :
        Notations.DoubleColon Self "new_fallback" := {
        Notations.double_colon := new_fallback;
      }.
      
      (*
          pub(super) fn set_fallback(&mut self, endpoint: Endpoint<S>) {
              self.replace_endpoint("/", endpoint.clone());
              self.replace_endpoint(FALLBACK_PARAM_PATH, endpoint);
          }
      *)
      Definition set_fallback
          (self : mut_ref Self)
          (endpoint : axum.routing.Endpoint.t S)
          : M unit :=
        let* self := M.alloc self in
        let* endpoint := M.alloc endpoint in
        M.read foo.
      
      Global Instance AssociatedFunction_set_fallback :
        Notations.DoubleColon Self "set_fallback" := {
        Notations.double_colon := set_fallback;
      }.
    End Impl_axum_routing_path_router_PathRouter_t_S.
    End Impl_axum_routing_path_router_PathRouter_t_S.
    
    Module  Impl_axum_routing_path_router_PathRouter_t_S_2.
    Section Impl_axum_routing_path_router_PathRouter_t_S_2.
      Context {S : Set}.
      
      Definition Self : Set := axum.routing.path_router.PathRouter.t S.
      
      (*
          pub(super) fn route(
              &mut self,
              path: &str,
              method_router: MethodRouter<S>,
          ) -> Result<(), Cow<'static, str>> {
              fn validate_path(path: &str) -> Result<(), &'static str> {
                  if path.is_empty() {
                      return Err("Paths must start with a `/`. Use \"/\" for root routes");
                  } else if !path.starts_with('/') {
                      return Err("Paths must start with a `/`");
                  }
      
                  Ok(())
              }
      
              validate_path(path)?;
      
              let endpoint = if let Some((route_id, Endpoint::MethodRouter(prev_method_router))) = self
                  .node
                  .path_to_route_id
                  .get(path)
                  .and_then(|route_id| self.routes.get(route_id).map(|svc| ( *route_id, svc)))
              {
                  // if we're adding a new `MethodRouter` to a route that already has one just
                  // merge them. This makes `.route("/", get(_)).route("/", post(_))` work
                  let service = Endpoint::MethodRouter(
                      prev_method_router
                          .clone()
                          .merge_for_path(Some(path), method_router),
                  );
                  self.routes.insert(route_id, service);
                  return Ok(());
              } else {
                  Endpoint::MethodRouter(method_router)
              };
      
              let id = self.next_route_id();
              self.set_node(path, id)?;
              self.routes.insert(id, endpoint);
      
              Ok(())
          }
      *)
      Definition route
          (self : mut_ref Self)
          (path : ref str.t)
          (method_router
            :
            axum.routing.method_routing.MethodRouter.t
              S
              axum.routing.method_routing.MethodRouter.Default.E)
          : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
        let* self := M.alloc self in
        let* path := M.alloc path in
        let* method_router := M.alloc method_router in
        M.read foo.
      
      Global Instance AssociatedFunction_route :
        Notations.DoubleColon Self "route" := {
        Notations.double_colon := route;
      }.
      
      (*
          pub(super) fn route_service<T>(
              &mut self,
              path: &str,
              service: T,
          ) -> Result<(), Cow<'static, str>>
          where
              T: Service<Request, Error = Infallible> + Clone + Send + 'static,
              T::Response: IntoResponse,
              T::Future: Send + 'static,
          {
              self.route_endpoint(path, Endpoint::Route(Route::new(service)))
          }
      *)
      Definition route_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : mut_ref Self)
          (path : ref str.t)
          (service : T)
          : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
        let* self := M.alloc self in
        let* path := M.alloc path in
        let* service := M.alloc service in
        M.read foo.
      
      Global Instance AssociatedFunction_route_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "route_service" := {
        Notations.double_colon := route_service (T := T);
      }.
      
      (*
          pub(super) fn route_endpoint(
              &mut self,
              path: &str,
              endpoint: Endpoint<S>,
          ) -> Result<(), Cow<'static, str>> {
              if path.is_empty() {
                  return Err("Paths must start with a `/`. Use \"/\" for root routes".into());
              } else if !path.starts_with('/') {
                  return Err("Paths must start with a `/`".into());
              }
      
              let id = self.next_route_id();
              self.set_node(path, id)?;
              self.routes.insert(id, endpoint);
      
              Ok(())
          }
      *)
      Definition route_endpoint
          (self : mut_ref Self)
          (path : ref str.t)
          (endpoint : axum.routing.Endpoint.t S)
          : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
        let* self := M.alloc self in
        let* path := M.alloc path in
        let* endpoint := M.alloc endpoint in
        M.read foo.
      
      Global Instance AssociatedFunction_route_endpoint :
        Notations.DoubleColon Self "route_endpoint" := {
        Notations.double_colon := route_endpoint;
      }.
      
      (*
          fn set_node(&mut self, path: &str, id: RouteId) -> Result<(), String> {
              let mut node =
                  Arc::try_unwrap(Arc::clone(&self.node)).unwrap_or_else(|node| ( *node).clone());
              if let Err(err) = node.insert(path, id) {
                  return Err(format!("Invalid route {path:?}: {err}"));
              }
              self.node = Arc::new(node);
              Ok(())
          }
      *)
      Definition set_node
          (self : mut_ref Self)
          (path : ref str.t)
          (id : axum.routing.RouteId.t)
          : M (core.result.Result.t unit alloc.string.String.t) :=
        let* self := M.alloc self in
        let* path := M.alloc path in
        let* id := M.alloc id in
        M.read foo.
      
      Global Instance AssociatedFunction_set_node :
        Notations.DoubleColon Self "set_node" := {
        Notations.double_colon := set_node;
      }.
      
      (*
          pub(super) fn merge(
              &mut self,
              other: PathRouter<S, IS_FALLBACK>,
          ) -> Result<(), Cow<'static, str>> {
              let PathRouter {
                  routes,
                  node,
                  prev_route_id: _,
              } = other;
      
              for (id, route) in routes {
                  let path = node
                      .route_id_to_path
                      .get(&id)
                      .expect("no path for route id. This is a bug in axum. Please file an issue");
      
                  if IS_FALLBACK && (&**path == "/" || &**path == FALLBACK_PARAM_PATH) {
                      // when merging two routers it doesn't matter if you do `a.merge(b)` or
                      // `b.merge(a)`. This must also be true for fallbacks.
                      //
                      // However all fallback routers will have routes for `/` and `/*` so when merging
                      // we have to ignore the top level fallbacks on one side otherwise we get
                      // conflicts.
                      //
                      // `Router::merge` makes sure that when merging fallbacks `other` always has the
                      // fallback we want to keep. It panics if both routers have a custom fallback. Thus
                      // it is always okay to ignore one fallback and `Router::merge` also makes sure the
                      // one we can ignore is that of `self`.
                      self.replace_endpoint(path, route);
                  } else {
                      match route {
                          Endpoint::MethodRouter(method_router) => self.route(path, method_router)?,
                          Endpoint::Route(route) => self.route_service(path, route)?,
                      }
                  }
              }
      
              Ok(())
          }
      *)
      Definition merge
          (self : mut_ref Self)
          (other : axum.routing.path_router.PathRouter.t S)
          : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_merge :
        Notations.DoubleColon Self "merge" := {
        Notations.double_colon := merge;
      }.
      
      (*
          pub(super) fn nest(
              &mut self,
              path_to_nest_at: &str,
              router: PathRouter<S, IS_FALLBACK>,
          ) -> Result<(), Cow<'static, str>> {
              let prefix = validate_nest_path(path_to_nest_at);
      
              let PathRouter {
                  routes,
                  node,
                  prev_route_id: _,
              } = router;
      
              for (id, endpoint) in routes {
                  let inner_path = node
                      .route_id_to_path
                      .get(&id)
                      .expect("no path for route id. This is a bug in axum. Please file an issue");
      
                  let path = path_for_nested_route(prefix, inner_path);
      
                  let layer = (
                      StripPrefix::layer(prefix),
                      SetNestedPath::layer(path_to_nest_at),
                  );
                  match endpoint.layer(layer) {
                      Endpoint::MethodRouter(method_router) => {
                          self.route(&path, method_router)?;
                      }
                      Endpoint::Route(route) => {
                          self.route_endpoint(&path, Endpoint::Route(route))?;
                      }
                  }
              }
      
              Ok(())
          }
      *)
      Definition nest
          (self : mut_ref Self)
          (path_to_nest_at : ref str.t)
          (router : axum.routing.path_router.PathRouter.t S)
          : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
        let* self := M.alloc self in
        let* path_to_nest_at := M.alloc path_to_nest_at in
        let* router := M.alloc router in
        M.read foo.
      
      Global Instance AssociatedFunction_nest :
        Notations.DoubleColon Self "nest" := {
        Notations.double_colon := nest;
      }.
      
      (*
          pub(super) fn nest_service<T>(
              &mut self,
              path_to_nest_at: &str,
              svc: T,
          ) -> Result<(), Cow<'static, str>>
          where
              T: Service<Request, Error = Infallible> + Clone + Send + 'static,
              T::Response: IntoResponse,
              T::Future: Send + 'static,
          {
              let path = validate_nest_path(path_to_nest_at);
              let prefix = path;
      
              let path = if path.ends_with('/') {
                  format!("{path}*{NEST_TAIL_PARAM}")
              } else {
                  format!("{path}/*{NEST_TAIL_PARAM}")
              };
      
              let layer = (
                  StripPrefix::layer(prefix),
                  SetNestedPath::layer(path_to_nest_at),
              );
              let endpoint = Endpoint::Route(Route::new(layer.layer(svc)));
      
              self.route_endpoint(&path, endpoint.clone())?;
      
              // `/*rest` is not matched by `/` so we need to also register a router at the
              // prefix itself. Otherwise if you were to nest at `/foo` then `/foo` itself
              // wouldn't match, which it should
              self.route_endpoint(prefix, endpoint.clone())?;
              if !prefix.ends_with('/') {
                  // same goes for `/foo/`, that should also match
                  self.route_endpoint(&format!("{prefix}/"), endpoint)?;
              }
      
              Ok(())
          }
      *)
      Definition nest_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (self : mut_ref Self)
          (path_to_nest_at : ref str.t)
          (svc : T)
          : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
        let* self := M.alloc self in
        let* path_to_nest_at := M.alloc path_to_nest_at in
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_nest_service
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "nest_service" := {
        Notations.double_colon := nest_service (T := T);
      }.
      
      (*
          pub(super) fn layer<L>(self, layer: L) -> PathRouter<S, IS_FALLBACK>
          where
              L: Layer<Route> + Clone + Send + 'static,
              L::Service: Service<Request> + Clone + Send + 'static,
              <L::Service as Service<Request>>::Response: IntoResponse + 'static,
              <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
              <L::Service as Service<Request>>::Future: Send + 'static,
          {
              let routes = self
                  .routes
                  .into_iter()
                  .map(|(id, endpoint)| {
                      let route = endpoint.layer(layer.clone());
                      (id, route)
                  })
                  .collect();
      
              PathRouter {
                  routes,
                  node: self.node,
                  prev_route_id: self.prev_route_id,
              }
          }
      *)
      Definition layer
          {L : Set}
          {ℋ_0 :
            tower_layer.Layer.Trait L
              (S := axum.routing.route.Route.t
                axum.routing.route.Route.Default.E)}
          {ℋ_1 : core.clone.Clone.Trait L}
          {ℋ_2 : core.marker.Send.Trait L}
          {ℋ_3 :
            tower_service.Service.Trait L::type["Service"].t
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
          {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
          {ℋ_6 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          {ℋ_7 :
            core.convert.Into.Trait
                (tower_service.Service.Error
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))
              (T := core.convert.Infallible.t)}
          {ℋ_8 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          (self : Self)
          (layer : L)
          : M (axum.routing.path_router.PathRouter.t S) :=
        let* self := M.alloc self in
        let* layer := M.alloc layer in
        M.read foo.
      
      Global Instance AssociatedFunction_layer
          {L : Set}
          {ℋ_0 :
            tower_layer.Layer.Trait L
              (S := axum.routing.route.Route.t
                axum.routing.route.Route.Default.E)}
          {ℋ_1 : core.clone.Clone.Trait L}
          {ℋ_2 : core.marker.Send.Trait L}
          {ℋ_3 :
            tower_service.Service.Trait L::type["Service"].t
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
          {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
          {ℋ_6 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          {ℋ_7 :
            core.convert.Into.Trait
                (tower_service.Service.Error
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))
              (T := core.convert.Infallible.t)}
          {ℋ_8 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))} :
        Notations.DoubleColon Self "layer" := {
        Notations.double_colon := layer (L := L);
      }.
      
      (*
          pub(super) fn route_layer<L>(self, layer: L) -> Self
          where
              L: Layer<Route> + Clone + Send + 'static,
              L::Service: Service<Request> + Clone + Send + 'static,
              <L::Service as Service<Request>>::Response: IntoResponse + 'static,
              <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
              <L::Service as Service<Request>>::Future: Send + 'static,
          {
              if self.routes.is_empty() {
                  panic!(
                      "Adding a route_layer before any routes is a no-op. \
                       Add the routes you want the layer to apply to first."
                  );
              }
      
              let routes = self
                  .routes
                  .into_iter()
                  .map(|(id, endpoint)| {
                      let route = endpoint.layer(layer.clone());
                      (id, route)
                  })
                  .collect();
      
              PathRouter {
                  routes,
                  node: self.node,
                  prev_route_id: self.prev_route_id,
              }
          }
      *)
      Definition route_layer
          {L : Set}
          {ℋ_0 :
            tower_layer.Layer.Trait L
              (S := axum.routing.route.Route.t
                axum.routing.route.Route.Default.E)}
          {ℋ_1 : core.clone.Clone.Trait L}
          {ℋ_2 : core.marker.Send.Trait L}
          {ℋ_3 :
            tower_service.Service.Trait L::type["Service"].t
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
          {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
          {ℋ_6 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          {ℋ_7 :
            core.convert.Into.Trait
                (tower_service.Service.Error
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))
              (T := core.convert.Infallible.t)}
          {ℋ_8 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          (self : Self)
          (layer : L)
          : M Self :=
        let* self := M.alloc self in
        let* layer := M.alloc layer in
        M.read foo.
      
      Global Instance AssociatedFunction_route_layer
          {L : Set}
          {ℋ_0 :
            tower_layer.Layer.Trait L
              (S := axum.routing.route.Route.t
                axum.routing.route.Route.Default.E)}
          {ℋ_1 : core.clone.Clone.Trait L}
          {ℋ_2 : core.marker.Send.Trait L}
          {ℋ_3 :
            tower_service.Service.Trait L::type["Service"].t
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
          {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
          {ℋ_6 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          {ℋ_7 :
            core.convert.Into.Trait
                (tower_service.Service.Error
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))
              (T := core.convert.Infallible.t)}
          {ℋ_8 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))} :
        Notations.DoubleColon Self "route_layer" := {
        Notations.double_colon := route_layer (L := L);
      }.
      
      (*
          pub(super) fn with_state<S2>(self, state: S) -> PathRouter<S2, IS_FALLBACK> {
              let routes = self
                  .routes
                  .into_iter()
                  .map(|(id, endpoint)| {
                      let endpoint: Endpoint<S2> = match endpoint {
                          Endpoint::MethodRouter(method_router) => {
                              Endpoint::MethodRouter(method_router.with_state(state.clone()))
                          }
                          Endpoint::Route(route) => Endpoint::Route(route),
                      };
                      (id, endpoint)
                  })
                  .collect();
      
              PathRouter {
                  routes,
                  node: self.node,
                  prev_route_id: self.prev_route_id,
              }
          }
      *)
      Definition with_state
          {S2 : Set}
          (self : Self)
          (state : S)
          : M (axum.routing.path_router.PathRouter.t S2) :=
        let* self := M.alloc self in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_with_state {S2 : Set} :
        Notations.DoubleColon Self "with_state" := {
        Notations.double_colon := with_state (S2 := S2);
      }.
      
      (*
          pub(super) fn call_with_state(
              &self,
              mut req: Request,
              state: S,
          ) -> Result<RouteFuture<Infallible>, (Request, S)> {
              #[cfg(feature = "original-uri")]
              {
                  use crate::extract::OriginalUri;
      
                  if req.extensions().get::<OriginalUri>().is_none() {
                      let original_uri = OriginalUri(req.uri().clone());
                      req.extensions_mut().insert(original_uri);
                  }
              }
      
              let path = req.uri().path().to_owned();
      
              match self.node.at(&path) {
                  Ok(match_) => {
                      let id = *match_.value;
      
                      if !IS_FALLBACK {
                          #[cfg(feature = "matched-path")]
                          crate::extract::matched_path::set_matched_path_for_request(
                              id,
                              &self.node.route_id_to_path,
                              req.extensions_mut(),
                          );
                      }
      
                      url_params::insert_url_params(req.extensions_mut(), match_.params);
      
                      let endpoint = self
                          .routes
                          .get(&id)
                          .expect("no route for id. This is a bug in axum. Please file an issue");
      
                      match endpoint {
                          Endpoint::MethodRouter(method_router) => {
                              Ok(method_router.call_with_state(req, state))
                          }
                          Endpoint::Route(route) => Ok(route.clone().call(req)),
                      }
                  }
                  // explicitly handle all variants in case matchit adds
                  // new ones we need to handle differently
                  Err(
                      MatchError::NotFound
                      | MatchError::ExtraTrailingSlash
                      | MatchError::MissingTrailingSlash,
                  ) => Err((req, state)),
              }
          }
      *)
      Definition call_with_state
          (self : ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : S)
          :
            M
              (core.result.Result.t
                (axum.routing.route.RouteFuture.t core.convert.Infallible.t)
                (ltac:(axum_core.extract.Request
                  axum_core.extract.Request.Default.T)
                *
                S)) :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_call_with_state :
        Notations.DoubleColon Self "call_with_state" := {
        Notations.double_colon := call_with_state;
      }.
      
      (*
          pub(super) fn replace_endpoint(&mut self, path: &str, endpoint: Endpoint<S>) {
              match self.node.at(path) {
                  Ok(match_) => {
                      let id = *match_.value;
                      self.routes.insert(id, endpoint);
                  }
                  Err(_) => self
                      .route_endpoint(path, endpoint)
                      .expect("path wasn't matched so endpoint shouldn't exist"),
              }
          }
      *)
      Definition replace_endpoint
          (self : mut_ref Self)
          (path : ref str.t)
          (endpoint : axum.routing.Endpoint.t S)
          : M unit :=
        let* self := M.alloc self in
        let* path := M.alloc path in
        let* endpoint := M.alloc endpoint in
        M.read foo.
      
      Global Instance AssociatedFunction_replace_endpoint :
        Notations.DoubleColon Self "replace_endpoint" := {
        Notations.double_colon := replace_endpoint;
      }.
      
      (*
          fn next_route_id(&mut self) -> RouteId {
              let next_id = self
                  .prev_route_id
                  .0
                  .checked_add(1)
                  .expect("Over `u32::MAX` routes created. If you need this, please file an issue.");
              self.prev_route_id = RouteId(next_id);
              self.prev_route_id
          }
      *)
      Definition next_route_id
          (self : mut_ref Self)
          : M axum.routing.RouteId.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_next_route_id :
        Notations.DoubleColon Self "next_route_id" := {
        Notations.double_colon := next_route_id;
      }.
    End Impl_axum_routing_path_router_PathRouter_t_S_2.
    End Impl_axum_routing_path_router_PathRouter_t_S_2.
    
    Module  Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.
    Section Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.routing.path_router.PathRouter.t S.
      
      (*
          fn default() -> Self {
              Self {
                  routes: Default::default(),
                  node: Default::default(),
                  prev_route_id: RouteId(0),
              }
          }
      *)
      Definition default : M Self := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.
    End Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.
    Section Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.routing.path_router.PathRouter.t S.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("PathRouter")
                  .field("routes", &self.routes)
                  .field("node", &self.node)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.
    End Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.
    
    Module  Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.
    Section Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.routing.path_router.PathRouter.t S.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  routes: self.routes.clone(),
                  node: self.node.clone(),
                  prev_route_id: self.prev_route_id,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.
    End Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.
    
    Module  Node.
    Section Node.
      Record t : Set := {
        inner : matchit.router.Router.t axum.routing.RouteId.t;
        route_id_to_path :
          std.collections.hash.map.HashMap.t
            axum.routing.RouteId.t
            (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
            std.collections.hash.map.HashMap.Default.S;
        path_to_route_id :
          std.collections.hash.map.HashMap.t
            (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
            axum.routing.RouteId.t
            std.collections.hash.map.HashMap.Default.S;
      }.
      
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
      Definition Get_route_id_to_path :=
        Ref.map
          (fun α => Some α.(route_id_to_path))
          (fun β α => Some (α <| route_id_to_path := β |>)).
      Definition Get_path_to_route_id :=
        Ref.map
          (fun α => Some α.(path_to_route_id))
          (fun β α => Some (α <| path_to_route_id := β |>)).
    End Node.
    End Node.
    
    Module  Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.
    Section Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.
      Definition Self : Set := axum.routing.path_router.Node.t.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M axum.routing.path_router.Node.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.
    End Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.
    
    Module  Impl_core_default_Default_for_axum_routing_path_router_Node_t.
    Section Impl_core_default_Default_for_axum_routing_path_router_Node_t.
      Definition Self : Set := axum.routing.path_router.Node.t.
      
      (*
      Default
      *)
      Definition default : M axum.routing.path_router.Node.t := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_routing_path_router_Node_t.
    End Impl_core_default_Default_for_axum_routing_path_router_Node_t.
    
    Module  Impl_axum_routing_path_router_Node_t.
    Section Impl_axum_routing_path_router_Node_t.
      Definition Self : Set := axum.routing.path_router.Node.t.
      
      (*
          fn insert(
              &mut self,
              path: impl Into<String>,
              val: RouteId,
          ) -> Result<(), matchit::InsertError> {
              let path = path.into();
      
              self.inner.insert(&path, val)?;
      
              let shared_path: Arc<str> = path.into();
              self.route_id_to_path.insert(val, shared_path.clone());
              self.path_to_route_id.insert(shared_path, val);
      
              Ok(())
          }
      *)
      Definition insert
          {impl Into<String> : Set}
          {ℋ_0 :
            core.convert.Into.Trait impl Into<String>
              (T := alloc.string.String.t)}
          (self : mut_ref Self)
          (path : impl Into<String>)
          (val : axum.routing.RouteId.t)
          : M (core.result.Result.t unit matchit.error.InsertError.t) :=
        let* self := M.alloc self in
        let* path := M.alloc path in
        let* val := M.alloc val in
        M.read foo.
      
      Global Instance AssociatedFunction_insert
          {impl Into<String> : Set}
          {ℋ_0 :
            core.convert.Into.Trait impl Into<String>
              (T := alloc.string.String.t)} :
        Notations.DoubleColon Self "insert" := {
        Notations.double_colon :=
          insert (impl Into<String> := impl Into<String>);
      }.
      
      (*
          fn at<'n, 'p>(
              &'n self,
              path: &'p str,
          ) -> Result<matchit::Match<'n, 'p, &'n RouteId>, MatchError> {
              self.inner.at(path)
          }
      *)
      Definition at
          (self : ref Self)
          (path : ref str.t)
          :
            M
              (core.result.Result.t
                (matchit.router.Match.t (ref axum.routing.RouteId.t))
                matchit.error.MatchError.t) :=
        let* self := M.alloc self in
        let* path := M.alloc path in
        M.read foo.
      
      Global Instance AssociatedFunction_at :
        Notations.DoubleColon Self "at" := {
        Notations.double_colon := at;
      }.
    End Impl_axum_routing_path_router_Node_t.
    End Impl_axum_routing_path_router_Node_t.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.
    Section Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.
      Definition Self : Set := axum.routing.path_router.Node.t.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("Node")
                  .field("paths", &self.route_id_to_path)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.
    End Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.
    
    (*
    fn validate_nest_path(path: &str) -> &str {
        if path.is_empty() {
            // nesting at `""` and `"/"` should mean the same thing
            return "/";
        }
    
        if path.contains('*') {
            panic!("Invalid route: nested routes cannot contain wildcards ( * )");
        }
    
        path
    }
    *)
    Definition validate_nest_path (path : ref str.t) : M (ref str.t) :=
      let* path := M.alloc path in
      M.read foo.
    
    (*
    pub(crate) fn path_for_nested_route<'a>(prefix: &'a str, path: &'a str) -> Cow<'a, str> {
        debug_assert!(prefix.starts_with('/'));
        debug_assert!(path.starts_with('/'));
    
        if prefix.ends_with('/') {
            format!("{prefix}{}", path.trim_start_matches('/')).into()
        } else if path == "/" {
            prefix.into()
        } else {
            format!("{prefix}{path}").into()
        }
    }
    *)
    Definition path_for_nested_route
        (prefix : ref str.t)
        (path : ref str.t)
        : M (alloc.borrow.Cow.t str.t) :=
      let* prefix := M.alloc prefix in
      let* path := M.alloc path in
      M.read foo.
  End path_router.
  
  Module route.
    Module  Route.
    Section Route.
      Context {E : Set}.
      
      Record t : Set := {
        x0 :
          ltac:(axum.util.mutex.AxumMutex
            (tower.util.boxed_clone.BoxCloneService.t
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T)
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              E));
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End Route.
    End Route.
    
    Module  Impl_axum_routing_route_Route_t_E.
    Section Impl_axum_routing_route_Route_t_E.
      Context {E : Set}.
      
      Definition Self : Set := axum.routing.route.Route.t E.
      
      (*
          pub(crate) fn new<T>(svc: T) -> Self
          where
              T: Service<Request, Error = E> + Clone + Send + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
          {
              Self(AxumMutex::new(BoxCloneService::new(
                  svc.map_response(IntoResponse::into_response),
              )))
          }
      *)
      Definition new
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
          (svc : T)
          : M Self :=
        let* svc := M.alloc svc in
        M.read foo.
      
      Global Instance AssociatedFunction_new
          {T : Set}
          {ℋ_0 :
            tower_service.Service.Trait T
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_1 : core.clone.Clone.Trait T}
          {ℋ_2 : core.marker.Send.Trait T}
          {ℋ_3 :
            axum_core.response.into_response.IntoResponse.Trait
                T::type["Response"].t}
          {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new (T := T);
      }.
      
      (*
          pub(crate) fn oneshot_inner(
              &mut self,
              req: Request,
          ) -> Oneshot<BoxCloneService<Request, Response, E>, Request> {
              self.0.get_mut().unwrap().clone().oneshot(req)
          }
      *)
      Definition oneshot_inner
          (self : mut_ref Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          :
            M
              (tower.util.oneshot.Oneshot.t
                (tower.util.boxed_clone.BoxCloneService.t
                  ltac:(axum_core.extract.Request
                    axum_core.extract.Request.Default.T)
                  ltac:(axum_core.response.Response
                    axum_core.response.Response.Default.T)
                  E)
                ltac:(axum_core.extract.Request
                  axum_core.extract.Request.Default.T)) :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_oneshot_inner :
        Notations.DoubleColon Self "oneshot_inner" := {
        Notations.double_colon := oneshot_inner;
      }.
      
      (*
          pub(crate) fn layer<L, NewError>(self, layer: L) -> Route<NewError>
          where
              L: Layer<Route<E>> + Clone + Send + 'static,
              L::Service: Service<Request> + Clone + Send + 'static,
              <L::Service as Service<Request>>::Response: IntoResponse + 'static,
              <L::Service as Service<Request>>::Error: Into<NewError> + 'static,
              <L::Service as Service<Request>>::Future: Send + 'static,
              NewError: 'static,
          {
              let layer = (
                  MapRequestLayer::new(|req: Request<_>| req.map(Body::new)),
                  MapErrLayer::new(Into::into),
                  MapResponseLayer::new(IntoResponse::into_response),
                  layer,
              );
      
              Route::new(layer.layer(self))
          }
      *)
      Definition layer
          {L NewError : Set}
          {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
          {ℋ_1 : core.clone.Clone.Trait L}
          {ℋ_2 : core.marker.Send.Trait L}
          {ℋ_3 :
            tower_service.Service.Trait L::type["Service"].t
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
          {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
          {ℋ_6 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          {ℋ_7 :
            core.convert.Into.Trait
                (tower_service.Service.Error
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))
              (T := NewError)}
          {ℋ_8 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          (self : Self)
          (layer : L)
          : M (axum.routing.route.Route.t NewError) :=
        let* self := M.alloc self in
        let* layer := M.alloc layer in
        M.read foo.
      
      Global Instance AssociatedFunction_layer
          {L NewError : Set}
          {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
          {ℋ_1 : core.clone.Clone.Trait L}
          {ℋ_2 : core.marker.Send.Trait L}
          {ℋ_3 :
            tower_service.Service.Trait L::type["Service"].t
              (Request := ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))}
          {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
          {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
          {ℋ_6 :
            axum_core.response.into_response.IntoResponse.Trait
                (tower_service.Service.Response
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))}
          {ℋ_7 :
            core.convert.Into.Trait
                (tower_service.Service.Error
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))
              (T := NewError)}
          {ℋ_8 :
            core.marker.Send.Trait
                (tower_service.Service.Future
                  (Self := L::type["Service"].t)
                  (Trait := ltac:(refine _)))} :
        Notations.DoubleColon Self "layer" := {
        Notations.double_colon := layer (L := L) (NewError := NewError);
      }.
    End Impl_axum_routing_route_Route_t_E.
    End Impl_axum_routing_route_Route_t_E.
    
    Module  Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.
    Section Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.
      Context {E : Set}.
      
      Definition Self : Set := axum.routing.route.Route.t E.
      
      (*
          fn clone(&self) -> Self {
              Self(AxumMutex::new(self.0.lock().unwrap().clone()))
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.
    End Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.
    Section Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.
      Context {E : Set}.
      
      Definition Self : Set := axum.routing.route.Route.t E.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("Route").finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.
    End Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.
    
    Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.
    Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.
      Context {B E : Set}.
      
      Context
        {ℋ_0 : http_body.Body.Trait B}
        {ℋ_1 : core.marker.Send.Trait B}
        {ℋ_2 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}.
      
      Definition Self : Set := axum.routing.route.Route.t E.
      
      (*
          type Response = Response;
      *)
      Definition Response : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
          type Error = E;
      *)
      Definition Error : Set := E.
      
      (*
          type Future = RouteFuture<E>;
      *)
      Definition Future : Set := axum.routing.route.RouteFuture.t E.
      
      (*
          fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              Poll::Ready(Ok(()))
          }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (_cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* _cx := M.alloc _cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
          fn call(&mut self, req: Request<B>) -> Self::Future {
              let req = req.map(Body::new);
              RouteFuture::from_future(self.oneshot_inner(req))
          }
      *)
      Definition call
          (self : mut_ref Self)
          (req : ltac:(axum_core.extract.Request B))
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := ltac:(axum_core.extract.Request B)) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.
    End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.
    
    Module  RouteFuture.
    Section RouteFuture.
      Context (E : Set).
      
      Record t : Set := {
        kind : axum.routing.route.RouteFutureKind.t E;
        strip_body : bool.t;
        allow_header : core.option.Option.t bytes.bytes.Bytes.t;
      }.
      
      Definition Get_kind :=
        Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
      Definition Get_strip_body :=
        Ref.map
          (fun α => Some α.(strip_body))
          (fun β α => Some (α <| strip_body := β |>)).
      Definition Get_allow_header :=
        Ref.map
          (fun α => Some α.(allow_header))
          (fun β α => Some (α <| allow_header := β |>)).
    End RouteFuture.
    End RouteFuture.
    
    Module RouteFutureKind.
      Module Future.
        Record t : Set := {
          future :
            tower.util.oneshot.Oneshot.t
              (tower.util.boxed_clone.BoxCloneService.t
                ltac:(axum_core.extract.Request
                  axum_core.extract.Request.Default.T)
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                E)
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T);
        }.
      End Future.
      
      Module Response.
        Record t : Set := {
          response :
            core.option.Option.t
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T);
        }.
      End Response.
      
      Inductive t (E : Set) : Set :=
      | Future (_ : Future.t)
      | Response (_ : Response.t).
      
      Definition Get_Future_future :=
        Ref.map
          (fun α =>
            match α with | Future α => Some α.(Future.future) | _ => None end)
          (fun β α =>
            match α with
            | Future α => Some (Future (α <| Future.future := β |>))
            | _ => None
            end).
      
      Definition Get_Response_response :=
        Ref.map
          (fun α =>
            match α with
            | Response α => Some α.(Response.response)
            | _ => None
            end)
          (fun β α =>
            match α with
            | Response α => Some (Response (α <| Response.response := β |>))
            | _ => None
            end).
    End RouteFutureKind.
    
    Module RouteFutureKindProj.
      Module Future.
        Record t : Set := {
          future :
            core.pin.Pin.t
              (mut_ref
                (tower.util.oneshot.Oneshot.t
                  (tower.util.boxed_clone.BoxCloneService.t
                    ltac:(axum_core.extract.Request
                      axum_core.extract.Request.Default.T)
                    ltac:(axum_core.response.Response
                      axum_core.response.Response.Default.T)
                    E)
                  ltac:(axum_core.extract.Request
                    axum_core.extract.Request.Default.T)));
        }.
      End Future.
      
      Module Response.
        Record t : Set := {
          response :
            mut_ref
              (core.option.Option.t
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T));
        }.
      End Response.
      
      Inductive t (E : Set) : Set :=
      | Future (_ : Future.t)
      | Response (_ : Response.t).
      
      Definition Get_Future_future :=
        Ref.map
          (fun α =>
            match α with | Future α => Some α.(Future.future) | _ => None end)
          (fun β α =>
            match α with
            | Future α => Some (Future (α <| Future.future := β |>))
            | _ => None
            end).
      
      Definition Get_Response_response :=
        Ref.map
          (fun α =>
            match α with
            | Response α => Some α.(Response.response)
            | _ => None
            end)
          (fun β α =>
            match α with
            | Response α => Some (Response (α <| Response.response := β |>))
            | _ => None
            end).
    End RouteFutureKindProj.
    
    Module  Impl_axum_routing_route_RouteFuture_t_E.
    Section Impl_axum_routing_route_RouteFuture_t_E.
      Context {E : Set}.
      
      Definition Self : Set := axum.routing.route.RouteFuture.t E.
      
      (*
          pub(crate) fn from_future(
              future: Oneshot<BoxCloneService<Request, Response, E>, Request>,
          ) -> Self {
              Self {
                  kind: RouteFutureKind::Future { future },
                  strip_body: false,
                  allow_header: None,
              }
          }
      *)
      Definition from_future
          (future
            :
            tower.util.oneshot.Oneshot.t
              (tower.util.boxed_clone.BoxCloneService.t
                ltac:(axum_core.extract.Request
                  axum_core.extract.Request.Default.T)
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                E)
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T))
          : M Self :=
        let* future := M.alloc future in
        M.read foo.
      
      Global Instance AssociatedFunction_from_future :
        Notations.DoubleColon Self "from_future" := {
        Notations.double_colon := from_future;
      }.
      
      (*
          pub(crate) fn strip_body(mut self, strip_body: bool) -> Self {
              self.strip_body = strip_body;
              self
          }
      *)
      Definition strip_body (self : Self) (strip_body : bool.t) : M Self :=
        let* self := M.alloc self in
        let* strip_body := M.alloc strip_body in
        M.read foo.
      
      Global Instance AssociatedFunction_strip_body :
        Notations.DoubleColon Self "strip_body" := {
        Notations.double_colon := strip_body;
      }.
      
      (*
          pub(crate) fn allow_header(mut self, allow_header: Bytes) -> Self {
              self.allow_header = Some(allow_header);
              self
          }
      *)
      Definition allow_header
          (self : Self)
          (allow_header : bytes.bytes.Bytes.t)
          : M Self :=
        let* self := M.alloc self in
        let* allow_header := M.alloc allow_header in
        M.read foo.
      
      Global Instance AssociatedFunction_allow_header :
        Notations.DoubleColon Self "allow_header" := {
        Notations.double_colon := allow_header;
      }.
    End Impl_axum_routing_route_RouteFuture_t_E.
    End Impl_axum_routing_route_RouteFuture_t_E.
    
    Module  Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.
    Section Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.
      Context {E : Set}.
      
      Definition Self : Set := axum.routing.route.RouteFuture.t E.
      
      (*
          type Output = Result<Response, E>;
      *)
      Definition Output : Set :=
        core.result.Result.t
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            E.
      
      (*
          fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
              let this = self.project();
      
              let mut res = match this.kind.project() {
                  RouteFutureKindProj::Future { future } => match future.poll(cx) {
                      Poll::Ready(Ok(res)) => res,
                      Poll::Ready(Err(err)) => return Poll::Ready(Err(err)),
                      Poll::Pending => return Poll::Pending,
                  },
                  RouteFutureKindProj::Response { response } => {
                      response.take().expect("future polled after completion")
                  }
              };
      
              set_allow_header(res.headers_mut(), this.allow_header);
      
              // make sure to set content-length before removing the body
              set_content_length(res.size_hint(), res.headers_mut());
      
              let res = if *this.strip_body {
                  res.map(|_| Body::empty())
              } else {
                  res
              };
      
              Poll::Ready(Ok(res))
          }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.
    End Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.
    
    (*
    fn set_allow_header(headers: &mut HeaderMap, allow_header: &mut Option<Bytes>) {
        match allow_header.take() {
            Some(allow_header) if !headers.contains_key(header::ALLOW) => {
                headers.insert(
                    header::ALLOW,
                    HeaderValue::from_maybe_shared(allow_header).expect("invalid `Allow` header"),
                );
            }
            _ => {}
        }
    }
    *)
    Definition set_allow_header
        (headers
          :
          mut_ref
            (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
        (allow_header : mut_ref (core.option.Option.t bytes.bytes.Bytes.t))
        : M unit :=
      let* headers := M.alloc headers in
      let* allow_header := M.alloc allow_header in
      M.read foo.
    
    (*
    fn set_content_length(size_hint: http_body::SizeHint, headers: &mut HeaderMap) {
        if headers.contains_key(CONTENT_LENGTH) {
            return;
        }
    
        if let Some(size) = size_hint.exact() {
            let header_value = if size == 0 {
                #[allow(clippy::declare_interior_mutable_const)]
                const ZERO: HeaderValue = HeaderValue::from_static("0");
    
                ZERO
            } else {
                let mut buffer = itoa::Buffer::new();
                HeaderValue::from_str(buffer.format(size)).unwrap()
            };
    
            headers.insert(CONTENT_LENGTH, header_value);
        }
    }
    *)
    Definition set_content_length
        (size_hint : http_body.size_hint.SizeHint.t)
        (headers
          :
          mut_ref
            (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
        : M unit :=
      let* size_hint := M.alloc size_hint in
      let* headers := M.alloc headers in
      M.read foo.
    
    Module  InfallibleRouteFuture.
    Section InfallibleRouteFuture.
      Record t : Set := {
        future : axum.routing.route.RouteFuture.t core.convert.Infallible.t;
      }.
      
      Definition Get_future :=
        Ref.map
          (fun α => Some α.(future))
          (fun β α => Some (α <| future := β |>)).
    End InfallibleRouteFuture.
    End InfallibleRouteFuture.
    
    Module  Impl_axum_routing_route_InfallibleRouteFuture_t.
    Section Impl_axum_routing_route_InfallibleRouteFuture_t.
      Definition Self : Set := axum.routing.route.InfallibleRouteFuture.t.
      
      (*
          pub(crate) fn new(future: RouteFuture<Infallible>) -> Self {
              Self { future }
          }
      *)
      Definition new
          (future : axum.routing.route.RouteFuture.t core.convert.Infallible.t)
          : M Self :=
        let* future := M.alloc future in
        M.read foo.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
    End Impl_axum_routing_route_InfallibleRouteFuture_t.
    End Impl_axum_routing_route_InfallibleRouteFuture_t.
    
    Module  Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.
    Section Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.
      Definition Self : Set := axum.routing.route.InfallibleRouteFuture.t.
      
      (*
          type Output = Response;
      *)
      Definition Output : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
          fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
              match futures_util::ready!(self.project().future.poll(cx)) {
                  Ok(response) => Poll::Ready(response),
                  Err(err) => match err {},
              }
          }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.
    End Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.
  End route.
  
  Module strip_prefix.
    Module  StripPrefix.
    Section StripPrefix.
      Context (S : Set).
      
      Record t : Set := {
        inner : S;
        prefix : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
      }.
      
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
      Definition Get_prefix :=
        Ref.map
          (fun α => Some α.(prefix))
          (fun β α => Some (α <| prefix := β |>)).
    End StripPrefix.
    End StripPrefix.
    
    Module  Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.
    Section Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set := axum.routing.strip_prefix.StripPrefix.t S.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M (axum.routing.strip_prefix.StripPrefix.t S) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.
    End Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.
    
    Module  Impl_axum_routing_strip_prefix_StripPrefix_t_S.
    Section Impl_axum_routing_strip_prefix_StripPrefix_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.routing.strip_prefix.StripPrefix.t S.
      
      (*
          pub(super) fn layer(prefix: &str) -> impl Layer<S, Service = Self> + Clone {
              let prefix = Arc::from(prefix);
              layer_fn(move |inner| Self {
                  inner,
                  prefix: Arc::clone(&prefix),
              })
          }
      *)
      Definition layer (prefix : ref str.t) : M _ (* OpaqueTy *) :=
        let* prefix := M.alloc prefix in
        M.read foo.
      
      Global Instance AssociatedFunction_layer :
        Notations.DoubleColon Self "layer" := {
        Notations.double_colon := layer;
      }.
    End Impl_axum_routing_strip_prefix_StripPrefix_t_S.
    End Impl_axum_routing_strip_prefix_StripPrefix_t_S.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.
      Context {S B : Set}.
      
      Context
        {ℋ_0 :
          tower_service.Service.Trait S (Request := http.request.Request.t B)}.
      
      Definition Self : Set := axum.routing.strip_prefix.StripPrefix.t S.
      
      (*
          type Response = S::Response;
      *)
      Definition Response : Set := S::type["Response"].t.
      
      (*
          type Error = S::Error;
      *)
      Definition Error : Set := S::type["Error"].t.
      
      (*
          type Future = S::Future;
      *)
      Definition Future : Set := S::type["Future"].t.
      
      (*
          fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              self.inner.poll_ready(cx)
          }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
          fn call(&mut self, mut req: Request<B>) -> Self::Future {
              if let Some(new_uri) = strip_prefix(req.uri(), &self.prefix) {
                  *req.uri_mut() = new_uri;
              }
              self.inner.call(req)
          }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.
    
    (*
    fn strip_prefix(uri: &Uri, prefix: &str) -> Option<Uri> {
        let path_and_query = uri.path_and_query()?;
    
        // Check whether the prefix matches the path and if so how long the matching prefix is.
        //
        // For example:
        //
        // prefix = /api
        // path   = /api/users
        //          ^^^^ this much is matched and the length is 4. Thus if we chop off the first 4
        //          characters we get the remainder
        //
        // prefix = /api/:version
        // path   = /api/v0/users
        //          ^^^^^^^ this much is matched and the length is 7.
        let mut matching_prefix_length = Some(0);
        for item in zip_longest(segments(path_and_query.path()), segments(prefix)) {
            // count the `/`
            *matching_prefix_length.as_mut().unwrap() += 1;
    
            match item {
                Item::Both(path_segment, prefix_segment) => {
                    if prefix_segment.starts_with(':') || path_segment == prefix_segment {
                        // the prefix segment is either a param, which matches anything, or
                        // it actually matches the path segment
                        *matching_prefix_length.as_mut().unwrap() += path_segment.len();
                    } else if prefix_segment.is_empty() {
                        // the prefix ended in a `/` so we got a match.
                        //
                        // For example:
                        //
                        // prefix = /foo/
                        // path   = /foo/bar
                        //
                        // The prefix matches and the new path should be `/bar`
                        break;
                    } else {
                        // the prefix segment didn't match so there is no match
                        matching_prefix_length = None;
                        break;
                    }
                }
                // the path had more segments than the prefix but we got a match.
                //
                // For example:
                //
                // prefix = /foo
                // path   = /foo/bar
                Item::First(_) => {
                    break;
                }
                // the prefix had more segments than the path so there is no match
                Item::Second(_) => {
                    matching_prefix_length = None;
                    break;
                }
            }
        }
    
        // if the prefix matches it will always do so up until a `/`, it cannot match only
        // part of a segment. Therefore this will always be at a char boundary and `split_at` wont
        // panic
        let after_prefix = uri.path().split_at(matching_prefix_length?).1;
    
        let new_path_and_query = match (after_prefix.starts_with('/'), path_and_query.query()) {
            (true, None) => after_prefix.parse().unwrap(),
            (true, Some(query)) => format!("{after_prefix}?{query}").parse().unwrap(),
            (false, None) => format!("/{after_prefix}").parse().unwrap(),
            (false, Some(query)) => format!("/{after_prefix}?{query}").parse().unwrap(),
        };
    
        let mut parts = uri.clone().into_parts();
        parts.path_and_query = Some(new_path_and_query);
    
        Some(Uri::from_parts(parts).unwrap())
    }
    *)
    Definition strip_prefix
        (uri : ref http.uri.Uri.t)
        (prefix : ref str.t)
        : M (core.option.Option.t http.uri.Uri.t) :=
      let* uri := M.alloc uri in
      let* prefix := M.alloc prefix in
      M.read foo.
    
    (*
    fn segments(s: &str) -> impl Iterator<Item = &str> {
        assert!(
            s.starts_with('/'),
            "path didn't start with '/'. axum should have caught this higher up."
        );
    
        s.split('/')
            // skip one because paths always start with `/` so `/a/b` would become ["", "a", "b"]
            // otherwise
            .skip(1)
    }
    *)
    Definition segments (s : ref str.t) : M OpaqueDef :=
      let* s := M.alloc s in
      M.read foo.
    
    (*
    fn zip_longest<I, I2>(a: I, b: I2) -> impl Iterator<Item = Item<I::Item>>
    where
        I: Iterator,
        I2: Iterator<Item = I::Item>,
    {
        let a = a.map(Some).chain(std::iter::repeat_with(|| None));
        let b = b.map(Some).chain(std::iter::repeat_with(|| None));
        a.zip(b).map_while(|(a, b)| match (a, b) {
            (Some(a), Some(b)) => Some(Item::Both(a, b)),
            (Some(a), None) => Some(Item::First(a)),
            (None, Some(b)) => Some(Item::Second(b)),
            (None, None) => None,
        })
    }
    *)
    Definition zip_longest
        {I I2 : Set}
        {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}
        {ℋ_1 : core.iter.traits.iterator.Iterator.Trait I2}
        (a : I)
        (b : I2)
        : M _ (* OpaqueTy *) :=
      let* a := M.alloc a in
      let* b := M.alloc b in
      M.read foo.
    
    Module Item.
      Inductive t (T : Set) : Set :=
      | Both (_ : T) (_ : T)
      | First (_ : T)
      | Second (_ : T).
      
      Definition Get_Both_0 :=
        Ref.map
          (fun α => match α with | Both α0 _ => Some α0 | _ => None end)
          (fun β α =>
            match α with | Both _ α1 => Some (Both β α1) | _ => None end).
      
      Definition Get_Both_1 :=
        Ref.map
          (fun α => match α with | Both _ α1 => Some α1 | _ => None end)
          (fun β α =>
            match α with | Both α0 _ => Some (Both α0 β) | _ => None end).
      
      Definition Get_First_0 :=
        Ref.map
          (fun α => match α with | First α0 => Some α0 | _ => None end)
          (fun β α => match α with | First _ => Some (First β) | _ => None end).
      
      Definition Get_Second_0 :=
        Ref.map
          (fun α => match α with | Second α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with | Second _ => Some (Second β) | _ => None end).
    End Item.
    
    Module  Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.
    Section Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait T}.
      
      Definition Self : Set := axum.routing.strip_prefix.Item.t T.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.
    End Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.
  End strip_prefix.
  
  Module url_params.
    Module UrlParams.
      Module InvalidUtf8InPathParam.
        Record t : Set := {
          key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
        }.
      End InvalidUtf8InPathParam.
      
      Inductive t : Set :=
      |
        Params
        (_ :
          alloc.vec.Vec.t
            ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
            *
            axum.util.PercentDecodedStr.t)
            alloc.vec.Vec.Default.A)
      | InvalidUtf8InPathParam (_ : InvalidUtf8InPathParam.t).
      
      Definition Get_Params_0 :=
        Ref.map
          (fun α => match α with | Params α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with | Params _ => Some (Params β) | _ => None end).
      
      Definition Get_InvalidUtf8InPathParam_key :=
        Ref.map
          (fun α =>
            match α with
            | InvalidUtf8InPathParam α => Some α.(InvalidUtf8InPathParam.key)
            | _ => None
            end)
          (fun β α =>
            match α with
            | InvalidUtf8InPathParam α =>
              Some
                (InvalidUtf8InPathParam
                  (α <| InvalidUtf8InPathParam.key := β |>))
            | _ => None
            end).
    End UrlParams.
    
    Module  Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.
    Section Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.
      Definition Self : Set := axum.routing.url_params.UrlParams.t.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum.routing.url_params.UrlParams.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.
    End Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.
    
    (*
    pub(super) fn insert_url_params(extensions: &mut Extensions, params: Params) {
        let current_params = extensions.get_mut();
    
        if let Some(UrlParams::InvalidUtf8InPathParam { .. }) = current_params {
            // nothing to do here since an error was stored earlier
            return;
        }
    
        let params = params
            .iter()
            .filter(|(key, _)| !key.starts_with(super::NEST_TAIL_PARAM))
            .filter(|(key, _)| !key.starts_with(super::FALLBACK_PARAM))
            .map(|(k, v)| {
                if let Some(decoded) = PercentDecodedStr::new(v) {
                    Ok((Arc::from(k), decoded))
                } else {
                    Err(Arc::from(k))
                }
            })
            .collect::<Result<Vec<_>, _>>();
    
        match (current_params, params) {
            (Some(UrlParams::InvalidUtf8InPathParam { .. }), _) => {
                unreachable!("we check for this state earlier in this method")
            }
            (_, Err(invalid_key)) => {
                extensions.insert(UrlParams::InvalidUtf8InPathParam { key: invalid_key });
            }
            (Some(UrlParams::Params(current)), Ok(params)) => {
                current.extend(params);
            }
            (None, Ok(params)) => {
                extensions.insert(UrlParams::Params(params));
            }
        }
    }
    *)
    Definition insert_url_params
        (extensions : mut_ref http.extensions.Extensions.t)
        (params : matchit.params.Params.t)
        : M unit :=
      let* extensions := M.alloc extensions in
      let* params := M.alloc params in
      M.read foo.
  End url_params.
  
  Module  RouteId.
  Section RouteId.
    Record t : Set := {
      x0 : u32.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End RouteId.
  End RouteId.
  
  Module  Impl_core_clone_Clone_for_axum_routing_RouteId_t.
  Section Impl_core_clone_Clone_for_axum_routing_RouteId_t.
    Definition Self : Set := axum.routing.RouteId.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum.routing.RouteId.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_RouteId_t.
  End Impl_core_clone_Clone_for_axum_routing_RouteId_t.
  
  Module  Impl_core_marker_Copy_for_axum_routing_RouteId_t.
  Section Impl_core_marker_Copy_for_axum_routing_RouteId_t.
    Definition Self : Set := axum.routing.RouteId.t.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_routing_RouteId_t.
  End Impl_core_marker_Copy_for_axum_routing_RouteId_t.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_RouteId_t.
  Section Impl_core_fmt_Debug_for_axum_routing_RouteId_t.
    Definition Self : Set := axum.routing.RouteId.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_RouteId_t.
  End Impl_core_fmt_Debug_for_axum_routing_RouteId_t.
  
  Module  Impl_core_marker_StructuralPartialEq_for_axum_routing_RouteId_t.
  Section Impl_core_marker_StructuralPartialEq_for_axum_routing_RouteId_t.
    Definition Self : Set := axum.routing.RouteId.t.
    
    Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralPartialEq_for_axum_routing_RouteId_t.
  End Impl_core_marker_StructuralPartialEq_for_axum_routing_RouteId_t.
  
  Module  Impl_core_cmp_PartialEq_for_axum_routing_RouteId_t.
  Section Impl_core_cmp_PartialEq_for_axum_routing_RouteId_t.
    Definition Self : Set := axum.routing.RouteId.t.
    
    (*
    PartialEq
    *)
    Definition eq
        (self : ref Self)
        (other : ref axum.routing.RouteId.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_axum_routing_RouteId_t.
  End Impl_core_cmp_PartialEq_for_axum_routing_RouteId_t.
  
  Module  Impl_core_marker_StructuralEq_for_axum_routing_RouteId_t.
  Section Impl_core_marker_StructuralEq_for_axum_routing_RouteId_t.
    Definition Self : Set := axum.routing.RouteId.t.
    
    Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralEq_for_axum_routing_RouteId_t.
  End Impl_core_marker_StructuralEq_for_axum_routing_RouteId_t.
  
  Module  Impl_core_cmp_Eq_for_axum_routing_RouteId_t.
  Section Impl_core_cmp_Eq_for_axum_routing_RouteId_t.
    Definition Self : Set := axum.routing.RouteId.t.
    
    (*
    Eq
    *)
    Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_assert_receiver_is_total_eq :
      Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
      Notations.double_colon := assert_receiver_is_total_eq;
    }.
    
    Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
      core.cmp.Eq.assert_receiver_is_total_eq :=
        Datatypes.Some assert_receiver_is_total_eq;
    }.
  End Impl_core_cmp_Eq_for_axum_routing_RouteId_t.
  End Impl_core_cmp_Eq_for_axum_routing_RouteId_t.
  
  Module  Impl_core_cmp_PartialOrd_for_axum_routing_RouteId_t.
  Section Impl_core_cmp_PartialOrd_for_axum_routing_RouteId_t.
    Definition Self : Set := axum.routing.RouteId.t.
    
    (*
    PartialOrd
    *)
    Definition partial_cmp
        (self : ref Self)
        (other : ref axum.routing.RouteId.t)
        : M (core.option.Option.t core.cmp.Ordering.t) :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_partial_cmp :
      Notations.DoubleColon Self "partial_cmp" := {
      Notations.double_colon := partial_cmp;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialOrd.Required.Trait Self
        (Rhs := core.cmp.PartialOrd.Default.Rhs Self) := {
      core.cmp.PartialOrd.partial_cmp := partial_cmp;
      core.cmp.PartialOrd.lt := Datatypes.None;
      core.cmp.PartialOrd.le := Datatypes.None;
      core.cmp.PartialOrd.gt := Datatypes.None;
      core.cmp.PartialOrd.ge := Datatypes.None;
    }.
  End Impl_core_cmp_PartialOrd_for_axum_routing_RouteId_t.
  End Impl_core_cmp_PartialOrd_for_axum_routing_RouteId_t.
  
  Module  Impl_core_cmp_Ord_for_axum_routing_RouteId_t.
  Section Impl_core_cmp_Ord_for_axum_routing_RouteId_t.
    Definition Self : Set := axum.routing.RouteId.t.
    
    (*
    Ord
    *)
    Definition cmp
        (self : ref Self)
        (other : ref axum.routing.RouteId.t)
        : M core.cmp.Ordering.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_cmp :
      Notations.DoubleColon Self "cmp" := {
      Notations.double_colon := cmp;
    }.
    
    Global Instance ℐ : core.cmp.Ord.Required.Trait Self := {
      core.cmp.Ord.cmp := cmp;
      core.cmp.Ord.max := Datatypes.None;
      core.cmp.Ord.min := Datatypes.None;
      core.cmp.Ord.clamp := Datatypes.None;
    }.
  End Impl_core_cmp_Ord_for_axum_routing_RouteId_t.
  End Impl_core_cmp_Ord_for_axum_routing_RouteId_t.
  
  Module  Impl_core_hash_Hash_for_axum_routing_RouteId_t.
  Section Impl_core_hash_Hash_for_axum_routing_RouteId_t.
    Definition Self : Set := axum.routing.RouteId.t.
    
    (*
    Hash
    *)
    Definition hash
        {__H : Set}
        {ℋ_0 : core.hash.Hasher.Trait __H}
        (self : ref Self)
        (state : mut_ref __H)
        : M unit :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_hash
        {__H : Set}
        {ℋ_0 : core.hash.Hasher.Trait __H} :
      Notations.DoubleColon Self "hash" := {
      Notations.double_colon := hash (__H := __H);
    }.
    
    Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
      core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
        hash (__H := __H);
      core.hash.Hash.hash_slice := Datatypes.None;
    }.
  End Impl_core_hash_Hash_for_axum_routing_RouteId_t.
  End Impl_core_hash_Hash_for_axum_routing_RouteId_t.
  
  Module  Router.
  Section Router.
    Context (S : Set).
    
    Record t : Set := {
      inner :
        alloc.sync.Arc.t
          (axum.routing.RouterInner.t S)
          alloc.sync.Arc.Default.A;
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Module Default.
      Definition S := unit.
    End Default.
  End Router.
  End Router.
  
  Module  Impl_core_clone_Clone_for_axum_routing_Router_t_S.
  Section Impl_core_clone_Clone_for_axum_routing_Router_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.Router.t S.
    
    (*
        fn clone(&self) -> Self {
            Self {
                inner: Arc::clone(&self.inner),
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_Router_t_S.
  End Impl_core_clone_Clone_for_axum_routing_Router_t_S.
  
  Module  RouterInner.
  Section RouterInner.
    Context (S : Set).
    
    Record t : Set := {
      path_router : axum.routing.path_router.PathRouter.t S;
      fallback_router : axum.routing.path_router.PathRouter.t S;
      default_fallback : bool.t;
      catch_all_fallback :
        axum.routing.Fallback.t S axum.routing.Fallback.Default.E;
    }.
    
    Definition Get_path_router :=
      Ref.map
        (fun α => Some α.(path_router))
        (fun β α => Some (α <| path_router := β |>)).
    Definition Get_fallback_router :=
      Ref.map
        (fun α => Some α.(fallback_router))
        (fun β α => Some (α <| fallback_router := β |>)).
    Definition Get_default_fallback :=
      Ref.map
        (fun α => Some α.(default_fallback))
        (fun β α => Some (α <| default_fallback := β |>)).
    Definition Get_catch_all_fallback :=
      Ref.map
        (fun α => Some α.(catch_all_fallback))
        (fun β α => Some (α <| catch_all_fallback := β |>)).
  End RouterInner.
  End RouterInner.
  
  Module  Impl_core_default_Default_for_axum_routing_Router_t_S.
  Section Impl_core_default_Default_for_axum_routing_Router_t_S.
    Context {S : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait S}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.routing.Router.t S.
    
    (*
        fn default() -> Self {
            Self::new()
        }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_routing_Router_t_S.
  End Impl_core_default_Default_for_axum_routing_Router_t_S.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_Router_t_S.
  Section Impl_core_fmt_Debug_for_axum_routing_Router_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.Router.t S.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Router")
                .field("path_router", &self.inner.path_router)
                .field("fallback_router", &self.inner.fallback_router)
                .field("default_fallback", &self.inner.default_fallback)
                .field("catch_all_fallback", &self.inner.catch_all_fallback)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_Router_t_S.
  End Impl_core_fmt_Debug_for_axum_routing_Router_t_S.
  
  Definition NEST_TAIL_PARAM : M.Val (ref str.t) := M.run (M.pure foo).
  
  Definition NEST_TAIL_PARAM_CAPTURE : M.Val (ref str.t) := M.run (M.pure foo).
  
  Definition FALLBACK_PARAM : M.Val (ref str.t) := M.run (M.pure foo).
  
  Definition FALLBACK_PARAM_PATH : M.Val (ref str.t) := M.run (M.pure foo).
  
  Module  Impl_axum_routing_Router_t_S.
  Section Impl_axum_routing_Router_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.Router.t S.
    
    (*
        pub fn new() -> Self {
            Self {
                inner: Arc::new(RouterInner {
                    path_router: Default::default(),
                    fallback_router: PathRouter::new_fallback(),
                    default_fallback: true,
                    catch_all_fallback: Fallback::Default(Route::new(NotFound)),
                }),
            }
        }
    *)
    Definition new : M Self := M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
    
    (*
        fn map_inner<F, S2>(self, f: F) -> Router<S2>
        where
            F: FnOnce(RouterInner<S>) -> RouterInner<S2>,
        {
            Router {
                inner: Arc::new(f(self.into_inner())),
            }
        }
    *)
    Definition map_inner
        {F S2 : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := axum.routing.RouterInner.t S)}
        (self : Self)
        (f : F)
        : M (axum.routing.Router.t S2) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_map_inner
        {F S2 : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := axum.routing.RouterInner.t S)} :
      Notations.DoubleColon Self "map_inner" := {
      Notations.double_colon := map_inner (F := F) (S2 := S2);
    }.
    
    (*
        fn tap_inner_mut<F>(self, f: F) -> Self
        where
            F: FnOnce(&mut RouterInner<S>),
        {
            let mut inner = self.into_inner();
            f(&mut inner);
            Router {
                inner: Arc::new(inner),
            }
        }
    *)
    Definition tap_inner_mut
        {F : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := mut_ref (axum.routing.RouterInner.t S))}
        (self : Self)
        (f : F)
        : M Self :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_tap_inner_mut
        {F : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := mut_ref (axum.routing.RouterInner.t S))} :
      Notations.DoubleColon Self "tap_inner_mut" := {
      Notations.double_colon := tap_inner_mut (F := F);
    }.
    
    (*
        fn into_inner(self) -> RouterInner<S> {
            match Arc::try_unwrap(self.inner) {
                Ok(inner) => inner,
                Err(arc) => RouterInner {
                    path_router: arc.path_router.clone(),
                    fallback_router: arc.fallback_router.clone(),
                    default_fallback: arc.default_fallback,
                    catch_all_fallback: arc.catch_all_fallback.clone(),
                },
            }
        }
    *)
    Definition into_inner (self : Self) : M (axum.routing.RouterInner.t S) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_inner :
      Notations.DoubleColon Self "into_inner" := {
      Notations.double_colon := into_inner;
    }.
    
    (*
        pub fn route(self, path: &str, method_router: MethodRouter<S>) -> Self {
            self.tap_inner_mut(|this| {
                panic_on_err!(this.path_router.route(path, method_router));
            })
        }
    *)
    Definition route
        (self : Self)
        (path : ref str.t)
        (method_router
          :
          axum.routing.method_routing.MethodRouter.t
            S
            axum.routing.method_routing.MethodRouter.Default.E)
        : M Self :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* method_router := M.alloc method_router in
      M.read foo.
    
    Global Instance AssociatedFunction_route :
      Notations.DoubleColon Self "route" := {
      Notations.double_colon := route;
    }.
    
    (*
        pub fn route_service<T>(self, path: &str, service: T) -> Self
        where
            T: Service<Request, Error = Infallible> + Clone + Send + 'static,
            T::Response: IntoResponse,
            T::Future: Send + 'static,
        {
            let service = match try_downcast::<Router<S>, _>(service) {
                Ok(_) => {
                    panic!(
                        "Invalid route: `Router::route_service` cannot be used with `Router`s. \
                         Use `Router::nest` instead"
                    );
                }
                Err(service) => service,
            };
    
            self.tap_inner_mut(|this| {
                panic_on_err!(this.path_router.route_service(path, service));
            })
        }
    *)
    Definition route_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (path : ref str.t)
        (service : T)
        : M Self :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* service := M.alloc service in
      M.read foo.
    
    Global Instance AssociatedFunction_route_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "route_service" := {
      Notations.double_colon := route_service (T := T);
    }.
    
    (*
        pub fn nest(self, path: &str, router: Router<S>) -> Self {
            let RouterInner {
                path_router,
                fallback_router,
                default_fallback,
                // we don't need to inherit the catch-all fallback. It is only used for CONNECT
                // requests with an empty path. If we were to inherit the catch-all fallback
                // it would end up matching `/{path}/*` which doesn't match empty paths.
                catch_all_fallback: _,
            } = router.into_inner();
    
            self.tap_inner_mut(|this| {
                panic_on_err!(this.path_router.nest(path, path_router));
    
                if !default_fallback {
                    panic_on_err!(this.fallback_router.nest(path, fallback_router));
                }
            })
        }
    *)
    Definition nest
        (self : Self)
        (path : ref str.t)
        (router : axum.routing.Router.t S)
        : M Self :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* router := M.alloc router in
      M.read foo.
    
    Global Instance AssociatedFunction_nest :
      Notations.DoubleColon Self "nest" := {
      Notations.double_colon := nest;
    }.
    
    (*
        pub fn nest_service<T>(self, path: &str, service: T) -> Self
        where
            T: Service<Request, Error = Infallible> + Clone + Send + 'static,
            T::Response: IntoResponse,
            T::Future: Send + 'static,
        {
            self.tap_inner_mut(|this| {
                panic_on_err!(this.path_router.nest_service(path, service));
            })
        }
    *)
    Definition nest_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (path : ref str.t)
        (service : T)
        : M Self :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* service := M.alloc service in
      M.read foo.
    
    Global Instance AssociatedFunction_nest_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "nest_service" := {
      Notations.double_colon := nest_service (T := T);
    }.
    
    (*
        pub fn merge<R>(self, other: R) -> Self
        where
            R: Into<Router<S>>,
        {
            const PANIC_MSG: &str =
                "Failed to merge fallbacks. This is a bug in axum. Please file an issue";
    
            let other: Router<S> = other.into();
            let RouterInner {
                path_router,
                fallback_router: mut other_fallback,
                default_fallback,
                catch_all_fallback,
            } = other.into_inner();
    
            self.map_inner(|mut this| {
                panic_on_err!(this.path_router.merge(path_router));
    
                match (this.default_fallback, default_fallback) {
                    // both have the default fallback
                    // use the one from other
                    (true, true) => {
                        this.fallback_router.merge(other_fallback).expect(PANIC_MSG);
                    }
                    // this has default fallback, other has a custom fallback
                    (true, false) => {
                        this.fallback_router.merge(other_fallback).expect(PANIC_MSG);
                        this.default_fallback = false;
                    }
                    // this has a custom fallback, other has a default
                    (false, true) => {
                        let fallback_router = std::mem::take(&mut this.fallback_router);
                        other_fallback.merge(fallback_router).expect(PANIC_MSG);
                        this.fallback_router = other_fallback;
                    }
                    // both have a custom fallback, not allowed
                    (false, false) => {
                        panic!("Cannot merge two `Router`s that both have a fallback")
                    }
                };
    
                this.catch_all_fallback = this
                    .catch_all_fallback
                    .merge(catch_all_fallback)
                    .unwrap_or_else(|| panic!("Cannot merge two `Router`s that both have a fallback"));
    
                this
            })
        }
    *)
    Definition merge
        {R : Set}
        {ℋ_0 : core.convert.Into.Trait R (T := axum.routing.Router.t S)}
        (self : Self)
        (other : R)
        : M Self :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_merge
        {R : Set}
        {ℋ_0 : core.convert.Into.Trait R (T := axum.routing.Router.t S)} :
      Notations.DoubleColon Self "merge" := {
      Notations.double_colon := merge (R := R);
    }.
    
    (*
        pub fn layer<L>(self, layer: L) -> Router<S>
        where
            L: Layer<Route> + Clone + Send + 'static,
            L::Service: Service<Request> + Clone + Send + 'static,
            <L::Service as Service<Request>>::Response: IntoResponse + 'static,
            <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
            <L::Service as Service<Request>>::Future: Send + 'static,
        {
            self.map_inner(|this| RouterInner {
                path_router: this.path_router.layer(layer.clone()),
                fallback_router: this.fallback_router.layer(layer.clone()),
                default_fallback: this.default_fallback,
                catch_all_fallback: this.catch_all_fallback.map(|route| route.layer(layer)),
            })
        }
    *)
    Definition layer
        {L : Set}
        {ℋ_0 :
          tower_layer.Layer.Trait L
            (S := axum.routing.route.Route.t
              axum.routing.route.Route.Default.E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := core.convert.Infallible.t)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        (self : Self)
        (layer : L)
        : M (axum.routing.Router.t S) :=
      let* self := M.alloc self in
      let* layer := M.alloc layer in
      M.read foo.
    
    Global Instance AssociatedFunction_layer
        {L : Set}
        {ℋ_0 :
          tower_layer.Layer.Trait L
            (S := axum.routing.route.Route.t
              axum.routing.route.Route.Default.E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := core.convert.Infallible.t)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))} :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer (L := L);
    }.
    
    (*
        pub fn route_layer<L>(self, layer: L) -> Self
        where
            L: Layer<Route> + Clone + Send + 'static,
            L::Service: Service<Request> + Clone + Send + 'static,
            <L::Service as Service<Request>>::Response: IntoResponse + 'static,
            <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
            <L::Service as Service<Request>>::Future: Send + 'static,
        {
            self.map_inner(|this| RouterInner {
                path_router: this.path_router.route_layer(layer),
                fallback_router: this.fallback_router,
                default_fallback: this.default_fallback,
                catch_all_fallback: this.catch_all_fallback,
            })
        }
    *)
    Definition route_layer
        {L : Set}
        {ℋ_0 :
          tower_layer.Layer.Trait L
            (S := axum.routing.route.Route.t
              axum.routing.route.Route.Default.E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := core.convert.Infallible.t)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        (self : Self)
        (layer : L)
        : M Self :=
      let* self := M.alloc self in
      let* layer := M.alloc layer in
      M.read foo.
    
    Global Instance AssociatedFunction_route_layer
        {L : Set}
        {ℋ_0 :
          tower_layer.Layer.Trait L
            (S := axum.routing.route.Route.t
              axum.routing.route.Route.Default.E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := core.convert.Infallible.t)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))} :
      Notations.DoubleColon Self "route_layer" := {
      Notations.double_colon := route_layer (L := L);
    }.
    
    (*
        pub fn fallback<H, T>(self, handler: H) -> Self
        where
            H: Handler<T, S>,
            T: 'static,
        {
            self.tap_inner_mut(|this| {
                this.catch_all_fallback =
                    Fallback::BoxedHandler(BoxedIntoRoute::from_handler(handler.clone()));
            })
            .fallback_endpoint(Endpoint::MethodRouter(any(handler)))
        }
    *)
    Definition fallback
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_fallback
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
      Notations.DoubleColon Self "fallback" := {
      Notations.double_colon := fallback (H := H) (T := T);
    }.
    
    (*
        pub fn fallback_service<T>(self, service: T) -> Self
        where
            T: Service<Request, Error = Infallible> + Clone + Send + 'static,
            T::Response: IntoResponse,
            T::Future: Send + 'static,
        {
            let route = Route::new(service);
            self.tap_inner_mut(|this| {
                this.catch_all_fallback = Fallback::Service(route.clone());
            })
            .fallback_endpoint(Endpoint::Route(route))
        }
    *)
    Definition fallback_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (service : T)
        : M Self :=
      let* self := M.alloc self in
      let* service := M.alloc service in
      M.read foo.
    
    Global Instance AssociatedFunction_fallback_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "fallback_service" := {
      Notations.double_colon := fallback_service (T := T);
    }.
    
    (*
        fn fallback_endpoint(self, endpoint: Endpoint<S>) -> Self {
            self.tap_inner_mut(|this| {
                this.fallback_router.set_fallback(endpoint);
                this.default_fallback = false;
            })
        }
    *)
    Definition fallback_endpoint
        (self : Self)
        (endpoint : axum.routing.Endpoint.t S)
        : M Self :=
      let* self := M.alloc self in
      let* endpoint := M.alloc endpoint in
      M.read foo.
    
    Global Instance AssociatedFunction_fallback_endpoint :
      Notations.DoubleColon Self "fallback_endpoint" := {
      Notations.double_colon := fallback_endpoint;
    }.
    
    (*
        pub fn with_state<S2>(self, state: S) -> Router<S2> {
            self.map_inner(|this| RouterInner {
                path_router: this.path_router.with_state(state.clone()),
                fallback_router: this.fallback_router.with_state(state.clone()),
                default_fallback: this.default_fallback,
                catch_all_fallback: this.catch_all_fallback.with_state(state),
            })
        }
    *)
    Definition with_state
        {S2 : Set}
        (self : Self)
        (state : S)
        : M (axum.routing.Router.t S2) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_with_state {S2 : Set} :
      Notations.DoubleColon Self "with_state" := {
      Notations.double_colon := with_state (S2 := S2);
    }.
    
    (*
        pub(crate) fn call_with_state(&self, req: Request, state: S) -> RouteFuture<Infallible> {
            let (req, state) = match self.inner.path_router.call_with_state(req, state) {
                Ok(future) => return future,
                Err((req, state)) => (req, state),
            };
    
            let (req, state) = match self.inner.fallback_router.call_with_state(req, state) {
                Ok(future) => return future,
                Err((req, state)) => (req, state),
            };
    
            self.inner
                .catch_all_fallback
                .clone()
                .call_with_state(req, state)
        }
    *)
    Definition call_with_state
        (self : ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M (axum.routing.route.RouteFuture.t core.convert.Infallible.t) :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call_with_state :
      Notations.DoubleColon Self "call_with_state" := {
      Notations.double_colon := call_with_state;
    }.
    
    (*
        pub fn as_service<B>(&mut self) -> RouterAsService<'_, B, S> {
            RouterAsService {
                router: self,
                _marker: PhantomData,
            }
        }
    *)
    Definition as_service
        {B : Set}
        (self : mut_ref Self)
        : M (axum.routing.RouterAsService.t B S) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_as_service {B : Set} :
      Notations.DoubleColon Self "as_service" := {
      Notations.double_colon := as_service (B := B);
    }.
    
    (*
        pub fn into_service<B>(self) -> RouterIntoService<B, S> {
            RouterIntoService {
                router: self,
                _marker: PhantomData,
            }
        }
    *)
    Definition into_service
        {B : Set}
        (self : Self)
        : M (axum.routing.RouterIntoService.t B S) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_service {B : Set} :
      Notations.DoubleColon Self "into_service" := {
      Notations.double_colon := into_service (B := B);
    }.
  End Impl_axum_routing_Router_t_S.
  End Impl_axum_routing_Router_t_S.
  
  Module  Impl_axum_routing_Router_t_axum_routing_Router_Default_S.
  Section Impl_axum_routing_Router_t_axum_routing_Router_Default_S.
    Definition Self : Set :=
      axum.routing.Router.t axum.routing.Router.Default.S.
    
    (*
        pub fn into_make_service(self) -> IntoMakeService<Self> {
            // call `Router::with_state` such that everything is turned into `Route` eagerly
            // rather than doing that per request
            IntoMakeService::new(self.with_state(()))
        }
    *)
    Definition into_make_service
        (self : Self)
        : M (axum.routing.into_make_service.IntoMakeService.t Self) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_make_service :
      Notations.DoubleColon Self "into_make_service" := {
      Notations.double_colon := into_make_service;
    }.
    
    (*
        pub fn into_make_service_with_connect_info<C>(self) -> IntoMakeServiceWithConnectInfo<Self, C> {
            // call `Router::with_state` such that everything is turned into `Route` eagerly
            // rather than doing that per request
            IntoMakeServiceWithConnectInfo::new(self.with_state(()))
        }
    *)
    Definition into_make_service_with_connect_info
        {C : Set}
        (self : Self)
        :
          M
            (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t
              Self
              C) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_make_service_with_connect_info
        {C : Set} :
      Notations.DoubleColon Self "into_make_service_with_connect_info" := {
      Notations.double_colon := into_make_service_with_connect_info (C := C);
    }.
  End Impl_axum_routing_Router_t_axum_routing_Router_Default_S.
  End Impl_axum_routing_Router_t_axum_routing_Router_Default_S.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_Router_t_Tuple_.
  Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_Router_t_Tuple_.
    Context {B : Set}.
    
    Context
      {ℋ_0 : http_body.Body.Trait B}
      {ℋ_1 : core.marker.Send.Trait B}
      {ℋ_2 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}.
    
    Definition Self : Set := axum.routing.Router.t unit.
    
    (*
        type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        type Future = RouteFuture<Infallible>;
    *)
    Definition Future : Set :=
      axum.routing.route.RouteFuture.t core.convert.Infallible.t.
    
    (*
        fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (Pattern : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, req: Request<B>) -> Self::Future {
            let req = req.map(Body::new);
            self.call_with_state(req, ())
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req : ltac:(axum_core.extract.Request B))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request B)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_Router_t_Tuple_.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_Router_t_Tuple_.
  
  Module  RouterAsService.
  Section RouterAsService.
    Context (B S : Set).
    
    Record t : Set := {
      router : mut_ref (axum.routing.Router.t S);
      _marker : core.marker.PhantomData.t B;
    }.
    
    Definition Get_router :=
      Ref.map
        (fun α => Some α.(router))
        (fun β α => Some (α <| router := β |>)).
    Definition Get__marker :=
      Ref.map
        (fun α => Some α.(_marker))
        (fun β α => Some (α <| _marker := β |>)).
    Module Default.
      Definition S := unit.
    End Default.
  End RouterAsService.
  End RouterAsService.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterAsService_t_B_Tuple_.
  Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterAsService_t_B_Tuple_.
    Context {B : Set}.
    
    Context
      {ℋ_0 : http_body.Body.Trait B}
      {ℋ_1 : core.marker.Send.Trait B}
      {ℋ_2 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}.
    
    Definition Self : Set := axum.routing.RouterAsService.t B unit.
    
    (*
        type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        type Future = RouteFuture<Infallible>;
    *)
    Definition Future : Set :=
      axum.routing.route.RouteFuture.t core.convert.Infallible.t.
    
    (*
        fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            <Router as Service<Request<B>>>::poll_ready(self.router, cx)
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, req: Request<B>) -> Self::Future {
            self.router.call(req)
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req : ltac:(axum_core.extract.Request B))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request B)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterAsService_t_B_Tuple_.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterAsService_t_B_Tuple_.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_RouterAsService_t_B_S.
  Section Impl_core_fmt_Debug_for_axum_routing_RouterAsService_t_B_S.
    Context {B S : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set := axum.routing.RouterAsService.t B S.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("RouterAsService")
                .field("router", &self.router)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_RouterAsService_t_B_S.
  End Impl_core_fmt_Debug_for_axum_routing_RouterAsService_t_B_S.
  
  Module  RouterIntoService.
  Section RouterIntoService.
    Context (B S : Set).
    
    Record t : Set := {
      router : axum.routing.Router.t S;
      _marker : core.marker.PhantomData.t B;
    }.
    
    Definition Get_router :=
      Ref.map
        (fun α => Some α.(router))
        (fun β α => Some (α <| router := β |>)).
    Definition Get__marker :=
      Ref.map
        (fun α => Some α.(_marker))
        (fun β α => Some (α <| _marker := β |>)).
    Module Default.
      Definition S := unit.
    End Default.
  End RouterIntoService.
  End RouterIntoService.
  
  Module  Impl_core_clone_Clone_for_axum_routing_RouterIntoService_t_B_S.
  Section Impl_core_clone_Clone_for_axum_routing_RouterIntoService_t_B_S.
    Context {B S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait (axum.routing.Router.t S)}.
    
    Definition Self : Set := axum.routing.RouterIntoService.t B S.
    
    (*
        fn clone(&self) -> Self {
            Self {
                router: self.router.clone(),
                _marker: PhantomData,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_RouterIntoService_t_B_S.
  End Impl_core_clone_Clone_for_axum_routing_RouterIntoService_t_B_S.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterIntoService_t_B_Tuple_.
  Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterIntoService_t_B_Tuple_.
    Context {B : Set}.
    
    Context
      {ℋ_0 : http_body.Body.Trait B}
      {ℋ_1 : core.marker.Send.Trait B}
      {ℋ_2 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}.
    
    Definition Self : Set := axum.routing.RouterIntoService.t B unit.
    
    (*
        type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        type Future = RouteFuture<Infallible>;
    *)
    Definition Future : Set :=
      axum.routing.route.RouteFuture.t core.convert.Infallible.t.
    
    (*
        fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            <Router as Service<Request<B>>>::poll_ready(&mut self.router, cx)
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, req: Request<B>) -> Self::Future {
            self.router.call(req)
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req : ltac:(axum_core.extract.Request B))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request B)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterIntoService_t_B_Tuple_.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterIntoService_t_B_Tuple_.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_RouterIntoService_t_B_S.
  Section Impl_core_fmt_Debug_for_axum_routing_RouterIntoService_t_B_S.
    Context {B S : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set := axum.routing.RouterIntoService.t B S.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("RouterIntoService")
                .field("router", &self.router)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_RouterIntoService_t_B_S.
  End Impl_core_fmt_Debug_for_axum_routing_RouterIntoService_t_B_S.
  
  Module Fallback.
    Inductive t (S : Set) (E : Set) : Set :=
    | Default (_ : axum.routing.route.Route.t E)
    | Service (_ : axum.routing.route.Route.t E)
    | BoxedHandler (_ : axum.boxed.BoxedIntoRoute.t S E).
    
    Definition Get_Default_0 :=
      Ref.map
        (fun α => match α with | Default α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with | Default _ => Some (Default β) | _ => None end).
    
    Definition Get_Service_0 :=
      Ref.map
        (fun α => match α with | Service α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with | Service _ => Some (Service β) | _ => None end).
    
    Definition Get_BoxedHandler_0 :=
      Ref.map
        (fun α => match α with | BoxedHandler α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | BoxedHandler _ => Some (BoxedHandler β)
          | _ => None
          end).
  End Fallback.
  
  Module  Impl_axum_routing_Fallback_t_S_E.
  Section Impl_axum_routing_Fallback_t_S_E.
    Context {S E : Set}.
    
    Definition Self : Set := axum.routing.Fallback.t S E.
    
    (*
        fn merge(self, other: Self) -> Option<Self> {
            match (self, other) {
                (Self::Default(_), pick @ Self::Default(_)) => Some(pick),
                (Self::Default(_), pick) | (pick, Self::Default(_)) => Some(pick),
                _ => None,
            }
        }
    *)
    Definition merge
        (self : Self)
        (other : Self)
        : M (core.option.Option.t Self) :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_merge :
      Notations.DoubleColon Self "merge" := {
      Notations.double_colon := merge;
    }.
    
    (*
        fn map<F, E2>(self, f: F) -> Fallback<S, E2>
        where
            S: 'static,
            E: 'static,
            F: FnOnce(Route<E>) -> Route<E2> + Clone + Send + 'static,
            E2: 'static,
        {
            match self {
                Self::Default(route) => Fallback::Default(f(route)),
                Self::Service(route) => Fallback::Service(f(route)),
                Self::BoxedHandler(handler) => Fallback::BoxedHandler(handler.map(f)),
            }
        }
    *)
    Definition map
        {F E2 : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        (self : Self)
        (f : F)
        : M (axum.routing.Fallback.t S E2) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_map
        {F E2 : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F} :
      Notations.DoubleColon Self "map" := {
      Notations.double_colon := map (F := F) (E2 := E2);
    }.
    
    (*
        fn with_state<S2>(self, state: S) -> Fallback<S2, E> {
            match self {
                Fallback::Default(route) => Fallback::Default(route),
                Fallback::Service(route) => Fallback::Service(route),
                Fallback::BoxedHandler(handler) => Fallback::Service(handler.into_route(state)),
            }
        }
    *)
    Definition with_state
        {S2 : Set}
        (self : Self)
        (state : S)
        : M (axum.routing.Fallback.t S2 E) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_with_state {S2 : Set} :
      Notations.DoubleColon Self "with_state" := {
      Notations.double_colon := with_state (S2 := S2);
    }.
    
    (*
        fn call_with_state(&mut self, req: Request, state: S) -> RouteFuture<E> {
            match self {
                Fallback::Default(route) | Fallback::Service(route) => {
                    RouteFuture::from_future(route.oneshot_inner(req))
                }
                Fallback::BoxedHandler(handler) => {
                    let mut route = handler.clone().into_route(state);
                    RouteFuture::from_future(route.oneshot_inner(req))
                }
            }
        }
    *)
    Definition call_with_state
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M (axum.routing.route.RouteFuture.t E) :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call_with_state :
      Notations.DoubleColon Self "call_with_state" := {
      Notations.double_colon := call_with_state;
    }.
  End Impl_axum_routing_Fallback_t_S_E.
  End Impl_axum_routing_Fallback_t_S_E.
  
  Module  Impl_core_clone_Clone_for_axum_routing_Fallback_t_S_E.
  Section Impl_core_clone_Clone_for_axum_routing_Fallback_t_S_E.
    Context {S E : Set}.
    
    Definition Self : Set := axum.routing.Fallback.t S E.
    
    (*
        fn clone(&self) -> Self {
            match self {
                Self::Default(inner) => Self::Default(inner.clone()),
                Self::Service(inner) => Self::Service(inner.clone()),
                Self::BoxedHandler(inner) => Self::BoxedHandler(inner.clone()),
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_Fallback_t_S_E.
  End Impl_core_clone_Clone_for_axum_routing_Fallback_t_S_E.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_Fallback_t_S_E.
  Section Impl_core_fmt_Debug_for_axum_routing_Fallback_t_S_E.
    Context {S E : Set}.
    
    Definition Self : Set := axum.routing.Fallback.t S E.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::Default(inner) => f.debug_tuple("Default").field(inner).finish(),
                Self::Service(inner) => f.debug_tuple("Service").field(inner).finish(),
                Self::BoxedHandler(_) => f.debug_tuple("BoxedHandler").finish(),
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_Fallback_t_S_E.
  End Impl_core_fmt_Debug_for_axum_routing_Fallback_t_S_E.
  
  Module Endpoint.
    Inductive t (S : Set) : Set :=
    |
      MethodRouter
      (_ :
        axum.routing.method_routing.MethodRouter.t
          S
          axum.routing.method_routing.MethodRouter.Default.E)
    | Route (_ : axum.routing.route.Route.t axum.routing.route.Route.Default.E).
    
    Definition Get_MethodRouter_0 :=
      Ref.map
        (fun α => match α with | MethodRouter α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | MethodRouter _ => Some (MethodRouter β)
          | _ => None
          end).
    
    Definition Get_Route_0 :=
      Ref.map
        (fun α => match α with | Route α0 => Some α0 | _ => None end)
        (fun β α => match α with | Route _ => Some (Route β) | _ => None end).
  End Endpoint.
  
  Module  Impl_axum_routing_Endpoint_t_S.
  Section Impl_axum_routing_Endpoint_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.Endpoint.t S.
    
    (*
        fn layer<L>(self, layer: L) -> Endpoint<S>
        where
            L: Layer<Route> + Clone + Send + 'static,
            L::Service: Service<Request> + Clone + Send + 'static,
            <L::Service as Service<Request>>::Response: IntoResponse + 'static,
            <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
            <L::Service as Service<Request>>::Future: Send + 'static,
        {
            match self {
                Endpoint::MethodRouter(method_router) => {
                    Endpoint::MethodRouter(method_router.layer(layer))
                }
                Endpoint::Route(route) => Endpoint::Route(route.layer(layer)),
            }
        }
    *)
    Definition layer
        {L : Set}
        {ℋ_0 :
          tower_layer.Layer.Trait L
            (S := axum.routing.route.Route.t
              axum.routing.route.Route.Default.E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := core.convert.Infallible.t)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        (self : Self)
        (layer : L)
        : M (axum.routing.Endpoint.t S) :=
      let* self := M.alloc self in
      let* layer := M.alloc layer in
      M.read foo.
    
    Global Instance AssociatedFunction_layer
        {L : Set}
        {ℋ_0 :
          tower_layer.Layer.Trait L
            (S := axum.routing.route.Route.t
              axum.routing.route.Route.Default.E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := core.convert.Infallible.t)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))} :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer (L := L);
    }.
  End Impl_axum_routing_Endpoint_t_S.
  End Impl_axum_routing_Endpoint_t_S.
  
  Module  Impl_core_clone_Clone_for_axum_routing_Endpoint_t_S.
  Section Impl_core_clone_Clone_for_axum_routing_Endpoint_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.Endpoint.t S.
    
    (*
        fn clone(&self) -> Self {
            match self {
                Self::MethodRouter(inner) => Self::MethodRouter(inner.clone()),
                Self::Route(inner) => Self::Route(inner.clone()),
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_Endpoint_t_S.
  End Impl_core_clone_Clone_for_axum_routing_Endpoint_t_S.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_Endpoint_t_S.
  Section Impl_core_fmt_Debug_for_axum_routing_Endpoint_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.Endpoint.t S.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::MethodRouter(method_router) => {
                    f.debug_tuple("MethodRouter").field(method_router).finish()
                }
                Self::Route(route) => f.debug_tuple("Route").field(route).finish(),
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_Endpoint_t_S.
  End Impl_core_fmt_Debug_for_axum_routing_Endpoint_t_S.
End routing.

Module method_routing.
  (*
          pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
          where
              T: Service<Request> + Clone + Send + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
              S: Clone,
          {
              on_service(MethodFilter::$method, svc)
          }
  *)
  Definition delete_service
      {T S : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      {ℋ_5 : core.clone.Clone.Trait S}
      (svc : T)
      : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
    let* svc := M.alloc svc in
    M.read foo.
  
  (*
          pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
          where
              T: Service<Request> + Clone + Send + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
              S: Clone,
          {
              on_service(MethodFilter::$method, svc)
          }
  *)
  Definition get_service
      {T S : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      {ℋ_5 : core.clone.Clone.Trait S}
      (svc : T)
      : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
    let* svc := M.alloc svc in
    M.read foo.
  
  (*
          pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
          where
              T: Service<Request> + Clone + Send + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
              S: Clone,
          {
              on_service(MethodFilter::$method, svc)
          }
  *)
  Definition head_service
      {T S : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      {ℋ_5 : core.clone.Clone.Trait S}
      (svc : T)
      : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
    let* svc := M.alloc svc in
    M.read foo.
  
  (*
          pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
          where
              T: Service<Request> + Clone + Send + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
              S: Clone,
          {
              on_service(MethodFilter::$method, svc)
          }
  *)
  Definition options_service
      {T S : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      {ℋ_5 : core.clone.Clone.Trait S}
      (svc : T)
      : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
    let* svc := M.alloc svc in
    M.read foo.
  
  (*
          pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
          where
              T: Service<Request> + Clone + Send + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
              S: Clone,
          {
              on_service(MethodFilter::$method, svc)
          }
  *)
  Definition patch_service
      {T S : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      {ℋ_5 : core.clone.Clone.Trait S}
      (svc : T)
      : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
    let* svc := M.alloc svc in
    M.read foo.
  
  (*
          pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
          where
              T: Service<Request> + Clone + Send + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
              S: Clone,
          {
              on_service(MethodFilter::$method, svc)
          }
  *)
  Definition post_service
      {T S : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      {ℋ_5 : core.clone.Clone.Trait S}
      (svc : T)
      : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
    let* svc := M.alloc svc in
    M.read foo.
  
  (*
          pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
          where
              T: Service<Request> + Clone + Send + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
              S: Clone,
          {
              on_service(MethodFilter::$method, svc)
          }
  *)
  Definition put_service
      {T S : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      {ℋ_5 : core.clone.Clone.Trait S}
      (svc : T)
      : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
    let* svc := M.alloc svc in
    M.read foo.
  
  (*
          pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
          where
              T: Service<Request> + Clone + Send + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
              S: Clone,
          {
              on_service(MethodFilter::$method, svc)
          }
  *)
  Definition trace_service
      {T S : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      {ℋ_5 : core.clone.Clone.Trait S}
      (svc : T)
      : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
    let* svc := M.alloc svc in
    M.read foo.
  
  (*
  pub fn on_service<T, S>(filter: MethodFilter, svc: T) -> MethodRouter<S, T::Error>
  where
      T: Service<Request> + Clone + Send + 'static,
      T::Response: IntoResponse + 'static,
      T::Future: Send + 'static,
      S: Clone,
  {
      MethodRouter::new().on_service(filter, svc)
  }
  *)
  Definition on_service
      {T S : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      {ℋ_5 : core.clone.Clone.Trait S}
      (filter : axum.routing.method_filter.MethodFilter.t)
      (svc : T)
      : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
    let* filter := M.alloc filter in
    let* svc := M.alloc svc in
    M.read foo.
  
  (*
  pub fn any_service<T, S>(svc: T) -> MethodRouter<S, T::Error>
  where
      T: Service<Request> + Clone + Send + 'static,
      T::Response: IntoResponse + 'static,
      T::Future: Send + 'static,
      S: Clone,
  {
      MethodRouter::new()
          .fallback_service(svc)
          .skip_allow_header()
  }
  *)
  Definition any_service
      {T S : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      {ℋ_5 : core.clone.Clone.Trait S}
      (svc : T)
      : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
    let* svc := M.alloc svc in
    M.read foo.
  
  (*
          pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
          where
              H: Handler<T, S>,
              T: 'static,
              S: Clone + Send + Sync + 'static,
          {
              on(MethodFilter::$method, handler)
          }
  *)
  Definition delete
      {H T S : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}
      (handler : H)
      :
        M
          (axum.routing.method_routing.MethodRouter.t
            S
            core.convert.Infallible.t) :=
    let* handler := M.alloc handler in
    M.read foo.
  
  (*
          pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
          where
              H: Handler<T, S>,
              T: 'static,
              S: Clone + Send + Sync + 'static,
          {
              on(MethodFilter::$method, handler)
          }
  *)
  Definition get
      {H T S : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}
      (handler : H)
      :
        M
          (axum.routing.method_routing.MethodRouter.t
            S
            core.convert.Infallible.t) :=
    let* handler := M.alloc handler in
    M.read foo.
  
  (*
          pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
          where
              H: Handler<T, S>,
              T: 'static,
              S: Clone + Send + Sync + 'static,
          {
              on(MethodFilter::$method, handler)
          }
  *)
  Definition head
      {H T S : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}
      (handler : H)
      :
        M
          (axum.routing.method_routing.MethodRouter.t
            S
            core.convert.Infallible.t) :=
    let* handler := M.alloc handler in
    M.read foo.
  
  (*
          pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
          where
              H: Handler<T, S>,
              T: 'static,
              S: Clone + Send + Sync + 'static,
          {
              on(MethodFilter::$method, handler)
          }
  *)
  Definition options
      {H T S : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}
      (handler : H)
      :
        M
          (axum.routing.method_routing.MethodRouter.t
            S
            core.convert.Infallible.t) :=
    let* handler := M.alloc handler in
    M.read foo.
  
  (*
          pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
          where
              H: Handler<T, S>,
              T: 'static,
              S: Clone + Send + Sync + 'static,
          {
              on(MethodFilter::$method, handler)
          }
  *)
  Definition patch
      {H T S : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}
      (handler : H)
      :
        M
          (axum.routing.method_routing.MethodRouter.t
            S
            core.convert.Infallible.t) :=
    let* handler := M.alloc handler in
    M.read foo.
  
  (*
          pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
          where
              H: Handler<T, S>,
              T: 'static,
              S: Clone + Send + Sync + 'static,
          {
              on(MethodFilter::$method, handler)
          }
  *)
  Definition post
      {H T S : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}
      (handler : H)
      :
        M
          (axum.routing.method_routing.MethodRouter.t
            S
            core.convert.Infallible.t) :=
    let* handler := M.alloc handler in
    M.read foo.
  
  (*
          pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
          where
              H: Handler<T, S>,
              T: 'static,
              S: Clone + Send + Sync + 'static,
          {
              on(MethodFilter::$method, handler)
          }
  *)
  Definition put
      {H T S : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}
      (handler : H)
      :
        M
          (axum.routing.method_routing.MethodRouter.t
            S
            core.convert.Infallible.t) :=
    let* handler := M.alloc handler in
    M.read foo.
  
  (*
          pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
          where
              H: Handler<T, S>,
              T: 'static,
              S: Clone + Send + Sync + 'static,
          {
              on(MethodFilter::$method, handler)
          }
  *)
  Definition trace
      {H T S : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}
      (handler : H)
      :
        M
          (axum.routing.method_routing.MethodRouter.t
            S
            core.convert.Infallible.t) :=
    let* handler := M.alloc handler in
    M.read foo.
  
  (*
  pub fn on<H, T, S>(filter: MethodFilter, handler: H) -> MethodRouter<S, Infallible>
  where
      H: Handler<T, S>,
      T: 'static,
      S: Clone + Send + Sync + 'static,
  {
      MethodRouter::new().on(filter, handler)
  }
  *)
  Definition on
      {H T S : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}
      (filter : axum.routing.method_filter.MethodFilter.t)
      (handler : H)
      :
        M
          (axum.routing.method_routing.MethodRouter.t
            S
            core.convert.Infallible.t) :=
    let* filter := M.alloc filter in
    let* handler := M.alloc handler in
    M.read foo.
  
  (*
  pub fn any<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
  where
      H: Handler<T, S>,
      T: 'static,
      S: Clone + Send + Sync + 'static,
  {
      MethodRouter::new().fallback(handler).skip_allow_header()
  }
  *)
  Definition any
      {H T S : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait S}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}
      (handler : H)
      :
        M
          (axum.routing.method_routing.MethodRouter.t
            S
            core.convert.Infallible.t) :=
    let* handler := M.alloc handler in
    M.read foo.
  
  Module  MethodRouter.
  Section MethodRouter.
    Context (S E : Set).
    
    Record t : Set := {
      get : axum.routing.method_routing.MethodEndpoint.t S E;
      head : axum.routing.method_routing.MethodEndpoint.t S E;
      delete : axum.routing.method_routing.MethodEndpoint.t S E;
      options : axum.routing.method_routing.MethodEndpoint.t S E;
      patch : axum.routing.method_routing.MethodEndpoint.t S E;
      post : axum.routing.method_routing.MethodEndpoint.t S E;
      put : axum.routing.method_routing.MethodEndpoint.t S E;
      trace : axum.routing.method_routing.MethodEndpoint.t S E;
      fallback : axum.routing.Fallback.t S E;
      allow_header : axum.routing.method_routing.AllowHeader.t;
    }.
    
    Definition Get_get :=
      Ref.map (fun α => Some α.(get)) (fun β α => Some (α <| get := β |>)).
    Definition Get_head :=
      Ref.map (fun α => Some α.(head)) (fun β α => Some (α <| head := β |>)).
    Definition Get_delete :=
      Ref.map
        (fun α => Some α.(delete))
        (fun β α => Some (α <| delete := β |>)).
    Definition Get_options :=
      Ref.map
        (fun α => Some α.(options))
        (fun β α => Some (α <| options := β |>)).
    Definition Get_patch :=
      Ref.map (fun α => Some α.(patch)) (fun β α => Some (α <| patch := β |>)).
    Definition Get_post :=
      Ref.map (fun α => Some α.(post)) (fun β α => Some (α <| post := β |>)).
    Definition Get_put :=
      Ref.map (fun α => Some α.(put)) (fun β α => Some (α <| put := β |>)).
    Definition Get_trace :=
      Ref.map (fun α => Some α.(trace)) (fun β α => Some (α <| trace := β |>)).
    Definition Get_fallback :=
      Ref.map
        (fun α => Some α.(fallback))
        (fun β α => Some (α <| fallback := β |>)).
    Definition Get_allow_header :=
      Ref.map
        (fun α => Some α.(allow_header))
        (fun β α => Some (α <| allow_header := β |>)).
    Module Default.
      Definition S := unit.
      Definition E := core.convert.Infallible.t.
    End Default.
  End MethodRouter.
  End MethodRouter.
  
  Module AllowHeader.
    Inductive t : Set :=
    | None
    | Skip
    | Bytes (_ : bytes.bytes_mut.BytesMut.t).
    
    Definition Get_Bytes_0 :=
      Ref.map
        (fun α => match α with | Bytes α0 => Some α0 | _ => None end)
        (fun β α => match α with | Bytes _ => Some (Bytes β) | _ => None end).
  End AllowHeader.
  
  Module  Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.
  Section Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.
    Definition Self : Set := axum.routing.method_routing.AllowHeader.t.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M axum.routing.method_routing.AllowHeader.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.
  End Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.
  Section Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.
    Definition Self : Set := axum.routing.method_routing.AllowHeader.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.
  End Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.
  
  Module  Impl_axum_routing_method_routing_AllowHeader_t_2.
  Section Impl_axum_routing_method_routing_AllowHeader_t_2.
    Definition Self : Set := axum.routing.method_routing.AllowHeader.t.
    
    (*
        fn merge(self, other: Self) -> Self {
            match (self, other) {
                (AllowHeader::Skip, _) | (_, AllowHeader::Skip) => AllowHeader::Skip,
                (AllowHeader::None, AllowHeader::None) => AllowHeader::None,
                (AllowHeader::None, AllowHeader::Bytes(pick)) => AllowHeader::Bytes(pick),
                (AllowHeader::Bytes(pick), AllowHeader::None) => AllowHeader::Bytes(pick),
                (AllowHeader::Bytes(mut a), AllowHeader::Bytes(b)) => {
                    a.extend_from_slice(b",");
                    a.extend_from_slice(&b);
                    AllowHeader::Bytes(a)
                }
            }
        }
    *)
    Definition merge (self : Self) (other : Self) : M Self :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_merge :
      Notations.DoubleColon Self "merge" := {
      Notations.double_colon := merge;
    }.
  End Impl_axum_routing_method_routing_AllowHeader_t_2.
  End Impl_axum_routing_method_routing_AllowHeader_t_2.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.
  Section Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.
    Context {S E : Set}.
    
    Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("MethodRouter")
                .field("get", &self.get)
                .field("head", &self.head)
                .field("delete", &self.delete)
                .field("options", &self.options)
                .field("patch", &self.patch)
                .field("post", &self.post)
                .field("put", &self.put)
                .field("trace", &self.trace)
                .field("fallback", &self.fallback)
                .field("allow_header", &self.allow_header)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.
  End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.
  
  Module  Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t_2.
  Section Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t_2.
    Context {S : Set}.
    
    Definition Self : Set :=
      axum.routing.method_routing.MethodRouter.t S core.convert.Infallible.t.
    
    (*
        pub fn on<H, T>(self, filter: MethodFilter, handler: H) -> Self
        where
            H: Handler<T, S>,
            T: 'static,
            S: Send + Sync + 'static,
        {
            self.on_endpoint(
                filter,
                MethodEndpoint::BoxedHandler(BoxedIntoRoute::from_handler(handler)),
            )
        }
    *)
    Definition on
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : Self)
        (filter : axum.routing.method_filter.MethodFilter.t)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* filter := M.alloc filter in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_on
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "on" := {
      Notations.double_colon := on (H := H) (T := T);
    }.
    
    (*
            pub fn $name<H, T>(self, handler: H) -> Self
            where
                H: Handler<T, S>,
                T: 'static,
                S: Send + Sync + 'static,
            {
                self.on(MethodFilter::$method, handler)
            }
    *)
    Definition delete
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_delete
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "delete" := {
      Notations.double_colon := delete (H := H) (T := T);
    }.
    
    (*
            pub fn $name<H, T>(self, handler: H) -> Self
            where
                H: Handler<T, S>,
                T: 'static,
                S: Send + Sync + 'static,
            {
                self.on(MethodFilter::$method, handler)
            }
    *)
    Definition get
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_get
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "get" := {
      Notations.double_colon := get (H := H) (T := T);
    }.
    
    (*
            pub fn $name<H, T>(self, handler: H) -> Self
            where
                H: Handler<T, S>,
                T: 'static,
                S: Send + Sync + 'static,
            {
                self.on(MethodFilter::$method, handler)
            }
    *)
    Definition head
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_head
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "head" := {
      Notations.double_colon := head (H := H) (T := T);
    }.
    
    (*
            pub fn $name<H, T>(self, handler: H) -> Self
            where
                H: Handler<T, S>,
                T: 'static,
                S: Send + Sync + 'static,
            {
                self.on(MethodFilter::$method, handler)
            }
    *)
    Definition options
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_options
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "options" := {
      Notations.double_colon := options (H := H) (T := T);
    }.
    
    (*
            pub fn $name<H, T>(self, handler: H) -> Self
            where
                H: Handler<T, S>,
                T: 'static,
                S: Send + Sync + 'static,
            {
                self.on(MethodFilter::$method, handler)
            }
    *)
    Definition patch
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_patch
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "patch" := {
      Notations.double_colon := patch (H := H) (T := T);
    }.
    
    (*
            pub fn $name<H, T>(self, handler: H) -> Self
            where
                H: Handler<T, S>,
                T: 'static,
                S: Send + Sync + 'static,
            {
                self.on(MethodFilter::$method, handler)
            }
    *)
    Definition post
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_post
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "post" := {
      Notations.double_colon := post (H := H) (T := T);
    }.
    
    (*
            pub fn $name<H, T>(self, handler: H) -> Self
            where
                H: Handler<T, S>,
                T: 'static,
                S: Send + Sync + 'static,
            {
                self.on(MethodFilter::$method, handler)
            }
    *)
    Definition put
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_put
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "put" := {
      Notations.double_colon := put (H := H) (T := T);
    }.
    
    (*
            pub fn $name<H, T>(self, handler: H) -> Self
            where
                H: Handler<T, S>,
                T: 'static,
                S: Send + Sync + 'static,
            {
                self.on(MethodFilter::$method, handler)
            }
    *)
    Definition trace
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_trace
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "trace" := {
      Notations.double_colon := trace (H := H) (T := T);
    }.
    
    (*
        pub fn fallback<H, T>(mut self, handler: H) -> Self
        where
            H: Handler<T, S>,
            T: 'static,
            S: Send + Sync + 'static,
        {
            self.fallback = Fallback::BoxedHandler(BoxedIntoRoute::from_handler(handler));
            self
        }
    *)
    Definition fallback
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_fallback
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "fallback" := {
      Notations.double_colon := fallback (H := H) (T := T);
    }.
  End Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t_2.
  End Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t_2.
  
  Module  Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t_2.
  Section Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t_2.
    Definition Self : Set :=
      axum.routing.method_routing.MethodRouter.t unit core.convert.Infallible.t.
    
    (*
        pub fn into_make_service(self) -> IntoMakeService<Self> {
            IntoMakeService::new(self.with_state(()))
        }
    *)
    Definition into_make_service
        (self : Self)
        : M (axum.routing.into_make_service.IntoMakeService.t Self) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_make_service :
      Notations.DoubleColon Self "into_make_service" := {
      Notations.double_colon := into_make_service;
    }.
    
    (*
        pub fn into_make_service_with_connect_info<C>(self) -> IntoMakeServiceWithConnectInfo<Self, C> {
            IntoMakeServiceWithConnectInfo::new(self.with_state(()))
        }
    *)
    Definition into_make_service_with_connect_info
        {C : Set}
        (self : Self)
        :
          M
            (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t
              Self
              C) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_make_service_with_connect_info
        {C : Set} :
      Notations.DoubleColon Self "into_make_service_with_connect_info" := {
      Notations.double_colon := into_make_service_with_connect_info (C := C);
    }.
  End Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t_2.
  End Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t_2.
  
  Module  Impl_axum_routing_method_routing_MethodRouter_t_S_E_2.
  Section Impl_axum_routing_method_routing_MethodRouter_t_S_E_2.
    Context {S E : Set}.
    
    Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
    
    (*
        pub fn new() -> Self {
            let fallback = Route::new(service_fn(|_: Request| async {
                Ok(StatusCode::METHOD_NOT_ALLOWED.into_response())
            }));
    
            Self {
                get: MethodEndpoint::None,
                head: MethodEndpoint::None,
                delete: MethodEndpoint::None,
                options: MethodEndpoint::None,
                patch: MethodEndpoint::None,
                post: MethodEndpoint::None,
                put: MethodEndpoint::None,
                trace: MethodEndpoint::None,
                allow_header: AllowHeader::None,
                fallback: Fallback::Default(fallback),
            }
        }
    *)
    Definition new : M Self := M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
    
    (*
        pub fn with_state<S2>(self, state: S) -> MethodRouter<S2, E> {
            MethodRouter {
                get: self.get.with_state(&state),
                head: self.head.with_state(&state),
                delete: self.delete.with_state(&state),
                options: self.options.with_state(&state),
                patch: self.patch.with_state(&state),
                post: self.post.with_state(&state),
                put: self.put.with_state(&state),
                trace: self.trace.with_state(&state),
                allow_header: self.allow_header,
                fallback: self.fallback.with_state(state),
            }
        }
    *)
    Definition with_state
        {S2 : Set}
        (self : Self)
        (state : S)
        : M (axum.routing.method_routing.MethodRouter.t S2 E) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_with_state {S2 : Set} :
      Notations.DoubleColon Self "with_state" := {
      Notations.double_colon := with_state (S2 := S2);
    }.
    
    (*
        pub fn on_service<T>(self, filter: MethodFilter, svc: T) -> Self
        where
            T: Service<Request, Error = E> + Clone + Send + 'static,
            T::Response: IntoResponse + 'static,
            T::Future: Send + 'static,
        {
            self.on_endpoint(filter, MethodEndpoint::Route(Route::new(svc)))
        }
    *)
    Definition on_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (filter : axum.routing.method_filter.MethodFilter.t)
        (svc : T)
        : M Self :=
      let* self := M.alloc self in
      let* filter := M.alloc filter in
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_on_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "on_service" := {
      Notations.double_colon := on_service (T := T);
    }.
    
    (*
        fn on_endpoint(mut self, filter: MethodFilter, endpoint: MethodEndpoint<S, E>) -> Self {
            // written as a separate function to generate less IR
            #[track_caller]
            fn set_endpoint<S, E>(
                method_name: &str,
                out: &mut MethodEndpoint<S, E>,
                endpoint: &MethodEndpoint<S, E>,
                endpoint_filter: MethodFilter,
                filter: MethodFilter,
                allow_header: &mut AllowHeader,
                methods: &[&'static str],
            ) where
                MethodEndpoint<S, E>: Clone,
                S: Clone,
            {
                if endpoint_filter.contains(filter) {
                    if out.is_some() {
                        panic!(
                            "Overlapping method route. Cannot add two method routes that both handle \
                             `{method_name}`",
                        )
                    }
                    *out = endpoint.clone();
                    for method in methods {
                        append_allow_header(allow_header, method);
                    }
                }
            }
    
            set_endpoint(
                "GET",
                &mut self.get,
                &endpoint,
                filter,
                MethodFilter::GET,
                &mut self.allow_header,
                &["GET", "HEAD"],
            );
    
            set_endpoint(
                "HEAD",
                &mut self.head,
                &endpoint,
                filter,
                MethodFilter::HEAD,
                &mut self.allow_header,
                &["HEAD"],
            );
    
            set_endpoint(
                "TRACE",
                &mut self.trace,
                &endpoint,
                filter,
                MethodFilter::TRACE,
                &mut self.allow_header,
                &["TRACE"],
            );
    
            set_endpoint(
                "PUT",
                &mut self.put,
                &endpoint,
                filter,
                MethodFilter::PUT,
                &mut self.allow_header,
                &["PUT"],
            );
    
            set_endpoint(
                "POST",
                &mut self.post,
                &endpoint,
                filter,
                MethodFilter::POST,
                &mut self.allow_header,
                &["POST"],
            );
    
            set_endpoint(
                "PATCH",
                &mut self.patch,
                &endpoint,
                filter,
                MethodFilter::PATCH,
                &mut self.allow_header,
                &["PATCH"],
            );
    
            set_endpoint(
                "OPTIONS",
                &mut self.options,
                &endpoint,
                filter,
                MethodFilter::OPTIONS,
                &mut self.allow_header,
                &["OPTIONS"],
            );
    
            set_endpoint(
                "DELETE",
                &mut self.delete,
                &endpoint,
                filter,
                MethodFilter::DELETE,
                &mut self.allow_header,
                &["DELETE"],
            );
    
            self
        }
    *)
    Definition on_endpoint
        (self : Self)
        (filter : axum.routing.method_filter.MethodFilter.t)
        (endpoint : axum.routing.method_routing.MethodEndpoint.t S E)
        : M Self :=
      let* self := M.alloc self in
      let* filter := M.alloc filter in
      let* endpoint := M.alloc endpoint in
      M.read foo.
    
    Global Instance AssociatedFunction_on_endpoint :
      Notations.DoubleColon Self "on_endpoint" := {
      Notations.double_colon := on_endpoint;
    }.
    
    (*
            pub fn $name<T>(self, svc: T) -> Self
            where
                T: Service<Request, Error = E>
                    + Clone
                    + Send
                    + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
            {
                self.on_service(MethodFilter::$method, svc)
            }
    *)
    Definition delete_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (svc : T)
        : M Self :=
      let* self := M.alloc self in
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_delete_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "delete_service" := {
      Notations.double_colon := delete_service (T := T);
    }.
    
    (*
            pub fn $name<T>(self, svc: T) -> Self
            where
                T: Service<Request, Error = E>
                    + Clone
                    + Send
                    + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
            {
                self.on_service(MethodFilter::$method, svc)
            }
    *)
    Definition get_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (svc : T)
        : M Self :=
      let* self := M.alloc self in
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_get_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "get_service" := {
      Notations.double_colon := get_service (T := T);
    }.
    
    (*
            pub fn $name<T>(self, svc: T) -> Self
            where
                T: Service<Request, Error = E>
                    + Clone
                    + Send
                    + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
            {
                self.on_service(MethodFilter::$method, svc)
            }
    *)
    Definition head_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (svc : T)
        : M Self :=
      let* self := M.alloc self in
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_head_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "head_service" := {
      Notations.double_colon := head_service (T := T);
    }.
    
    (*
            pub fn $name<T>(self, svc: T) -> Self
            where
                T: Service<Request, Error = E>
                    + Clone
                    + Send
                    + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
            {
                self.on_service(MethodFilter::$method, svc)
            }
    *)
    Definition options_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (svc : T)
        : M Self :=
      let* self := M.alloc self in
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_options_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "options_service" := {
      Notations.double_colon := options_service (T := T);
    }.
    
    (*
            pub fn $name<T>(self, svc: T) -> Self
            where
                T: Service<Request, Error = E>
                    + Clone
                    + Send
                    + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
            {
                self.on_service(MethodFilter::$method, svc)
            }
    *)
    Definition patch_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (svc : T)
        : M Self :=
      let* self := M.alloc self in
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_patch_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "patch_service" := {
      Notations.double_colon := patch_service (T := T);
    }.
    
    (*
            pub fn $name<T>(self, svc: T) -> Self
            where
                T: Service<Request, Error = E>
                    + Clone
                    + Send
                    + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
            {
                self.on_service(MethodFilter::$method, svc)
            }
    *)
    Definition post_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (svc : T)
        : M Self :=
      let* self := M.alloc self in
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_post_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "post_service" := {
      Notations.double_colon := post_service (T := T);
    }.
    
    (*
            pub fn $name<T>(self, svc: T) -> Self
            where
                T: Service<Request, Error = E>
                    + Clone
                    + Send
                    + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
            {
                self.on_service(MethodFilter::$method, svc)
            }
    *)
    Definition put_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (svc : T)
        : M Self :=
      let* self := M.alloc self in
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_put_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "put_service" := {
      Notations.double_colon := put_service (T := T);
    }.
    
    (*
            pub fn $name<T>(self, svc: T) -> Self
            where
                T: Service<Request, Error = E>
                    + Clone
                    + Send
                    + 'static,
                T::Response: IntoResponse + 'static,
                T::Future: Send + 'static,
            {
                self.on_service(MethodFilter::$method, svc)
            }
    *)
    Definition trace_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (svc : T)
        : M Self :=
      let* self := M.alloc self in
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_trace_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "trace_service" := {
      Notations.double_colon := trace_service (T := T);
    }.
    
    (*
        pub fn fallback_service<T>(mut self, svc: T) -> Self
        where
            T: Service<Request, Error = E> + Clone + Send + 'static,
            T::Response: IntoResponse + 'static,
            T::Future: Send + 'static,
        {
            self.fallback = Fallback::Service(Route::new(svc));
            self
        }
    *)
    Definition fallback_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (svc : T)
        : M Self :=
      let* self := M.alloc self in
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_fallback_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "fallback_service" := {
      Notations.double_colon := fallback_service (T := T);
    }.
    
    (*
        pub fn layer<L, NewError>(self, layer: L) -> MethodRouter<S, NewError>
        where
            L: Layer<Route<E>> + Clone + Send + 'static,
            L::Service: Service<Request> + Clone + Send + 'static,
            <L::Service as Service<Request>>::Response: IntoResponse + 'static,
            <L::Service as Service<Request>>::Error: Into<NewError> + 'static,
            <L::Service as Service<Request>>::Future: Send + 'static,
            E: 'static,
            S: 'static,
            NewError: 'static,
        {
            let layer_fn = move |route: Route<E>| route.layer(layer.clone());
    
            MethodRouter {
                get: self.get.map(layer_fn.clone()),
                head: self.head.map(layer_fn.clone()),
                delete: self.delete.map(layer_fn.clone()),
                options: self.options.map(layer_fn.clone()),
                patch: self.patch.map(layer_fn.clone()),
                post: self.post.map(layer_fn.clone()),
                put: self.put.map(layer_fn.clone()),
                trace: self.trace.map(layer_fn.clone()),
                fallback: self.fallback.map(layer_fn),
                allow_header: self.allow_header,
            }
        }
    *)
    Definition layer
        {L NewError : Set}
        {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := NewError)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        (self : Self)
        (layer : L)
        : M (axum.routing.method_routing.MethodRouter.t S NewError) :=
      let* self := M.alloc self in
      let* layer := M.alloc layer in
      M.read foo.
    
    Global Instance AssociatedFunction_layer
        {L NewError : Set}
        {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := NewError)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))} :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer (L := L) (NewError := NewError);
    }.
    
    (*
        pub fn route_layer<L>(mut self, layer: L) -> MethodRouter<S, E>
        where
            L: Layer<Route<E>> + Clone + Send + 'static,
            L::Service: Service<Request, Error = E> + Clone + Send + 'static,
            <L::Service as Service<Request>>::Response: IntoResponse + 'static,
            <L::Service as Service<Request>>::Future: Send + 'static,
            E: 'static,
            S: 'static,
        {
            if self.get.is_none()
                && self.head.is_none()
                && self.delete.is_none()
                && self.options.is_none()
                && self.patch.is_none()
                && self.post.is_none()
                && self.put.is_none()
                && self.trace.is_none()
            {
                panic!(
                    "Adding a route_layer before any routes is a no-op. \
                     Add the routes you want the layer to apply to first."
                );
            }
    
            let layer_fn = move |svc| {
                let svc = layer.layer(svc);
                let svc = MapResponseLayer::new(IntoResponse::into_response).layer(svc);
                Route::new(svc)
            };
    
            self.get = self.get.map(layer_fn.clone());
            self.head = self.head.map(layer_fn.clone());
            self.delete = self.delete.map(layer_fn.clone());
            self.options = self.options.map(layer_fn.clone());
            self.patch = self.patch.map(layer_fn.clone());
            self.post = self.post.map(layer_fn.clone());
            self.put = self.put.map(layer_fn.clone());
            self.trace = self.trace.map(layer_fn);
    
            self
        }
    *)
    Definition route_layer
        {L : Set}
        {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        (self : Self)
        (layer : L)
        : M (axum.routing.method_routing.MethodRouter.t S E) :=
      let* self := M.alloc self in
      let* layer := M.alloc layer in
      M.read foo.
    
    Global Instance AssociatedFunction_route_layer
        {L : Set}
        {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))} :
      Notations.DoubleColon Self "route_layer" := {
      Notations.double_colon := route_layer (L := L);
    }.
    
    (*
        pub(crate) fn merge_for_path(mut self, path: Option<&str>, other: MethodRouter<S, E>) -> Self {
            // written using inner functions to generate less IR
            #[track_caller]
            fn merge_inner<S, E>(
                path: Option<&str>,
                name: &str,
                first: MethodEndpoint<S, E>,
                second: MethodEndpoint<S, E>,
            ) -> MethodEndpoint<S, E> {
                match (first, second) {
                    (MethodEndpoint::None, MethodEndpoint::None) => MethodEndpoint::None,
                    (pick, MethodEndpoint::None) | (MethodEndpoint::None, pick) => pick,
                    _ => {
                        if let Some(path) = path {
                            panic!(
                                "Overlapping method route. Handler for `{name} {path}` already exists"
                            );
                        } else {
                            panic!(
                                "Overlapping method route. Cannot merge two method routes that both \
                                 define `{name}`"
                            );
                        }
                    }
                }
            }
    
            self.get = merge_inner(path, "GET", self.get, other.get);
            self.head = merge_inner(path, "HEAD", self.head, other.head);
            self.delete = merge_inner(path, "DELETE", self.delete, other.delete);
            self.options = merge_inner(path, "OPTIONS", self.options, other.options);
            self.patch = merge_inner(path, "PATCH", self.patch, other.patch);
            self.post = merge_inner(path, "POST", self.post, other.post);
            self.put = merge_inner(path, "PUT", self.put, other.put);
            self.trace = merge_inner(path, "TRACE", self.trace, other.trace);
    
            self.fallback = self
                .fallback
                .merge(other.fallback)
                .expect("Cannot merge two `MethodRouter`s that both have a fallback");
    
            self.allow_header = self.allow_header.merge(other.allow_header);
    
            self
        }
    *)
    Definition merge_for_path
        (self : Self)
        (path : core.option.Option.t (ref str.t))
        (other : axum.routing.method_routing.MethodRouter.t S E)
        : M Self :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_merge_for_path :
      Notations.DoubleColon Self "merge_for_path" := {
      Notations.double_colon := merge_for_path;
    }.
    
    (*
        pub fn merge(self, other: MethodRouter<S, E>) -> Self {
            self.merge_for_path(None, other)
        }
    *)
    Definition merge
        (self : Self)
        (other : axum.routing.method_routing.MethodRouter.t S E)
        : M Self :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_merge :
      Notations.DoubleColon Self "merge" := {
      Notations.double_colon := merge;
    }.
    
    (*
        pub fn handle_error<F, T>(self, f: F) -> MethodRouter<S, Infallible>
        where
            F: Clone + Send + Sync + 'static,
            HandleError<Route<E>, F, T>: Service<Request, Error = Infallible>,
            <HandleError<Route<E>, F, T> as Service<Request>>::Future: Send,
            <HandleError<Route<E>, F, T> as Service<Request>>::Response: IntoResponse + Send,
            T: 'static,
            E: 'static,
            S: 'static,
        {
            self.layer(HandleErrorLayer::new(f))
        }
    *)
    Definition handle_error
        {F T : Set}
        {ℋ_0 : core.clone.Clone.Trait F}
        {ℋ_1 : core.marker.Send.Trait F}
        {ℋ_2 : core.marker.Sync.Trait F}
        {ℋ_3 :
          tower_service.Service.Trait
              (axum.error_handling.HandleError.t
                (axum.routing.route.Route.t E)
                F
                T)
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := axum.error_handling.HandleError.t
                  (axum.routing.route.Route.t E)
                  F
                  T)
                (Trait := ltac:(refine _)))}
        {ℋ_5 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := axum.error_handling.HandleError.t
                  (axum.routing.route.Route.t E)
                  F
                  T)
                (Trait := ltac:(refine _)))}
        {ℋ_6 :
          core.marker.Send.Trait
              (tower_service.Service.Response
                (Self := axum.error_handling.HandleError.t
                  (axum.routing.route.Route.t E)
                  F
                  T)
                (Trait := ltac:(refine _)))}
        (self : Self)
        (f : F)
        :
          M
            (axum.routing.method_routing.MethodRouter.t
              S
              core.convert.Infallible.t) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_handle_error
        {F T : Set}
        {ℋ_0 : core.clone.Clone.Trait F}
        {ℋ_1 : core.marker.Send.Trait F}
        {ℋ_2 : core.marker.Sync.Trait F}
        {ℋ_3 :
          tower_service.Service.Trait
              (axum.error_handling.HandleError.t
                (axum.routing.route.Route.t E)
                F
                T)
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := axum.error_handling.HandleError.t
                  (axum.routing.route.Route.t E)
                  F
                  T)
                (Trait := ltac:(refine _)))}
        {ℋ_5 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := axum.error_handling.HandleError.t
                  (axum.routing.route.Route.t E)
                  F
                  T)
                (Trait := ltac:(refine _)))}
        {ℋ_6 :
          core.marker.Send.Trait
              (tower_service.Service.Response
                (Self := axum.error_handling.HandleError.t
                  (axum.routing.route.Route.t E)
                  F
                  T)
                (Trait := ltac:(refine _)))} :
      Notations.DoubleColon Self "handle_error" := {
      Notations.double_colon := handle_error (F := F) (T := T);
    }.
    
    (*
        fn skip_allow_header(mut self) -> Self {
            self.allow_header = AllowHeader::Skip;
            self
        }
    *)
    Definition skip_allow_header (self : Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_skip_allow_header :
      Notations.DoubleColon Self "skip_allow_header" := {
      Notations.double_colon := skip_allow_header;
    }.
    
    (*
        pub(crate) fn call_with_state(&self, req: Request, state: S) -> RouteFuture<E> {
            macro_rules! call {
                (
                    $req:expr,
                    $method:expr,
                    $method_variant:ident,
                    $svc:expr
                ) => {
                    if $method == Method::$method_variant {
                        match $svc {
                            MethodEndpoint::None => {}
                            MethodEndpoint::Route(route) => {
                                return RouteFuture::from_future(route.clone().oneshot_inner($req))
                                    .strip_body($method == Method::HEAD);
                            }
                            MethodEndpoint::BoxedHandler(handler) => {
                                let route = handler.clone().into_route(state);
                                return RouteFuture::from_future(route.clone().oneshot_inner($req))
                                    .strip_body($method == Method::HEAD);
                            }
                        }
                    }
                };
            }
    
            let method = req.method().clone();
    
            // written with a pattern match like this to ensure we call all routes
            let Self {
                get,
                head,
                delete,
                options,
                patch,
                post,
                put,
                trace,
                fallback,
                allow_header,
            } = self;
    
            call!(req, method, HEAD, head);
            call!(req, method, HEAD, get);
            call!(req, method, GET, get);
            call!(req, method, POST, post);
            call!(req, method, OPTIONS, options);
            call!(req, method, PATCH, patch);
            call!(req, method, PUT, put);
            call!(req, method, DELETE, delete);
            call!(req, method, TRACE, trace);
    
            let future = fallback.clone().call_with_state(req, state);
    
            match allow_header {
                AllowHeader::None => future.allow_header(Bytes::new()),
                AllowHeader::Skip => future,
                AllowHeader::Bytes(allow_header) => future.allow_header(allow_header.clone().freeze()),
            }
        }
    *)
    Definition call_with_state
        (self : ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M (axum.routing.route.RouteFuture.t E) :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call_with_state :
      Notations.DoubleColon Self "call_with_state" := {
      Notations.double_colon := call_with_state;
    }.
  End Impl_axum_routing_method_routing_MethodRouter_t_S_E_2.
  End Impl_axum_routing_method_routing_MethodRouter_t_S_E_2.
  
  (*
  fn append_allow_header(allow_header: &mut AllowHeader, method: &'static str) {
      match allow_header {
          AllowHeader::None => {
              *allow_header = AllowHeader::Bytes(BytesMut::from(method));
          }
          AllowHeader::Skip => {}
          AllowHeader::Bytes(allow_header) => {
              if let Ok(s) = std::str::from_utf8(allow_header) {
                  if !s.contains(method) {
                      allow_header.extend_from_slice(b",");
                      allow_header.extend_from_slice(method.as_bytes());
                  }
              } else {
                  #[cfg(debug_assertions)]
                  panic!("`allow_header` contained invalid uft-8. This should never happen")
              }
          }
      }
  }
  *)
  Definition append_allow_header
      (allow_header : mut_ref axum.routing.method_routing.AllowHeader.t)
      (method : ref str.t)
      : M unit :=
    let* allow_header := M.alloc allow_header in
    let* method := M.alloc method in
    M.read foo.
  
  Module  Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.
  Section Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.
    Context {S E : Set}.
    
    Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
    
    (*
        fn clone(&self) -> Self {
            Self {
                get: self.get.clone(),
                head: self.head.clone(),
                delete: self.delete.clone(),
                options: self.options.clone(),
                patch: self.patch.clone(),
                post: self.post.clone(),
                put: self.put.clone(),
                trace: self.trace.clone(),
                fallback: self.fallback.clone(),
                allow_header: self.allow_header.clone(),
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.
  End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.
  
  Module  Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.
  Section Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.
    Context {S E : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
    
    (*
        fn default() -> Self {
            Self::new()
        }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.
  End Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.
  
  Module MethodEndpoint.
    Inductive t (S : Set) (E : Set) : Set :=
    | None
    | Route (_ : axum.routing.route.Route.t E)
    | BoxedHandler (_ : axum.boxed.BoxedIntoRoute.t S E).
    
    Definition Get_Route_0 :=
      Ref.map
        (fun α => match α with | Route α0 => Some α0 | _ => None end)
        (fun β α => match α with | Route _ => Some (Route β) | _ => None end).
    
    Definition Get_BoxedHandler_0 :=
      Ref.map
        (fun α => match α with | BoxedHandler α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | BoxedHandler _ => Some (BoxedHandler β)
          | _ => None
          end).
  End MethodEndpoint.
  
  Module  Impl_axum_routing_method_routing_MethodEndpoint_t_S_E_2.
  Section Impl_axum_routing_method_routing_MethodEndpoint_t_S_E_2.
    Context {S E : Set}.
    
    Definition Self : Set := axum.routing.method_routing.MethodEndpoint.t S E.
    
    (*
        fn is_some(&self) -> bool {
            matches!(self, Self::Route(_) | Self::BoxedHandler(_))
        }
    *)
    Definition is_some (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_some :
      Notations.DoubleColon Self "is_some" := {
      Notations.double_colon := is_some;
    }.
    
    (*
        fn is_none(&self) -> bool {
            matches!(self, Self::None)
        }
    *)
    Definition is_none (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_none :
      Notations.DoubleColon Self "is_none" := {
      Notations.double_colon := is_none;
    }.
    
    (*
        fn map<F, E2>(self, f: F) -> MethodEndpoint<S, E2>
        where
            S: 'static,
            E: 'static,
            F: FnOnce(Route<E>) -> Route<E2> + Clone + Send + 'static,
            E2: 'static,
        {
            match self {
                Self::None => MethodEndpoint::None,
                Self::Route(route) => MethodEndpoint::Route(f(route)),
                Self::BoxedHandler(handler) => MethodEndpoint::BoxedHandler(handler.map(f)),
            }
        }
    *)
    Definition map
        {F E2 : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F}
        (self : Self)
        (f : F)
        : M (axum.routing.method_routing.MethodEndpoint.t S E2) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_map
        {F E2 : Set}
        {ℋ_0 :
          core.ops.function.FnOnce.Trait F
            (Args := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait F}
        {ℋ_2 : core.marker.Send.Trait F} :
      Notations.DoubleColon Self "map" := {
      Notations.double_colon := map (F := F) (E2 := E2);
    }.
    
    (*
        fn with_state<S2>(self, state: &S) -> MethodEndpoint<S2, E> {
            match self {
                MethodEndpoint::None => MethodEndpoint::None,
                MethodEndpoint::Route(route) => MethodEndpoint::Route(route),
                MethodEndpoint::BoxedHandler(handler) => {
                    MethodEndpoint::Route(handler.into_route(state.clone()))
                }
            }
        }
    *)
    Definition with_state
        {S2 : Set}
        (self : Self)
        (state : ref S)
        : M (axum.routing.method_routing.MethodEndpoint.t S2 E) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_with_state {S2 : Set} :
      Notations.DoubleColon Self "with_state" := {
      Notations.double_colon := with_state (S2 := S2);
    }.
  End Impl_axum_routing_method_routing_MethodEndpoint_t_S_E_2.
  End Impl_axum_routing_method_routing_MethodEndpoint_t_S_E_2.
  
  Module  Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
  Section Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
    Context {S E : Set}.
    
    Definition Self : Set := axum.routing.method_routing.MethodEndpoint.t S E.
    
    (*
        fn clone(&self) -> Self {
            match self {
                Self::None => Self::None,
                Self::Route(inner) => Self::Route(inner.clone()),
                Self::BoxedHandler(inner) => Self::BoxedHandler(inner.clone()),
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
  End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
  Section Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
    Context {S E : Set}.
    
    Definition Self : Set := axum.routing.method_routing.MethodEndpoint.t S E.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::None => f.debug_tuple("None").finish(),
                Self::Route(inner) => inner.fmt(f),
                Self::BoxedHandler(_) => f.debug_tuple("BoxedHandler").finish(),
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
  End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.
  Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.
    Context {B E : Set}.
    
    Context
      {ℋ_0 : http_body.Body.Trait B}
      {ℋ_1 : core.marker.Send.Trait B}
      {ℋ_2 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}.
    
    Definition Self : Set := axum.routing.method_routing.MethodRouter.t unit E.
    
    (*
        type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        type Error = E;
    *)
    Definition Error : Set := E.
    
    (*
        type Future = RouteFuture<E>;
    *)
    Definition Future : Set := axum.routing.route.RouteFuture.t E.
    
    (*
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (_cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* _cx := M.alloc _cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, req: Request<B>) -> Self::Future {
            let req = req.map(Body::new);
            self.call_with_state(req, ())
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req : ltac:(axum_core.extract.Request B))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request B)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.
  
  Module  Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.
  Section Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.
    Context {S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set :=
      axum.routing.method_routing.MethodRouter.t
        S
        axum.routing.method_routing.MethodRouter.Default.E.
    
    (*
        type Future = InfallibleRouteFuture;
    *)
    Definition Future : Set := axum.routing.route.InfallibleRouteFuture.t.
    
    (*
        fn call(self, req: Request, state: S) -> Self::Future {
            InfallibleRouteFuture::new(self.call_with_state(req, state))
        }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self (T := unit) (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.
  End Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.
End method_routing.

(*
        pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
        where
            T: Service<Request> + Clone + Send + 'static,
            T::Response: IntoResponse + 'static,
            T::Future: Send + 'static,
            S: Clone,
        {
            on_service(MethodFilter::$method, svc)
        }
*)
Definition delete_service
    {T S : Set}
    {ℋ_0 :
      tower_service.Service.Trait T
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait T::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
    {ℋ_5 : core.clone.Clone.Trait S}
    (svc : T)
    : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
  let* svc := M.alloc svc in
  M.read foo.

(*
        pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
        where
            T: Service<Request> + Clone + Send + 'static,
            T::Response: IntoResponse + 'static,
            T::Future: Send + 'static,
            S: Clone,
        {
            on_service(MethodFilter::$method, svc)
        }
*)
Definition get_service
    {T S : Set}
    {ℋ_0 :
      tower_service.Service.Trait T
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait T::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
    {ℋ_5 : core.clone.Clone.Trait S}
    (svc : T)
    : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
  let* svc := M.alloc svc in
  M.read foo.

(*
        pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
        where
            T: Service<Request> + Clone + Send + 'static,
            T::Response: IntoResponse + 'static,
            T::Future: Send + 'static,
            S: Clone,
        {
            on_service(MethodFilter::$method, svc)
        }
*)
Definition head_service
    {T S : Set}
    {ℋ_0 :
      tower_service.Service.Trait T
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait T::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
    {ℋ_5 : core.clone.Clone.Trait S}
    (svc : T)
    : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
  let* svc := M.alloc svc in
  M.read foo.

(*
        pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
        where
            T: Service<Request> + Clone + Send + 'static,
            T::Response: IntoResponse + 'static,
            T::Future: Send + 'static,
            S: Clone,
        {
            on_service(MethodFilter::$method, svc)
        }
*)
Definition options_service
    {T S : Set}
    {ℋ_0 :
      tower_service.Service.Trait T
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait T::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
    {ℋ_5 : core.clone.Clone.Trait S}
    (svc : T)
    : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
  let* svc := M.alloc svc in
  M.read foo.

(*
        pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
        where
            T: Service<Request> + Clone + Send + 'static,
            T::Response: IntoResponse + 'static,
            T::Future: Send + 'static,
            S: Clone,
        {
            on_service(MethodFilter::$method, svc)
        }
*)
Definition patch_service
    {T S : Set}
    {ℋ_0 :
      tower_service.Service.Trait T
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait T::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
    {ℋ_5 : core.clone.Clone.Trait S}
    (svc : T)
    : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
  let* svc := M.alloc svc in
  M.read foo.

(*
        pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
        where
            T: Service<Request> + Clone + Send + 'static,
            T::Response: IntoResponse + 'static,
            T::Future: Send + 'static,
            S: Clone,
        {
            on_service(MethodFilter::$method, svc)
        }
*)
Definition post_service
    {T S : Set}
    {ℋ_0 :
      tower_service.Service.Trait T
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait T::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
    {ℋ_5 : core.clone.Clone.Trait S}
    (svc : T)
    : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
  let* svc := M.alloc svc in
  M.read foo.

(*
        pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
        where
            T: Service<Request> + Clone + Send + 'static,
            T::Response: IntoResponse + 'static,
            T::Future: Send + 'static,
            S: Clone,
        {
            on_service(MethodFilter::$method, svc)
        }
*)
Definition put_service
    {T S : Set}
    {ℋ_0 :
      tower_service.Service.Trait T
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait T::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
    {ℋ_5 : core.clone.Clone.Trait S}
    (svc : T)
    : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
  let* svc := M.alloc svc in
  M.read foo.

(*
        pub fn $name<T, S>(svc: T) -> MethodRouter<S, T::Error>
        where
            T: Service<Request> + Clone + Send + 'static,
            T::Response: IntoResponse + 'static,
            T::Future: Send + 'static,
            S: Clone,
        {
            on_service(MethodFilter::$method, svc)
        }
*)
Definition trace_service
    {T S : Set}
    {ℋ_0 :
      tower_service.Service.Trait T
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait T::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
    {ℋ_5 : core.clone.Clone.Trait S}
    (svc : T)
    : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
  let* svc := M.alloc svc in
  M.read foo.

(*
pub fn on_service<T, S>(filter: MethodFilter, svc: T) -> MethodRouter<S, T::Error>
where
    T: Service<Request> + Clone + Send + 'static,
    T::Response: IntoResponse + 'static,
    T::Future: Send + 'static,
    S: Clone,
{
    MethodRouter::new().on_service(filter, svc)
}
*)
Definition on_service
    {T S : Set}
    {ℋ_0 :
      tower_service.Service.Trait T
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait T::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
    {ℋ_5 : core.clone.Clone.Trait S}
    (filter : axum.routing.method_filter.MethodFilter.t)
    (svc : T)
    : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
  let* filter := M.alloc filter in
  let* svc := M.alloc svc in
  M.read foo.

(*
pub fn any_service<T, S>(svc: T) -> MethodRouter<S, T::Error>
where
    T: Service<Request> + Clone + Send + 'static,
    T::Response: IntoResponse + 'static,
    T::Future: Send + 'static,
    S: Clone,
{
    MethodRouter::new()
        .fallback_service(svc)
        .skip_allow_header()
}
*)
Definition any_service
    {T S : Set}
    {ℋ_0 :
      tower_service.Service.Trait T
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_1 : core.clone.Clone.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait T::type["Response"].t}
    {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
    {ℋ_5 : core.clone.Clone.Trait S}
    (svc : T)
    : M (axum.routing.method_routing.MethodRouter.t S T::type["Error"].t) :=
  let* svc := M.alloc svc in
  M.read foo.

(*
        pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
        where
            H: Handler<T, S>,
            T: 'static,
            S: Clone + Send + Sync + 'static,
        {
            on(MethodFilter::$method, handler)
        }
*)
Definition delete
    {H T S : Set}
    {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}
    (handler : H)
    :
      M
        (axum.routing.method_routing.MethodRouter.t
          S
          core.convert.Infallible.t) :=
  let* handler := M.alloc handler in
  M.read foo.

(*
        pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
        where
            H: Handler<T, S>,
            T: 'static,
            S: Clone + Send + Sync + 'static,
        {
            on(MethodFilter::$method, handler)
        }
*)
Definition get
    {H T S : Set}
    {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}
    (handler : H)
    :
      M
        (axum.routing.method_routing.MethodRouter.t
          S
          core.convert.Infallible.t) :=
  let* handler := M.alloc handler in
  M.read foo.

(*
        pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
        where
            H: Handler<T, S>,
            T: 'static,
            S: Clone + Send + Sync + 'static,
        {
            on(MethodFilter::$method, handler)
        }
*)
Definition head
    {H T S : Set}
    {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}
    (handler : H)
    :
      M
        (axum.routing.method_routing.MethodRouter.t
          S
          core.convert.Infallible.t) :=
  let* handler := M.alloc handler in
  M.read foo.

(*
        pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
        where
            H: Handler<T, S>,
            T: 'static,
            S: Clone + Send + Sync + 'static,
        {
            on(MethodFilter::$method, handler)
        }
*)
Definition options
    {H T S : Set}
    {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}
    (handler : H)
    :
      M
        (axum.routing.method_routing.MethodRouter.t
          S
          core.convert.Infallible.t) :=
  let* handler := M.alloc handler in
  M.read foo.

(*
        pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
        where
            H: Handler<T, S>,
            T: 'static,
            S: Clone + Send + Sync + 'static,
        {
            on(MethodFilter::$method, handler)
        }
*)
Definition patch
    {H T S : Set}
    {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}
    (handler : H)
    :
      M
        (axum.routing.method_routing.MethodRouter.t
          S
          core.convert.Infallible.t) :=
  let* handler := M.alloc handler in
  M.read foo.

(*
        pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
        where
            H: Handler<T, S>,
            T: 'static,
            S: Clone + Send + Sync + 'static,
        {
            on(MethodFilter::$method, handler)
        }
*)
Definition post
    {H T S : Set}
    {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}
    (handler : H)
    :
      M
        (axum.routing.method_routing.MethodRouter.t
          S
          core.convert.Infallible.t) :=
  let* handler := M.alloc handler in
  M.read foo.

(*
        pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
        where
            H: Handler<T, S>,
            T: 'static,
            S: Clone + Send + Sync + 'static,
        {
            on(MethodFilter::$method, handler)
        }
*)
Definition put
    {H T S : Set}
    {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}
    (handler : H)
    :
      M
        (axum.routing.method_routing.MethodRouter.t
          S
          core.convert.Infallible.t) :=
  let* handler := M.alloc handler in
  M.read foo.

(*
        pub fn $name<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
        where
            H: Handler<T, S>,
            T: 'static,
            S: Clone + Send + Sync + 'static,
        {
            on(MethodFilter::$method, handler)
        }
*)
Definition trace
    {H T S : Set}
    {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}
    (handler : H)
    :
      M
        (axum.routing.method_routing.MethodRouter.t
          S
          core.convert.Infallible.t) :=
  let* handler := M.alloc handler in
  M.read foo.

(*
pub fn on<H, T, S>(filter: MethodFilter, handler: H) -> MethodRouter<S, Infallible>
where
    H: Handler<T, S>,
    T: 'static,
    S: Clone + Send + Sync + 'static,
{
    MethodRouter::new().on(filter, handler)
}
*)
Definition on
    {H T S : Set}
    {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}
    (filter : axum.routing.method_filter.MethodFilter.t)
    (handler : H)
    :
      M
        (axum.routing.method_routing.MethodRouter.t
          S
          core.convert.Infallible.t) :=
  let* filter := M.alloc filter in
  let* handler := M.alloc handler in
  M.read foo.

(*
pub fn any<H, T, S>(handler: H) -> MethodRouter<S, Infallible>
where
    H: Handler<T, S>,
    T: 'static,
    S: Clone + Send + Sync + 'static,
{
    MethodRouter::new().fallback(handler).skip_allow_header()
}
*)
Definition any
    {H T S : Set}
    {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait S}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}
    (handler : H)
    :
      M
        (axum.routing.method_routing.MethodRouter.t
          S
          core.convert.Infallible.t) :=
  let* handler := M.alloc handler in
  M.read foo.

Module  MethodRouter.
Section MethodRouter.
  Context (S E : Set).
  
  Record t : Set := {
    get : axum.routing.method_routing.MethodEndpoint.t S E;
    head : axum.routing.method_routing.MethodEndpoint.t S E;
    delete : axum.routing.method_routing.MethodEndpoint.t S E;
    options : axum.routing.method_routing.MethodEndpoint.t S E;
    patch : axum.routing.method_routing.MethodEndpoint.t S E;
    post : axum.routing.method_routing.MethodEndpoint.t S E;
    put : axum.routing.method_routing.MethodEndpoint.t S E;
    trace : axum.routing.method_routing.MethodEndpoint.t S E;
    fallback : axum.routing.Fallback.t S E;
    allow_header : axum.routing.method_routing.AllowHeader.t;
  }.
  
  Definition Get_get :=
    Ref.map (fun α => Some α.(get)) (fun β α => Some (α <| get := β |>)).
  Definition Get_head :=
    Ref.map (fun α => Some α.(head)) (fun β α => Some (α <| head := β |>)).
  Definition Get_delete :=
    Ref.map (fun α => Some α.(delete)) (fun β α => Some (α <| delete := β |>)).
  Definition Get_options :=
    Ref.map
      (fun α => Some α.(options))
      (fun β α => Some (α <| options := β |>)).
  Definition Get_patch :=
    Ref.map (fun α => Some α.(patch)) (fun β α => Some (α <| patch := β |>)).
  Definition Get_post :=
    Ref.map (fun α => Some α.(post)) (fun β α => Some (α <| post := β |>)).
  Definition Get_put :=
    Ref.map (fun α => Some α.(put)) (fun β α => Some (α <| put := β |>)).
  Definition Get_trace :=
    Ref.map (fun α => Some α.(trace)) (fun β α => Some (α <| trace := β |>)).
  Definition Get_fallback :=
    Ref.map
      (fun α => Some α.(fallback))
      (fun β α => Some (α <| fallback := β |>)).
  Definition Get_allow_header :=
    Ref.map
      (fun α => Some α.(allow_header))
      (fun β α => Some (α <| allow_header := β |>)).
  Module Default.
    Definition S := unit.
    Definition E := core.convert.Infallible.t.
  End Default.
End MethodRouter.
End MethodRouter.

Module AllowHeader.
  Inductive t : Set :=
  | None
  | Skip
  | Bytes (_ : bytes.bytes_mut.BytesMut.t).
  
  Definition Get_Bytes_0 :=
    Ref.map
      (fun α => match α with | Bytes α0 => Some α0 | _ => None end)
      (fun β α => match α with | Bytes _ => Some (Bytes β) | _ => None end).
End AllowHeader.

Module  Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.
Section Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.
  Definition Self : Set := axum.routing.method_routing.AllowHeader.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M axum.routing.method_routing.AllowHeader.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.
End Impl_core_clone_Clone_for_axum_routing_method_routing_AllowHeader_t.

Module  Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.
Section Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.
  Definition Self : Set := axum.routing.method_routing.AllowHeader.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.
End Impl_core_fmt_Debug_for_axum_routing_method_routing_AllowHeader_t.

Module  Impl_axum_routing_method_routing_AllowHeader_t_3.
Section Impl_axum_routing_method_routing_AllowHeader_t_3.
  Definition Self : Set := axum.routing.method_routing.AllowHeader.t.
  
  (*
      fn merge(self, other: Self) -> Self {
          match (self, other) {
              (AllowHeader::Skip, _) | (_, AllowHeader::Skip) => AllowHeader::Skip,
              (AllowHeader::None, AllowHeader::None) => AllowHeader::None,
              (AllowHeader::None, AllowHeader::Bytes(pick)) => AllowHeader::Bytes(pick),
              (AllowHeader::Bytes(pick), AllowHeader::None) => AllowHeader::Bytes(pick),
              (AllowHeader::Bytes(mut a), AllowHeader::Bytes(b)) => {
                  a.extend_from_slice(b",");
                  a.extend_from_slice(&b);
                  AllowHeader::Bytes(a)
              }
          }
      }
  *)
  Definition merge (self : Self) (other : Self) : M Self :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_merge :
    Notations.DoubleColon Self "merge" := {
    Notations.double_colon := merge;
  }.
End Impl_axum_routing_method_routing_AllowHeader_t_3.
End Impl_axum_routing_method_routing_AllowHeader_t_3.

Module  Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.
Section Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.
  Context {S E : Set}.
  
  Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("MethodRouter")
              .field("get", &self.get)
              .field("head", &self.head)
              .field("delete", &self.delete)
              .field("options", &self.options)
              .field("patch", &self.patch)
              .field("post", &self.post)
              .field("put", &self.put)
              .field("trace", &self.trace)
              .field("fallback", &self.fallback)
              .field("allow_header", &self.allow_header)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.
End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodRouter_t_S_E.

Module  Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t_3.
Section Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t_3.
  Context {S : Set}.
  
  Definition Self : Set :=
    axum.routing.method_routing.MethodRouter.t S core.convert.Infallible.t.
  
  (*
      pub fn on<H, T>(self, filter: MethodFilter, handler: H) -> Self
      where
          H: Handler<T, S>,
          T: 'static,
          S: Send + Sync + 'static,
      {
          self.on_endpoint(
              filter,
              MethodEndpoint::BoxedHandler(BoxedIntoRoute::from_handler(handler)),
          )
      }
  *)
  Definition on
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : Self)
      (filter : axum.routing.method_filter.MethodFilter.t)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* filter := M.alloc filter in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_on
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "on" := {
    Notations.double_colon := on (H := H) (T := T);
  }.
  
  (*
          pub fn $name<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
              S: Send + Sync + 'static,
          {
              self.on(MethodFilter::$method, handler)
          }
  *)
  Definition delete
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_delete
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "delete" := {
    Notations.double_colon := delete (H := H) (T := T);
  }.
  
  (*
          pub fn $name<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
              S: Send + Sync + 'static,
          {
              self.on(MethodFilter::$method, handler)
          }
  *)
  Definition get
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_get
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "get" := {
    Notations.double_colon := get (H := H) (T := T);
  }.
  
  (*
          pub fn $name<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
              S: Send + Sync + 'static,
          {
              self.on(MethodFilter::$method, handler)
          }
  *)
  Definition head
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_head
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "head" := {
    Notations.double_colon := head (H := H) (T := T);
  }.
  
  (*
          pub fn $name<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
              S: Send + Sync + 'static,
          {
              self.on(MethodFilter::$method, handler)
          }
  *)
  Definition options
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_options
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "options" := {
    Notations.double_colon := options (H := H) (T := T);
  }.
  
  (*
          pub fn $name<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
              S: Send + Sync + 'static,
          {
              self.on(MethodFilter::$method, handler)
          }
  *)
  Definition patch
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_patch
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "patch" := {
    Notations.double_colon := patch (H := H) (T := T);
  }.
  
  (*
          pub fn $name<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
              S: Send + Sync + 'static,
          {
              self.on(MethodFilter::$method, handler)
          }
  *)
  Definition post
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_post
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "post" := {
    Notations.double_colon := post (H := H) (T := T);
  }.
  
  (*
          pub fn $name<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
              S: Send + Sync + 'static,
          {
              self.on(MethodFilter::$method, handler)
          }
  *)
  Definition put
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_put
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "put" := {
    Notations.double_colon := put (H := H) (T := T);
  }.
  
  (*
          pub fn $name<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
              S: Send + Sync + 'static,
          {
              self.on(MethodFilter::$method, handler)
          }
  *)
  Definition trace
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_trace
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "trace" := {
    Notations.double_colon := trace (H := H) (T := T);
  }.
  
  (*
      pub fn fallback<H, T>(mut self, handler: H) -> Self
      where
          H: Handler<T, S>,
          T: 'static,
          S: Send + Sync + 'static,
      {
          self.fallback = Fallback::BoxedHandler(BoxedIntoRoute::from_handler(handler));
          self
      }
  *)
  Definition fallback
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_fallback
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "fallback" := {
    Notations.double_colon := fallback (H := H) (T := T);
  }.
End Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t_3.
End Impl_axum_routing_method_routing_MethodRouter_t_S_core_convert_Infallible_t_3.

Module  Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t_3.
Section Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t_3.
  Definition Self : Set :=
    axum.routing.method_routing.MethodRouter.t unit core.convert.Infallible.t.
  
  (*
      pub fn into_make_service(self) -> IntoMakeService<Self> {
          IntoMakeService::new(self.with_state(()))
      }
  *)
  Definition into_make_service
      (self : Self)
      : M (axum.routing.into_make_service.IntoMakeService.t Self) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_make_service :
    Notations.DoubleColon Self "into_make_service" := {
    Notations.double_colon := into_make_service;
  }.
  
  (*
      pub fn into_make_service_with_connect_info<C>(self) -> IntoMakeServiceWithConnectInfo<Self, C> {
          IntoMakeServiceWithConnectInfo::new(self.with_state(()))
      }
  *)
  Definition into_make_service_with_connect_info
      {C : Set}
      (self : Self)
      : M (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t Self C) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_make_service_with_connect_info
      {C : Set} :
    Notations.DoubleColon Self "into_make_service_with_connect_info" := {
    Notations.double_colon := into_make_service_with_connect_info (C := C);
  }.
End Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t_3.
End Impl_axum_routing_method_routing_MethodRouter_t_Tuple__core_convert_Infallible_t_3.

Module  Impl_axum_routing_method_routing_MethodRouter_t_S_E_3.
Section Impl_axum_routing_method_routing_MethodRouter_t_S_E_3.
  Context {S E : Set}.
  
  Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
  
  (*
      pub fn new() -> Self {
          let fallback = Route::new(service_fn(|_: Request| async {
              Ok(StatusCode::METHOD_NOT_ALLOWED.into_response())
          }));
  
          Self {
              get: MethodEndpoint::None,
              head: MethodEndpoint::None,
              delete: MethodEndpoint::None,
              options: MethodEndpoint::None,
              patch: MethodEndpoint::None,
              post: MethodEndpoint::None,
              put: MethodEndpoint::None,
              trace: MethodEndpoint::None,
              allow_header: AllowHeader::None,
              fallback: Fallback::Default(fallback),
          }
      }
  *)
  Definition new : M Self := M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn with_state<S2>(self, state: S) -> MethodRouter<S2, E> {
          MethodRouter {
              get: self.get.with_state(&state),
              head: self.head.with_state(&state),
              delete: self.delete.with_state(&state),
              options: self.options.with_state(&state),
              patch: self.patch.with_state(&state),
              post: self.post.with_state(&state),
              put: self.put.with_state(&state),
              trace: self.trace.with_state(&state),
              allow_header: self.allow_header,
              fallback: self.fallback.with_state(state),
          }
      }
  *)
  Definition with_state
      {S2 : Set}
      (self : Self)
      (state : S)
      : M (axum.routing.method_routing.MethodRouter.t S2 E) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_with_state {S2 : Set} :
    Notations.DoubleColon Self "with_state" := {
    Notations.double_colon := with_state (S2 := S2);
  }.
  
  (*
      pub fn on_service<T>(self, filter: MethodFilter, svc: T) -> Self
      where
          T: Service<Request, Error = E> + Clone + Send + 'static,
          T::Response: IntoResponse + 'static,
          T::Future: Send + 'static,
      {
          self.on_endpoint(filter, MethodEndpoint::Route(Route::new(svc)))
      }
  *)
  Definition on_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (filter : axum.routing.method_filter.MethodFilter.t)
      (svc : T)
      : M Self :=
    let* self := M.alloc self in
    let* filter := M.alloc filter in
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_on_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "on_service" := {
    Notations.double_colon := on_service (T := T);
  }.
  
  (*
      fn on_endpoint(mut self, filter: MethodFilter, endpoint: MethodEndpoint<S, E>) -> Self {
          // written as a separate function to generate less IR
          #[track_caller]
          fn set_endpoint<S, E>(
              method_name: &str,
              out: &mut MethodEndpoint<S, E>,
              endpoint: &MethodEndpoint<S, E>,
              endpoint_filter: MethodFilter,
              filter: MethodFilter,
              allow_header: &mut AllowHeader,
              methods: &[&'static str],
          ) where
              MethodEndpoint<S, E>: Clone,
              S: Clone,
          {
              if endpoint_filter.contains(filter) {
                  if out.is_some() {
                      panic!(
                          "Overlapping method route. Cannot add two method routes that both handle \
                           `{method_name}`",
                      )
                  }
                  *out = endpoint.clone();
                  for method in methods {
                      append_allow_header(allow_header, method);
                  }
              }
          }
  
          set_endpoint(
              "GET",
              &mut self.get,
              &endpoint,
              filter,
              MethodFilter::GET,
              &mut self.allow_header,
              &["GET", "HEAD"],
          );
  
          set_endpoint(
              "HEAD",
              &mut self.head,
              &endpoint,
              filter,
              MethodFilter::HEAD,
              &mut self.allow_header,
              &["HEAD"],
          );
  
          set_endpoint(
              "TRACE",
              &mut self.trace,
              &endpoint,
              filter,
              MethodFilter::TRACE,
              &mut self.allow_header,
              &["TRACE"],
          );
  
          set_endpoint(
              "PUT",
              &mut self.put,
              &endpoint,
              filter,
              MethodFilter::PUT,
              &mut self.allow_header,
              &["PUT"],
          );
  
          set_endpoint(
              "POST",
              &mut self.post,
              &endpoint,
              filter,
              MethodFilter::POST,
              &mut self.allow_header,
              &["POST"],
          );
  
          set_endpoint(
              "PATCH",
              &mut self.patch,
              &endpoint,
              filter,
              MethodFilter::PATCH,
              &mut self.allow_header,
              &["PATCH"],
          );
  
          set_endpoint(
              "OPTIONS",
              &mut self.options,
              &endpoint,
              filter,
              MethodFilter::OPTIONS,
              &mut self.allow_header,
              &["OPTIONS"],
          );
  
          set_endpoint(
              "DELETE",
              &mut self.delete,
              &endpoint,
              filter,
              MethodFilter::DELETE,
              &mut self.allow_header,
              &["DELETE"],
          );
  
          self
      }
  *)
  Definition on_endpoint
      (self : Self)
      (filter : axum.routing.method_filter.MethodFilter.t)
      (endpoint : axum.routing.method_routing.MethodEndpoint.t S E)
      : M Self :=
    let* self := M.alloc self in
    let* filter := M.alloc filter in
    let* endpoint := M.alloc endpoint in
    M.read foo.
  
  Global Instance AssociatedFunction_on_endpoint :
    Notations.DoubleColon Self "on_endpoint" := {
    Notations.double_colon := on_endpoint;
  }.
  
  (*
          pub fn $name<T>(self, svc: T) -> Self
          where
              T: Service<Request, Error = E>
                  + Clone
                  + Send
                  + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
          {
              self.on_service(MethodFilter::$method, svc)
          }
  *)
  Definition delete_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (svc : T)
      : M Self :=
    let* self := M.alloc self in
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_delete_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "delete_service" := {
    Notations.double_colon := delete_service (T := T);
  }.
  
  (*
          pub fn $name<T>(self, svc: T) -> Self
          where
              T: Service<Request, Error = E>
                  + Clone
                  + Send
                  + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
          {
              self.on_service(MethodFilter::$method, svc)
          }
  *)
  Definition get_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (svc : T)
      : M Self :=
    let* self := M.alloc self in
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_get_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "get_service" := {
    Notations.double_colon := get_service (T := T);
  }.
  
  (*
          pub fn $name<T>(self, svc: T) -> Self
          where
              T: Service<Request, Error = E>
                  + Clone
                  + Send
                  + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
          {
              self.on_service(MethodFilter::$method, svc)
          }
  *)
  Definition head_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (svc : T)
      : M Self :=
    let* self := M.alloc self in
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_head_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "head_service" := {
    Notations.double_colon := head_service (T := T);
  }.
  
  (*
          pub fn $name<T>(self, svc: T) -> Self
          where
              T: Service<Request, Error = E>
                  + Clone
                  + Send
                  + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
          {
              self.on_service(MethodFilter::$method, svc)
          }
  *)
  Definition options_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (svc : T)
      : M Self :=
    let* self := M.alloc self in
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_options_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "options_service" := {
    Notations.double_colon := options_service (T := T);
  }.
  
  (*
          pub fn $name<T>(self, svc: T) -> Self
          where
              T: Service<Request, Error = E>
                  + Clone
                  + Send
                  + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
          {
              self.on_service(MethodFilter::$method, svc)
          }
  *)
  Definition patch_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (svc : T)
      : M Self :=
    let* self := M.alloc self in
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_patch_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "patch_service" := {
    Notations.double_colon := patch_service (T := T);
  }.
  
  (*
          pub fn $name<T>(self, svc: T) -> Self
          where
              T: Service<Request, Error = E>
                  + Clone
                  + Send
                  + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
          {
              self.on_service(MethodFilter::$method, svc)
          }
  *)
  Definition post_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (svc : T)
      : M Self :=
    let* self := M.alloc self in
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_post_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "post_service" := {
    Notations.double_colon := post_service (T := T);
  }.
  
  (*
          pub fn $name<T>(self, svc: T) -> Self
          where
              T: Service<Request, Error = E>
                  + Clone
                  + Send
                  + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
          {
              self.on_service(MethodFilter::$method, svc)
          }
  *)
  Definition put_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (svc : T)
      : M Self :=
    let* self := M.alloc self in
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_put_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "put_service" := {
    Notations.double_colon := put_service (T := T);
  }.
  
  (*
          pub fn $name<T>(self, svc: T) -> Self
          where
              T: Service<Request, Error = E>
                  + Clone
                  + Send
                  + 'static,
              T::Response: IntoResponse + 'static,
              T::Future: Send + 'static,
          {
              self.on_service(MethodFilter::$method, svc)
          }
  *)
  Definition trace_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (svc : T)
      : M Self :=
    let* self := M.alloc self in
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_trace_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "trace_service" := {
    Notations.double_colon := trace_service (T := T);
  }.
  
  (*
      pub fn fallback_service<T>(mut self, svc: T) -> Self
      where
          T: Service<Request, Error = E> + Clone + Send + 'static,
          T::Response: IntoResponse + 'static,
          T::Future: Send + 'static,
      {
          self.fallback = Fallback::Service(Route::new(svc));
          self
      }
  *)
  Definition fallback_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (svc : T)
      : M Self :=
    let* self := M.alloc self in
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_fallback_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "fallback_service" := {
    Notations.double_colon := fallback_service (T := T);
  }.
  
  (*
      pub fn layer<L, NewError>(self, layer: L) -> MethodRouter<S, NewError>
      where
          L: Layer<Route<E>> + Clone + Send + 'static,
          L::Service: Service<Request> + Clone + Send + 'static,
          <L::Service as Service<Request>>::Response: IntoResponse + 'static,
          <L::Service as Service<Request>>::Error: Into<NewError> + 'static,
          <L::Service as Service<Request>>::Future: Send + 'static,
          E: 'static,
          S: 'static,
          NewError: 'static,
      {
          let layer_fn = move |route: Route<E>| route.layer(layer.clone());
  
          MethodRouter {
              get: self.get.map(layer_fn.clone()),
              head: self.head.map(layer_fn.clone()),
              delete: self.delete.map(layer_fn.clone()),
              options: self.options.map(layer_fn.clone()),
              patch: self.patch.map(layer_fn.clone()),
              post: self.post.map(layer_fn.clone()),
              put: self.put.map(layer_fn.clone()),
              trace: self.trace.map(layer_fn.clone()),
              fallback: self.fallback.map(layer_fn),
              allow_header: self.allow_header,
          }
      }
  *)
  Definition layer
      {L NewError : Set}
      {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := NewError)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      (self : Self)
      (layer : L)
      : M (axum.routing.method_routing.MethodRouter.t S NewError) :=
    let* self := M.alloc self in
    let* layer := M.alloc layer in
    M.read foo.
  
  Global Instance AssociatedFunction_layer
      {L NewError : Set}
      {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := NewError)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))} :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer (L := L) (NewError := NewError);
  }.
  
  (*
      pub fn route_layer<L>(mut self, layer: L) -> MethodRouter<S, E>
      where
          L: Layer<Route<E>> + Clone + Send + 'static,
          L::Service: Service<Request, Error = E> + Clone + Send + 'static,
          <L::Service as Service<Request>>::Response: IntoResponse + 'static,
          <L::Service as Service<Request>>::Future: Send + 'static,
          E: 'static,
          S: 'static,
      {
          if self.get.is_none()
              && self.head.is_none()
              && self.delete.is_none()
              && self.options.is_none()
              && self.patch.is_none()
              && self.post.is_none()
              && self.put.is_none()
              && self.trace.is_none()
          {
              panic!(
                  "Adding a route_layer before any routes is a no-op. \
                   Add the routes you want the layer to apply to first."
              );
          }
  
          let layer_fn = move |svc| {
              let svc = layer.layer(svc);
              let svc = MapResponseLayer::new(IntoResponse::into_response).layer(svc);
              Route::new(svc)
          };
  
          self.get = self.get.map(layer_fn.clone());
          self.head = self.head.map(layer_fn.clone());
          self.delete = self.delete.map(layer_fn.clone());
          self.options = self.options.map(layer_fn.clone());
          self.patch = self.patch.map(layer_fn.clone());
          self.post = self.post.map(layer_fn.clone());
          self.put = self.put.map(layer_fn.clone());
          self.trace = self.trace.map(layer_fn);
  
          self
      }
  *)
  Definition route_layer
      {L : Set}
      {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      (self : Self)
      (layer : L)
      : M (axum.routing.method_routing.MethodRouter.t S E) :=
    let* self := M.alloc self in
    let* layer := M.alloc layer in
    M.read foo.
  
  Global Instance AssociatedFunction_route_layer
      {L : Set}
      {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))} :
    Notations.DoubleColon Self "route_layer" := {
    Notations.double_colon := route_layer (L := L);
  }.
  
  (*
      pub(crate) fn merge_for_path(mut self, path: Option<&str>, other: MethodRouter<S, E>) -> Self {
          // written using inner functions to generate less IR
          #[track_caller]
          fn merge_inner<S, E>(
              path: Option<&str>,
              name: &str,
              first: MethodEndpoint<S, E>,
              second: MethodEndpoint<S, E>,
          ) -> MethodEndpoint<S, E> {
              match (first, second) {
                  (MethodEndpoint::None, MethodEndpoint::None) => MethodEndpoint::None,
                  (pick, MethodEndpoint::None) | (MethodEndpoint::None, pick) => pick,
                  _ => {
                      if let Some(path) = path {
                          panic!(
                              "Overlapping method route. Handler for `{name} {path}` already exists"
                          );
                      } else {
                          panic!(
                              "Overlapping method route. Cannot merge two method routes that both \
                               define `{name}`"
                          );
                      }
                  }
              }
          }
  
          self.get = merge_inner(path, "GET", self.get, other.get);
          self.head = merge_inner(path, "HEAD", self.head, other.head);
          self.delete = merge_inner(path, "DELETE", self.delete, other.delete);
          self.options = merge_inner(path, "OPTIONS", self.options, other.options);
          self.patch = merge_inner(path, "PATCH", self.patch, other.patch);
          self.post = merge_inner(path, "POST", self.post, other.post);
          self.put = merge_inner(path, "PUT", self.put, other.put);
          self.trace = merge_inner(path, "TRACE", self.trace, other.trace);
  
          self.fallback = self
              .fallback
              .merge(other.fallback)
              .expect("Cannot merge two `MethodRouter`s that both have a fallback");
  
          self.allow_header = self.allow_header.merge(other.allow_header);
  
          self
      }
  *)
  Definition merge_for_path
      (self : Self)
      (path : core.option.Option.t (ref str.t))
      (other : axum.routing.method_routing.MethodRouter.t S E)
      : M Self :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_merge_for_path :
    Notations.DoubleColon Self "merge_for_path" := {
    Notations.double_colon := merge_for_path;
  }.
  
  (*
      pub fn merge(self, other: MethodRouter<S, E>) -> Self {
          self.merge_for_path(None, other)
      }
  *)
  Definition merge
      (self : Self)
      (other : axum.routing.method_routing.MethodRouter.t S E)
      : M Self :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_merge :
    Notations.DoubleColon Self "merge" := {
    Notations.double_colon := merge;
  }.
  
  (*
      pub fn handle_error<F, T>(self, f: F) -> MethodRouter<S, Infallible>
      where
          F: Clone + Send + Sync + 'static,
          HandleError<Route<E>, F, T>: Service<Request, Error = Infallible>,
          <HandleError<Route<E>, F, T> as Service<Request>>::Future: Send,
          <HandleError<Route<E>, F, T> as Service<Request>>::Response: IntoResponse + Send,
          T: 'static,
          E: 'static,
          S: 'static,
      {
          self.layer(HandleErrorLayer::new(f))
      }
  *)
  Definition handle_error
      {F T : Set}
      {ℋ_0 : core.clone.Clone.Trait F}
      {ℋ_1 : core.marker.Send.Trait F}
      {ℋ_2 : core.marker.Sync.Trait F}
      {ℋ_3 :
        tower_service.Service.Trait
            (axum.error_handling.HandleError.t
              (axum.routing.route.Route.t E)
              F
              T)
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := axum.error_handling.HandleError.t
                (axum.routing.route.Route.t E)
                F
                T)
              (Trait := ltac:(refine _)))}
      {ℋ_5 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := axum.error_handling.HandleError.t
                (axum.routing.route.Route.t E)
                F
                T)
              (Trait := ltac:(refine _)))}
      {ℋ_6 :
        core.marker.Send.Trait
            (tower_service.Service.Response
              (Self := axum.error_handling.HandleError.t
                (axum.routing.route.Route.t E)
                F
                T)
              (Trait := ltac:(refine _)))}
      (self : Self)
      (f : F)
      :
        M
          (axum.routing.method_routing.MethodRouter.t
            S
            core.convert.Infallible.t) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_handle_error
      {F T : Set}
      {ℋ_0 : core.clone.Clone.Trait F}
      {ℋ_1 : core.marker.Send.Trait F}
      {ℋ_2 : core.marker.Sync.Trait F}
      {ℋ_3 :
        tower_service.Service.Trait
            (axum.error_handling.HandleError.t
              (axum.routing.route.Route.t E)
              F
              T)
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := axum.error_handling.HandleError.t
                (axum.routing.route.Route.t E)
                F
                T)
              (Trait := ltac:(refine _)))}
      {ℋ_5 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := axum.error_handling.HandleError.t
                (axum.routing.route.Route.t E)
                F
                T)
              (Trait := ltac:(refine _)))}
      {ℋ_6 :
        core.marker.Send.Trait
            (tower_service.Service.Response
              (Self := axum.error_handling.HandleError.t
                (axum.routing.route.Route.t E)
                F
                T)
              (Trait := ltac:(refine _)))} :
    Notations.DoubleColon Self "handle_error" := {
    Notations.double_colon := handle_error (F := F) (T := T);
  }.
  
  (*
      fn skip_allow_header(mut self) -> Self {
          self.allow_header = AllowHeader::Skip;
          self
      }
  *)
  Definition skip_allow_header (self : Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_skip_allow_header :
    Notations.DoubleColon Self "skip_allow_header" := {
    Notations.double_colon := skip_allow_header;
  }.
  
  (*
      pub(crate) fn call_with_state(&self, req: Request, state: S) -> RouteFuture<E> {
          macro_rules! call {
              (
                  $req:expr,
                  $method:expr,
                  $method_variant:ident,
                  $svc:expr
              ) => {
                  if $method == Method::$method_variant {
                      match $svc {
                          MethodEndpoint::None => {}
                          MethodEndpoint::Route(route) => {
                              return RouteFuture::from_future(route.clone().oneshot_inner($req))
                                  .strip_body($method == Method::HEAD);
                          }
                          MethodEndpoint::BoxedHandler(handler) => {
                              let route = handler.clone().into_route(state);
                              return RouteFuture::from_future(route.clone().oneshot_inner($req))
                                  .strip_body($method == Method::HEAD);
                          }
                      }
                  }
              };
          }
  
          let method = req.method().clone();
  
          // written with a pattern match like this to ensure we call all routes
          let Self {
              get,
              head,
              delete,
              options,
              patch,
              post,
              put,
              trace,
              fallback,
              allow_header,
          } = self;
  
          call!(req, method, HEAD, head);
          call!(req, method, HEAD, get);
          call!(req, method, GET, get);
          call!(req, method, POST, post);
          call!(req, method, OPTIONS, options);
          call!(req, method, PATCH, patch);
          call!(req, method, PUT, put);
          call!(req, method, DELETE, delete);
          call!(req, method, TRACE, trace);
  
          let future = fallback.clone().call_with_state(req, state);
  
          match allow_header {
              AllowHeader::None => future.allow_header(Bytes::new()),
              AllowHeader::Skip => future,
              AllowHeader::Bytes(allow_header) => future.allow_header(allow_header.clone().freeze()),
          }
      }
  *)
  Definition call_with_state
      (self : ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M (axum.routing.route.RouteFuture.t E) :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call_with_state :
    Notations.DoubleColon Self "call_with_state" := {
    Notations.double_colon := call_with_state;
  }.
End Impl_axum_routing_method_routing_MethodRouter_t_S_E_3.
End Impl_axum_routing_method_routing_MethodRouter_t_S_E_3.

(*
        fn set_endpoint<S, E>(
            method_name: &str,
            out: &mut MethodEndpoint<S, E>,
            endpoint: &MethodEndpoint<S, E>,
            endpoint_filter: MethodFilter,
            filter: MethodFilter,
            allow_header: &mut AllowHeader,
            methods: &[&'static str],
        ) where
            MethodEndpoint<S, E>: Clone,
            S: Clone,
        {
            if endpoint_filter.contains(filter) {
                if out.is_some() {
                    panic!(
                        "Overlapping method route. Cannot add two method routes that both handle \
                         `{method_name}`",
                    )
                }
                *out = endpoint.clone();
                for method in methods {
                    append_allow_header(allow_header, method);
                }
            }
        }
*)
Definition set_endpoint
    {S E : Set}
    {ℋ_0 :
      core.clone.Clone.Trait (axum.routing.method_routing.MethodEndpoint.t S E)}
    {ℋ_1 : core.clone.Clone.Trait S}
    (method_name : ref str.t)
    (out : mut_ref (axum.routing.method_routing.MethodEndpoint.t S E))
    (endpoint : ref (axum.routing.method_routing.MethodEndpoint.t S E))
    (endpoint_filter : axum.routing.method_filter.MethodFilter.t)
    (filter : axum.routing.method_filter.MethodFilter.t)
    (allow_header : mut_ref axum.routing.method_routing.AllowHeader.t)
    (methods : ref (slice (ref str.t)))
    : M unit :=
  let* method_name := M.alloc method_name in
  let* out := M.alloc out in
  let* endpoint := M.alloc endpoint in
  let* endpoint_filter := M.alloc endpoint_filter in
  let* filter := M.alloc filter in
  let* allow_header := M.alloc allow_header in
  let* methods := M.alloc methods in
  M.read foo.

(*
        fn merge_inner<S, E>(
            path: Option<&str>,
            name: &str,
            first: MethodEndpoint<S, E>,
            second: MethodEndpoint<S, E>,
        ) -> MethodEndpoint<S, E> {
            match (first, second) {
                (MethodEndpoint::None, MethodEndpoint::None) => MethodEndpoint::None,
                (pick, MethodEndpoint::None) | (MethodEndpoint::None, pick) => pick,
                _ => {
                    if let Some(path) = path {
                        panic!(
                            "Overlapping method route. Handler for `{name} {path}` already exists"
                        );
                    } else {
                        panic!(
                            "Overlapping method route. Cannot merge two method routes that both \
                             define `{name}`"
                        );
                    }
                }
            }
        }
*)
Definition merge_inner
    {S E : Set}
    (path : core.option.Option.t (ref str.t))
    (name : ref str.t)
    (first : axum.routing.method_routing.MethodEndpoint.t S E)
    (second : axum.routing.method_routing.MethodEndpoint.t S E)
    : M (axum.routing.method_routing.MethodEndpoint.t S E) :=
  let* path := M.alloc path in
  let* name := M.alloc name in
  let* first := M.alloc first in
  let* second := M.alloc second in
  M.read foo.

(*
fn append_allow_header(allow_header: &mut AllowHeader, method: &'static str) {
    match allow_header {
        AllowHeader::None => {
            *allow_header = AllowHeader::Bytes(BytesMut::from(method));
        }
        AllowHeader::Skip => {}
        AllowHeader::Bytes(allow_header) => {
            if let Ok(s) = std::str::from_utf8(allow_header) {
                if !s.contains(method) {
                    allow_header.extend_from_slice(b",");
                    allow_header.extend_from_slice(method.as_bytes());
                }
            } else {
                #[cfg(debug_assertions)]
                panic!("`allow_header` contained invalid uft-8. This should never happen")
            }
        }
    }
}
*)
Definition append_allow_header
    (allow_header : mut_ref axum.routing.method_routing.AllowHeader.t)
    (method : ref str.t)
    : M unit :=
  let* allow_header := M.alloc allow_header in
  let* method := M.alloc method in
  M.read foo.

Module  Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.
Section Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.
  Context {S E : Set}.
  
  Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
  
  (*
      fn clone(&self) -> Self {
          Self {
              get: self.get.clone(),
              head: self.head.clone(),
              delete: self.delete.clone(),
              options: self.options.clone(),
              patch: self.patch.clone(),
              post: self.post.clone(),
              put: self.put.clone(),
              trace: self.trace.clone(),
              fallback: self.fallback.clone(),
              allow_header: self.allow_header.clone(),
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.
End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodRouter_t_S_E.

Module  Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.
Section Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.
  Context {S E : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.routing.method_routing.MethodRouter.t S E.
  
  (*
      fn default() -> Self {
          Self::new()
      }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.
End Impl_core_default_Default_for_axum_routing_method_routing_MethodRouter_t_S_E.

Module MethodEndpoint.
  Inductive t (S : Set) (E : Set) : Set :=
  | None
  | Route (_ : axum.routing.route.Route.t E)
  | BoxedHandler (_ : axum.boxed.BoxedIntoRoute.t S E).
  
  Definition Get_Route_0 :=
    Ref.map
      (fun α => match α with | Route α0 => Some α0 | _ => None end)
      (fun β α => match α with | Route _ => Some (Route β) | _ => None end).
  
  Definition Get_BoxedHandler_0 :=
    Ref.map
      (fun α => match α with | BoxedHandler α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | BoxedHandler _ => Some (BoxedHandler β) | _ => None end).
End MethodEndpoint.

Module  Impl_axum_routing_method_routing_MethodEndpoint_t_S_E_3.
Section Impl_axum_routing_method_routing_MethodEndpoint_t_S_E_3.
  Context {S E : Set}.
  
  Definition Self : Set := axum.routing.method_routing.MethodEndpoint.t S E.
  
  (*
      fn is_some(&self) -> bool {
          matches!(self, Self::Route(_) | Self::BoxedHandler(_))
      }
  *)
  Definition is_some (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_some :
    Notations.DoubleColon Self "is_some" := {
    Notations.double_colon := is_some;
  }.
  
  (*
      fn is_none(&self) -> bool {
          matches!(self, Self::None)
      }
  *)
  Definition is_none (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_none :
    Notations.DoubleColon Self "is_none" := {
    Notations.double_colon := is_none;
  }.
  
  (*
      fn map<F, E2>(self, f: F) -> MethodEndpoint<S, E2>
      where
          S: 'static,
          E: 'static,
          F: FnOnce(Route<E>) -> Route<E2> + Clone + Send + 'static,
          E2: 'static,
      {
          match self {
              Self::None => MethodEndpoint::None,
              Self::Route(route) => MethodEndpoint::Route(f(route)),
              Self::BoxedHandler(handler) => MethodEndpoint::BoxedHandler(handler.map(f)),
          }
      }
  *)
  Definition map
      {F E2 : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F (Args := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      (self : Self)
      (f : F)
      : M (axum.routing.method_routing.MethodEndpoint.t S E2) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_map
      {F E2 : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F (Args := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F} :
    Notations.DoubleColon Self "map" := {
    Notations.double_colon := map (F := F) (E2 := E2);
  }.
  
  (*
      fn with_state<S2>(self, state: &S) -> MethodEndpoint<S2, E> {
          match self {
              MethodEndpoint::None => MethodEndpoint::None,
              MethodEndpoint::Route(route) => MethodEndpoint::Route(route),
              MethodEndpoint::BoxedHandler(handler) => {
                  MethodEndpoint::Route(handler.into_route(state.clone()))
              }
          }
      }
  *)
  Definition with_state
      {S2 : Set}
      (self : Self)
      (state : ref S)
      : M (axum.routing.method_routing.MethodEndpoint.t S2 E) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_with_state {S2 : Set} :
    Notations.DoubleColon Self "with_state" := {
    Notations.double_colon := with_state (S2 := S2);
  }.
End Impl_axum_routing_method_routing_MethodEndpoint_t_S_E_3.
End Impl_axum_routing_method_routing_MethodEndpoint_t_S_E_3.

Module  Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
Section Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
  Context {S E : Set}.
  
  Definition Self : Set := axum.routing.method_routing.MethodEndpoint.t S E.
  
  (*
      fn clone(&self) -> Self {
          match self {
              Self::None => Self::None,
              Self::Route(inner) => Self::Route(inner.clone()),
              Self::BoxedHandler(inner) => Self::BoxedHandler(inner.clone()),
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
End Impl_core_clone_Clone_for_axum_routing_method_routing_MethodEndpoint_t_S_E.

Module  Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
Section Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
  Context {S E : Set}.
  
  Definition Self : Set := axum.routing.method_routing.MethodEndpoint.t S E.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          match self {
              Self::None => f.debug_tuple("None").finish(),
              Self::Route(inner) => inner.fmt(f),
              Self::BoxedHandler(_) => f.debug_tuple("BoxedHandler").finish(),
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.
End Impl_core_fmt_Debug_for_axum_routing_method_routing_MethodEndpoint_t_S_E.

Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.
Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.
  Context {B E : Set}.
  
  Context
    {ℋ_0 : http_body.Body.Trait B}
    {ℋ_1 : core.marker.Send.Trait B}
    {ℋ_2 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}.
  
  Definition Self : Set := axum.routing.method_routing.MethodRouter.t unit E.
  
  (*
      type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      type Error = E;
  *)
  Definition Error : Set := E.
  
  (*
      type Future = RouteFuture<E>;
  *)
  Definition Future : Set := axum.routing.route.RouteFuture.t E.
  
  (*
      fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          Poll::Ready(Ok(()))
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (_cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* _cx := M.alloc _cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, req: Request<B>) -> Self::Future {
          let req = req.map(Body::new);
          self.call_with_state(req, ())
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req : ltac:(axum_core.extract.Request B))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request B)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_method_routing_MethodRouter_t_Tuple__E.

Module  Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.
Section Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.
  Context {S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set :=
    axum.routing.method_routing.MethodRouter.t
      S
      axum.routing.method_routing.MethodRouter.Default.E.
  
  (*
      type Future = InfallibleRouteFuture;
  *)
  Definition Future : Set := axum.routing.route.InfallibleRouteFuture.t.
  
  (*
      fn call(self, req: Request, state: S) -> Self::Future {
          InfallibleRouteFuture::new(self.call_with_state(req, state))
      }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self (T := unit) (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.
End Impl_axum_handler_Handler_Tuple__S_for_axum_routing_method_routing_MethodRouter_t_S_axum_routing_method_routing_MethodRouter_Default_E.

Module  Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_routing_method_routing_MethodRouter_t_Tuple__axum_routing_method_routing_MethodRouter_Default_E.
Section Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_routing_method_routing_MethodRouter_t_Tuple__axum_routing_method_routing_MethodRouter_Default_E.
  Definition Self : Set :=
    axum.routing.method_routing.MethodRouter.t
      unit
      axum.routing.method_routing.MethodRouter.Default.E.
  
  (*
          type Response = Self;
  *)
  Definition Response : Set := Self.
  
  (*
          type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
          type Future = std::future::Ready<Result<Self::Response, Self::Error>>;
  *)
  Definition Future : Set :=
    core.future.ready.Ready.t (core.result.Result.t Response Error).
  
  (*
          fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              Poll::Ready(Ok(()))
          }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (_cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* _cx := M.alloc _cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
          fn call(&mut self, _req: IncomingStream<'_>) -> Self::Future {
              std::future::ready(Ok(self.clone()))
          }
  *)
  Definition call
      (self : mut_ref Self)
      (_req : axum.serve.IncomingStream.t)
      : M Future :=
    let* self := M.alloc self in
    let* _req := M.alloc _req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := axum.serve.IncomingStream.t) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_routing_method_routing_MethodRouter_t_Tuple__axum_routing_method_routing_MethodRouter_Default_E.
End Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_routing_method_routing_MethodRouter_t_Tuple__axum_routing_method_routing_MethodRouter_Default_E.

Module into_make_service.
  Module  IntoMakeService.
  Section IntoMakeService.
    Context (S : Set).
    
    Record t : Set := {
      svc : S;
    }.
    
    Definition Get_svc :=
      Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
  End IntoMakeService.
  End IntoMakeService.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.
  Section Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set := axum.routing.into_make_service.IntoMakeService.t S.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.
  End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.
  
  Module  Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.
  Section Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.routing.into_make_service.IntoMakeService.t S.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum.routing.into_make_service.IntoMakeService.t S) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.
  End Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.
  
  Module  Impl_axum_routing_into_make_service_IntoMakeService_t_S_2.
  Section Impl_axum_routing_into_make_service_IntoMakeService_t_S_2.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.into_make_service.IntoMakeService.t S.
    
    (*
        pub(crate) fn new(svc: S) -> Self {
            Self { svc }
        }
    *)
    Definition new (svc : S) : M Self :=
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_axum_routing_into_make_service_IntoMakeService_t_S_2.
  End Impl_axum_routing_into_make_service_IntoMakeService_t_S_2.
  
  Module  Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.
  Section Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.
    Context {S T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.routing.into_make_service.IntoMakeService.t S.
    
    (*
        type Response = S;
    *)
    Definition Response : Set := S.
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        type Future = IntoMakeServiceFuture<S>;
    *)
    Definition Future : Set :=
      axum.routing.into_make_service.IntoMakeServiceFuture.t S.
    
    (*
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (_cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* _cx := M.alloc _cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, _target: T) -> Self::Future {
            IntoMakeServiceFuture::new(ready(Ok(self.svc.clone())))
        }
    *)
    Definition call (self : mut_ref Self) (_target : T) : M Future :=
      let* self := M.alloc self in
      let* _target := M.alloc _target in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ : tower_service.Service.Trait Self (Request := T) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.
  End Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.
  
  Module  IntoMakeServiceFuture.
  Section IntoMakeServiceFuture.
    Context (S : Set).
    
    Record t : Set := {
      future :
        core.future.ready.Ready.t
          (core.result.Result.t S core.convert.Infallible.t);
    }.
    
    Definition Get_future :=
      Ref.map
        (fun α => Some α.(future))
        (fun β α => Some (α <| future := β |>)).
  End IntoMakeServiceFuture.
  End IntoMakeServiceFuture.
  
  Module  Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_2.
  Section Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_2.
    Context {S : Set}.
    
    Definition Self : Set :=
      axum.routing.into_make_service.IntoMakeServiceFuture.t S.
    
    (*
                pub(crate) fn new(future: $actual) -> Self {
                    Self { future }
                }
    *)
    Definition new
        (future
          :
          core.future.ready.Ready.t
            (core.result.Result.t S core.convert.Infallible.t))
        : M Self :=
      let* future := M.alloc future in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_2.
  End Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_2.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
  Section Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
    Context {S : Set}.
    
    Definition Self : Set :=
      axum.routing.into_make_service.IntoMakeServiceFuture.t S.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.debug_struct(stringify!($name)).finish_non_exhaustive()
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
  End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
  
  Module  Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
  Section Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
    Context {S : Set}.
    
    Context
      {ℋ_0 :
        core.future.future.Future.Trait
            (core.future.ready.Ready.t
              (core.result.Result.t S core.convert.Infallible.t))}.
    
    Definition Self : Set :=
      axum.routing.into_make_service.IntoMakeServiceFuture.t S.
    
    (*
                type Output = <$actual as std::future::Future>::Output;
    *)
    Definition Output : Set :=
      core.future.future.Future.Output
          (Self := core.future.ready.Ready.t
            (core.result.Result.t S core.convert.Infallible.t))
          (Trait := ltac:(refine _)).
    
    (*
                fn poll(
                    self: std::pin::Pin<&mut Self>,
                    cx: &mut std::task::Context<'_>,
                ) -> std::task::Poll<Self::Output> {
                    self.project().future.poll(cx)
                }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
  End Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
End into_make_service.

Module  IntoMakeService.
Section IntoMakeService.
  Context (S : Set).
  
  Record t : Set := {
    svc : S;
  }.
  
  Definition Get_svc :=
    Ref.map (fun α => Some α.(svc)) (fun β α => Some (α <| svc := β |>)).
End IntoMakeService.
End IntoMakeService.

Module  Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.
Section Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set := axum.routing.into_make_service.IntoMakeService.t S.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.
End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeService_t_S.

Module  Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.
Section Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.routing.into_make_service.IntoMakeService.t S.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum.routing.into_make_service.IntoMakeService.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.
End Impl_core_clone_Clone_for_axum_routing_into_make_service_IntoMakeService_t_S.

Module  Impl_axum_routing_into_make_service_IntoMakeService_t_S_3.
Section Impl_axum_routing_into_make_service_IntoMakeService_t_S_3.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.into_make_service.IntoMakeService.t S.
  
  (*
      pub(crate) fn new(svc: S) -> Self {
          Self { svc }
      }
  *)
  Definition new (svc : S) : M Self :=
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_axum_routing_into_make_service_IntoMakeService_t_S_3.
End Impl_axum_routing_into_make_service_IntoMakeService_t_S_3.

Module  Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.
Section Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.
  Context {S T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.routing.into_make_service.IntoMakeService.t S.
  
  (*
      type Response = S;
  *)
  Definition Response : Set := S.
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      type Future = IntoMakeServiceFuture<S>;
  *)
  Definition Future : Set :=
    axum.routing.into_make_service.IntoMakeServiceFuture.t S.
  
  (*
      fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          Poll::Ready(Ok(()))
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (_cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* _cx := M.alloc _cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, _target: T) -> Self::Future {
          IntoMakeServiceFuture::new(ready(Ok(self.svc.clone())))
      }
  *)
  Definition call (self : mut_ref Self) (_target : T) : M Future :=
    let* self := M.alloc self in
    let* _target := M.alloc _target in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ : tower_service.Service.Trait Self (Request := T) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.
End Impl_tower_service_Service_T_for_axum_routing_into_make_service_IntoMakeService_t_S.

Module  IntoMakeServiceFuture.
Section IntoMakeServiceFuture.
  Context (S : Set).
  
  Record t : Set := {
    future :
      core.future.ready.Ready.t
        (core.result.Result.t S core.convert.Infallible.t);
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End IntoMakeServiceFuture.
End IntoMakeServiceFuture.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Context (S : Set).
  
  Record t : Set := {
    future :
      core.pin.Pin.t
        (mut_ref
          (core.future.ready.Ready.t
            (core.result.Result.t S core.convert.Infallible.t)));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Context (S : Set).
  
  Record t : Set := {
    future :
      core.pin.Pin.t
        (ref
          (core.future.ready.Ready.t
            (core.result.Result.t S core.convert.Infallible.t)));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_3.
Section Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_3.
  Context {S : Set}.
  
  Definition Self : Set :=
    axum.routing.into_make_service.IntoMakeServiceFuture.t S.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum.routing.into_make_service._.Projection.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M (axum.routing.into_make_service._.ProjectionRef.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_3.
End Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_3.

Module  __Origin.
Section __Origin.
  Context (S : Set).
  
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    future :
      core.future.ready.Ready.t
        (core.result.Result.t S core.convert.Infallible.t);
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
Section Impl_core_marker_Unpin_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
  Context {S : Set}.
  
  Context
    {ℋ_0 :
      core.marker.Unpin.Trait (axum.routing.into_make_service._.__Origin.t S)}.
  
  Definition Self : Set :=
    axum.routing.into_make_service.IntoMakeServiceFuture.t S.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
End Impl_core_marker_Unpin_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.

Module  Impl_axum_routing_into_make_service___MustNotImplDrop_for_T.
Section Impl_axum_routing_into_make_service___MustNotImplDrop_for_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.ops.drop.Drop.Trait T}.
  
  Definition Self : Set := T.
  
  Global Instance ℐ :
    axum.routing.into_make_service._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_routing_into_make_service___MustNotImplDrop_for_T.
End Impl_axum_routing_into_make_service___MustNotImplDrop_for_T.

Module  Impl_axum_routing_into_make_service___MustNotImplDrop_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
Section Impl_axum_routing_into_make_service___MustNotImplDrop_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
  Context {S : Set}.
  
  Definition Self : Set :=
    axum.routing.into_make_service.IntoMakeServiceFuture.t S.
  
  Global Instance ℐ :
    axum.routing.into_make_service._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_routing_into_make_service___MustNotImplDrop_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
End Impl_axum_routing_into_make_service___MustNotImplDrop_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    {S : Set}
    (this : ref (axum.routing.into_make_service.IntoMakeServiceFuture.t S))
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module  Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_4.
Section Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_4.
  Context {S : Set}.
  
  Definition Self : Set :=
    axum.routing.into_make_service.IntoMakeServiceFuture.t S.
  
  (*
              pub(crate) fn new(future: $actual) -> Self {
                  Self { future }
              }
  *)
  Definition new
      (future
        :
        core.future.ready.Ready.t
          (core.result.Result.t S core.convert.Infallible.t))
      : M Self :=
    let* future := M.alloc future in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_4.
End Impl_axum_routing_into_make_service_IntoMakeServiceFuture_t_S_4.

Module  Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
Section Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
  Context {S : Set}.
  
  Definition Self : Set :=
    axum.routing.into_make_service.IntoMakeServiceFuture.t S.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  f.debug_struct(stringify!($name)).finish_non_exhaustive()
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
End Impl_core_fmt_Debug_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.

Module  Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
Section Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
  Context {S : Set}.
  
  Context
    {ℋ_0 :
      core.future.future.Future.Trait
          (core.future.ready.Ready.t
            (core.result.Result.t S core.convert.Infallible.t))}.
  
  Definition Self : Set :=
    axum.routing.into_make_service.IntoMakeServiceFuture.t S.
  
  (*
              type Output = <$actual as std::future::Future>::Output;
  *)
  Definition Output : Set :=
    core.future.future.Future.Output
        (Self := core.future.ready.Ready.t
          (core.result.Result.t S core.convert.Infallible.t))
        (Trait := ltac:(refine _)).
  
  (*
              fn poll(
                  self: std::pin::Pin<&mut Self>,
                  cx: &mut std::task::Context<'_>,
              ) -> std::task::Poll<Self::Output> {
                  self.project().future.poll(cx)
              }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.
End Impl_core_future_future_Future_for_axum_routing_into_make_service_IntoMakeServiceFuture_t_S.

Module method_filter.
  Module  MethodFilter.
  Section MethodFilter.
    Record t : Set := {
      x0 : u16.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End MethodFilter.
  End MethodFilter.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.
  Section Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.
    Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.
  End Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.
  
  Module  Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.
  Section Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.
    Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.
  End Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.
  
  Module  Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.
  Section Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.
    Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M axum.routing.method_filter.MethodFilter.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.
  End Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.
  
  Module  Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.
  Section Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.
    Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
    
    Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.
  End Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.
  
  Module  Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.
  Section Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.
    Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
    
    (*
    PartialEq
    *)
    Definition eq
        (self : ref Self)
        (other : ref axum.routing.method_filter.MethodFilter.t)
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.
  End Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.
  
  Module  Impl_axum_routing_method_filter_MethodFilter_t_2.
  Section Impl_axum_routing_method_filter_MethodFilter_t_2.
    Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
    
    (*
        pub const DELETE: Self = Self::from_bits(0b0_0000_0010);
    *)
    
    Definition DELETE : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_DELETE :
      Notations.DoubleColon Self "DELETE" := {
      Notations.double_colon := DELETE;
    }.
    
    (*
        pub const GET: Self = Self::from_bits(0b0_0000_0100);
    *)
    
    Definition GET : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_GET :
      Notations.DoubleColon Self "GET" := {
      Notations.double_colon := GET;
    }.
    
    (*
        pub const HEAD: Self = Self::from_bits(0b0_0000_1000);
    *)
    
    Definition HEAD : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_HEAD :
      Notations.DoubleColon Self "HEAD" := {
      Notations.double_colon := HEAD;
    }.
    
    (*
        pub const OPTIONS: Self = Self::from_bits(0b0_0001_0000);
    *)
    
    Definition OPTIONS : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_OPTIONS :
      Notations.DoubleColon Self "OPTIONS" := {
      Notations.double_colon := OPTIONS;
    }.
    
    (*
        pub const PATCH: Self = Self::from_bits(0b0_0010_0000);
    *)
    
    Definition PATCH : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_PATCH :
      Notations.DoubleColon Self "PATCH" := {
      Notations.double_colon := PATCH;
    }.
    
    (*
        pub const POST: Self = Self::from_bits(0b0_0100_0000);
    *)
    
    Definition POST : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_POST :
      Notations.DoubleColon Self "POST" := {
      Notations.double_colon := POST;
    }.
    
    (*
        pub const PUT: Self = Self::from_bits(0b0_1000_0000);
    *)
    
    Definition PUT : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_PUT :
      Notations.DoubleColon Self "PUT" := {
      Notations.double_colon := PUT;
    }.
    
    (*
        pub const TRACE: Self = Self::from_bits(0b1_0000_0000);
    *)
    
    Definition TRACE : Self := M.run (M.pure foo).
    
    Global Instance AssociatedFunction_TRACE :
      Notations.DoubleColon Self "TRACE" := {
      Notations.double_colon := TRACE;
    }.
    
    (*
        const fn bits(&self) -> u16 {
            let bits = self;
            bits.0
        }
    *)
    Definition bits (self : ref Self) : M u16.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_bits :
      Notations.DoubleColon Self "bits" := {
      Notations.double_colon := bits;
    }.
    
    (*
        const fn from_bits(bits: u16) -> Self {
            Self(bits)
        }
    *)
    Definition from_bits (bits : u16.t) : M Self :=
      let* bits := M.alloc bits in
      M.read foo.
    
    Global Instance AssociatedFunction_from_bits :
      Notations.DoubleColon Self "from_bits" := {
      Notations.double_colon := from_bits;
    }.
    
    (*
        pub(crate) const fn contains(&self, other: Self) -> bool {
            self.bits() & other.bits() == other.bits()
        }
    *)
    Definition contains (self : ref Self) (other : Self) : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_contains :
      Notations.DoubleColon Self "contains" := {
      Notations.double_colon := contains;
    }.
    
    (*
        pub const fn or(self, other: Self) -> Self {
            Self(self.0 | other.0)
        }
    *)
    Definition or (self : Self) (other : Self) : M Self :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_or : Notations.DoubleColon Self "or" := {
      Notations.double_colon := or;
    }.
  End Impl_axum_routing_method_filter_MethodFilter_t_2.
  End Impl_axum_routing_method_filter_MethodFilter_t_2.
  
  Module  NoMatchingMethodFilter.
  Section NoMatchingMethodFilter.
    Record t : Set := {
      method : http.method.Method.t;
    }.
    
    Definition Get_method :=
      Ref.map
        (fun α => Some α.(method))
        (fun β α => Some (α <| method := β |>)).
  End NoMatchingMethodFilter.
  End NoMatchingMethodFilter.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  Section Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    Definition Self : Set :=
      axum.routing.method_filter.NoMatchingMethodFilter.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  End Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  
  Module  Impl_axum_routing_method_filter_NoMatchingMethodFilter_t_2.
  Section Impl_axum_routing_method_filter_NoMatchingMethodFilter_t_2.
    Definition Self : Set :=
      axum.routing.method_filter.NoMatchingMethodFilter.t.
    
    (*
        pub fn method(&self) -> &Method {
            &self.method
        }
    *)
    Definition method (self : ref Self) : M (ref http.method.Method.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_method :
      Notations.DoubleColon Self "method" := {
      Notations.double_colon := method;
    }.
  End Impl_axum_routing_method_filter_NoMatchingMethodFilter_t_2.
  End Impl_axum_routing_method_filter_NoMatchingMethodFilter_t_2.
  
  Module  Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  Section Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    Definition Self : Set :=
      axum.routing.method_filter.NoMatchingMethodFilter.t.
    
    (*
        fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
            write!(f, "no `MethodFilter` for `{}`", self.method.as_str())
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  End Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  
  Module  Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  Section Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
    Definition Self : Set :=
      axum.routing.method_filter.NoMatchingMethodFilter.t.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.None;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  End Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  
  Module  Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.
  Section Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.
    Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
    
    (*
        type Error = NoMatchingMethodFilter;
    *)
    Definition Error : Set :=
      axum.routing.method_filter.NoMatchingMethodFilter.t.
    
    (*
        fn try_from(m: Method) -> Result<Self, NoMatchingMethodFilter> {
            match m {
                Method::DELETE => Ok(MethodFilter::DELETE),
                Method::GET => Ok(MethodFilter::GET),
                Method::HEAD => Ok(MethodFilter::HEAD),
                Method::OPTIONS => Ok(MethodFilter::OPTIONS),
                Method::PATCH => Ok(MethodFilter::PATCH),
                Method::POST => Ok(MethodFilter::POST),
                Method::PUT => Ok(MethodFilter::PUT),
                Method::TRACE => Ok(MethodFilter::TRACE),
                other => Err(NoMatchingMethodFilter { method: other }),
            }
        }
    *)
    Definition try_from
        (m : http.method.Method.t)
        :
          M
            (core.result.Result.t
              Self
              axum.routing.method_filter.NoMatchingMethodFilter.t) :=
      let* m := M.alloc m in
      M.read foo.
    
    Global Instance AssociatedFunction_try_from :
      Notations.DoubleColon Self "try_from" := {
      Notations.double_colon := try_from;
    }.
    
    Global Instance ℐ :
      core.convert.TryFrom.Trait Self (T := http.method.Method.t) := {
      core.convert.TryFrom.Error := Error;
      core.convert.TryFrom.try_from := try_from;
    }.
  End Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.
  End Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.
End method_filter.

Module  MethodFilter.
Section MethodFilter.
  Record t : Set := {
    x0 : u16.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End MethodFilter.
End MethodFilter.

Module  Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.
Section Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.
  Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.
End Impl_core_fmt_Debug_for_axum_routing_method_filter_MethodFilter_t.

Module  Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.
Section Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.
  Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.
End Impl_core_marker_Copy_for_axum_routing_method_filter_MethodFilter_t.

Module  Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.
Section Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.
  Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M axum.routing.method_filter.MethodFilter.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.
End Impl_core_clone_Clone_for_axum_routing_method_filter_MethodFilter_t.

Module  Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.
Section Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.
  Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.
End Impl_core_marker_StructuralPartialEq_for_axum_routing_method_filter_MethodFilter_t.

Module  Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.
Section Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.
  Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref axum.routing.method_filter.MethodFilter.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.
End Impl_core_cmp_PartialEq_for_axum_routing_method_filter_MethodFilter_t.

Module  Impl_axum_routing_method_filter_MethodFilter_t_3.
Section Impl_axum_routing_method_filter_MethodFilter_t_3.
  Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
  
  (*
      pub const DELETE: Self = Self::from_bits(0b0_0000_0010);
  *)
  
  Definition DELETE : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_DELETE :
    Notations.DoubleColon Self "DELETE" := {
    Notations.double_colon := DELETE;
  }.
  
  (*
      pub const GET: Self = Self::from_bits(0b0_0000_0100);
  *)
  
  Definition GET : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_GET : Notations.DoubleColon Self "GET" := {
    Notations.double_colon := GET;
  }.
  
  (*
      pub const HEAD: Self = Self::from_bits(0b0_0000_1000);
  *)
  
  Definition HEAD : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_HEAD :
    Notations.DoubleColon Self "HEAD" := {
    Notations.double_colon := HEAD;
  }.
  
  (*
      pub const OPTIONS: Self = Self::from_bits(0b0_0001_0000);
  *)
  
  Definition OPTIONS : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_OPTIONS :
    Notations.DoubleColon Self "OPTIONS" := {
    Notations.double_colon := OPTIONS;
  }.
  
  (*
      pub const PATCH: Self = Self::from_bits(0b0_0010_0000);
  *)
  
  Definition PATCH : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_PATCH :
    Notations.DoubleColon Self "PATCH" := {
    Notations.double_colon := PATCH;
  }.
  
  (*
      pub const POST: Self = Self::from_bits(0b0_0100_0000);
  *)
  
  Definition POST : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_POST :
    Notations.DoubleColon Self "POST" := {
    Notations.double_colon := POST;
  }.
  
  (*
      pub const PUT: Self = Self::from_bits(0b0_1000_0000);
  *)
  
  Definition PUT : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_PUT : Notations.DoubleColon Self "PUT" := {
    Notations.double_colon := PUT;
  }.
  
  (*
      pub const TRACE: Self = Self::from_bits(0b1_0000_0000);
  *)
  
  Definition TRACE : Self := M.run (M.pure foo).
  
  Global Instance AssociatedFunction_TRACE :
    Notations.DoubleColon Self "TRACE" := {
    Notations.double_colon := TRACE;
  }.
  
  (*
      const fn bits(&self) -> u16 {
          let bits = self;
          bits.0
      }
  *)
  Definition bits (self : ref Self) : M u16.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_bits :
    Notations.DoubleColon Self "bits" := {
    Notations.double_colon := bits;
  }.
  
  (*
      const fn from_bits(bits: u16) -> Self {
          Self(bits)
      }
  *)
  Definition from_bits (bits : u16.t) : M Self :=
    let* bits := M.alloc bits in
    M.read foo.
  
  Global Instance AssociatedFunction_from_bits :
    Notations.DoubleColon Self "from_bits" := {
    Notations.double_colon := from_bits;
  }.
  
  (*
      pub(crate) const fn contains(&self, other: Self) -> bool {
          self.bits() & other.bits() == other.bits()
      }
  *)
  Definition contains (self : ref Self) (other : Self) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      pub const fn or(self, other: Self) -> Self {
          Self(self.0 | other.0)
      }
  *)
  Definition or (self : Self) (other : Self) : M Self :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_or : Notations.DoubleColon Self "or" := {
    Notations.double_colon := or;
  }.
End Impl_axum_routing_method_filter_MethodFilter_t_3.
End Impl_axum_routing_method_filter_MethodFilter_t_3.

Module  NoMatchingMethodFilter.
Section NoMatchingMethodFilter.
  Record t : Set := {
    method : http.method.Method.t;
  }.
  
  Definition Get_method :=
    Ref.map (fun α => Some α.(method)) (fun β α => Some (α <| method := β |>)).
End NoMatchingMethodFilter.
End NoMatchingMethodFilter.

Module  Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
Section Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  Definition Self : Set := axum.routing.method_filter.NoMatchingMethodFilter.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
End Impl_core_fmt_Debug_for_axum_routing_method_filter_NoMatchingMethodFilter_t.

Module  Impl_axum_routing_method_filter_NoMatchingMethodFilter_t_3.
Section Impl_axum_routing_method_filter_NoMatchingMethodFilter_t_3.
  Definition Self : Set := axum.routing.method_filter.NoMatchingMethodFilter.t.
  
  (*
      pub fn method(&self) -> &Method {
          &self.method
      }
  *)
  Definition method (self : ref Self) : M (ref http.method.Method.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_method :
    Notations.DoubleColon Self "method" := {
    Notations.double_colon := method;
  }.
End Impl_axum_routing_method_filter_NoMatchingMethodFilter_t_3.
End Impl_axum_routing_method_filter_NoMatchingMethodFilter_t_3.

Module  Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
Section Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  Definition Self : Set := axum.routing.method_filter.NoMatchingMethodFilter.t.
  
  (*
      fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
          write!(f, "no `MethodFilter` for `{}`", self.method.as_str())
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
End Impl_core_fmt_Display_for_axum_routing_method_filter_NoMatchingMethodFilter_t.

Module  Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
Section Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
  Definition Self : Set := axum.routing.method_filter.NoMatchingMethodFilter.t.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.None;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.
End Impl_core_error_Error_for_axum_routing_method_filter_NoMatchingMethodFilter_t.

Module  Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.
Section Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.
  Definition Self : Set := axum.routing.method_filter.MethodFilter.t.
  
  (*
      type Error = NoMatchingMethodFilter;
  *)
  Definition Error : Set := axum.routing.method_filter.NoMatchingMethodFilter.t.
  
  (*
      fn try_from(m: Method) -> Result<Self, NoMatchingMethodFilter> {
          match m {
              Method::DELETE => Ok(MethodFilter::DELETE),
              Method::GET => Ok(MethodFilter::GET),
              Method::HEAD => Ok(MethodFilter::HEAD),
              Method::OPTIONS => Ok(MethodFilter::OPTIONS),
              Method::PATCH => Ok(MethodFilter::PATCH),
              Method::POST => Ok(MethodFilter::POST),
              Method::PUT => Ok(MethodFilter::PUT),
              Method::TRACE => Ok(MethodFilter::TRACE),
              other => Err(NoMatchingMethodFilter { method: other }),
          }
      }
  *)
  Definition try_from
      (m : http.method.Method.t)
      :
        M
          (core.result.Result.t
            Self
            axum.routing.method_filter.NoMatchingMethodFilter.t) :=
    let* m := M.alloc m in
    M.read foo.
  
  Global Instance AssociatedFunction_try_from :
    Notations.DoubleColon Self "try_from" := {
    Notations.double_colon := try_from;
  }.
  
  Global Instance ℐ :
    core.convert.TryFrom.Trait Self (T := http.method.Method.t) := {
    core.convert.TryFrom.Error := Error;
    core.convert.TryFrom.try_from := try_from;
  }.
End Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.
End Impl_core_convert_TryFrom_http_method_Method_t_for_axum_routing_method_filter_MethodFilter_t.

Module not_found.
  Module  NotFound.
  Section NotFound.
    Inductive t : Set := Build.
  End NotFound.
  End NotFound.
  
  Module  Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.
  Section Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.
    Definition Self : Set := axum.routing.not_found.NotFound.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum.routing.not_found.NotFound.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.
  End Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.
  
  Module  Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.
  Section Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.
    Definition Self : Set := axum.routing.not_found.NotFound.t.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.
  End Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.
  Section Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.
    Definition Self : Set := axum.routing.not_found.NotFound.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.
  End Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.
    Context {B : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait B}.
    
    Definition Self : Set := axum.routing.not_found.NotFound.t.
    
    (*
        type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        type Future = std::future::Ready<Result<Response, Self::Error>>;
    *)
    Definition Future : Set :=
      core.future.ready.Ready.t
          (core.result.Result.t
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            Error).
    
    (*
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (_cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* _cx := M.alloc _cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, _req: Request<B>) -> Self::Future {
            ready(Ok(StatusCode::NOT_FOUND.into_response()))
        }
    *)
    Definition call
        (self : mut_ref Self)
        (_req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* _req := M.alloc _req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.
End not_found.

Module  NotFound.
Section NotFound.
  Inductive t : Set := Build.
End NotFound.
End NotFound.

Module  Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.
Section Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.
  Definition Self : Set := axum.routing.not_found.NotFound.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.routing.not_found.NotFound.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.
End Impl_core_clone_Clone_for_axum_routing_not_found_NotFound_t.

Module  Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.
Section Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.
  Definition Self : Set := axum.routing.not_found.NotFound.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.
End Impl_core_marker_Copy_for_axum_routing_not_found_NotFound_t.

Module  Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.
Section Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.
  Definition Self : Set := axum.routing.not_found.NotFound.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.
End Impl_core_fmt_Debug_for_axum_routing_not_found_NotFound_t.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.
  Context {B : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait B}.
  
  Definition Self : Set := axum.routing.not_found.NotFound.t.
  
  (*
      type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      type Future = std::future::Ready<Result<Response, Self::Error>>;
  *)
  Definition Future : Set :=
    core.future.ready.Ready.t
        (core.result.Result.t
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          Error).
  
  (*
      fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          Poll::Ready(Ok(()))
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (_cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* _cx := M.alloc _cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, _req: Request<B>) -> Self::Future {
          ready(Ok(StatusCode::NOT_FOUND.into_response()))
      }
  *)
  Definition call
      (self : mut_ref Self)
      (_req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* _req := M.alloc _req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_not_found_NotFound_t.

Module path_router.
  Module  PathRouter.
  Section PathRouter.
    Context (S : Set).
    
    Record t : Set := {
      routes :
        std.collections.hash.map.HashMap.t
          axum.routing.RouteId.t
          (axum.routing.Endpoint.t S)
          std.collections.hash.map.HashMap.Default.S;
      node :
        alloc.sync.Arc.t
          axum.routing.path_router.Node.t
          alloc.sync.Arc.Default.A;
      prev_route_id : axum.routing.RouteId.t;
    }.
    
    Definition Get_routes :=
      Ref.map
        (fun α => Some α.(routes))
        (fun β α => Some (α <| routes := β |>)).
    Definition Get_node :=
      Ref.map (fun α => Some α.(node)) (fun β α => Some (α <| node := β |>)).
    Definition Get_prev_route_id :=
      Ref.map
        (fun α => Some α.(prev_route_id))
        (fun β α => Some (α <| prev_route_id := β |>)).
  End PathRouter.
  End PathRouter.
  
  Module  Impl_axum_routing_path_router_PathRouter_t_S_3.
  Section Impl_axum_routing_path_router_PathRouter_t_S_3.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.path_router.PathRouter.t S.
    
    (*
        pub(super) fn new_fallback() -> Self {
            let mut this = Self::default();
            this.set_fallback(Endpoint::Route(Route::new(NotFound)));
            this
        }
    *)
    Definition new_fallback : M Self := M.read foo.
    
    Global Instance AssociatedFunction_new_fallback :
      Notations.DoubleColon Self "new_fallback" := {
      Notations.double_colon := new_fallback;
    }.
    
    (*
        pub(super) fn set_fallback(&mut self, endpoint: Endpoint<S>) {
            self.replace_endpoint("/", endpoint.clone());
            self.replace_endpoint(FALLBACK_PARAM_PATH, endpoint);
        }
    *)
    Definition set_fallback
        (self : mut_ref Self)
        (endpoint : axum.routing.Endpoint.t S)
        : M unit :=
      let* self := M.alloc self in
      let* endpoint := M.alloc endpoint in
      M.read foo.
    
    Global Instance AssociatedFunction_set_fallback :
      Notations.DoubleColon Self "set_fallback" := {
      Notations.double_colon := set_fallback;
    }.
  End Impl_axum_routing_path_router_PathRouter_t_S_3.
  End Impl_axum_routing_path_router_PathRouter_t_S_3.
  
  Module  Impl_axum_routing_path_router_PathRouter_t_S_4.
  Section Impl_axum_routing_path_router_PathRouter_t_S_4.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.path_router.PathRouter.t S.
    
    (*
        pub(super) fn route(
            &mut self,
            path: &str,
            method_router: MethodRouter<S>,
        ) -> Result<(), Cow<'static, str>> {
            fn validate_path(path: &str) -> Result<(), &'static str> {
                if path.is_empty() {
                    return Err("Paths must start with a `/`. Use \"/\" for root routes");
                } else if !path.starts_with('/') {
                    return Err("Paths must start with a `/`");
                }
    
                Ok(())
            }
    
            validate_path(path)?;
    
            let endpoint = if let Some((route_id, Endpoint::MethodRouter(prev_method_router))) = self
                .node
                .path_to_route_id
                .get(path)
                .and_then(|route_id| self.routes.get(route_id).map(|svc| ( *route_id, svc)))
            {
                // if we're adding a new `MethodRouter` to a route that already has one just
                // merge them. This makes `.route("/", get(_)).route("/", post(_))` work
                let service = Endpoint::MethodRouter(
                    prev_method_router
                        .clone()
                        .merge_for_path(Some(path), method_router),
                );
                self.routes.insert(route_id, service);
                return Ok(());
            } else {
                Endpoint::MethodRouter(method_router)
            };
    
            let id = self.next_route_id();
            self.set_node(path, id)?;
            self.routes.insert(id, endpoint);
    
            Ok(())
        }
    *)
    Definition route
        (self : mut_ref Self)
        (path : ref str.t)
        (method_router
          :
          axum.routing.method_routing.MethodRouter.t
            S
            axum.routing.method_routing.MethodRouter.Default.E)
        : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* method_router := M.alloc method_router in
      M.read foo.
    
    Global Instance AssociatedFunction_route :
      Notations.DoubleColon Self "route" := {
      Notations.double_colon := route;
    }.
    
    (*
        pub(super) fn route_service<T>(
            &mut self,
            path: &str,
            service: T,
        ) -> Result<(), Cow<'static, str>>
        where
            T: Service<Request, Error = Infallible> + Clone + Send + 'static,
            T::Response: IntoResponse,
            T::Future: Send + 'static,
        {
            self.route_endpoint(path, Endpoint::Route(Route::new(service)))
        }
    *)
    Definition route_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : mut_ref Self)
        (path : ref str.t)
        (service : T)
        : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* service := M.alloc service in
      M.read foo.
    
    Global Instance AssociatedFunction_route_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "route_service" := {
      Notations.double_colon := route_service (T := T);
    }.
    
    (*
        pub(super) fn route_endpoint(
            &mut self,
            path: &str,
            endpoint: Endpoint<S>,
        ) -> Result<(), Cow<'static, str>> {
            if path.is_empty() {
                return Err("Paths must start with a `/`. Use \"/\" for root routes".into());
            } else if !path.starts_with('/') {
                return Err("Paths must start with a `/`".into());
            }
    
            let id = self.next_route_id();
            self.set_node(path, id)?;
            self.routes.insert(id, endpoint);
    
            Ok(())
        }
    *)
    Definition route_endpoint
        (self : mut_ref Self)
        (path : ref str.t)
        (endpoint : axum.routing.Endpoint.t S)
        : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* endpoint := M.alloc endpoint in
      M.read foo.
    
    Global Instance AssociatedFunction_route_endpoint :
      Notations.DoubleColon Self "route_endpoint" := {
      Notations.double_colon := route_endpoint;
    }.
    
    (*
        fn set_node(&mut self, path: &str, id: RouteId) -> Result<(), String> {
            let mut node =
                Arc::try_unwrap(Arc::clone(&self.node)).unwrap_or_else(|node| ( *node).clone());
            if let Err(err) = node.insert(path, id) {
                return Err(format!("Invalid route {path:?}: {err}"));
            }
            self.node = Arc::new(node);
            Ok(())
        }
    *)
    Definition set_node
        (self : mut_ref Self)
        (path : ref str.t)
        (id : axum.routing.RouteId.t)
        : M (core.result.Result.t unit alloc.string.String.t) :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* id := M.alloc id in
      M.read foo.
    
    Global Instance AssociatedFunction_set_node :
      Notations.DoubleColon Self "set_node" := {
      Notations.double_colon := set_node;
    }.
    
    (*
        pub(super) fn merge(
            &mut self,
            other: PathRouter<S, IS_FALLBACK>,
        ) -> Result<(), Cow<'static, str>> {
            let PathRouter {
                routes,
                node,
                prev_route_id: _,
            } = other;
    
            for (id, route) in routes {
                let path = node
                    .route_id_to_path
                    .get(&id)
                    .expect("no path for route id. This is a bug in axum. Please file an issue");
    
                if IS_FALLBACK && (&**path == "/" || &**path == FALLBACK_PARAM_PATH) {
                    // when merging two routers it doesn't matter if you do `a.merge(b)` or
                    // `b.merge(a)`. This must also be true for fallbacks.
                    //
                    // However all fallback routers will have routes for `/` and `/*` so when merging
                    // we have to ignore the top level fallbacks on one side otherwise we get
                    // conflicts.
                    //
                    // `Router::merge` makes sure that when merging fallbacks `other` always has the
                    // fallback we want to keep. It panics if both routers have a custom fallback. Thus
                    // it is always okay to ignore one fallback and `Router::merge` also makes sure the
                    // one we can ignore is that of `self`.
                    self.replace_endpoint(path, route);
                } else {
                    match route {
                        Endpoint::MethodRouter(method_router) => self.route(path, method_router)?,
                        Endpoint::Route(route) => self.route_service(path, route)?,
                    }
                }
            }
    
            Ok(())
        }
    *)
    Definition merge
        (self : mut_ref Self)
        (other : axum.routing.path_router.PathRouter.t S)
        : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_merge :
      Notations.DoubleColon Self "merge" := {
      Notations.double_colon := merge;
    }.
    
    (*
        pub(super) fn nest(
            &mut self,
            path_to_nest_at: &str,
            router: PathRouter<S, IS_FALLBACK>,
        ) -> Result<(), Cow<'static, str>> {
            let prefix = validate_nest_path(path_to_nest_at);
    
            let PathRouter {
                routes,
                node,
                prev_route_id: _,
            } = router;
    
            for (id, endpoint) in routes {
                let inner_path = node
                    .route_id_to_path
                    .get(&id)
                    .expect("no path for route id. This is a bug in axum. Please file an issue");
    
                let path = path_for_nested_route(prefix, inner_path);
    
                let layer = (
                    StripPrefix::layer(prefix),
                    SetNestedPath::layer(path_to_nest_at),
                );
                match endpoint.layer(layer) {
                    Endpoint::MethodRouter(method_router) => {
                        self.route(&path, method_router)?;
                    }
                    Endpoint::Route(route) => {
                        self.route_endpoint(&path, Endpoint::Route(route))?;
                    }
                }
            }
    
            Ok(())
        }
    *)
    Definition nest
        (self : mut_ref Self)
        (path_to_nest_at : ref str.t)
        (router : axum.routing.path_router.PathRouter.t S)
        : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
      let* self := M.alloc self in
      let* path_to_nest_at := M.alloc path_to_nest_at in
      let* router := M.alloc router in
      M.read foo.
    
    Global Instance AssociatedFunction_nest :
      Notations.DoubleColon Self "nest" := {
      Notations.double_colon := nest;
    }.
    
    (*
        pub(super) fn nest_service<T>(
            &mut self,
            path_to_nest_at: &str,
            svc: T,
        ) -> Result<(), Cow<'static, str>>
        where
            T: Service<Request, Error = Infallible> + Clone + Send + 'static,
            T::Response: IntoResponse,
            T::Future: Send + 'static,
        {
            let path = validate_nest_path(path_to_nest_at);
            let prefix = path;
    
            let path = if path.ends_with('/') {
                format!("{path}*{NEST_TAIL_PARAM}")
            } else {
                format!("{path}/*{NEST_TAIL_PARAM}")
            };
    
            let layer = (
                StripPrefix::layer(prefix),
                SetNestedPath::layer(path_to_nest_at),
            );
            let endpoint = Endpoint::Route(Route::new(layer.layer(svc)));
    
            self.route_endpoint(&path, endpoint.clone())?;
    
            // `/*rest` is not matched by `/` so we need to also register a router at the
            // prefix itself. Otherwise if you were to nest at `/foo` then `/foo` itself
            // wouldn't match, which it should
            self.route_endpoint(prefix, endpoint.clone())?;
            if !prefix.ends_with('/') {
                // same goes for `/foo/`, that should also match
                self.route_endpoint(&format!("{prefix}/"), endpoint)?;
            }
    
            Ok(())
        }
    *)
    Definition nest_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : mut_ref Self)
        (path_to_nest_at : ref str.t)
        (svc : T)
        : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
      let* self := M.alloc self in
      let* path_to_nest_at := M.alloc path_to_nest_at in
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_nest_service
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "nest_service" := {
      Notations.double_colon := nest_service (T := T);
    }.
    
    (*
        pub(super) fn layer<L>(self, layer: L) -> PathRouter<S, IS_FALLBACK>
        where
            L: Layer<Route> + Clone + Send + 'static,
            L::Service: Service<Request> + Clone + Send + 'static,
            <L::Service as Service<Request>>::Response: IntoResponse + 'static,
            <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
            <L::Service as Service<Request>>::Future: Send + 'static,
        {
            let routes = self
                .routes
                .into_iter()
                .map(|(id, endpoint)| {
                    let route = endpoint.layer(layer.clone());
                    (id, route)
                })
                .collect();
    
            PathRouter {
                routes,
                node: self.node,
                prev_route_id: self.prev_route_id,
            }
        }
    *)
    Definition layer
        {L : Set}
        {ℋ_0 :
          tower_layer.Layer.Trait L
            (S := axum.routing.route.Route.t
              axum.routing.route.Route.Default.E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := core.convert.Infallible.t)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        (self : Self)
        (layer : L)
        : M (axum.routing.path_router.PathRouter.t S) :=
      let* self := M.alloc self in
      let* layer := M.alloc layer in
      M.read foo.
    
    Global Instance AssociatedFunction_layer
        {L : Set}
        {ℋ_0 :
          tower_layer.Layer.Trait L
            (S := axum.routing.route.Route.t
              axum.routing.route.Route.Default.E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := core.convert.Infallible.t)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))} :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer (L := L);
    }.
    
    (*
        pub(super) fn route_layer<L>(self, layer: L) -> Self
        where
            L: Layer<Route> + Clone + Send + 'static,
            L::Service: Service<Request> + Clone + Send + 'static,
            <L::Service as Service<Request>>::Response: IntoResponse + 'static,
            <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
            <L::Service as Service<Request>>::Future: Send + 'static,
        {
            if self.routes.is_empty() {
                panic!(
                    "Adding a route_layer before any routes is a no-op. \
                     Add the routes you want the layer to apply to first."
                );
            }
    
            let routes = self
                .routes
                .into_iter()
                .map(|(id, endpoint)| {
                    let route = endpoint.layer(layer.clone());
                    (id, route)
                })
                .collect();
    
            PathRouter {
                routes,
                node: self.node,
                prev_route_id: self.prev_route_id,
            }
        }
    *)
    Definition route_layer
        {L : Set}
        {ℋ_0 :
          tower_layer.Layer.Trait L
            (S := axum.routing.route.Route.t
              axum.routing.route.Route.Default.E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := core.convert.Infallible.t)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        (self : Self)
        (layer : L)
        : M Self :=
      let* self := M.alloc self in
      let* layer := M.alloc layer in
      M.read foo.
    
    Global Instance AssociatedFunction_route_layer
        {L : Set}
        {ℋ_0 :
          tower_layer.Layer.Trait L
            (S := axum.routing.route.Route.t
              axum.routing.route.Route.Default.E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := core.convert.Infallible.t)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))} :
      Notations.DoubleColon Self "route_layer" := {
      Notations.double_colon := route_layer (L := L);
    }.
    
    (*
        pub(super) fn with_state<S2>(self, state: S) -> PathRouter<S2, IS_FALLBACK> {
            let routes = self
                .routes
                .into_iter()
                .map(|(id, endpoint)| {
                    let endpoint: Endpoint<S2> = match endpoint {
                        Endpoint::MethodRouter(method_router) => {
                            Endpoint::MethodRouter(method_router.with_state(state.clone()))
                        }
                        Endpoint::Route(route) => Endpoint::Route(route),
                    };
                    (id, endpoint)
                })
                .collect();
    
            PathRouter {
                routes,
                node: self.node,
                prev_route_id: self.prev_route_id,
            }
        }
    *)
    Definition with_state
        {S2 : Set}
        (self : Self)
        (state : S)
        : M (axum.routing.path_router.PathRouter.t S2) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_with_state {S2 : Set} :
      Notations.DoubleColon Self "with_state" := {
      Notations.double_colon := with_state (S2 := S2);
    }.
    
    (*
        pub(super) fn call_with_state(
            &self,
            mut req: Request,
            state: S,
        ) -> Result<RouteFuture<Infallible>, (Request, S)> {
            #[cfg(feature = "original-uri")]
            {
                use crate::extract::OriginalUri;
    
                if req.extensions().get::<OriginalUri>().is_none() {
                    let original_uri = OriginalUri(req.uri().clone());
                    req.extensions_mut().insert(original_uri);
                }
            }
    
            let path = req.uri().path().to_owned();
    
            match self.node.at(&path) {
                Ok(match_) => {
                    let id = *match_.value;
    
                    if !IS_FALLBACK {
                        #[cfg(feature = "matched-path")]
                        crate::extract::matched_path::set_matched_path_for_request(
                            id,
                            &self.node.route_id_to_path,
                            req.extensions_mut(),
                        );
                    }
    
                    url_params::insert_url_params(req.extensions_mut(), match_.params);
    
                    let endpoint = self
                        .routes
                        .get(&id)
                        .expect("no route for id. This is a bug in axum. Please file an issue");
    
                    match endpoint {
                        Endpoint::MethodRouter(method_router) => {
                            Ok(method_router.call_with_state(req, state))
                        }
                        Endpoint::Route(route) => Ok(route.clone().call(req)),
                    }
                }
                // explicitly handle all variants in case matchit adds
                // new ones we need to handle differently
                Err(
                    MatchError::NotFound
                    | MatchError::ExtraTrailingSlash
                    | MatchError::MissingTrailingSlash,
                ) => Err((req, state)),
            }
        }
    *)
    Definition call_with_state
        (self : ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        :
          M
            (core.result.Result.t
              (axum.routing.route.RouteFuture.t core.convert.Infallible.t)
              (ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T)
              *
              S)) :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call_with_state :
      Notations.DoubleColon Self "call_with_state" := {
      Notations.double_colon := call_with_state;
    }.
    
    (*
        pub(super) fn replace_endpoint(&mut self, path: &str, endpoint: Endpoint<S>) {
            match self.node.at(path) {
                Ok(match_) => {
                    let id = *match_.value;
                    self.routes.insert(id, endpoint);
                }
                Err(_) => self
                    .route_endpoint(path, endpoint)
                    .expect("path wasn't matched so endpoint shouldn't exist"),
            }
        }
    *)
    Definition replace_endpoint
        (self : mut_ref Self)
        (path : ref str.t)
        (endpoint : axum.routing.Endpoint.t S)
        : M unit :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* endpoint := M.alloc endpoint in
      M.read foo.
    
    Global Instance AssociatedFunction_replace_endpoint :
      Notations.DoubleColon Self "replace_endpoint" := {
      Notations.double_colon := replace_endpoint;
    }.
    
    (*
        fn next_route_id(&mut self) -> RouteId {
            let next_id = self
                .prev_route_id
                .0
                .checked_add(1)
                .expect("Over `u32::MAX` routes created. If you need this, please file an issue.");
            self.prev_route_id = RouteId(next_id);
            self.prev_route_id
        }
    *)
    Definition next_route_id (self : mut_ref Self) : M axum.routing.RouteId.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next_route_id :
      Notations.DoubleColon Self "next_route_id" := {
      Notations.double_colon := next_route_id;
    }.
  End Impl_axum_routing_path_router_PathRouter_t_S_4.
  End Impl_axum_routing_path_router_PathRouter_t_S_4.
  
  Module  Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.
  Section Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.path_router.PathRouter.t S.
    
    (*
        fn default() -> Self {
            Self {
                routes: Default::default(),
                node: Default::default(),
                prev_route_id: RouteId(0),
            }
        }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.
  End Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.
  Section Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.path_router.PathRouter.t S.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("PathRouter")
                .field("routes", &self.routes)
                .field("node", &self.node)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.
  End Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.
  
  Module  Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.
  Section Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.path_router.PathRouter.t S.
    
    (*
        fn clone(&self) -> Self {
            Self {
                routes: self.routes.clone(),
                node: self.node.clone(),
                prev_route_id: self.prev_route_id,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.
  End Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.
  
  Module  Node.
  Section Node.
    Record t : Set := {
      inner : matchit.router.Router.t axum.routing.RouteId.t;
      route_id_to_path :
        std.collections.hash.map.HashMap.t
          axum.routing.RouteId.t
          (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
          std.collections.hash.map.HashMap.Default.S;
      path_to_route_id :
        std.collections.hash.map.HashMap.t
          (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
          axum.routing.RouteId.t
          std.collections.hash.map.HashMap.Default.S;
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Definition Get_route_id_to_path :=
      Ref.map
        (fun α => Some α.(route_id_to_path))
        (fun β α => Some (α <| route_id_to_path := β |>)).
    Definition Get_path_to_route_id :=
      Ref.map
        (fun α => Some α.(path_to_route_id))
        (fun β α => Some (α <| path_to_route_id := β |>)).
  End Node.
  End Node.
  
  Module  Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.
  Section Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.
    Definition Self : Set := axum.routing.path_router.Node.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum.routing.path_router.Node.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.
  End Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.
  
  Module  Impl_core_default_Default_for_axum_routing_path_router_Node_t.
  Section Impl_core_default_Default_for_axum_routing_path_router_Node_t.
    Definition Self : Set := axum.routing.path_router.Node.t.
    
    (*
    Default
    *)
    Definition default : M axum.routing.path_router.Node.t := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_routing_path_router_Node_t.
  End Impl_core_default_Default_for_axum_routing_path_router_Node_t.
  
  Module  Impl_axum_routing_path_router_Node_t_2.
  Section Impl_axum_routing_path_router_Node_t_2.
    Definition Self : Set := axum.routing.path_router.Node.t.
    
    (*
        fn insert(
            &mut self,
            path: impl Into<String>,
            val: RouteId,
        ) -> Result<(), matchit::InsertError> {
            let path = path.into();
    
            self.inner.insert(&path, val)?;
    
            let shared_path: Arc<str> = path.into();
            self.route_id_to_path.insert(val, shared_path.clone());
            self.path_to_route_id.insert(shared_path, val);
    
            Ok(())
        }
    *)
    Definition insert
        {impl Into<String> : Set}
        {ℋ_0 :
          core.convert.Into.Trait impl Into<String>
            (T := alloc.string.String.t)}
        (self : mut_ref Self)
        (path : impl Into<String>)
        (val : axum.routing.RouteId.t)
        : M (core.result.Result.t unit matchit.error.InsertError.t) :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* val := M.alloc val in
      M.read foo.
    
    Global Instance AssociatedFunction_insert
        {impl Into<String> : Set}
        {ℋ_0 :
          core.convert.Into.Trait impl Into<String>
            (T := alloc.string.String.t)} :
      Notations.DoubleColon Self "insert" := {
      Notations.double_colon := insert (impl Into<String> := impl Into<String>);
    }.
    
    (*
        fn at<'n, 'p>(
            &'n self,
            path: &'p str,
        ) -> Result<matchit::Match<'n, 'p, &'n RouteId>, MatchError> {
            self.inner.at(path)
        }
    *)
    Definition at
        (self : ref Self)
        (path : ref str.t)
        :
          M
            (core.result.Result.t
              (matchit.router.Match.t (ref axum.routing.RouteId.t))
              matchit.error.MatchError.t) :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      M.read foo.
    
    Global Instance AssociatedFunction_at : Notations.DoubleColon Self "at" := {
      Notations.double_colon := at;
    }.
  End Impl_axum_routing_path_router_Node_t_2.
  End Impl_axum_routing_path_router_Node_t_2.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.
  Section Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.
    Definition Self : Set := axum.routing.path_router.Node.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Node")
                .field("paths", &self.route_id_to_path)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.
  End Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.
  
  (*
  fn validate_nest_path(path: &str) -> &str {
      if path.is_empty() {
          // nesting at `""` and `"/"` should mean the same thing
          return "/";
      }
  
      if path.contains('*') {
          panic!("Invalid route: nested routes cannot contain wildcards ( * )");
      }
  
      path
  }
  *)
  Definition validate_nest_path (path : ref str.t) : M (ref str.t) :=
    let* path := M.alloc path in
    M.read foo.
  
  (*
  pub(crate) fn path_for_nested_route<'a>(prefix: &'a str, path: &'a str) -> Cow<'a, str> {
      debug_assert!(prefix.starts_with('/'));
      debug_assert!(path.starts_with('/'));
  
      if prefix.ends_with('/') {
          format!("{prefix}{}", path.trim_start_matches('/')).into()
      } else if path == "/" {
          prefix.into()
      } else {
          format!("{prefix}{path}").into()
      }
  }
  *)
  Definition path_for_nested_route
      (prefix : ref str.t)
      (path : ref str.t)
      : M (alloc.borrow.Cow.t str.t) :=
    let* prefix := M.alloc prefix in
    let* path := M.alloc path in
    M.read foo.
End path_router.

Module  PathRouter.
Section PathRouter.
  Context (S : Set).
  
  Record t : Set := {
    routes :
      std.collections.hash.map.HashMap.t
        axum.routing.RouteId.t
        (axum.routing.Endpoint.t S)
        std.collections.hash.map.HashMap.Default.S;
    node :
      alloc.sync.Arc.t axum.routing.path_router.Node.t alloc.sync.Arc.Default.A;
    prev_route_id : axum.routing.RouteId.t;
  }.
  
  Definition Get_routes :=
    Ref.map (fun α => Some α.(routes)) (fun β α => Some (α <| routes := β |>)).
  Definition Get_node :=
    Ref.map (fun α => Some α.(node)) (fun β α => Some (α <| node := β |>)).
  Definition Get_prev_route_id :=
    Ref.map
      (fun α => Some α.(prev_route_id))
      (fun β α => Some (α <| prev_route_id := β |>)).
End PathRouter.
End PathRouter.

Module  Impl_axum_routing_path_router_PathRouter_t_S_5.
Section Impl_axum_routing_path_router_PathRouter_t_S_5.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.path_router.PathRouter.t S.
  
  (*
      pub(super) fn new_fallback() -> Self {
          let mut this = Self::default();
          this.set_fallback(Endpoint::Route(Route::new(NotFound)));
          this
      }
  *)
  Definition new_fallback : M Self := M.read foo.
  
  Global Instance AssociatedFunction_new_fallback :
    Notations.DoubleColon Self "new_fallback" := {
    Notations.double_colon := new_fallback;
  }.
  
  (*
      pub(super) fn set_fallback(&mut self, endpoint: Endpoint<S>) {
          self.replace_endpoint("/", endpoint.clone());
          self.replace_endpoint(FALLBACK_PARAM_PATH, endpoint);
      }
  *)
  Definition set_fallback
      (self : mut_ref Self)
      (endpoint : axum.routing.Endpoint.t S)
      : M unit :=
    let* self := M.alloc self in
    let* endpoint := M.alloc endpoint in
    M.read foo.
  
  Global Instance AssociatedFunction_set_fallback :
    Notations.DoubleColon Self "set_fallback" := {
    Notations.double_colon := set_fallback;
  }.
End Impl_axum_routing_path_router_PathRouter_t_S_5.
End Impl_axum_routing_path_router_PathRouter_t_S_5.

Module  Impl_axum_routing_path_router_PathRouter_t_S_6.
Section Impl_axum_routing_path_router_PathRouter_t_S_6.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.path_router.PathRouter.t S.
  
  (*
      pub(super) fn route(
          &mut self,
          path: &str,
          method_router: MethodRouter<S>,
      ) -> Result<(), Cow<'static, str>> {
          fn validate_path(path: &str) -> Result<(), &'static str> {
              if path.is_empty() {
                  return Err("Paths must start with a `/`. Use \"/\" for root routes");
              } else if !path.starts_with('/') {
                  return Err("Paths must start with a `/`");
              }
  
              Ok(())
          }
  
          validate_path(path)?;
  
          let endpoint = if let Some((route_id, Endpoint::MethodRouter(prev_method_router))) = self
              .node
              .path_to_route_id
              .get(path)
              .and_then(|route_id| self.routes.get(route_id).map(|svc| ( *route_id, svc)))
          {
              // if we're adding a new `MethodRouter` to a route that already has one just
              // merge them. This makes `.route("/", get(_)).route("/", post(_))` work
              let service = Endpoint::MethodRouter(
                  prev_method_router
                      .clone()
                      .merge_for_path(Some(path), method_router),
              );
              self.routes.insert(route_id, service);
              return Ok(());
          } else {
              Endpoint::MethodRouter(method_router)
          };
  
          let id = self.next_route_id();
          self.set_node(path, id)?;
          self.routes.insert(id, endpoint);
  
          Ok(())
      }
  *)
  Definition route
      (self : mut_ref Self)
      (path : ref str.t)
      (method_router
        :
        axum.routing.method_routing.MethodRouter.t
          S
          axum.routing.method_routing.MethodRouter.Default.E)
      : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* method_router := M.alloc method_router in
    M.read foo.
  
  Global Instance AssociatedFunction_route :
    Notations.DoubleColon Self "route" := {
    Notations.double_colon := route;
  }.
  
  (*
      pub(super) fn route_service<T>(
          &mut self,
          path: &str,
          service: T,
      ) -> Result<(), Cow<'static, str>>
      where
          T: Service<Request, Error = Infallible> + Clone + Send + 'static,
          T::Response: IntoResponse,
          T::Future: Send + 'static,
      {
          self.route_endpoint(path, Endpoint::Route(Route::new(service)))
      }
  *)
  Definition route_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : mut_ref Self)
      (path : ref str.t)
      (service : T)
      : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* service := M.alloc service in
    M.read foo.
  
  Global Instance AssociatedFunction_route_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "route_service" := {
    Notations.double_colon := route_service (T := T);
  }.
  
  (*
      pub(super) fn route_endpoint(
          &mut self,
          path: &str,
          endpoint: Endpoint<S>,
      ) -> Result<(), Cow<'static, str>> {
          if path.is_empty() {
              return Err("Paths must start with a `/`. Use \"/\" for root routes".into());
          } else if !path.starts_with('/') {
              return Err("Paths must start with a `/`".into());
          }
  
          let id = self.next_route_id();
          self.set_node(path, id)?;
          self.routes.insert(id, endpoint);
  
          Ok(())
      }
  *)
  Definition route_endpoint
      (self : mut_ref Self)
      (path : ref str.t)
      (endpoint : axum.routing.Endpoint.t S)
      : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* endpoint := M.alloc endpoint in
    M.read foo.
  
  Global Instance AssociatedFunction_route_endpoint :
    Notations.DoubleColon Self "route_endpoint" := {
    Notations.double_colon := route_endpoint;
  }.
  
  (*
      fn set_node(&mut self, path: &str, id: RouteId) -> Result<(), String> {
          let mut node =
              Arc::try_unwrap(Arc::clone(&self.node)).unwrap_or_else(|node| ( *node).clone());
          if let Err(err) = node.insert(path, id) {
              return Err(format!("Invalid route {path:?}: {err}"));
          }
          self.node = Arc::new(node);
          Ok(())
      }
  *)
  Definition set_node
      (self : mut_ref Self)
      (path : ref str.t)
      (id : axum.routing.RouteId.t)
      : M (core.result.Result.t unit alloc.string.String.t) :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* id := M.alloc id in
    M.read foo.
  
  Global Instance AssociatedFunction_set_node :
    Notations.DoubleColon Self "set_node" := {
    Notations.double_colon := set_node;
  }.
  
  (*
      pub(super) fn merge(
          &mut self,
          other: PathRouter<S, IS_FALLBACK>,
      ) -> Result<(), Cow<'static, str>> {
          let PathRouter {
              routes,
              node,
              prev_route_id: _,
          } = other;
  
          for (id, route) in routes {
              let path = node
                  .route_id_to_path
                  .get(&id)
                  .expect("no path for route id. This is a bug in axum. Please file an issue");
  
              if IS_FALLBACK && (&**path == "/" || &**path == FALLBACK_PARAM_PATH) {
                  // when merging two routers it doesn't matter if you do `a.merge(b)` or
                  // `b.merge(a)`. This must also be true for fallbacks.
                  //
                  // However all fallback routers will have routes for `/` and `/*` so when merging
                  // we have to ignore the top level fallbacks on one side otherwise we get
                  // conflicts.
                  //
                  // `Router::merge` makes sure that when merging fallbacks `other` always has the
                  // fallback we want to keep. It panics if both routers have a custom fallback. Thus
                  // it is always okay to ignore one fallback and `Router::merge` also makes sure the
                  // one we can ignore is that of `self`.
                  self.replace_endpoint(path, route);
              } else {
                  match route {
                      Endpoint::MethodRouter(method_router) => self.route(path, method_router)?,
                      Endpoint::Route(route) => self.route_service(path, route)?,
                  }
              }
          }
  
          Ok(())
      }
  *)
  Definition merge
      (self : mut_ref Self)
      (other : axum.routing.path_router.PathRouter.t S)
      : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_merge :
    Notations.DoubleColon Self "merge" := {
    Notations.double_colon := merge;
  }.
  
  (*
      pub(super) fn nest(
          &mut self,
          path_to_nest_at: &str,
          router: PathRouter<S, IS_FALLBACK>,
      ) -> Result<(), Cow<'static, str>> {
          let prefix = validate_nest_path(path_to_nest_at);
  
          let PathRouter {
              routes,
              node,
              prev_route_id: _,
          } = router;
  
          for (id, endpoint) in routes {
              let inner_path = node
                  .route_id_to_path
                  .get(&id)
                  .expect("no path for route id. This is a bug in axum. Please file an issue");
  
              let path = path_for_nested_route(prefix, inner_path);
  
              let layer = (
                  StripPrefix::layer(prefix),
                  SetNestedPath::layer(path_to_nest_at),
              );
              match endpoint.layer(layer) {
                  Endpoint::MethodRouter(method_router) => {
                      self.route(&path, method_router)?;
                  }
                  Endpoint::Route(route) => {
                      self.route_endpoint(&path, Endpoint::Route(route))?;
                  }
              }
          }
  
          Ok(())
      }
  *)
  Definition nest
      (self : mut_ref Self)
      (path_to_nest_at : ref str.t)
      (router : axum.routing.path_router.PathRouter.t S)
      : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
    let* self := M.alloc self in
    let* path_to_nest_at := M.alloc path_to_nest_at in
    let* router := M.alloc router in
    M.read foo.
  
  Global Instance AssociatedFunction_nest :
    Notations.DoubleColon Self "nest" := {
    Notations.double_colon := nest;
  }.
  
  (*
      pub(super) fn nest_service<T>(
          &mut self,
          path_to_nest_at: &str,
          svc: T,
      ) -> Result<(), Cow<'static, str>>
      where
          T: Service<Request, Error = Infallible> + Clone + Send + 'static,
          T::Response: IntoResponse,
          T::Future: Send + 'static,
      {
          let path = validate_nest_path(path_to_nest_at);
          let prefix = path;
  
          let path = if path.ends_with('/') {
              format!("{path}*{NEST_TAIL_PARAM}")
          } else {
              format!("{path}/*{NEST_TAIL_PARAM}")
          };
  
          let layer = (
              StripPrefix::layer(prefix),
              SetNestedPath::layer(path_to_nest_at),
          );
          let endpoint = Endpoint::Route(Route::new(layer.layer(svc)));
  
          self.route_endpoint(&path, endpoint.clone())?;
  
          // `/*rest` is not matched by `/` so we need to also register a router at the
          // prefix itself. Otherwise if you were to nest at `/foo` then `/foo` itself
          // wouldn't match, which it should
          self.route_endpoint(prefix, endpoint.clone())?;
          if !prefix.ends_with('/') {
              // same goes for `/foo/`, that should also match
              self.route_endpoint(&format!("{prefix}/"), endpoint)?;
          }
  
          Ok(())
      }
  *)
  Definition nest_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : mut_ref Self)
      (path_to_nest_at : ref str.t)
      (svc : T)
      : M (core.result.Result.t unit (alloc.borrow.Cow.t str.t)) :=
    let* self := M.alloc self in
    let* path_to_nest_at := M.alloc path_to_nest_at in
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_nest_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "nest_service" := {
    Notations.double_colon := nest_service (T := T);
  }.
  
  (*
      pub(super) fn layer<L>(self, layer: L) -> PathRouter<S, IS_FALLBACK>
      where
          L: Layer<Route> + Clone + Send + 'static,
          L::Service: Service<Request> + Clone + Send + 'static,
          <L::Service as Service<Request>>::Response: IntoResponse + 'static,
          <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
          <L::Service as Service<Request>>::Future: Send + 'static,
      {
          let routes = self
              .routes
              .into_iter()
              .map(|(id, endpoint)| {
                  let route = endpoint.layer(layer.clone());
                  (id, route)
              })
              .collect();
  
          PathRouter {
              routes,
              node: self.node,
              prev_route_id: self.prev_route_id,
          }
      }
  *)
  Definition layer
      {L : Set}
      {ℋ_0 :
        tower_layer.Layer.Trait L
          (S := axum.routing.route.Route.t axum.routing.route.Route.Default.E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := core.convert.Infallible.t)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      (self : Self)
      (layer : L)
      : M (axum.routing.path_router.PathRouter.t S) :=
    let* self := M.alloc self in
    let* layer := M.alloc layer in
    M.read foo.
  
  Global Instance AssociatedFunction_layer
      {L : Set}
      {ℋ_0 :
        tower_layer.Layer.Trait L
          (S := axum.routing.route.Route.t axum.routing.route.Route.Default.E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := core.convert.Infallible.t)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))} :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer (L := L);
  }.
  
  (*
      pub(super) fn route_layer<L>(self, layer: L) -> Self
      where
          L: Layer<Route> + Clone + Send + 'static,
          L::Service: Service<Request> + Clone + Send + 'static,
          <L::Service as Service<Request>>::Response: IntoResponse + 'static,
          <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
          <L::Service as Service<Request>>::Future: Send + 'static,
      {
          if self.routes.is_empty() {
              panic!(
                  "Adding a route_layer before any routes is a no-op. \
                   Add the routes you want the layer to apply to first."
              );
          }
  
          let routes = self
              .routes
              .into_iter()
              .map(|(id, endpoint)| {
                  let route = endpoint.layer(layer.clone());
                  (id, route)
              })
              .collect();
  
          PathRouter {
              routes,
              node: self.node,
              prev_route_id: self.prev_route_id,
          }
      }
  *)
  Definition route_layer
      {L : Set}
      {ℋ_0 :
        tower_layer.Layer.Trait L
          (S := axum.routing.route.Route.t axum.routing.route.Route.Default.E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := core.convert.Infallible.t)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      (self : Self)
      (layer : L)
      : M Self :=
    let* self := M.alloc self in
    let* layer := M.alloc layer in
    M.read foo.
  
  Global Instance AssociatedFunction_route_layer
      {L : Set}
      {ℋ_0 :
        tower_layer.Layer.Trait L
          (S := axum.routing.route.Route.t axum.routing.route.Route.Default.E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := core.convert.Infallible.t)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))} :
    Notations.DoubleColon Self "route_layer" := {
    Notations.double_colon := route_layer (L := L);
  }.
  
  (*
      pub(super) fn with_state<S2>(self, state: S) -> PathRouter<S2, IS_FALLBACK> {
          let routes = self
              .routes
              .into_iter()
              .map(|(id, endpoint)| {
                  let endpoint: Endpoint<S2> = match endpoint {
                      Endpoint::MethodRouter(method_router) => {
                          Endpoint::MethodRouter(method_router.with_state(state.clone()))
                      }
                      Endpoint::Route(route) => Endpoint::Route(route),
                  };
                  (id, endpoint)
              })
              .collect();
  
          PathRouter {
              routes,
              node: self.node,
              prev_route_id: self.prev_route_id,
          }
      }
  *)
  Definition with_state
      {S2 : Set}
      (self : Self)
      (state : S)
      : M (axum.routing.path_router.PathRouter.t S2) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_with_state {S2 : Set} :
    Notations.DoubleColon Self "with_state" := {
    Notations.double_colon := with_state (S2 := S2);
  }.
  
  (*
      pub(super) fn call_with_state(
          &self,
          mut req: Request,
          state: S,
      ) -> Result<RouteFuture<Infallible>, (Request, S)> {
          #[cfg(feature = "original-uri")]
          {
              use crate::extract::OriginalUri;
  
              if req.extensions().get::<OriginalUri>().is_none() {
                  let original_uri = OriginalUri(req.uri().clone());
                  req.extensions_mut().insert(original_uri);
              }
          }
  
          let path = req.uri().path().to_owned();
  
          match self.node.at(&path) {
              Ok(match_) => {
                  let id = *match_.value;
  
                  if !IS_FALLBACK {
                      #[cfg(feature = "matched-path")]
                      crate::extract::matched_path::set_matched_path_for_request(
                          id,
                          &self.node.route_id_to_path,
                          req.extensions_mut(),
                      );
                  }
  
                  url_params::insert_url_params(req.extensions_mut(), match_.params);
  
                  let endpoint = self
                      .routes
                      .get(&id)
                      .expect("no route for id. This is a bug in axum. Please file an issue");
  
                  match endpoint {
                      Endpoint::MethodRouter(method_router) => {
                          Ok(method_router.call_with_state(req, state))
                      }
                      Endpoint::Route(route) => Ok(route.clone().call(req)),
                  }
              }
              // explicitly handle all variants in case matchit adds
              // new ones we need to handle differently
              Err(
                  MatchError::NotFound
                  | MatchError::ExtraTrailingSlash
                  | MatchError::MissingTrailingSlash,
              ) => Err((req, state)),
          }
      }
  *)
  Definition call_with_state
      (self : ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      :
        M
          (core.result.Result.t
            (axum.routing.route.RouteFuture.t core.convert.Infallible.t)
            (ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T)
            *
            S)) :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call_with_state :
    Notations.DoubleColon Self "call_with_state" := {
    Notations.double_colon := call_with_state;
  }.
  
  (*
      pub(super) fn replace_endpoint(&mut self, path: &str, endpoint: Endpoint<S>) {
          match self.node.at(path) {
              Ok(match_) => {
                  let id = *match_.value;
                  self.routes.insert(id, endpoint);
              }
              Err(_) => self
                  .route_endpoint(path, endpoint)
                  .expect("path wasn't matched so endpoint shouldn't exist"),
          }
      }
  *)
  Definition replace_endpoint
      (self : mut_ref Self)
      (path : ref str.t)
      (endpoint : axum.routing.Endpoint.t S)
      : M unit :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* endpoint := M.alloc endpoint in
    M.read foo.
  
  Global Instance AssociatedFunction_replace_endpoint :
    Notations.DoubleColon Self "replace_endpoint" := {
    Notations.double_colon := replace_endpoint;
  }.
  
  (*
      fn next_route_id(&mut self) -> RouteId {
          let next_id = self
              .prev_route_id
              .0
              .checked_add(1)
              .expect("Over `u32::MAX` routes created. If you need this, please file an issue.");
          self.prev_route_id = RouteId(next_id);
          self.prev_route_id
      }
  *)
  Definition next_route_id (self : mut_ref Self) : M axum.routing.RouteId.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next_route_id :
    Notations.DoubleColon Self "next_route_id" := {
    Notations.double_colon := next_route_id;
  }.
End Impl_axum_routing_path_router_PathRouter_t_S_6.
End Impl_axum_routing_path_router_PathRouter_t_S_6.

(*
        fn validate_path(path: &str) -> Result<(), &'static str> {
            if path.is_empty() {
                return Err("Paths must start with a `/`. Use \"/\" for root routes");
            } else if !path.starts_with('/') {
                return Err("Paths must start with a `/`");
            }

            Ok(())
        }
*)
Definition validate_path
    (path : ref str.t)
    : M (core.result.Result.t unit (ref str.t)) :=
  let* path := M.alloc path in
  M.read foo.

Module  Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.
Section Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.path_router.PathRouter.t S.
  
  (*
      fn default() -> Self {
          Self {
              routes: Default::default(),
              node: Default::default(),
              prev_route_id: RouteId(0),
          }
      }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.
End Impl_core_default_Default_for_axum_routing_path_router_PathRouter_t_S.

Module  Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.
Section Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.path_router.PathRouter.t S.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("PathRouter")
              .field("routes", &self.routes)
              .field("node", &self.node)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.
End Impl_core_fmt_Debug_for_axum_routing_path_router_PathRouter_t_S.

Module  Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.
Section Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.path_router.PathRouter.t S.
  
  (*
      fn clone(&self) -> Self {
          Self {
              routes: self.routes.clone(),
              node: self.node.clone(),
              prev_route_id: self.prev_route_id,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.
End Impl_core_clone_Clone_for_axum_routing_path_router_PathRouter_t_S.

Module  Node.
Section Node.
  Record t : Set := {
    inner : matchit.router.Router.t axum.routing.RouteId.t;
    route_id_to_path :
      std.collections.hash.map.HashMap.t
        axum.routing.RouteId.t
        (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
        std.collections.hash.map.HashMap.Default.S;
    path_to_route_id :
      std.collections.hash.map.HashMap.t
        (alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
        axum.routing.RouteId.t
        std.collections.hash.map.HashMap.Default.S;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Definition Get_route_id_to_path :=
    Ref.map
      (fun α => Some α.(route_id_to_path))
      (fun β α => Some (α <| route_id_to_path := β |>)).
  Definition Get_path_to_route_id :=
    Ref.map
      (fun α => Some α.(path_to_route_id))
      (fun β α => Some (α <| path_to_route_id := β |>)).
End Node.
End Node.

Module  Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.
Section Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.
  Definition Self : Set := axum.routing.path_router.Node.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.routing.path_router.Node.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.
End Impl_core_clone_Clone_for_axum_routing_path_router_Node_t.

Module  Impl_core_default_Default_for_axum_routing_path_router_Node_t.
Section Impl_core_default_Default_for_axum_routing_path_router_Node_t.
  Definition Self : Set := axum.routing.path_router.Node.t.
  
  (*
  Default
  *)
  Definition default : M axum.routing.path_router.Node.t := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_routing_path_router_Node_t.
End Impl_core_default_Default_for_axum_routing_path_router_Node_t.

Module  Impl_axum_routing_path_router_Node_t_3.
Section Impl_axum_routing_path_router_Node_t_3.
  Definition Self : Set := axum.routing.path_router.Node.t.
  
  (*
      fn insert(
          &mut self,
          path: impl Into<String>,
          val: RouteId,
      ) -> Result<(), matchit::InsertError> {
          let path = path.into();
  
          self.inner.insert(&path, val)?;
  
          let shared_path: Arc<str> = path.into();
          self.route_id_to_path.insert(val, shared_path.clone());
          self.path_to_route_id.insert(shared_path, val);
  
          Ok(())
      }
  *)
  Definition insert
      {impl Into<String> : Set}
      {ℋ_0 :
        core.convert.Into.Trait impl Into<String> (T := alloc.string.String.t)}
      (self : mut_ref Self)
      (path : impl Into<String>)
      (val : axum.routing.RouteId.t)
      : M (core.result.Result.t unit matchit.error.InsertError.t) :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* val := M.alloc val in
    M.read foo.
  
  Global Instance AssociatedFunction_insert
      {impl Into<String> : Set}
      {ℋ_0 :
        core.convert.Into.Trait impl Into<String>
          (T := alloc.string.String.t)} :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert (impl Into<String> := impl Into<String>);
  }.
  
  (*
      fn at<'n, 'p>(
          &'n self,
          path: &'p str,
      ) -> Result<matchit::Match<'n, 'p, &'n RouteId>, MatchError> {
          self.inner.at(path)
      }
  *)
  Definition at
      (self : ref Self)
      (path : ref str.t)
      :
        M
          (core.result.Result.t
            (matchit.router.Match.t (ref axum.routing.RouteId.t))
            matchit.error.MatchError.t) :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    M.read foo.
  
  Global Instance AssociatedFunction_at : Notations.DoubleColon Self "at" := {
    Notations.double_colon := at;
  }.
End Impl_axum_routing_path_router_Node_t_3.
End Impl_axum_routing_path_router_Node_t_3.

Module  Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.
Section Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.
  Definition Self : Set := axum.routing.path_router.Node.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("Node")
              .field("paths", &self.route_id_to_path)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.
End Impl_core_fmt_Debug_for_axum_routing_path_router_Node_t.

(*
fn validate_nest_path(path: &str) -> &str {
    if path.is_empty() {
        // nesting at `""` and `"/"` should mean the same thing
        return "/";
    }

    if path.contains('*') {
        panic!("Invalid route: nested routes cannot contain wildcards ( * )");
    }

    path
}
*)
Definition validate_nest_path (path : ref str.t) : M (ref str.t) :=
  let* path := M.alloc path in
  M.read foo.

(*
pub(crate) fn path_for_nested_route<'a>(prefix: &'a str, path: &'a str) -> Cow<'a, str> {
    debug_assert!(prefix.starts_with('/'));
    debug_assert!(path.starts_with('/'));

    if prefix.ends_with('/') {
        format!("{prefix}{}", path.trim_start_matches('/')).into()
    } else if path == "/" {
        prefix.into()
    } else {
        format!("{prefix}{path}").into()
    }
}
*)
Definition path_for_nested_route
    (prefix : ref str.t)
    (path : ref str.t)
    : M (alloc.borrow.Cow.t str.t) :=
  let* prefix := M.alloc prefix in
  let* path := M.alloc path in
  M.read foo.

Module route.
  Module  Route.
  Section Route.
    Context {E : Set}.
    
    Record t : Set := {
      x0 :
        ltac:(axum.util.mutex.AxumMutex
          (tower.util.boxed_clone.BoxCloneService.t
            ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T)
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            E));
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Route.
  End Route.
  
  Module  Impl_axum_routing_route_Route_t_E_2.
  Section Impl_axum_routing_route_Route_t_E_2.
    Context {E : Set}.
    
    Definition Self : Set := axum.routing.route.Route.t E.
    
    (*
        pub(crate) fn new<T>(svc: T) -> Self
        where
            T: Service<Request, Error = E> + Clone + Send + 'static,
            T::Response: IntoResponse + 'static,
            T::Future: Send + 'static,
        {
            Self(AxumMutex::new(BoxCloneService::new(
                svc.map_response(IntoResponse::into_response),
            )))
        }
    *)
    Definition new
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (svc : T)
        : M Self :=
      let* svc := M.alloc svc in
      M.read foo.
    
    Global Instance AssociatedFunction_new
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new (T := T);
    }.
    
    (*
        pub(crate) fn oneshot_inner(
            &mut self,
            req: Request,
        ) -> Oneshot<BoxCloneService<Request, Response, E>, Request> {
            self.0.get_mut().unwrap().clone().oneshot(req)
        }
    *)
    Definition oneshot_inner
        (self : mut_ref Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        :
          M
            (tower.util.oneshot.Oneshot.t
              (tower.util.boxed_clone.BoxCloneService.t
                ltac:(axum_core.extract.Request
                  axum_core.extract.Request.Default.T)
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                E)
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T)) :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_oneshot_inner :
      Notations.DoubleColon Self "oneshot_inner" := {
      Notations.double_colon := oneshot_inner;
    }.
    
    (*
        pub(crate) fn layer<L, NewError>(self, layer: L) -> Route<NewError>
        where
            L: Layer<Route<E>> + Clone + Send + 'static,
            L::Service: Service<Request> + Clone + Send + 'static,
            <L::Service as Service<Request>>::Response: IntoResponse + 'static,
            <L::Service as Service<Request>>::Error: Into<NewError> + 'static,
            <L::Service as Service<Request>>::Future: Send + 'static,
            NewError: 'static,
        {
            let layer = (
                MapRequestLayer::new(|req: Request<_>| req.map(Body::new)),
                MapErrLayer::new(Into::into),
                MapResponseLayer::new(IntoResponse::into_response),
                layer,
            );
    
            Route::new(layer.layer(self))
        }
    *)
    Definition layer
        {L NewError : Set}
        {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := NewError)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        (self : Self)
        (layer : L)
        : M (axum.routing.route.Route.t NewError) :=
      let* self := M.alloc self in
      let* layer := M.alloc layer in
      M.read foo.
    
    Global Instance AssociatedFunction_layer
        {L NewError : Set}
        {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          tower_service.Service.Trait L::type["Service"].t
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
        {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
        {ℋ_6 :
          axum_core.response.into_response.IntoResponse.Trait
              (tower_service.Service.Response
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))}
        {ℋ_7 :
          core.convert.Into.Trait
              (tower_service.Service.Error
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))
            (T := NewError)}
        {ℋ_8 :
          core.marker.Send.Trait
              (tower_service.Service.Future
                (Self := L::type["Service"].t)
                (Trait := ltac:(refine _)))} :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer (L := L) (NewError := NewError);
    }.
  End Impl_axum_routing_route_Route_t_E_2.
  End Impl_axum_routing_route_Route_t_E_2.
  
  Module  Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.
  Section Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.
    Context {E : Set}.
    
    Definition Self : Set := axum.routing.route.Route.t E.
    
    (*
        fn clone(&self) -> Self {
            Self(AxumMutex::new(self.0.lock().unwrap().clone()))
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.
  End Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.
  Section Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.
    Context {E : Set}.
    
    Definition Self : Set := axum.routing.route.Route.t E.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Route").finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.
  End Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.
  
  Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.
  Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.
    Context {B E : Set}.
    
    Context
      {ℋ_0 : http_body.Body.Trait B}
      {ℋ_1 : core.marker.Send.Trait B}
      {ℋ_2 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}.
    
    Definition Self : Set := axum.routing.route.Route.t E.
    
    (*
        type Response = Response;
    *)
    Definition Response : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        type Error = E;
    *)
    Definition Error : Set := E.
    
    (*
        type Future = RouteFuture<E>;
    *)
    Definition Future : Set := axum.routing.route.RouteFuture.t E.
    
    (*
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (_cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* _cx := M.alloc _cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, req: Request<B>) -> Self::Future {
            let req = req.map(Body::new);
            RouteFuture::from_future(self.oneshot_inner(req))
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req : ltac:(axum_core.extract.Request B))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request B)) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.
  End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.
  
  Module  RouteFuture.
  Section RouteFuture.
    Context (E : Set).
    
    Record t : Set := {
      kind : axum.routing.route.RouteFutureKind.t E;
      strip_body : bool.t;
      allow_header : core.option.Option.t bytes.bytes.Bytes.t;
    }.
    
    Definition Get_kind :=
      Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
    Definition Get_strip_body :=
      Ref.map
        (fun α => Some α.(strip_body))
        (fun β α => Some (α <| strip_body := β |>)).
    Definition Get_allow_header :=
      Ref.map
        (fun α => Some α.(allow_header))
        (fun β α => Some (α <| allow_header := β |>)).
  End RouteFuture.
  End RouteFuture.
  
  Module RouteFutureKind.
    Module Future.
      Record t : Set := {
        future :
          tower.util.oneshot.Oneshot.t
            (tower.util.boxed_clone.BoxCloneService.t
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T)
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              E)
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T);
      }.
    End Future.
    
    Module Response.
      Record t : Set := {
        response :
          core.option.Option.t
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T);
      }.
    End Response.
    
    Inductive t (E : Set) : Set :=
    | Future (_ : Future.t)
    | Response (_ : Response.t).
    
    Definition Get_Future_future :=
      Ref.map
        (fun α =>
          match α with | Future α => Some α.(Future.future) | _ => None end)
        (fun β α =>
          match α with
          | Future α => Some (Future (α <| Future.future := β |>))
          | _ => None
          end).
    
    Definition Get_Response_response :=
      Ref.map
        (fun α =>
          match α with
          | Response α => Some α.(Response.response)
          | _ => None
          end)
        (fun β α =>
          match α with
          | Response α => Some (Response (α <| Response.response := β |>))
          | _ => None
          end).
  End RouteFutureKind.
  
  Module RouteFutureKindProj.
    Module Future.
      Record t : Set := {
        future :
          core.pin.Pin.t
            (mut_ref
              (tower.util.oneshot.Oneshot.t
                (tower.util.boxed_clone.BoxCloneService.t
                  ltac:(axum_core.extract.Request
                    axum_core.extract.Request.Default.T)
                  ltac:(axum_core.response.Response
                    axum_core.response.Response.Default.T)
                  E)
                ltac:(axum_core.extract.Request
                  axum_core.extract.Request.Default.T)));
      }.
    End Future.
    
    Module Response.
      Record t : Set := {
        response :
          mut_ref
            (core.option.Option.t
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T));
      }.
    End Response.
    
    Inductive t (E : Set) : Set :=
    | Future (_ : Future.t)
    | Response (_ : Response.t).
    
    Definition Get_Future_future :=
      Ref.map
        (fun α =>
          match α with | Future α => Some α.(Future.future) | _ => None end)
        (fun β α =>
          match α with
          | Future α => Some (Future (α <| Future.future := β |>))
          | _ => None
          end).
    
    Definition Get_Response_response :=
      Ref.map
        (fun α =>
          match α with
          | Response α => Some α.(Response.response)
          | _ => None
          end)
        (fun β α =>
          match α with
          | Response α => Some (Response (α <| Response.response := β |>))
          | _ => None
          end).
  End RouteFutureKindProj.
  
  Module  Impl_axum_routing_route_RouteFuture_t_E_2.
  Section Impl_axum_routing_route_RouteFuture_t_E_2.
    Context {E : Set}.
    
    Definition Self : Set := axum.routing.route.RouteFuture.t E.
    
    (*
        pub(crate) fn from_future(
            future: Oneshot<BoxCloneService<Request, Response, E>, Request>,
        ) -> Self {
            Self {
                kind: RouteFutureKind::Future { future },
                strip_body: false,
                allow_header: None,
            }
        }
    *)
    Definition from_future
        (future
          :
          tower.util.oneshot.Oneshot.t
            (tower.util.boxed_clone.BoxCloneService.t
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T)
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              E)
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
        : M Self :=
      let* future := M.alloc future in
      M.read foo.
    
    Global Instance AssociatedFunction_from_future :
      Notations.DoubleColon Self "from_future" := {
      Notations.double_colon := from_future;
    }.
    
    (*
        pub(crate) fn strip_body(mut self, strip_body: bool) -> Self {
            self.strip_body = strip_body;
            self
        }
    *)
    Definition strip_body (self : Self) (strip_body : bool.t) : M Self :=
      let* self := M.alloc self in
      let* strip_body := M.alloc strip_body in
      M.read foo.
    
    Global Instance AssociatedFunction_strip_body :
      Notations.DoubleColon Self "strip_body" := {
      Notations.double_colon := strip_body;
    }.
    
    (*
        pub(crate) fn allow_header(mut self, allow_header: Bytes) -> Self {
            self.allow_header = Some(allow_header);
            self
        }
    *)
    Definition allow_header
        (self : Self)
        (allow_header : bytes.bytes.Bytes.t)
        : M Self :=
      let* self := M.alloc self in
      let* allow_header := M.alloc allow_header in
      M.read foo.
    
    Global Instance AssociatedFunction_allow_header :
      Notations.DoubleColon Self "allow_header" := {
      Notations.double_colon := allow_header;
    }.
  End Impl_axum_routing_route_RouteFuture_t_E_2.
  End Impl_axum_routing_route_RouteFuture_t_E_2.
  
  Module  Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.
  Section Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.
    Context {E : Set}.
    
    Definition Self : Set := axum.routing.route.RouteFuture.t E.
    
    (*
        type Output = Result<Response, E>;
    *)
    Definition Output : Set :=
      core.result.Result.t
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          E.
    
    (*
        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            let this = self.project();
    
            let mut res = match this.kind.project() {
                RouteFutureKindProj::Future { future } => match future.poll(cx) {
                    Poll::Ready(Ok(res)) => res,
                    Poll::Ready(Err(err)) => return Poll::Ready(Err(err)),
                    Poll::Pending => return Poll::Pending,
                },
                RouteFutureKindProj::Response { response } => {
                    response.take().expect("future polled after completion")
                }
            };
    
            set_allow_header(res.headers_mut(), this.allow_header);
    
            // make sure to set content-length before removing the body
            set_content_length(res.size_hint(), res.headers_mut());
    
            let res = if *this.strip_body {
                res.map(|_| Body::empty())
            } else {
                res
            };
    
            Poll::Ready(Ok(res))
        }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.
  End Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.
  
  (*
  fn set_allow_header(headers: &mut HeaderMap, allow_header: &mut Option<Bytes>) {
      match allow_header.take() {
          Some(allow_header) if !headers.contains_key(header::ALLOW) => {
              headers.insert(
                  header::ALLOW,
                  HeaderValue::from_maybe_shared(allow_header).expect("invalid `Allow` header"),
              );
          }
          _ => {}
      }
  }
  *)
  Definition set_allow_header
      (headers
        :
        mut_ref
          (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
      (allow_header : mut_ref (core.option.Option.t bytes.bytes.Bytes.t))
      : M unit :=
    let* headers := M.alloc headers in
    let* allow_header := M.alloc allow_header in
    M.read foo.
  
  (*
  fn set_content_length(size_hint: http_body::SizeHint, headers: &mut HeaderMap) {
      if headers.contains_key(CONTENT_LENGTH) {
          return;
      }
  
      if let Some(size) = size_hint.exact() {
          let header_value = if size == 0 {
              #[allow(clippy::declare_interior_mutable_const)]
              const ZERO: HeaderValue = HeaderValue::from_static("0");
  
              ZERO
          } else {
              let mut buffer = itoa::Buffer::new();
              HeaderValue::from_str(buffer.format(size)).unwrap()
          };
  
          headers.insert(CONTENT_LENGTH, header_value);
      }
  }
  *)
  Definition set_content_length
      (size_hint : http_body.size_hint.SizeHint.t)
      (headers
        :
        mut_ref
          (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
      : M unit :=
    let* size_hint := M.alloc size_hint in
    let* headers := M.alloc headers in
    M.read foo.
  
  Module  InfallibleRouteFuture.
  Section InfallibleRouteFuture.
    Record t : Set := {
      future : axum.routing.route.RouteFuture.t core.convert.Infallible.t;
    }.
    
    Definition Get_future :=
      Ref.map
        (fun α => Some α.(future))
        (fun β α => Some (α <| future := β |>)).
  End InfallibleRouteFuture.
  End InfallibleRouteFuture.
  
  Module  Impl_axum_routing_route_InfallibleRouteFuture_t_2.
  Section Impl_axum_routing_route_InfallibleRouteFuture_t_2.
    Definition Self : Set := axum.routing.route.InfallibleRouteFuture.t.
    
    (*
        pub(crate) fn new(future: RouteFuture<Infallible>) -> Self {
            Self { future }
        }
    *)
    Definition new
        (future : axum.routing.route.RouteFuture.t core.convert.Infallible.t)
        : M Self :=
      let* future := M.alloc future in
      M.read foo.
    
    Global Instance AssociatedFunction_new :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new;
    }.
  End Impl_axum_routing_route_InfallibleRouteFuture_t_2.
  End Impl_axum_routing_route_InfallibleRouteFuture_t_2.
  
  Module  Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.
  Section Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.
    Definition Self : Set := axum.routing.route.InfallibleRouteFuture.t.
    
    (*
        type Output = Response;
    *)
    Definition Output : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            match futures_util::ready!(self.project().future.poll(cx)) {
                Ok(response) => Poll::Ready(response),
                Err(err) => match err {},
            }
        }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.
  End Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.
End route.

Module  Route.
Section Route.
  Context {E : Set}.
  
  Record t : Set := {
    x0 :
      ltac:(axum.util.mutex.AxumMutex
        (tower.util.boxed_clone.BoxCloneService.t
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T)
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          E));
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Route.
End Route.

Module  Impl_axum_routing_route_Route_t_E_3.
Section Impl_axum_routing_route_Route_t_E_3.
  Context {E : Set}.
  
  Definition Self : Set := axum.routing.route.Route.t E.
  
  (*
      pub(crate) fn new<T>(svc: T) -> Self
      where
          T: Service<Request, Error = E> + Clone + Send + 'static,
          T::Response: IntoResponse + 'static,
          T::Future: Send + 'static,
      {
          Self(AxumMutex::new(BoxCloneService::new(
              svc.map_response(IntoResponse::into_response),
          )))
      }
  *)
  Definition new
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (svc : T)
      : M Self :=
    let* svc := M.alloc svc in
    M.read foo.
  
  Global Instance AssociatedFunction_new
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "new" := {
    Notations.double_colon := new (T := T);
  }.
  
  (*
      pub(crate) fn oneshot_inner(
          &mut self,
          req: Request,
      ) -> Oneshot<BoxCloneService<Request, Response, E>, Request> {
          self.0.get_mut().unwrap().clone().oneshot(req)
      }
  *)
  Definition oneshot_inner
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      :
        M
          (tower.util.oneshot.Oneshot.t
            (tower.util.boxed_clone.BoxCloneService.t
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T)
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)
              E)
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T)) :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_oneshot_inner :
    Notations.DoubleColon Self "oneshot_inner" := {
    Notations.double_colon := oneshot_inner;
  }.
  
  (*
      pub(crate) fn layer<L, NewError>(self, layer: L) -> Route<NewError>
      where
          L: Layer<Route<E>> + Clone + Send + 'static,
          L::Service: Service<Request> + Clone + Send + 'static,
          <L::Service as Service<Request>>::Response: IntoResponse + 'static,
          <L::Service as Service<Request>>::Error: Into<NewError> + 'static,
          <L::Service as Service<Request>>::Future: Send + 'static,
          NewError: 'static,
      {
          let layer = (
              MapRequestLayer::new(|req: Request<_>| req.map(Body::new)),
              MapErrLayer::new(Into::into),
              MapResponseLayer::new(IntoResponse::into_response),
              layer,
          );
  
          Route::new(layer.layer(self))
      }
  *)
  Definition layer
      {L NewError : Set}
      {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := NewError)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      (self : Self)
      (layer : L)
      : M (axum.routing.route.Route.t NewError) :=
    let* self := M.alloc self in
    let* layer := M.alloc layer in
    M.read foo.
  
  Global Instance AssociatedFunction_layer
      {L NewError : Set}
      {ℋ_0 : tower_layer.Layer.Trait L (S := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := NewError)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))} :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer (L := L) (NewError := NewError);
  }.
End Impl_axum_routing_route_Route_t_E_3.
End Impl_axum_routing_route_Route_t_E_3.

Module  Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.
Section Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.
  Context {E : Set}.
  
  Definition Self : Set := axum.routing.route.Route.t E.
  
  (*
      fn clone(&self) -> Self {
          Self(AxumMutex::new(self.0.lock().unwrap().clone()))
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.
End Impl_core_clone_Clone_for_axum_routing_route_Route_t_E.

Module  Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.
Section Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.
  Context {E : Set}.
  
  Definition Self : Set := axum.routing.route.Route.t E.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("Route").finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.
End Impl_core_fmt_Debug_for_axum_routing_route_Route_t_E.

Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.
Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.
  Context {B E : Set}.
  
  Context
    {ℋ_0 : http_body.Body.Trait B}
    {ℋ_1 : core.marker.Send.Trait B}
    {ℋ_2 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}.
  
  Definition Self : Set := axum.routing.route.Route.t E.
  
  (*
      type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      type Error = E;
  *)
  Definition Error : Set := E.
  
  (*
      type Future = RouteFuture<E>;
  *)
  Definition Future : Set := axum.routing.route.RouteFuture.t E.
  
  (*
      fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          Poll::Ready(Ok(()))
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (_cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* _cx := M.alloc _cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, req: Request<B>) -> Self::Future {
          let req = req.map(Body::new);
          RouteFuture::from_future(self.oneshot_inner(req))
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req : ltac:(axum_core.extract.Request B))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request B)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_route_Route_t_E.

Module  RouteFuture.
Section RouteFuture.
  Context (E : Set).
  
  Record t : Set := {
    kind : axum.routing.route.RouteFutureKind.t E;
    strip_body : bool.t;
    allow_header : core.option.Option.t bytes.bytes.Bytes.t;
  }.
  
  Definition Get_kind :=
    Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
  Definition Get_strip_body :=
    Ref.map
      (fun α => Some α.(strip_body))
      (fun β α => Some (α <| strip_body := β |>)).
  Definition Get_allow_header :=
    Ref.map
      (fun α => Some α.(allow_header))
      (fun β α => Some (α <| allow_header := β |>)).
End RouteFuture.
End RouteFuture.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Context (E : Set).
  
  Record t : Set := {
    kind : core.pin.Pin.t (mut_ref (axum.routing.route.RouteFutureKind.t E));
    strip_body : mut_ref bool.t;
    allow_header : mut_ref (core.option.Option.t bytes.bytes.Bytes.t);
  }.
  
  Definition Get_kind :=
    Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
  Definition Get_strip_body :=
    Ref.map
      (fun α => Some α.(strip_body))
      (fun β α => Some (α <| strip_body := β |>)).
  Definition Get_allow_header :=
    Ref.map
      (fun α => Some α.(allow_header))
      (fun β α => Some (α <| allow_header := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Context (E : Set).
  
  Record t : Set := {
    kind : core.pin.Pin.t (ref (axum.routing.route.RouteFutureKind.t E));
    strip_body : ref bool.t;
    allow_header : ref (core.option.Option.t bytes.bytes.Bytes.t);
  }.
  
  Definition Get_kind :=
    Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
  Definition Get_strip_body :=
    Ref.map
      (fun α => Some α.(strip_body))
      (fun β α => Some (α <| strip_body := β |>)).
  Definition Get_allow_header :=
    Ref.map
      (fun α => Some α.(allow_header))
      (fun β α => Some (α <| allow_header := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_routing_route_RouteFuture_t_E_3.
Section Impl_axum_routing_route_RouteFuture_t_E_3.
  Context {E : Set}.
  
  Definition Self : Set := axum.routing.route.RouteFuture.t E.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum.routing.route._.Projection.t E) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M (axum.routing.route._.ProjectionRef.t E) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_routing_route_RouteFuture_t_E_3.
End Impl_axum_routing_route_RouteFuture_t_E_3.

Module  __Origin.
Section __Origin.
  Context (E : Set).
  
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    kind : axum.routing.route.RouteFutureKind.t E;
    strip_body : pin_project_lite.__private.AlwaysUnpin.t bool.t;
    allow_header :
      pin_project_lite.__private.AlwaysUnpin.t
        (core.option.Option.t bytes.bytes.Bytes.t);
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_kind :=
    Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
  Definition Get_strip_body :=
    Ref.map
      (fun α => Some α.(strip_body))
      (fun β α => Some (α <| strip_body := β |>)).
  Definition Get_allow_header :=
    Ref.map
      (fun α => Some α.(allow_header))
      (fun β α => Some (α <| allow_header := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_routing_route_RouteFuture_t_E.
Section Impl_core_marker_Unpin_for_axum_routing_route_RouteFuture_t_E.
  Context {E : Set}.
  
  Context {ℋ_0 : core.marker.Unpin.Trait (axum.routing.route._.__Origin.t E)}.
  
  Definition Self : Set := axum.routing.route.RouteFuture.t E.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_routing_route_RouteFuture_t_E.
End Impl_core_marker_Unpin_for_axum_routing_route_RouteFuture_t_E.

Module  Impl_axum_routing_route___MustNotImplDrop_for_T.
Section Impl_axum_routing_route___MustNotImplDrop_for_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.ops.drop.Drop.Trait T}.
  
  Definition Self : Set := T.
  
  Global Instance ℐ : axum.routing.route._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_routing_route___MustNotImplDrop_for_T.
End Impl_axum_routing_route___MustNotImplDrop_for_T.

Module  Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_RouteFuture_t_E.
Section Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_RouteFuture_t_E.
  Context {E : Set}.
  
  Definition Self : Set := axum.routing.route.RouteFuture.t E.
  
  Global Instance ℐ : axum.routing.route._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_RouteFuture_t_E.
End Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_RouteFuture_t_E.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    {E : Set}
    (this : ref (axum.routing.route.RouteFuture.t E))
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module RouteFutureKind.
  Module Future.
    Record t : Set := {
      future :
        tower.util.oneshot.Oneshot.t
          (tower.util.boxed_clone.BoxCloneService.t
            ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T)
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            E)
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T);
    }.
  End Future.
  
  Module Response.
    Record t : Set := {
      response :
        core.option.Option.t
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T);
    }.
  End Response.
  
  Inductive t (E : Set) : Set :=
  | Future (_ : Future.t)
  | Response (_ : Response.t).
  
  Definition Get_Future_future :=
    Ref.map
      (fun α =>
        match α with | Future α => Some α.(Future.future) | _ => None end)
      (fun β α =>
        match α with
        | Future α => Some (Future (α <| Future.future := β |>))
        | _ => None
        end).
  
  Definition Get_Response_response :=
    Ref.map
      (fun α =>
        match α with | Response α => Some α.(Response.response) | _ => None end)
      (fun β α =>
        match α with
        | Response α => Some (Response (α <| Response.response := β |>))
        | _ => None
        end).
End RouteFutureKind.

Module RouteFutureKindProj.
  Module Future.
    Record t : Set := {
      future :
        core.pin.Pin.t
          (mut_ref
            (tower.util.oneshot.Oneshot.t
              (tower.util.boxed_clone.BoxCloneService.t
                ltac:(axum_core.extract.Request
                  axum_core.extract.Request.Default.T)
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)
                E)
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T)));
    }.
  End Future.
  
  Module Response.
    Record t : Set := {
      response :
        mut_ref
          (core.option.Option.t
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T));
    }.
  End Response.
  
  Inductive t (E : Set) : Set :=
  | Future (_ : Future.t)
  | Response (_ : Response.t).
  
  Definition Get_Future_future :=
    Ref.map
      (fun α =>
        match α with | Future α => Some α.(Future.future) | _ => None end)
      (fun β α =>
        match α with
        | Future α => Some (Future (α <| Future.future := β |>))
        | _ => None
        end).
  
  Definition Get_Response_response :=
    Ref.map
      (fun α =>
        match α with | Response α => Some α.(Response.response) | _ => None end)
      (fun β α =>
        match α with
        | Response α => Some (Response (α <| Response.response := β |>))
        | _ => None
        end).
End RouteFutureKindProj.

Module  Impl_axum_routing_route_RouteFutureKind_t_E.
Section Impl_axum_routing_route_RouteFutureKind_t_E.
  Context {E : Set}.
  
  Definition Self : Set := axum.routing.route.RouteFutureKind.t E.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  match self.$get_method() {
                      $(
                          Self::$variant $({
                              $($field),+
                          })? => {
                              $proj_ty_ident::$variant $({
                                  $(
                                      $field: $crate::__pin_project_make_unsafe_field_proj!(
                                          $(#[$pin])? $field
                                      )
                                  ),+
                              })?
                          }
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum.routing.route.RouteFutureKindProj.t E) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
End Impl_axum_routing_route_RouteFutureKind_t_E.
End Impl_axum_routing_route_RouteFutureKind_t_E.

Module  __Origin.
Section __Origin.
  Context (E : Set).
  
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    Future :
      tower.util.oneshot.Oneshot.t
        (tower.util.boxed_clone.BoxCloneService.t
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T)
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)
          E)
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T);
    Response :
      pin_project_lite.__private.AlwaysUnpin.t
        (core.option.Option.t
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T));
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_Future :=
    Ref.map (fun α => Some α.(Future)) (fun β α => Some (α <| Future := β |>)).
  Definition Get_Response :=
    Ref.map
      (fun α => Some α.(Response))
      (fun β α => Some (α <| Response := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_routing_route_RouteFutureKind_t_E.
Section Impl_core_marker_Unpin_for_axum_routing_route_RouteFutureKind_t_E.
  Context {E : Set}.
  
  Context {ℋ_0 : core.marker.Unpin.Trait (axum.routing.route._.__Origin.t E)}.
  
  Definition Self : Set := axum.routing.route.RouteFutureKind.t E.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_routing_route_RouteFutureKind_t_E.
End Impl_core_marker_Unpin_for_axum_routing_route_RouteFutureKind_t_E.

Module  Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_RouteFutureKind_t_E.
Section Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_RouteFutureKind_t_E.
  Context {E : Set}.
  
  Definition Self : Set := axum.routing.route.RouteFutureKind.t E.
  
  Global Instance ℐ : axum.routing.route._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_RouteFutureKind_t_E.
End Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_RouteFutureKind_t_E.

Module  Impl_axum_routing_route_RouteFuture_t_E_4.
Section Impl_axum_routing_route_RouteFuture_t_E_4.
  Context {E : Set}.
  
  Definition Self : Set := axum.routing.route.RouteFuture.t E.
  
  (*
      pub(crate) fn from_future(
          future: Oneshot<BoxCloneService<Request, Response, E>, Request>,
      ) -> Self {
          Self {
              kind: RouteFutureKind::Future { future },
              strip_body: false,
              allow_header: None,
          }
      }
  *)
  Definition from_future
      (future
        :
        tower.util.oneshot.Oneshot.t
          (tower.util.boxed_clone.BoxCloneService.t
            ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T)
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)
            E)
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      : M Self :=
    let* future := M.alloc future in
    M.read foo.
  
  Global Instance AssociatedFunction_from_future :
    Notations.DoubleColon Self "from_future" := {
    Notations.double_colon := from_future;
  }.
  
  (*
      pub(crate) fn strip_body(mut self, strip_body: bool) -> Self {
          self.strip_body = strip_body;
          self
      }
  *)
  Definition strip_body (self : Self) (strip_body : bool.t) : M Self :=
    let* self := M.alloc self in
    let* strip_body := M.alloc strip_body in
    M.read foo.
  
  Global Instance AssociatedFunction_strip_body :
    Notations.DoubleColon Self "strip_body" := {
    Notations.double_colon := strip_body;
  }.
  
  (*
      pub(crate) fn allow_header(mut self, allow_header: Bytes) -> Self {
          self.allow_header = Some(allow_header);
          self
      }
  *)
  Definition allow_header
      (self : Self)
      (allow_header : bytes.bytes.Bytes.t)
      : M Self :=
    let* self := M.alloc self in
    let* allow_header := M.alloc allow_header in
    M.read foo.
  
  Global Instance AssociatedFunction_allow_header :
    Notations.DoubleColon Self "allow_header" := {
    Notations.double_colon := allow_header;
  }.
End Impl_axum_routing_route_RouteFuture_t_E_4.
End Impl_axum_routing_route_RouteFuture_t_E_4.

Module  Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.
Section Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.
  Context {E : Set}.
  
  Definition Self : Set := axum.routing.route.RouteFuture.t E.
  
  (*
      type Output = Result<Response, E>;
  *)
  Definition Output : Set :=
    core.result.Result.t
        ltac:(axum_core.response.Response axum_core.response.Response.Default.T)
        E.
  
  (*
      fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
          let this = self.project();
  
          let mut res = match this.kind.project() {
              RouteFutureKindProj::Future { future } => match future.poll(cx) {
                  Poll::Ready(Ok(res)) => res,
                  Poll::Ready(Err(err)) => return Poll::Ready(Err(err)),
                  Poll::Pending => return Poll::Pending,
              },
              RouteFutureKindProj::Response { response } => {
                  response.take().expect("future polled after completion")
              }
          };
  
          set_allow_header(res.headers_mut(), this.allow_header);
  
          // make sure to set content-length before removing the body
          set_content_length(res.size_hint(), res.headers_mut());
  
          let res = if *this.strip_body {
              res.map(|_| Body::empty())
          } else {
              res
          };
  
          Poll::Ready(Ok(res))
      }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.
End Impl_core_future_future_Future_for_axum_routing_route_RouteFuture_t_E.

(*
fn set_allow_header(headers: &mut HeaderMap, allow_header: &mut Option<Bytes>) {
    match allow_header.take() {
        Some(allow_header) if !headers.contains_key(header::ALLOW) => {
            headers.insert(
                header::ALLOW,
                HeaderValue::from_maybe_shared(allow_header).expect("invalid `Allow` header"),
            );
        }
        _ => {}
    }
}
*)
Definition set_allow_header
    (headers
      :
      mut_ref (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
    (allow_header : mut_ref (core.option.Option.t bytes.bytes.Bytes.t))
    : M unit :=
  let* headers := M.alloc headers in
  let* allow_header := M.alloc allow_header in
  M.read foo.

(*
fn set_content_length(size_hint: http_body::SizeHint, headers: &mut HeaderMap) {
    if headers.contains_key(CONTENT_LENGTH) {
        return;
    }

    if let Some(size) = size_hint.exact() {
        let header_value = if size == 0 {
            #[allow(clippy::declare_interior_mutable_const)]
            const ZERO: HeaderValue = HeaderValue::from_static("0");

            ZERO
        } else {
            let mut buffer = itoa::Buffer::new();
            HeaderValue::from_str(buffer.format(size)).unwrap()
        };

        headers.insert(CONTENT_LENGTH, header_value);
    }
}
*)
Definition set_content_length
    (size_hint : http_body.size_hint.SizeHint.t)
    (headers
      :
      mut_ref (http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T))
    : M unit :=
  let* size_hint := M.alloc size_hint in
  let* headers := M.alloc headers in
  M.read foo.

Definition ZERO : M.Val http.header.value.HeaderValue.t := M.run (M.pure foo).

Module  InfallibleRouteFuture.
Section InfallibleRouteFuture.
  Record t : Set := {
    future : axum.routing.route.RouteFuture.t core.convert.Infallible.t;
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End InfallibleRouteFuture.
End InfallibleRouteFuture.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Record t : Set := {
    future :
      core.pin.Pin.t
        (mut_ref (axum.routing.route.RouteFuture.t core.convert.Infallible.t));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Record t : Set := {
    future :
      core.pin.Pin.t
        (ref (axum.routing.route.RouteFuture.t core.convert.Infallible.t));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_routing_route_InfallibleRouteFuture_t_3.
Section Impl_axum_routing_route_InfallibleRouteFuture_t_3.
  Definition Self : Set := axum.routing.route.InfallibleRouteFuture.t.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M axum.routing.route._.Projection.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M axum.routing.route._.ProjectionRef.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_routing_route_InfallibleRouteFuture_t_3.
End Impl_axum_routing_route_InfallibleRouteFuture_t_3.

Module  __Origin.
Section __Origin.
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    future : axum.routing.route.RouteFuture.t core.convert.Infallible.t;
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_routing_route_InfallibleRouteFuture_t.
Section Impl_core_marker_Unpin_for_axum_routing_route_InfallibleRouteFuture_t.
  Context {ℋ_0 : core.marker.Unpin.Trait axum.routing.route._.__Origin.t}.
  
  Definition Self : Set := axum.routing.route.InfallibleRouteFuture.t.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_routing_route_InfallibleRouteFuture_t.
End Impl_core_marker_Unpin_for_axum_routing_route_InfallibleRouteFuture_t.

Module  Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_InfallibleRouteFuture_t.
Section Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_InfallibleRouteFuture_t.
  Definition Self : Set := axum.routing.route.InfallibleRouteFuture.t.
  
  Global Instance ℐ : axum.routing.route._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_InfallibleRouteFuture_t.
End Impl_axum_routing_route___MustNotImplDrop_for_axum_routing_route_InfallibleRouteFuture_t.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    (this : ref axum.routing.route.InfallibleRouteFuture.t)
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module  Impl_axum_routing_route_InfallibleRouteFuture_t_4.
Section Impl_axum_routing_route_InfallibleRouteFuture_t_4.
  Definition Self : Set := axum.routing.route.InfallibleRouteFuture.t.
  
  (*
      pub(crate) fn new(future: RouteFuture<Infallible>) -> Self {
          Self { future }
      }
  *)
  Definition new
      (future : axum.routing.route.RouteFuture.t core.convert.Infallible.t)
      : M Self :=
    let* future := M.alloc future in
    M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
End Impl_axum_routing_route_InfallibleRouteFuture_t_4.
End Impl_axum_routing_route_InfallibleRouteFuture_t_4.

Module  Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.
Section Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.
  Definition Self : Set := axum.routing.route.InfallibleRouteFuture.t.
  
  (*
      type Output = Response;
  *)
  Definition Output : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
          match futures_util::ready!(self.project().future.poll(cx)) {
              Ok(response) => Poll::Ready(response),
              Err(err) => match err {},
          }
      }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.
End Impl_core_future_future_Future_for_axum_routing_route_InfallibleRouteFuture_t.

Module strip_prefix.
  Module  StripPrefix.
  Section StripPrefix.
    Context (S : Set).
    
    Record t : Set := {
      inner : S;
      prefix : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Definition Get_prefix :=
      Ref.map
        (fun α => Some α.(prefix))
        (fun β α => Some (α <| prefix := β |>)).
  End StripPrefix.
  End StripPrefix.
  
  Module  Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.
  Section Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.routing.strip_prefix.StripPrefix.t S.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum.routing.strip_prefix.StripPrefix.t S) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.
  End Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.
  
  Module  Impl_axum_routing_strip_prefix_StripPrefix_t_S_2.
  Section Impl_axum_routing_strip_prefix_StripPrefix_t_S_2.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.strip_prefix.StripPrefix.t S.
    
    (*
        pub(super) fn layer(prefix: &str) -> impl Layer<S, Service = Self> + Clone {
            let prefix = Arc::from(prefix);
            layer_fn(move |inner| Self {
                inner,
                prefix: Arc::clone(&prefix),
            })
        }
    *)
    Definition layer (prefix : ref str.t) : M _ (* OpaqueTy *) :=
      let* prefix := M.alloc prefix in
      M.read foo.
    
    Global Instance AssociatedFunction_layer :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer;
    }.
  End Impl_axum_routing_strip_prefix_StripPrefix_t_S_2.
  End Impl_axum_routing_strip_prefix_StripPrefix_t_S_2.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.
    Context {S B : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}.
    
    Definition Self : Set := axum.routing.strip_prefix.StripPrefix.t S.
    
    (*
        type Response = S::Response;
    *)
    Definition Response : Set := S::type["Response"].t.
    
    (*
        type Error = S::Error;
    *)
    Definition Error : Set := S::type["Error"].t.
    
    (*
        type Future = S::Future;
    *)
    Definition Future : Set := S::type["Future"].t.
    
    (*
        fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            self.inner.poll_ready(cx)
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, mut req: Request<B>) -> Self::Future {
            if let Some(new_uri) = strip_prefix(req.uri(), &self.prefix) {
                *req.uri_mut() = new_uri;
            }
            self.inner.call(req)
        }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.
  
  (*
  fn strip_prefix(uri: &Uri, prefix: &str) -> Option<Uri> {
      let path_and_query = uri.path_and_query()?;
  
      // Check whether the prefix matches the path and if so how long the matching prefix is.
      //
      // For example:
      //
      // prefix = /api
      // path   = /api/users
      //          ^^^^ this much is matched and the length is 4. Thus if we chop off the first 4
      //          characters we get the remainder
      //
      // prefix = /api/:version
      // path   = /api/v0/users
      //          ^^^^^^^ this much is matched and the length is 7.
      let mut matching_prefix_length = Some(0);
      for item in zip_longest(segments(path_and_query.path()), segments(prefix)) {
          // count the `/`
          *matching_prefix_length.as_mut().unwrap() += 1;
  
          match item {
              Item::Both(path_segment, prefix_segment) => {
                  if prefix_segment.starts_with(':') || path_segment == prefix_segment {
                      // the prefix segment is either a param, which matches anything, or
                      // it actually matches the path segment
                      *matching_prefix_length.as_mut().unwrap() += path_segment.len();
                  } else if prefix_segment.is_empty() {
                      // the prefix ended in a `/` so we got a match.
                      //
                      // For example:
                      //
                      // prefix = /foo/
                      // path   = /foo/bar
                      //
                      // The prefix matches and the new path should be `/bar`
                      break;
                  } else {
                      // the prefix segment didn't match so there is no match
                      matching_prefix_length = None;
                      break;
                  }
              }
              // the path had more segments than the prefix but we got a match.
              //
              // For example:
              //
              // prefix = /foo
              // path   = /foo/bar
              Item::First(_) => {
                  break;
              }
              // the prefix had more segments than the path so there is no match
              Item::Second(_) => {
                  matching_prefix_length = None;
                  break;
              }
          }
      }
  
      // if the prefix matches it will always do so up until a `/`, it cannot match only
      // part of a segment. Therefore this will always be at a char boundary and `split_at` wont
      // panic
      let after_prefix = uri.path().split_at(matching_prefix_length?).1;
  
      let new_path_and_query = match (after_prefix.starts_with('/'), path_and_query.query()) {
          (true, None) => after_prefix.parse().unwrap(),
          (true, Some(query)) => format!("{after_prefix}?{query}").parse().unwrap(),
          (false, None) => format!("/{after_prefix}").parse().unwrap(),
          (false, Some(query)) => format!("/{after_prefix}?{query}").parse().unwrap(),
      };
  
      let mut parts = uri.clone().into_parts();
      parts.path_and_query = Some(new_path_and_query);
  
      Some(Uri::from_parts(parts).unwrap())
  }
  *)
  Definition strip_prefix
      (uri : ref http.uri.Uri.t)
      (prefix : ref str.t)
      : M (core.option.Option.t http.uri.Uri.t) :=
    let* uri := M.alloc uri in
    let* prefix := M.alloc prefix in
    M.read foo.
  
  (*
  fn segments(s: &str) -> impl Iterator<Item = &str> {
      assert!(
          s.starts_with('/'),
          "path didn't start with '/'. axum should have caught this higher up."
      );
  
      s.split('/')
          // skip one because paths always start with `/` so `/a/b` would become ["", "a", "b"]
          // otherwise
          .skip(1)
  }
  *)
  Definition segments (s : ref str.t) : M OpaqueDef :=
    let* s := M.alloc s in
    M.read foo.
  
  (*
  fn zip_longest<I, I2>(a: I, b: I2) -> impl Iterator<Item = Item<I::Item>>
  where
      I: Iterator,
      I2: Iterator<Item = I::Item>,
  {
      let a = a.map(Some).chain(std::iter::repeat_with(|| None));
      let b = b.map(Some).chain(std::iter::repeat_with(|| None));
      a.zip(b).map_while(|(a, b)| match (a, b) {
          (Some(a), Some(b)) => Some(Item::Both(a, b)),
          (Some(a), None) => Some(Item::First(a)),
          (None, Some(b)) => Some(Item::Second(b)),
          (None, None) => None,
      })
  }
  *)
  Definition zip_longest
      {I I2 : Set}
      {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}
      {ℋ_1 : core.iter.traits.iterator.Iterator.Trait I2}
      (a : I)
      (b : I2)
      : M _ (* OpaqueTy *) :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    M.read foo.
  
  Module Item.
    Inductive t (T : Set) : Set :=
    | Both (_ : T) (_ : T)
    | First (_ : T)
    | Second (_ : T).
    
    Definition Get_Both_0 :=
      Ref.map
        (fun α => match α with | Both α0 _ => Some α0 | _ => None end)
        (fun β α =>
          match α with | Both _ α1 => Some (Both β α1) | _ => None end).
    
    Definition Get_Both_1 :=
      Ref.map
        (fun α => match α with | Both _ α1 => Some α1 | _ => None end)
        (fun β α =>
          match α with | Both α0 _ => Some (Both α0 β) | _ => None end).
    
    Definition Get_First_0 :=
      Ref.map
        (fun α => match α with | First α0 => Some α0 | _ => None end)
        (fun β α => match α with | First _ => Some (First β) | _ => None end).
    
    Definition Get_Second_0 :=
      Ref.map
        (fun α => match α with | Second α0 => Some α0 | _ => None end)
        (fun β α => match α with | Second _ => Some (Second β) | _ => None end).
  End Item.
  
  Module  Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.
  Section Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum.routing.strip_prefix.Item.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.
  End Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.
End strip_prefix.

Module  StripPrefix.
Section StripPrefix.
  Context (S : Set).
  
  Record t : Set := {
    inner : S;
    prefix : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Definition Get_prefix :=
    Ref.map (fun α => Some α.(prefix)) (fun β α => Some (α <| prefix := β |>)).
End StripPrefix.
End StripPrefix.

Module  Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.
Section Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.routing.strip_prefix.StripPrefix.t S.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum.routing.strip_prefix.StripPrefix.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.
End Impl_core_clone_Clone_for_axum_routing_strip_prefix_StripPrefix_t_S.

Module  Impl_axum_routing_strip_prefix_StripPrefix_t_S_3.
Section Impl_axum_routing_strip_prefix_StripPrefix_t_S_3.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.strip_prefix.StripPrefix.t S.
  
  (*
      pub(super) fn layer(prefix: &str) -> impl Layer<S, Service = Self> + Clone {
          let prefix = Arc::from(prefix);
          layer_fn(move |inner| Self {
              inner,
              prefix: Arc::clone(&prefix),
          })
      }
  *)
  Definition layer (prefix : ref str.t) : M _ (* OpaqueTy *) :=
    let* prefix := M.alloc prefix in
    M.read foo.
  
  Global Instance AssociatedFunction_layer :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer;
  }.
End Impl_axum_routing_strip_prefix_StripPrefix_t_S_3.
End Impl_axum_routing_strip_prefix_StripPrefix_t_S_3.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.
  Context {S B : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}.
  
  Definition Self : Set := axum.routing.strip_prefix.StripPrefix.t S.
  
  (*
      type Response = S::Response;
  *)
  Definition Response : Set := S::type["Response"].t.
  
  (*
      type Error = S::Error;
  *)
  Definition Error : Set := S::type["Error"].t.
  
  (*
      type Future = S::Future;
  *)
  Definition Future : Set := S::type["Future"].t.
  
  (*
      fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          self.inner.poll_ready(cx)
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, mut req: Request<B>) -> Self::Future {
          if let Some(new_uri) = strip_prefix(req.uri(), &self.prefix) {
              *req.uri_mut() = new_uri;
          }
          self.inner.call(req)
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_routing_strip_prefix_StripPrefix_t_S.

(*
fn strip_prefix(uri: &Uri, prefix: &str) -> Option<Uri> {
    let path_and_query = uri.path_and_query()?;

    // Check whether the prefix matches the path and if so how long the matching prefix is.
    //
    // For example:
    //
    // prefix = /api
    // path   = /api/users
    //          ^^^^ this much is matched and the length is 4. Thus if we chop off the first 4
    //          characters we get the remainder
    //
    // prefix = /api/:version
    // path   = /api/v0/users
    //          ^^^^^^^ this much is matched and the length is 7.
    let mut matching_prefix_length = Some(0);
    for item in zip_longest(segments(path_and_query.path()), segments(prefix)) {
        // count the `/`
        *matching_prefix_length.as_mut().unwrap() += 1;

        match item {
            Item::Both(path_segment, prefix_segment) => {
                if prefix_segment.starts_with(':') || path_segment == prefix_segment {
                    // the prefix segment is either a param, which matches anything, or
                    // it actually matches the path segment
                    *matching_prefix_length.as_mut().unwrap() += path_segment.len();
                } else if prefix_segment.is_empty() {
                    // the prefix ended in a `/` so we got a match.
                    //
                    // For example:
                    //
                    // prefix = /foo/
                    // path   = /foo/bar
                    //
                    // The prefix matches and the new path should be `/bar`
                    break;
                } else {
                    // the prefix segment didn't match so there is no match
                    matching_prefix_length = None;
                    break;
                }
            }
            // the path had more segments than the prefix but we got a match.
            //
            // For example:
            //
            // prefix = /foo
            // path   = /foo/bar
            Item::First(_) => {
                break;
            }
            // the prefix had more segments than the path so there is no match
            Item::Second(_) => {
                matching_prefix_length = None;
                break;
            }
        }
    }

    // if the prefix matches it will always do so up until a `/`, it cannot match only
    // part of a segment. Therefore this will always be at a char boundary and `split_at` wont
    // panic
    let after_prefix = uri.path().split_at(matching_prefix_length?).1;

    let new_path_and_query = match (after_prefix.starts_with('/'), path_and_query.query()) {
        (true, None) => after_prefix.parse().unwrap(),
        (true, Some(query)) => format!("{after_prefix}?{query}").parse().unwrap(),
        (false, None) => format!("/{after_prefix}").parse().unwrap(),
        (false, Some(query)) => format!("/{after_prefix}?{query}").parse().unwrap(),
    };

    let mut parts = uri.clone().into_parts();
    parts.path_and_query = Some(new_path_and_query);

    Some(Uri::from_parts(parts).unwrap())
}
*)
Definition strip_prefix
    (uri : ref http.uri.Uri.t)
    (prefix : ref str.t)
    : M (core.option.Option.t http.uri.Uri.t) :=
  let* uri := M.alloc uri in
  let* prefix := M.alloc prefix in
  M.read foo.

(*
fn segments(s: &str) -> impl Iterator<Item = &str> {
    assert!(
        s.starts_with('/'),
        "path didn't start with '/'. axum should have caught this higher up."
    );

    s.split('/')
        // skip one because paths always start with `/` so `/a/b` would become ["", "a", "b"]
        // otherwise
        .skip(1)
}
*)
Definition segments (s : ref str.t) : M OpaqueDef :=
  let* s := M.alloc s in
  M.read foo.

(*
fn zip_longest<I, I2>(a: I, b: I2) -> impl Iterator<Item = Item<I::Item>>
where
    I: Iterator,
    I2: Iterator<Item = I::Item>,
{
    let a = a.map(Some).chain(std::iter::repeat_with(|| None));
    let b = b.map(Some).chain(std::iter::repeat_with(|| None));
    a.zip(b).map_while(|(a, b)| match (a, b) {
        (Some(a), Some(b)) => Some(Item::Both(a, b)),
        (Some(a), None) => Some(Item::First(a)),
        (None, Some(b)) => Some(Item::Second(b)),
        (None, None) => None,
    })
}
*)
Definition zip_longest
    {I I2 : Set}
    {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}
    {ℋ_1 : core.iter.traits.iterator.Iterator.Trait I2}
    (a : I)
    (b : I2)
    : M _ (* OpaqueTy *) :=
  let* a := M.alloc a in
  let* b := M.alloc b in
  M.read foo.

Module Item.
  Inductive t (T : Set) : Set :=
  | Both (_ : T) (_ : T)
  | First (_ : T)
  | Second (_ : T).
  
  Definition Get_Both_0 :=
    Ref.map
      (fun α => match α with | Both α0 _ => Some α0 | _ => None end)
      (fun β α => match α with | Both _ α1 => Some (Both β α1) | _ => None end).
  
  Definition Get_Both_1 :=
    Ref.map
      (fun α => match α with | Both _ α1 => Some α1 | _ => None end)
      (fun β α => match α with | Both α0 _ => Some (Both α0 β) | _ => None end).
  
  Definition Get_First_0 :=
    Ref.map
      (fun α => match α with | First α0 => Some α0 | _ => None end)
      (fun β α => match α with | First _ => Some (First β) | _ => None end).
  
  Definition Get_Second_0 :=
    Ref.map
      (fun α => match α with | Second α0 => Some α0 | _ => None end)
      (fun β α => match α with | Second _ => Some (Second β) | _ => None end).
End Item.

Module  Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.
Section Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum.routing.strip_prefix.Item.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.
End Impl_core_fmt_Debug_for_axum_routing_strip_prefix_Item_t_T.

Module url_params.
  Module UrlParams.
    Module InvalidUtf8InPathParam.
      Record t : Set := {
        key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
      }.
    End InvalidUtf8InPathParam.
    
    Inductive t : Set :=
    |
      Params
      (_ :
        alloc.vec.Vec.t
          ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
          *
          axum.util.PercentDecodedStr.t)
          alloc.vec.Vec.Default.A)
    | InvalidUtf8InPathParam (_ : InvalidUtf8InPathParam.t).
    
    Definition Get_Params_0 :=
      Ref.map
        (fun α => match α with | Params α0 => Some α0 | _ => None end)
        (fun β α => match α with | Params _ => Some (Params β) | _ => None end).
    
    Definition Get_InvalidUtf8InPathParam_key :=
      Ref.map
        (fun α =>
          match α with
          | InvalidUtf8InPathParam α => Some α.(InvalidUtf8InPathParam.key)
          | _ => None
          end)
        (fun β α =>
          match α with
          | InvalidUtf8InPathParam α =>
            Some
              (InvalidUtf8InPathParam (α <| InvalidUtf8InPathParam.key := β |>))
          | _ => None
          end).
  End UrlParams.
  
  Module  Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.
  Section Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.
    Definition Self : Set := axum.routing.url_params.UrlParams.t.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M axum.routing.url_params.UrlParams.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.
  End Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.
  
  (*
  pub(super) fn insert_url_params(extensions: &mut Extensions, params: Params) {
      let current_params = extensions.get_mut();
  
      if let Some(UrlParams::InvalidUtf8InPathParam { .. }) = current_params {
          // nothing to do here since an error was stored earlier
          return;
      }
  
      let params = params
          .iter()
          .filter(|(key, _)| !key.starts_with(super::NEST_TAIL_PARAM))
          .filter(|(key, _)| !key.starts_with(super::FALLBACK_PARAM))
          .map(|(k, v)| {
              if let Some(decoded) = PercentDecodedStr::new(v) {
                  Ok((Arc::from(k), decoded))
              } else {
                  Err(Arc::from(k))
              }
          })
          .collect::<Result<Vec<_>, _>>();
  
      match (current_params, params) {
          (Some(UrlParams::InvalidUtf8InPathParam { .. }), _) => {
              unreachable!("we check for this state earlier in this method")
          }
          (_, Err(invalid_key)) => {
              extensions.insert(UrlParams::InvalidUtf8InPathParam { key: invalid_key });
          }
          (Some(UrlParams::Params(current)), Ok(params)) => {
              current.extend(params);
          }
          (None, Ok(params)) => {
              extensions.insert(UrlParams::Params(params));
          }
      }
  }
  *)
  Definition insert_url_params
      (extensions : mut_ref http.extensions.Extensions.t)
      (params : matchit.params.Params.t)
      : M unit :=
    let* extensions := M.alloc extensions in
    let* params := M.alloc params in
    M.read foo.
End url_params.

Module UrlParams.
  Module InvalidUtf8InPathParam.
    Record t : Set := {
      key : alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A;
    }.
  End InvalidUtf8InPathParam.
  
  Inductive t : Set :=
  |
    Params
    (_ :
      alloc.vec.Vec.t
        ((alloc.sync.Arc.t str.t alloc.sync.Arc.Default.A)
        *
        axum.util.PercentDecodedStr.t)
        alloc.vec.Vec.Default.A)
  | InvalidUtf8InPathParam (_ : InvalidUtf8InPathParam.t).
  
  Definition Get_Params_0 :=
    Ref.map
      (fun α => match α with | Params α0 => Some α0 | _ => None end)
      (fun β α => match α with | Params _ => Some (Params β) | _ => None end).
  
  Definition Get_InvalidUtf8InPathParam_key :=
    Ref.map
      (fun α =>
        match α with
        | InvalidUtf8InPathParam α => Some α.(InvalidUtf8InPathParam.key)
        | _ => None
        end)
      (fun β α =>
        match α with
        | InvalidUtf8InPathParam α =>
          Some
            (InvalidUtf8InPathParam (α <| InvalidUtf8InPathParam.key := β |>))
        | _ => None
        end).
End UrlParams.

Module  Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.
Section Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.
  Definition Self : Set := axum.routing.url_params.UrlParams.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.routing.url_params.UrlParams.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.
End Impl_core_clone_Clone_for_axum_routing_url_params_UrlParams_t.

(*
pub(super) fn insert_url_params(extensions: &mut Extensions, params: Params) {
    let current_params = extensions.get_mut();

    if let Some(UrlParams::InvalidUtf8InPathParam { .. }) = current_params {
        // nothing to do here since an error was stored earlier
        return;
    }

    let params = params
        .iter()
        .filter(|(key, _)| !key.starts_with(super::NEST_TAIL_PARAM))
        .filter(|(key, _)| !key.starts_with(super::FALLBACK_PARAM))
        .map(|(k, v)| {
            if let Some(decoded) = PercentDecodedStr::new(v) {
                Ok((Arc::from(k), decoded))
            } else {
                Err(Arc::from(k))
            }
        })
        .collect::<Result<Vec<_>, _>>();

    match (current_params, params) {
        (Some(UrlParams::InvalidUtf8InPathParam { .. }), _) => {
            unreachable!("we check for this state earlier in this method")
        }
        (_, Err(invalid_key)) => {
            extensions.insert(UrlParams::InvalidUtf8InPathParam { key: invalid_key });
        }
        (Some(UrlParams::Params(current)), Ok(params)) => {
            current.extend(params);
        }
        (None, Ok(params)) => {
            extensions.insert(UrlParams::Params(params));
        }
    }
}
*)
Definition insert_url_params
    (extensions : mut_ref http.extensions.Extensions.t)
    (params : matchit.params.Params.t)
    : M unit :=
  let* extensions := M.alloc extensions in
  let* params := M.alloc params in
  M.read foo.

Module  RouteId.
Section RouteId.
  Record t : Set := {
    x0 : u32.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End RouteId.
End RouteId.

Module  Impl_core_clone_Clone_for_axum_routing_RouteId_t.
Section Impl_core_clone_Clone_for_axum_routing_RouteId_t.
  Definition Self : Set := axum.routing.RouteId.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum.routing.RouteId.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_RouteId_t.
End Impl_core_clone_Clone_for_axum_routing_RouteId_t.

Module  Impl_core_marker_Copy_for_axum_routing_RouteId_t.
Section Impl_core_marker_Copy_for_axum_routing_RouteId_t.
  Definition Self : Set := axum.routing.RouteId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_routing_RouteId_t.
End Impl_core_marker_Copy_for_axum_routing_RouteId_t.

Module  Impl_core_fmt_Debug_for_axum_routing_RouteId_t.
Section Impl_core_fmt_Debug_for_axum_routing_RouteId_t.
  Definition Self : Set := axum.routing.RouteId.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_RouteId_t.
End Impl_core_fmt_Debug_for_axum_routing_RouteId_t.

Module  Impl_core_marker_StructuralPartialEq_for_axum_routing_RouteId_t.
Section Impl_core_marker_StructuralPartialEq_for_axum_routing_RouteId_t.
  Definition Self : Set := axum.routing.RouteId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_axum_routing_RouteId_t.
End Impl_core_marker_StructuralPartialEq_for_axum_routing_RouteId_t.

Module  Impl_core_cmp_PartialEq_for_axum_routing_RouteId_t.
Section Impl_core_cmp_PartialEq_for_axum_routing_RouteId_t.
  Definition Self : Set := axum.routing.RouteId.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref axum.routing.RouteId.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_routing_RouteId_t.
End Impl_core_cmp_PartialEq_for_axum_routing_RouteId_t.

Module  Impl_core_marker_StructuralEq_for_axum_routing_RouteId_t.
Section Impl_core_marker_StructuralEq_for_axum_routing_RouteId_t.
  Definition Self : Set := axum.routing.RouteId.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_axum_routing_RouteId_t.
End Impl_core_marker_StructuralEq_for_axum_routing_RouteId_t.

Module  Impl_core_cmp_Eq_for_axum_routing_RouteId_t.
Section Impl_core_cmp_Eq_for_axum_routing_RouteId_t.
  Definition Self : Set := axum.routing.RouteId.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_axum_routing_RouteId_t.
End Impl_core_cmp_Eq_for_axum_routing_RouteId_t.

Module  Impl_core_cmp_PartialOrd_for_axum_routing_RouteId_t.
Section Impl_core_cmp_PartialOrd_for_axum_routing_RouteId_t.
  Definition Self : Set := axum.routing.RouteId.t.
  
  (*
  PartialOrd
  *)
  Definition partial_cmp
      (self : ref Self)
      (other : ref axum.routing.RouteId.t)
      : M (core.option.Option.t core.cmp.Ordering.t) :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_partial_cmp :
    Notations.DoubleColon Self "partial_cmp" := {
    Notations.double_colon := partial_cmp;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialOrd.Required.Trait Self
      (Rhs := core.cmp.PartialOrd.Default.Rhs Self) := {
    core.cmp.PartialOrd.partial_cmp := partial_cmp;
    core.cmp.PartialOrd.lt := Datatypes.None;
    core.cmp.PartialOrd.le := Datatypes.None;
    core.cmp.PartialOrd.gt := Datatypes.None;
    core.cmp.PartialOrd.ge := Datatypes.None;
  }.
End Impl_core_cmp_PartialOrd_for_axum_routing_RouteId_t.
End Impl_core_cmp_PartialOrd_for_axum_routing_RouteId_t.

Module  Impl_core_cmp_Ord_for_axum_routing_RouteId_t.
Section Impl_core_cmp_Ord_for_axum_routing_RouteId_t.
  Definition Self : Set := axum.routing.RouteId.t.
  
  (*
  Ord
  *)
  Definition cmp
      (self : ref Self)
      (other : ref axum.routing.RouteId.t)
      : M core.cmp.Ordering.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_cmp : Notations.DoubleColon Self "cmp" := {
    Notations.double_colon := cmp;
  }.
  
  Global Instance ℐ : core.cmp.Ord.Required.Trait Self := {
    core.cmp.Ord.cmp := cmp;
    core.cmp.Ord.max := Datatypes.None;
    core.cmp.Ord.min := Datatypes.None;
    core.cmp.Ord.clamp := Datatypes.None;
  }.
End Impl_core_cmp_Ord_for_axum_routing_RouteId_t.
End Impl_core_cmp_Ord_for_axum_routing_RouteId_t.

Module  Impl_core_hash_Hash_for_axum_routing_RouteId_t.
Section Impl_core_hash_Hash_for_axum_routing_RouteId_t.
  Definition Self : Set := axum.routing.RouteId.t.
  
  (*
  Hash
  *)
  Definition hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H}
      (self : ref Self)
      (state : mut_ref __H)
      : M unit :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
      hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_axum_routing_RouteId_t.
End Impl_core_hash_Hash_for_axum_routing_RouteId_t.

Module  Router.
Section Router.
  Context (S : Set).
  
  Record t : Set := {
    inner :
      alloc.sync.Arc.t (axum.routing.RouterInner.t S) alloc.sync.Arc.Default.A;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Module Default.
    Definition S := unit.
  End Default.
End Router.
End Router.

Module  Impl_core_clone_Clone_for_axum_routing_Router_t_S.
Section Impl_core_clone_Clone_for_axum_routing_Router_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.Router.t S.
  
  (*
      fn clone(&self) -> Self {
          Self {
              inner: Arc::clone(&self.inner),
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_Router_t_S.
End Impl_core_clone_Clone_for_axum_routing_Router_t_S.

Module  RouterInner.
Section RouterInner.
  Context (S : Set).
  
  Record t : Set := {
    path_router : axum.routing.path_router.PathRouter.t S;
    fallback_router : axum.routing.path_router.PathRouter.t S;
    default_fallback : bool.t;
    catch_all_fallback :
      axum.routing.Fallback.t S axum.routing.Fallback.Default.E;
  }.
  
  Definition Get_path_router :=
    Ref.map
      (fun α => Some α.(path_router))
      (fun β α => Some (α <| path_router := β |>)).
  Definition Get_fallback_router :=
    Ref.map
      (fun α => Some α.(fallback_router))
      (fun β α => Some (α <| fallback_router := β |>)).
  Definition Get_default_fallback :=
    Ref.map
      (fun α => Some α.(default_fallback))
      (fun β α => Some (α <| default_fallback := β |>)).
  Definition Get_catch_all_fallback :=
    Ref.map
      (fun α => Some α.(catch_all_fallback))
      (fun β α => Some (α <| catch_all_fallback := β |>)).
End RouterInner.
End RouterInner.

Module  Impl_core_default_Default_for_axum_routing_Router_t_S.
Section Impl_core_default_Default_for_axum_routing_Router_t_S.
  Context {S : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait S}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.routing.Router.t S.
  
  (*
      fn default() -> Self {
          Self::new()
      }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_routing_Router_t_S.
End Impl_core_default_Default_for_axum_routing_Router_t_S.

Module  Impl_core_fmt_Debug_for_axum_routing_Router_t_S.
Section Impl_core_fmt_Debug_for_axum_routing_Router_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.Router.t S.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("Router")
              .field("path_router", &self.inner.path_router)
              .field("fallback_router", &self.inner.fallback_router)
              .field("default_fallback", &self.inner.default_fallback)
              .field("catch_all_fallback", &self.inner.catch_all_fallback)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_Router_t_S.
End Impl_core_fmt_Debug_for_axum_routing_Router_t_S.

Definition NEST_TAIL_PARAM : M.Val (ref str.t) := M.run (M.pure foo).

Definition NEST_TAIL_PARAM_CAPTURE : M.Val (ref str.t) := M.run (M.pure foo).

Definition FALLBACK_PARAM : M.Val (ref str.t) := M.run (M.pure foo).

Definition FALLBACK_PARAM_PATH : M.Val (ref str.t) := M.run (M.pure foo).

Module  Impl_axum_routing_Router_t_S_2.
Section Impl_axum_routing_Router_t_S_2.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.Router.t S.
  
  (*
      pub fn new() -> Self {
          Self {
              inner: Arc::new(RouterInner {
                  path_router: Default::default(),
                  fallback_router: PathRouter::new_fallback(),
                  default_fallback: true,
                  catch_all_fallback: Fallback::Default(Route::new(NotFound)),
              }),
          }
      }
  *)
  Definition new : M Self := M.read foo.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      fn map_inner<F, S2>(self, f: F) -> Router<S2>
      where
          F: FnOnce(RouterInner<S>) -> RouterInner<S2>,
      {
          Router {
              inner: Arc::new(f(self.into_inner())),
          }
      }
  *)
  Definition map_inner
      {F S2 : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F (Args := axum.routing.RouterInner.t S)}
      (self : Self)
      (f : F)
      : M (axum.routing.Router.t S2) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_map_inner
      {F S2 : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := axum.routing.RouterInner.t S)} :
    Notations.DoubleColon Self "map_inner" := {
    Notations.double_colon := map_inner (F := F) (S2 := S2);
  }.
  
  (*
      fn tap_inner_mut<F>(self, f: F) -> Self
      where
          F: FnOnce(&mut RouterInner<S>),
      {
          let mut inner = self.into_inner();
          f(&mut inner);
          Router {
              inner: Arc::new(inner),
          }
      }
  *)
  Definition tap_inner_mut
      {F : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := mut_ref (axum.routing.RouterInner.t S))}
      (self : Self)
      (f : F)
      : M Self :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_tap_inner_mut
      {F : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := mut_ref (axum.routing.RouterInner.t S))} :
    Notations.DoubleColon Self "tap_inner_mut" := {
    Notations.double_colon := tap_inner_mut (F := F);
  }.
  
  (*
      fn into_inner(self) -> RouterInner<S> {
          match Arc::try_unwrap(self.inner) {
              Ok(inner) => inner,
              Err(arc) => RouterInner {
                  path_router: arc.path_router.clone(),
                  fallback_router: arc.fallback_router.clone(),
                  default_fallback: arc.default_fallback,
                  catch_all_fallback: arc.catch_all_fallback.clone(),
              },
          }
      }
  *)
  Definition into_inner (self : Self) : M (axum.routing.RouterInner.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_inner :
    Notations.DoubleColon Self "into_inner" := {
    Notations.double_colon := into_inner;
  }.
  
  (*
      pub fn route(self, path: &str, method_router: MethodRouter<S>) -> Self {
          self.tap_inner_mut(|this| {
              panic_on_err!(this.path_router.route(path, method_router));
          })
      }
  *)
  Definition route
      (self : Self)
      (path : ref str.t)
      (method_router
        :
        axum.routing.method_routing.MethodRouter.t
          S
          axum.routing.method_routing.MethodRouter.Default.E)
      : M Self :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* method_router := M.alloc method_router in
    M.read foo.
  
  Global Instance AssociatedFunction_route :
    Notations.DoubleColon Self "route" := {
    Notations.double_colon := route;
  }.
  
  (*
      pub fn route_service<T>(self, path: &str, service: T) -> Self
      where
          T: Service<Request, Error = Infallible> + Clone + Send + 'static,
          T::Response: IntoResponse,
          T::Future: Send + 'static,
      {
          let service = match try_downcast::<Router<S>, _>(service) {
              Ok(_) => {
                  panic!(
                      "Invalid route: `Router::route_service` cannot be used with `Router`s. \
                       Use `Router::nest` instead"
                  );
              }
              Err(service) => service,
          };
  
          self.tap_inner_mut(|this| {
              panic_on_err!(this.path_router.route_service(path, service));
          })
      }
  *)
  Definition route_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (path : ref str.t)
      (service : T)
      : M Self :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* service := M.alloc service in
    M.read foo.
  
  Global Instance AssociatedFunction_route_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "route_service" := {
    Notations.double_colon := route_service (T := T);
  }.
  
  (*
      pub fn nest(self, path: &str, router: Router<S>) -> Self {
          let RouterInner {
              path_router,
              fallback_router,
              default_fallback,
              // we don't need to inherit the catch-all fallback. It is only used for CONNECT
              // requests with an empty path. If we were to inherit the catch-all fallback
              // it would end up matching `/{path}/*` which doesn't match empty paths.
              catch_all_fallback: _,
          } = router.into_inner();
  
          self.tap_inner_mut(|this| {
              panic_on_err!(this.path_router.nest(path, path_router));
  
              if !default_fallback {
                  panic_on_err!(this.fallback_router.nest(path, fallback_router));
              }
          })
      }
  *)
  Definition nest
      (self : Self)
      (path : ref str.t)
      (router : axum.routing.Router.t S)
      : M Self :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* router := M.alloc router in
    M.read foo.
  
  Global Instance AssociatedFunction_nest :
    Notations.DoubleColon Self "nest" := {
    Notations.double_colon := nest;
  }.
  
  (*
      pub fn nest_service<T>(self, path: &str, service: T) -> Self
      where
          T: Service<Request, Error = Infallible> + Clone + Send + 'static,
          T::Response: IntoResponse,
          T::Future: Send + 'static,
      {
          self.tap_inner_mut(|this| {
              panic_on_err!(this.path_router.nest_service(path, service));
          })
      }
  *)
  Definition nest_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (path : ref str.t)
      (service : T)
      : M Self :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* service := M.alloc service in
    M.read foo.
  
  Global Instance AssociatedFunction_nest_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "nest_service" := {
    Notations.double_colon := nest_service (T := T);
  }.
  
  (*
      pub fn merge<R>(self, other: R) -> Self
      where
          R: Into<Router<S>>,
      {
          const PANIC_MSG: &str =
              "Failed to merge fallbacks. This is a bug in axum. Please file an issue";
  
          let other: Router<S> = other.into();
          let RouterInner {
              path_router,
              fallback_router: mut other_fallback,
              default_fallback,
              catch_all_fallback,
          } = other.into_inner();
  
          self.map_inner(|mut this| {
              panic_on_err!(this.path_router.merge(path_router));
  
              match (this.default_fallback, default_fallback) {
                  // both have the default fallback
                  // use the one from other
                  (true, true) => {
                      this.fallback_router.merge(other_fallback).expect(PANIC_MSG);
                  }
                  // this has default fallback, other has a custom fallback
                  (true, false) => {
                      this.fallback_router.merge(other_fallback).expect(PANIC_MSG);
                      this.default_fallback = false;
                  }
                  // this has a custom fallback, other has a default
                  (false, true) => {
                      let fallback_router = std::mem::take(&mut this.fallback_router);
                      other_fallback.merge(fallback_router).expect(PANIC_MSG);
                      this.fallback_router = other_fallback;
                  }
                  // both have a custom fallback, not allowed
                  (false, false) => {
                      panic!("Cannot merge two `Router`s that both have a fallback")
                  }
              };
  
              this.catch_all_fallback = this
                  .catch_all_fallback
                  .merge(catch_all_fallback)
                  .unwrap_or_else(|| panic!("Cannot merge two `Router`s that both have a fallback"));
  
              this
          })
      }
  *)
  Definition merge
      {R : Set}
      {ℋ_0 : core.convert.Into.Trait R (T := axum.routing.Router.t S)}
      (self : Self)
      (other : R)
      : M Self :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_merge
      {R : Set}
      {ℋ_0 : core.convert.Into.Trait R (T := axum.routing.Router.t S)} :
    Notations.DoubleColon Self "merge" := {
    Notations.double_colon := merge (R := R);
  }.
  
  (*
      pub fn layer<L>(self, layer: L) -> Router<S>
      where
          L: Layer<Route> + Clone + Send + 'static,
          L::Service: Service<Request> + Clone + Send + 'static,
          <L::Service as Service<Request>>::Response: IntoResponse + 'static,
          <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
          <L::Service as Service<Request>>::Future: Send + 'static,
      {
          self.map_inner(|this| RouterInner {
              path_router: this.path_router.layer(layer.clone()),
              fallback_router: this.fallback_router.layer(layer.clone()),
              default_fallback: this.default_fallback,
              catch_all_fallback: this.catch_all_fallback.map(|route| route.layer(layer)),
          })
      }
  *)
  Definition layer
      {L : Set}
      {ℋ_0 :
        tower_layer.Layer.Trait L
          (S := axum.routing.route.Route.t axum.routing.route.Route.Default.E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := core.convert.Infallible.t)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      (self : Self)
      (layer : L)
      : M (axum.routing.Router.t S) :=
    let* self := M.alloc self in
    let* layer := M.alloc layer in
    M.read foo.
  
  Global Instance AssociatedFunction_layer
      {L : Set}
      {ℋ_0 :
        tower_layer.Layer.Trait L
          (S := axum.routing.route.Route.t axum.routing.route.Route.Default.E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := core.convert.Infallible.t)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))} :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer (L := L);
  }.
  
  (*
      pub fn route_layer<L>(self, layer: L) -> Self
      where
          L: Layer<Route> + Clone + Send + 'static,
          L::Service: Service<Request> + Clone + Send + 'static,
          <L::Service as Service<Request>>::Response: IntoResponse + 'static,
          <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
          <L::Service as Service<Request>>::Future: Send + 'static,
      {
          self.map_inner(|this| RouterInner {
              path_router: this.path_router.route_layer(layer),
              fallback_router: this.fallback_router,
              default_fallback: this.default_fallback,
              catch_all_fallback: this.catch_all_fallback,
          })
      }
  *)
  Definition route_layer
      {L : Set}
      {ℋ_0 :
        tower_layer.Layer.Trait L
          (S := axum.routing.route.Route.t axum.routing.route.Route.Default.E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := core.convert.Infallible.t)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      (self : Self)
      (layer : L)
      : M Self :=
    let* self := M.alloc self in
    let* layer := M.alloc layer in
    M.read foo.
  
  Global Instance AssociatedFunction_route_layer
      {L : Set}
      {ℋ_0 :
        tower_layer.Layer.Trait L
          (S := axum.routing.route.Route.t axum.routing.route.Route.Default.E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := core.convert.Infallible.t)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))} :
    Notations.DoubleColon Self "route_layer" := {
    Notations.double_colon := route_layer (L := L);
  }.
  
  (*
      pub fn fallback<H, T>(self, handler: H) -> Self
      where
          H: Handler<T, S>,
          T: 'static,
      {
          self.tap_inner_mut(|this| {
              this.catch_all_fallback =
                  Fallback::BoxedHandler(BoxedIntoRoute::from_handler(handler.clone()));
          })
          .fallback_endpoint(Endpoint::MethodRouter(any(handler)))
      }
  *)
  Definition fallback
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_fallback
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
    Notations.DoubleColon Self "fallback" := {
    Notations.double_colon := fallback (H := H) (T := T);
  }.
  
  (*
      pub fn fallback_service<T>(self, service: T) -> Self
      where
          T: Service<Request, Error = Infallible> + Clone + Send + 'static,
          T::Response: IntoResponse,
          T::Future: Send + 'static,
      {
          let route = Route::new(service);
          self.tap_inner_mut(|this| {
              this.catch_all_fallback = Fallback::Service(route.clone());
          })
          .fallback_endpoint(Endpoint::Route(route))
      }
  *)
  Definition fallback_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (service : T)
      : M Self :=
    let* self := M.alloc self in
    let* service := M.alloc service in
    M.read foo.
  
  Global Instance AssociatedFunction_fallback_service
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "fallback_service" := {
    Notations.double_colon := fallback_service (T := T);
  }.
  
  (*
      fn fallback_endpoint(self, endpoint: Endpoint<S>) -> Self {
          self.tap_inner_mut(|this| {
              this.fallback_router.set_fallback(endpoint);
              this.default_fallback = false;
          })
      }
  *)
  Definition fallback_endpoint
      (self : Self)
      (endpoint : axum.routing.Endpoint.t S)
      : M Self :=
    let* self := M.alloc self in
    let* endpoint := M.alloc endpoint in
    M.read foo.
  
  Global Instance AssociatedFunction_fallback_endpoint :
    Notations.DoubleColon Self "fallback_endpoint" := {
    Notations.double_colon := fallback_endpoint;
  }.
  
  (*
      pub fn with_state<S2>(self, state: S) -> Router<S2> {
          self.map_inner(|this| RouterInner {
              path_router: this.path_router.with_state(state.clone()),
              fallback_router: this.fallback_router.with_state(state.clone()),
              default_fallback: this.default_fallback,
              catch_all_fallback: this.catch_all_fallback.with_state(state),
          })
      }
  *)
  Definition with_state
      {S2 : Set}
      (self : Self)
      (state : S)
      : M (axum.routing.Router.t S2) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_with_state {S2 : Set} :
    Notations.DoubleColon Self "with_state" := {
    Notations.double_colon := with_state (S2 := S2);
  }.
  
  (*
      pub(crate) fn call_with_state(&self, req: Request, state: S) -> RouteFuture<Infallible> {
          let (req, state) = match self.inner.path_router.call_with_state(req, state) {
              Ok(future) => return future,
              Err((req, state)) => (req, state),
          };
  
          let (req, state) = match self.inner.fallback_router.call_with_state(req, state) {
              Ok(future) => return future,
              Err((req, state)) => (req, state),
          };
  
          self.inner
              .catch_all_fallback
              .clone()
              .call_with_state(req, state)
      }
  *)
  Definition call_with_state
      (self : ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M (axum.routing.route.RouteFuture.t core.convert.Infallible.t) :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call_with_state :
    Notations.DoubleColon Self "call_with_state" := {
    Notations.double_colon := call_with_state;
  }.
  
  (*
      pub fn as_service<B>(&mut self) -> RouterAsService<'_, B, S> {
          RouterAsService {
              router: self,
              _marker: PhantomData,
          }
      }
  *)
  Definition as_service
      {B : Set}
      (self : mut_ref Self)
      : M (axum.routing.RouterAsService.t B S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_as_service {B : Set} :
    Notations.DoubleColon Self "as_service" := {
    Notations.double_colon := as_service (B := B);
  }.
  
  (*
      pub fn into_service<B>(self) -> RouterIntoService<B, S> {
          RouterIntoService {
              router: self,
              _marker: PhantomData,
          }
      }
  *)
  Definition into_service
      {B : Set}
      (self : Self)
      : M (axum.routing.RouterIntoService.t B S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_service {B : Set} :
    Notations.DoubleColon Self "into_service" := {
    Notations.double_colon := into_service (B := B);
  }.
End Impl_axum_routing_Router_t_S_2.
End Impl_axum_routing_Router_t_S_2.

Definition PANIC_MSG : M.Val (ref str.t) := M.run (M.pure foo).

Module  Impl_axum_routing_Router_t_axum_routing_Router_Default_S_2.
Section Impl_axum_routing_Router_t_axum_routing_Router_Default_S_2.
  Definition Self : Set := axum.routing.Router.t axum.routing.Router.Default.S.
  
  (*
      pub fn into_make_service(self) -> IntoMakeService<Self> {
          // call `Router::with_state` such that everything is turned into `Route` eagerly
          // rather than doing that per request
          IntoMakeService::new(self.with_state(()))
      }
  *)
  Definition into_make_service
      (self : Self)
      : M (axum.routing.into_make_service.IntoMakeService.t Self) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_make_service :
    Notations.DoubleColon Self "into_make_service" := {
    Notations.double_colon := into_make_service;
  }.
  
  (*
      pub fn into_make_service_with_connect_info<C>(self) -> IntoMakeServiceWithConnectInfo<Self, C> {
          // call `Router::with_state` such that everything is turned into `Route` eagerly
          // rather than doing that per request
          IntoMakeServiceWithConnectInfo::new(self.with_state(()))
      }
  *)
  Definition into_make_service_with_connect_info
      {C : Set}
      (self : Self)
      : M (axum.extract.connect_info.IntoMakeServiceWithConnectInfo.t Self C) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_make_service_with_connect_info
      {C : Set} :
    Notations.DoubleColon Self "into_make_service_with_connect_info" := {
    Notations.double_colon := into_make_service_with_connect_info (C := C);
  }.
End Impl_axum_routing_Router_t_axum_routing_Router_Default_S_2.
End Impl_axum_routing_Router_t_axum_routing_Router_Default_S_2.

Module  Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_routing_Router_t_Tuple_.
Section Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_routing_Router_t_Tuple_.
  Definition Self : Set := axum.routing.Router.t unit.
  
  (*
          type Response = Self;
  *)
  Definition Response : Set := Self.
  
  (*
          type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
          type Future = std::future::Ready<Result<Self::Response, Self::Error>>;
  *)
  Definition Future : Set :=
    core.future.ready.Ready.t (core.result.Result.t Response Error).
  
  (*
          fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
              Poll::Ready(Ok(()))
          }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (_cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* _cx := M.alloc _cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
          fn call(&mut self, _req: IncomingStream<'_>) -> Self::Future {
              std::future::ready(Ok(self.clone()))
          }
  *)
  Definition call
      (self : mut_ref Self)
      (_req : axum.serve.IncomingStream.t)
      : M Future :=
    let* self := M.alloc self in
    let* _req := M.alloc _req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := axum.serve.IncomingStream.t) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_routing_Router_t_Tuple_.
End Impl_tower_service_Service_axum_serve_IncomingStream_t_for_axum_routing_Router_t_Tuple_.

Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_Router_t_Tuple_.
Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_Router_t_Tuple_.
  Context {B : Set}.
  
  Context
    {ℋ_0 : http_body.Body.Trait B}
    {ℋ_1 : core.marker.Send.Trait B}
    {ℋ_2 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}.
  
  Definition Self : Set := axum.routing.Router.t unit.
  
  (*
      type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      type Future = RouteFuture<Infallible>;
  *)
  Definition Future : Set :=
    axum.routing.route.RouteFuture.t core.convert.Infallible.t.
  
  (*
      fn poll_ready(&mut self, _: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          Poll::Ready(Ok(()))
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (Pattern : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, req: Request<B>) -> Self::Future {
          let req = req.map(Body::new);
          self.call_with_state(req, ())
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req : ltac:(axum_core.extract.Request B))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request B)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_Router_t_Tuple_.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_Router_t_Tuple_.

Module  RouterAsService.
Section RouterAsService.
  Context (B S : Set).
  
  Record t : Set := {
    router : mut_ref (axum.routing.Router.t S);
    _marker : core.marker.PhantomData.t B;
  }.
  
  Definition Get_router :=
    Ref.map (fun α => Some α.(router)) (fun β α => Some (α <| router := β |>)).
  Definition Get__marker :=
    Ref.map
      (fun α => Some α.(_marker))
      (fun β α => Some (α <| _marker := β |>)).
  Module Default.
    Definition S := unit.
  End Default.
End RouterAsService.
End RouterAsService.

Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterAsService_t_B_Tuple_.
Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterAsService_t_B_Tuple_.
  Context {B : Set}.
  
  Context
    {ℋ_0 : http_body.Body.Trait B}
    {ℋ_1 : core.marker.Send.Trait B}
    {ℋ_2 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}.
  
  Definition Self : Set := axum.routing.RouterAsService.t B unit.
  
  (*
      type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      type Future = RouteFuture<Infallible>;
  *)
  Definition Future : Set :=
    axum.routing.route.RouteFuture.t core.convert.Infallible.t.
  
  (*
      fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          <Router as Service<Request<B>>>::poll_ready(self.router, cx)
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, req: Request<B>) -> Self::Future {
          self.router.call(req)
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req : ltac:(axum_core.extract.Request B))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request B)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterAsService_t_B_Tuple_.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterAsService_t_B_Tuple_.

Module  Impl_core_fmt_Debug_for_axum_routing_RouterAsService_t_B_S.
Section Impl_core_fmt_Debug_for_axum_routing_RouterAsService_t_B_S.
  Context {B S : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set := axum.routing.RouterAsService.t B S.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("RouterAsService")
              .field("router", &self.router)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_RouterAsService_t_B_S.
End Impl_core_fmt_Debug_for_axum_routing_RouterAsService_t_B_S.

Module  RouterIntoService.
Section RouterIntoService.
  Context (B S : Set).
  
  Record t : Set := {
    router : axum.routing.Router.t S;
    _marker : core.marker.PhantomData.t B;
  }.
  
  Definition Get_router :=
    Ref.map (fun α => Some α.(router)) (fun β α => Some (α <| router := β |>)).
  Definition Get__marker :=
    Ref.map
      (fun α => Some α.(_marker))
      (fun β α => Some (α <| _marker := β |>)).
  Module Default.
    Definition S := unit.
  End Default.
End RouterIntoService.
End RouterIntoService.

Module  Impl_core_clone_Clone_for_axum_routing_RouterIntoService_t_B_S.
Section Impl_core_clone_Clone_for_axum_routing_RouterIntoService_t_B_S.
  Context {B S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait (axum.routing.Router.t S)}.
  
  Definition Self : Set := axum.routing.RouterIntoService.t B S.
  
  (*
      fn clone(&self) -> Self {
          Self {
              router: self.router.clone(),
              _marker: PhantomData,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_RouterIntoService_t_B_S.
End Impl_core_clone_Clone_for_axum_routing_RouterIntoService_t_B_S.

Module  Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterIntoService_t_B_Tuple_.
Section Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterIntoService_t_B_Tuple_.
  Context {B : Set}.
  
  Context
    {ℋ_0 : http_body.Body.Trait B}
    {ℋ_1 : core.marker.Send.Trait B}
    {ℋ_2 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}.
  
  Definition Self : Set := axum.routing.RouterIntoService.t B unit.
  
  (*
      type Response = Response;
  *)
  Definition Response : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      type Future = RouteFuture<Infallible>;
  *)
  Definition Future : Set :=
    axum.routing.route.RouteFuture.t core.convert.Infallible.t.
  
  (*
      fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          <Router as Service<Request<B>>>::poll_ready(&mut self.router, cx)
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, req: Request<B>) -> Self::Future {
          self.router.call(req)
      }
  *)
  Definition call
      (self : mut_ref Self)
      (req : ltac:(axum_core.extract.Request B))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request B)) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterIntoService_t_B_Tuple_.
End Impl_tower_service_Service_axum_core_extract_Request_B_for_axum_routing_RouterIntoService_t_B_Tuple_.

Module  Impl_core_fmt_Debug_for_axum_routing_RouterIntoService_t_B_S.
Section Impl_core_fmt_Debug_for_axum_routing_RouterIntoService_t_B_S.
  Context {B S : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set := axum.routing.RouterIntoService.t B S.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          f.debug_struct("RouterIntoService")
              .field("router", &self.router)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_RouterIntoService_t_B_S.
End Impl_core_fmt_Debug_for_axum_routing_RouterIntoService_t_B_S.

Module Fallback.
  Inductive t (S : Set) (E : Set) : Set :=
  | Default (_ : axum.routing.route.Route.t E)
  | Service (_ : axum.routing.route.Route.t E)
  | BoxedHandler (_ : axum.boxed.BoxedIntoRoute.t S E).
  
  Definition Get_Default_0 :=
    Ref.map
      (fun α => match α with | Default α0 => Some α0 | _ => None end)
      (fun β α => match α with | Default _ => Some (Default β) | _ => None end).
  
  Definition Get_Service_0 :=
    Ref.map
      (fun α => match α with | Service α0 => Some α0 | _ => None end)
      (fun β α => match α with | Service _ => Some (Service β) | _ => None end).
  
  Definition Get_BoxedHandler_0 :=
    Ref.map
      (fun α => match α with | BoxedHandler α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | BoxedHandler _ => Some (BoxedHandler β) | _ => None end).
End Fallback.

Module  Impl_axum_routing_Fallback_t_S_E_2.
Section Impl_axum_routing_Fallback_t_S_E_2.
  Context {S E : Set}.
  
  Definition Self : Set := axum.routing.Fallback.t S E.
  
  (*
      fn merge(self, other: Self) -> Option<Self> {
          match (self, other) {
              (Self::Default(_), pick @ Self::Default(_)) => Some(pick),
              (Self::Default(_), pick) | (pick, Self::Default(_)) => Some(pick),
              _ => None,
          }
      }
  *)
  Definition merge
      (self : Self)
      (other : Self)
      : M (core.option.Option.t Self) :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_merge :
    Notations.DoubleColon Self "merge" := {
    Notations.double_colon := merge;
  }.
  
  (*
      fn map<F, E2>(self, f: F) -> Fallback<S, E2>
      where
          S: 'static,
          E: 'static,
          F: FnOnce(Route<E>) -> Route<E2> + Clone + Send + 'static,
          E2: 'static,
      {
          match self {
              Self::Default(route) => Fallback::Default(f(route)),
              Self::Service(route) => Fallback::Service(f(route)),
              Self::BoxedHandler(handler) => Fallback::BoxedHandler(handler.map(f)),
          }
      }
  *)
  Definition map
      {F E2 : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F (Args := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F}
      (self : Self)
      (f : F)
      : M (axum.routing.Fallback.t S E2) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_map
      {F E2 : Set}
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F (Args := axum.routing.route.Route.t E)}
      {ℋ_1 : core.clone.Clone.Trait F}
      {ℋ_2 : core.marker.Send.Trait F} :
    Notations.DoubleColon Self "map" := {
    Notations.double_colon := map (F := F) (E2 := E2);
  }.
  
  (*
      fn with_state<S2>(self, state: S) -> Fallback<S2, E> {
          match self {
              Fallback::Default(route) => Fallback::Default(route),
              Fallback::Service(route) => Fallback::Service(route),
              Fallback::BoxedHandler(handler) => Fallback::Service(handler.into_route(state)),
          }
      }
  *)
  Definition with_state
      {S2 : Set}
      (self : Self)
      (state : S)
      : M (axum.routing.Fallback.t S2 E) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_with_state {S2 : Set} :
    Notations.DoubleColon Self "with_state" := {
    Notations.double_colon := with_state (S2 := S2);
  }.
  
  (*
      fn call_with_state(&mut self, req: Request, state: S) -> RouteFuture<E> {
          match self {
              Fallback::Default(route) | Fallback::Service(route) => {
                  RouteFuture::from_future(route.oneshot_inner(req))
              }
              Fallback::BoxedHandler(handler) => {
                  let mut route = handler.clone().into_route(state);
                  RouteFuture::from_future(route.oneshot_inner(req))
              }
          }
      }
  *)
  Definition call_with_state
      (self : mut_ref Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M (axum.routing.route.RouteFuture.t E) :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call_with_state :
    Notations.DoubleColon Self "call_with_state" := {
    Notations.double_colon := call_with_state;
  }.
End Impl_axum_routing_Fallback_t_S_E_2.
End Impl_axum_routing_Fallback_t_S_E_2.

Module  Impl_core_clone_Clone_for_axum_routing_Fallback_t_S_E.
Section Impl_core_clone_Clone_for_axum_routing_Fallback_t_S_E.
  Context {S E : Set}.
  
  Definition Self : Set := axum.routing.Fallback.t S E.
  
  (*
      fn clone(&self) -> Self {
          match self {
              Self::Default(inner) => Self::Default(inner.clone()),
              Self::Service(inner) => Self::Service(inner.clone()),
              Self::BoxedHandler(inner) => Self::BoxedHandler(inner.clone()),
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_Fallback_t_S_E.
End Impl_core_clone_Clone_for_axum_routing_Fallback_t_S_E.

Module  Impl_core_fmt_Debug_for_axum_routing_Fallback_t_S_E.
Section Impl_core_fmt_Debug_for_axum_routing_Fallback_t_S_E.
  Context {S E : Set}.
  
  Definition Self : Set := axum.routing.Fallback.t S E.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          match self {
              Self::Default(inner) => f.debug_tuple("Default").field(inner).finish(),
              Self::Service(inner) => f.debug_tuple("Service").field(inner).finish(),
              Self::BoxedHandler(_) => f.debug_tuple("BoxedHandler").finish(),
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_Fallback_t_S_E.
End Impl_core_fmt_Debug_for_axum_routing_Fallback_t_S_E.

Module Endpoint.
  Inductive t (S : Set) : Set :=
  |
    MethodRouter
    (_ :
      axum.routing.method_routing.MethodRouter.t
        S
        axum.routing.method_routing.MethodRouter.Default.E)
  | Route (_ : axum.routing.route.Route.t axum.routing.route.Route.Default.E).
  
  Definition Get_MethodRouter_0 :=
    Ref.map
      (fun α => match α with | MethodRouter α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | MethodRouter _ => Some (MethodRouter β) | _ => None end).
  
  Definition Get_Route_0 :=
    Ref.map
      (fun α => match α with | Route α0 => Some α0 | _ => None end)
      (fun β α => match α with | Route _ => Some (Route β) | _ => None end).
End Endpoint.

Module  Impl_axum_routing_Endpoint_t_S_2.
Section Impl_axum_routing_Endpoint_t_S_2.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.Endpoint.t S.
  
  (*
      fn layer<L>(self, layer: L) -> Endpoint<S>
      where
          L: Layer<Route> + Clone + Send + 'static,
          L::Service: Service<Request> + Clone + Send + 'static,
          <L::Service as Service<Request>>::Response: IntoResponse + 'static,
          <L::Service as Service<Request>>::Error: Into<Infallible> + 'static,
          <L::Service as Service<Request>>::Future: Send + 'static,
      {
          match self {
              Endpoint::MethodRouter(method_router) => {
                  Endpoint::MethodRouter(method_router.layer(layer))
              }
              Endpoint::Route(route) => Endpoint::Route(route.layer(layer)),
          }
      }
  *)
  Definition layer
      {L : Set}
      {ℋ_0 :
        tower_layer.Layer.Trait L
          (S := axum.routing.route.Route.t axum.routing.route.Route.Default.E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := core.convert.Infallible.t)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      (self : Self)
      (layer : L)
      : M (axum.routing.Endpoint.t S) :=
    let* self := M.alloc self in
    let* layer := M.alloc layer in
    M.read foo.
  
  Global Instance AssociatedFunction_layer
      {L : Set}
      {ℋ_0 :
        tower_layer.Layer.Trait L
          (S := axum.routing.route.Route.t axum.routing.route.Route.Default.E)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        tower_service.Service.Trait L::type["Service"].t
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait L::type["Service"].t}
      {ℋ_5 : core.marker.Send.Trait L::type["Service"].t}
      {ℋ_6 :
        axum_core.response.into_response.IntoResponse.Trait
            (tower_service.Service.Response
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))}
      {ℋ_7 :
        core.convert.Into.Trait
            (tower_service.Service.Error
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))
          (T := core.convert.Infallible.t)}
      {ℋ_8 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := L::type["Service"].t)
              (Trait := ltac:(refine _)))} :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer (L := L);
  }.
End Impl_axum_routing_Endpoint_t_S_2.
End Impl_axum_routing_Endpoint_t_S_2.

Module  Impl_core_clone_Clone_for_axum_routing_Endpoint_t_S.
Section Impl_core_clone_Clone_for_axum_routing_Endpoint_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.Endpoint.t S.
  
  (*
      fn clone(&self) -> Self {
          match self {
              Self::MethodRouter(inner) => Self::MethodRouter(inner.clone()),
              Self::Route(inner) => Self::Route(inner.clone()),
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_routing_Endpoint_t_S.
End Impl_core_clone_Clone_for_axum_routing_Endpoint_t_S.

Module  Impl_core_fmt_Debug_for_axum_routing_Endpoint_t_S.
Section Impl_core_fmt_Debug_for_axum_routing_Endpoint_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.Endpoint.t S.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          match self {
              Self::MethodRouter(method_router) => {
                  f.debug_tuple("MethodRouter").field(method_router).finish()
              }
              Self::Route(route) => f.debug_tuple("Route").field(route).finish(),
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_routing_Endpoint_t_S.
End Impl_core_fmt_Debug_for_axum_routing_Endpoint_t_S.

Module serve.
  (*
  pub fn serve<M, S>(tcp_listener: TcpListener, make_service: M) -> Serve<M, S>
  where
      M: for<'a> Service<IncomingStream<'a>, Error = Infallible, Response = S>,
      S: Service<Request, Response = Response, Error = Infallible> + Clone + Send + 'static,
      S::Future: Send,
  {
      Serve {
          tcp_listener,
          make_service,
          _marker: PhantomData,
      }
  }
  *)
  Definition serve
      {M S : Set}
      {ℋ_0 :
        tower_service.Service.Trait M (Request := axum.serve.IncomingStream.t)}
      {ℋ_1 :
        tower_service.Service.Trait S
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_2 : core.clone.Clone.Trait S}
      {ℋ_3 : core.marker.Send.Trait S}
      {ℋ_4 : core.marker.Send.Trait S::type["Future"].t}
      (tcp_listener : tokio.net.tcp.listener.TcpListener.t)
      (make_service : M)
      : M (axum.serve.Serve.t M S) :=
    let* tcp_listener := M.alloc tcp_listener in
    let* make_service := M.alloc make_service in
    M.read foo.
  
  Module  Serve.
  Section Serve.
    Context (M S : Set).
    
    Record t : Set := {
      tcp_listener : tokio.net.tcp.listener.TcpListener.t;
      make_service : M;
      _marker : core.marker.PhantomData.t S;
    }.
    
    Definition Get_tcp_listener :=
      Ref.map
        (fun α => Some α.(tcp_listener))
        (fun β α => Some (α <| tcp_listener := β |>)).
    Definition Get_make_service :=
      Ref.map
        (fun α => Some α.(make_service))
        (fun β α => Some (α <| make_service := β |>)).
    Definition Get__marker :=
      Ref.map
        (fun α => Some α.(_marker))
        (fun β α => Some (α <| _marker := β |>)).
  End Serve.
  End Serve.
  
  Module  Impl_axum_serve_Serve_t_M_S.
  Section Impl_axum_serve_Serve_t_M_S.
    Context {M S : Set}.
    
    Definition Self : Set := axum.serve.Serve.t M S.
    
    (*
        pub fn with_graceful_shutdown<F>(self, signal: F) -> WithGracefulShutdown<M, S, F>
        where
            F: Future<Output = ()> + Send + 'static,
        {
            WithGracefulShutdown {
                tcp_listener: self.tcp_listener,
                make_service: self.make_service,
                signal,
                _marker: PhantomData,
            }
        }
    *)
    Definition with_graceful_shutdown
        {F : Set}
        {ℋ_0 : core.future.future.Future.Trait F}
        {ℋ_1 : core.marker.Send.Trait F}
        (self : Self)
        (signal : F)
        : M (axum.serve.WithGracefulShutdown.t M S F) :=
      let* self := M.alloc self in
      let* signal := M.alloc signal in
      M.read foo.
    
    Global Instance AssociatedFunction_with_graceful_shutdown
        {F : Set}
        {ℋ_0 : core.future.future.Future.Trait F}
        {ℋ_1 : core.marker.Send.Trait F} :
      Notations.DoubleColon Self "with_graceful_shutdown" := {
      Notations.double_colon := with_graceful_shutdown (F := F);
    }.
  End Impl_axum_serve_Serve_t_M_S.
  End Impl_axum_serve_Serve_t_M_S.
  
  Module  Impl_core_fmt_Debug_for_axum_serve_Serve_t_M_S.
  Section Impl_core_fmt_Debug_for_axum_serve_Serve_t_M_S.
    Context {M S : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait M}.
    
    Definition Self : Set := axum.serve.Serve.t M S.
    
    (*
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let Self {
                tcp_listener,
                make_service,
                _marker: _,
            } = self;
    
            f.debug_struct("Serve")
                .field("tcp_listener", tcp_listener)
                .field("make_service", make_service)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_serve_Serve_t_M_S.
  End Impl_core_fmt_Debug_for_axum_serve_Serve_t_M_S.
  
  Module  Impl_core_future_into_future_IntoFuture_for_axum_serve_Serve_t_M_S.
  Section Impl_core_future_into_future_IntoFuture_for_axum_serve_Serve_t_M_S.
    Context {M S : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait M (Request := axum.serve.IncomingStream.t)}
      {ℋ_1 : core.marker.Send.Trait M}
      {ℋ_2 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := M)
              (Trait := ltac:(refine _)))}
      {ℋ_3 :
        tower_service.Service.Trait S
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait S}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}.
    
    Definition Self : Set := axum.serve.Serve.t M S.
    
    (*
        type Output = io::Result<()>;
    *)
    Definition Output : Set := ltac:(std.io.error.Result unit).
    
    (*
        type IntoFuture = private::ServeFuture;
    *)
    Definition IntoFuture : Set := axum.serve.private.ServeFuture.t.
    
    (*
        fn into_future(self) -> Self::IntoFuture {
            private::ServeFuture(Box::pin(async move {
                let Self {
                    tcp_listener,
                    mut make_service,
                    _marker: _,
                } = self;
    
                loop {
                    let (tcp_stream, remote_addr) = match tcp_accept(&tcp_listener).await {
                        Some(conn) => conn,
                        None => continue,
                    };
                    let tcp_stream = TokioIo::new(tcp_stream);
    
                    poll_fn(|cx| make_service.poll_ready(cx))
                        .await
                        .unwrap_or_else(|err| match err {});
    
                    let tower_service = make_service
                        .call(IncomingStream {
                            tcp_stream: &tcp_stream,
                            remote_addr,
                        })
                        .await
                        .unwrap_or_else(|err| match err {});
    
                    let hyper_service = TowerToHyperService {
                        service: tower_service,
                    };
    
                    tokio::spawn(async move {
                        match Builder::new(TokioExecutor::new())
                            // upgrades needed for websockets
                            .serve_connection_with_upgrades(tcp_stream, hyper_service)
                            .await
                        {
                            Ok(()) => {}
                            Err(_err) => {
                                // This error only appears when the client doesn't send a request and
                                // terminate the connection.
                                //
                                // If client sends one request then terminate connection whenever, it doesn't
                                // appear.
                            }
                        }
                    });
                }
            }))
        }
    *)
    Definition into_future (self : Self) : M IntoFuture :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_future :
      Notations.DoubleColon Self "into_future" := {
      Notations.double_colon := into_future;
    }.
    
    Global Instance ℐ : core.future.into_future.IntoFuture.Trait Self := {
      core.future.into_future.IntoFuture.Output := Output;
      core.future.into_future.IntoFuture.IntoFuture := IntoFuture;
      core.future.into_future.IntoFuture.into_future := into_future;
    }.
  End Impl_core_future_into_future_IntoFuture_for_axum_serve_Serve_t_M_S.
  End Impl_core_future_into_future_IntoFuture_for_axum_serve_Serve_t_M_S.
  
  Module  WithGracefulShutdown.
  Section WithGracefulShutdown.
    Context (M S F : Set).
    
    Record t : Set := {
      tcp_listener : tokio.net.tcp.listener.TcpListener.t;
      make_service : M;
      signal : F;
      _marker : core.marker.PhantomData.t S;
    }.
    
    Definition Get_tcp_listener :=
      Ref.map
        (fun α => Some α.(tcp_listener))
        (fun β α => Some (α <| tcp_listener := β |>)).
    Definition Get_make_service :=
      Ref.map
        (fun α => Some α.(make_service))
        (fun β α => Some (α <| make_service := β |>)).
    Definition Get_signal :=
      Ref.map
        (fun α => Some α.(signal))
        (fun β α => Some (α <| signal := β |>)).
    Definition Get__marker :=
      Ref.map
        (fun α => Some α.(_marker))
        (fun β α => Some (α <| _marker := β |>)).
  End WithGracefulShutdown.
  End WithGracefulShutdown.
  
  Module  Impl_core_fmt_Debug_for_axum_serve_WithGracefulShutdown_t_M_S_F.
  Section Impl_core_fmt_Debug_for_axum_serve_WithGracefulShutdown_t_M_S_F.
    Context {M S F : Set}.
    
    Context
      {ℋ_0 : core.fmt.Debug.Trait M}
      {ℋ_1 : core.fmt.Debug.Trait S}
      {ℋ_2 : core.fmt.Debug.Trait F}.
    
    Definition Self : Set := axum.serve.WithGracefulShutdown.t M S F.
    
    (*
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let Self {
                tcp_listener,
                make_service,
                signal,
                _marker: _,
            } = self;
    
            f.debug_struct("WithGracefulShutdown")
                .field("tcp_listener", tcp_listener)
                .field("make_service", make_service)
                .field("signal", signal)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_serve_WithGracefulShutdown_t_M_S_F.
  End Impl_core_fmt_Debug_for_axum_serve_WithGracefulShutdown_t_M_S_F.
  
  Module  Impl_core_future_into_future_IntoFuture_for_axum_serve_WithGracefulShutdown_t_M_S_F.
  Section Impl_core_future_into_future_IntoFuture_for_axum_serve_WithGracefulShutdown_t_M_S_F.
    Context {M S F : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait M (Request := axum.serve.IncomingStream.t)}
      {ℋ_1 : core.marker.Send.Trait M}
      {ℋ_2 :
        core.marker.Send.Trait
            (tower_service.Service.Future
              (Self := M)
              (Trait := ltac:(refine _)))}
      {ℋ_3 :
        tower_service.Service.Trait S
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_4 : core.clone.Clone.Trait S}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
      {ℋ_7 : core.future.future.Future.Trait F}
      {ℋ_8 : core.marker.Send.Trait F}.
    
    Definition Self : Set := axum.serve.WithGracefulShutdown.t M S F.
    
    (*
        type Output = io::Result<()>;
    *)
    Definition Output : Set := ltac:(std.io.error.Result unit).
    
    (*
        type IntoFuture = private::ServeFuture;
    *)
    Definition IntoFuture : Set := axum.serve.private.ServeFuture.t.
    
    (*
        fn into_future(self) -> Self::IntoFuture {
            let Self {
                tcp_listener,
                mut make_service,
                signal,
                _marker: _,
            } = self;
    
            let (signal_tx, signal_rx) = watch::channel(());
            let signal_tx = Arc::new(signal_tx);
            tokio::spawn(async move {
                signal.await;
                trace!("received graceful shutdown signal. Telling tasks to shutdown");
                drop(signal_rx);
            });
    
            let (close_tx, close_rx) = watch::channel(());
    
            private::ServeFuture(Box::pin(async move {
                loop {
                    let (tcp_stream, remote_addr) = tokio::select! {
                        conn = tcp_accept(&tcp_listener) => {
                            match conn {
                                Some(conn) => conn,
                                None => continue,
                            }
                        }
                        _ = signal_tx.closed() => {
                            trace!("signal received, not accepting new connections");
                            break;
                        }
                    };
                    let tcp_stream = TokioIo::new(tcp_stream);
    
                    trace!("connection {remote_addr} accepted");
    
                    poll_fn(|cx| make_service.poll_ready(cx))
                        .await
                        .unwrap_or_else(|err| match err {});
    
                    let tower_service = make_service
                        .call(IncomingStream {
                            tcp_stream: &tcp_stream,
                            remote_addr,
                        })
                        .await
                        .unwrap_or_else(|err| match err {});
    
                    let hyper_service = TowerToHyperService {
                        service: tower_service,
                    };
    
                    let signal_tx = Arc::clone(&signal_tx);
    
                    let close_rx = close_rx.clone();
    
                    tokio::spawn(async move {
                        let builder = Builder::new(TokioExecutor::new());
                        let conn = builder.serve_connection_with_upgrades(tcp_stream, hyper_service);
                        pin_mut!(conn);
    
                        let signal_closed = signal_tx.closed().fuse();
                        pin_mut!(signal_closed);
    
                        loop {
                            tokio::select! {
                                result = conn.as_mut() => {
                                    if let Err(_err) = result {
                                        trace!("failed to serve connection: {_err:#}");
                                    }
                                    break;
                                }
                                _ = &mut signal_closed => {
                                    trace!("signal received in task, starting graceful shutdown");
                                    conn.as_mut().graceful_shutdown();
                                }
                            }
                        }
    
                        trace!("connection {remote_addr} closed");
    
                        drop(close_rx);
                    });
                }
    
                drop(close_rx);
                drop(tcp_listener);
    
                trace!(
                    "waiting for {} task(s) to finish",
                    close_tx.receiver_count()
                );
                close_tx.closed().await;
    
                Ok(())
            }))
        }
    *)
    Definition into_future (self : Self) : M IntoFuture :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_future :
      Notations.DoubleColon Self "into_future" := {
      Notations.double_colon := into_future;
    }.
    
    Global Instance ℐ : core.future.into_future.IntoFuture.Trait Self := {
      core.future.into_future.IntoFuture.Output := Output;
      core.future.into_future.IntoFuture.IntoFuture := IntoFuture;
      core.future.into_future.IntoFuture.into_future := into_future;
    }.
  End Impl_core_future_into_future_IntoFuture_for_axum_serve_WithGracefulShutdown_t_M_S_F.
  End Impl_core_future_into_future_IntoFuture_for_axum_serve_WithGracefulShutdown_t_M_S_F.
  
  (*
  fn is_connection_error(e: &io::Error) -> bool {
      matches!(
          e.kind(),
          io::ErrorKind::ConnectionRefused
              | io::ErrorKind::ConnectionAborted
              | io::ErrorKind::ConnectionReset
      )
  }
  *)
  Definition is_connection_error (e : ref std.io.error.Error.t) : M bool.t :=
    let* e := M.alloc e in
    M.read foo.
  
  (*
  async fn tcp_accept(listener: &TcpListener) -> Option<(TcpStream, SocketAddr)> {
      match listener.accept().await {
          Ok(conn) => Some(conn),
          Err(e) => {
              if is_connection_error(&e) {
                  return None;
              }
  
              // [From `hyper::Server` in 0.14](https://github.com/hyperium/hyper/blob/v0.14.27/src/server/tcp.rs#L186)
              //
              // > A possible scenario is that the process has hit the max open files
              // > allowed, and so trying to accept a new connection will fail with
              // > `EMFILE`. In some cases, it's preferable to just wait for some time, if
              // > the application will likely close some files (or connections), and try
              // > to accept the connection again. If this option is `true`, the error
              // > will be logged at the `error` level, since it is still a big deal,
              // > and then the listener will sleep for 1 second.
              //
              // hyper allowed customizing this but axum does not.
              error!("accept error: {e}");
              tokio::time::sleep(Duration::from_secs(1)).await;
              None
          }
      }
  }
  *)
  Definition tcp_accept
      (listener : ref tokio.net.tcp.listener.TcpListener.t)
      : M OpaqueDef :=
    let* listener := M.alloc listener in
    M.read foo.
  
  Module private.
    Module  ServeFuture.
    Section ServeFuture.
      Record t : Set := {
        x0 :
          ltac:(futures_core.future.BoxFuture ltac:(std.io.error.Result unit));
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End ServeFuture.
    End ServeFuture.
    
    Module  Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.
    Section Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.
      Definition Self : Set := axum.serve.private.ServeFuture.t.
      
      (*
              type Output = io::Result<()>;
      *)
      Definition Output : Set := ltac:(std.io.error.Result unit).
      
      (*
              fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
                  self.0.as_mut().poll(cx)
              }
      *)
      Definition poll
          (self : core.pin.Pin.t (mut_ref Self))
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t Output) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll :
        Notations.DoubleColon Self "poll" := {
        Notations.double_colon := poll;
      }.
      
      Global Instance ℐ : core.future.future.Future.Trait Self := {
        core.future.future.Future.Output := Output;
        core.future.future.Future.poll := poll;
      }.
    End Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.
    End Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.
    
    Module  Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.
    Section Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.
      Definition Self : Set := axum.serve.private.ServeFuture.t.
      
      (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  f.debug_struct("ServeFuture").finish_non_exhaustive()
              }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.
    End Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.
  End private.
  
  Module  TowerToHyperService.
  Section TowerToHyperService.
    Context (S : Set).
    
    Record t : Set := {
      service : S;
    }.
    
    Definition Get_service :=
      Ref.map
        (fun α => Some α.(service))
        (fun β α => Some (α <| service := β |>)).
  End TowerToHyperService.
  End TowerToHyperService.
  
  Module  Impl_core_fmt_Debug_for_axum_serve_TowerToHyperService_t_S.
  Section Impl_core_fmt_Debug_for_axum_serve_TowerToHyperService_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set := axum.serve.TowerToHyperService.t S.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_serve_TowerToHyperService_t_S.
  End Impl_core_fmt_Debug_for_axum_serve_TowerToHyperService_t_S.
  
  Module  Impl_core_marker_Copy_for_axum_serve_TowerToHyperService_t_S.
  Section Impl_core_marker_Copy_for_axum_serve_TowerToHyperService_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait S}.
    
    Definition Self : Set := axum.serve.TowerToHyperService.t S.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_serve_TowerToHyperService_t_S.
  End Impl_core_marker_Copy_for_axum_serve_TowerToHyperService_t_S.
  
  Module  Impl_core_clone_Clone_for_axum_serve_TowerToHyperService_t_S.
  Section Impl_core_clone_Clone_for_axum_serve_TowerToHyperService_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.serve.TowerToHyperService.t S.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum.serve.TowerToHyperService.t S) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_serve_TowerToHyperService_t_S.
  End Impl_core_clone_Clone_for_axum_serve_TowerToHyperService_t_S.
  
  Module  Impl_hyper_service_service_Service_axum_core_extract_Request_hyper_body_incoming_Incoming_t_for_axum_serve_TowerToHyperService_t_S.
  Section Impl_hyper_service_service_Service_axum_core_extract_Request_hyper_body_incoming_Incoming_t_for_axum_serve_TowerToHyperService_t_S.
    Context {S : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait S}.
    
    Definition Self : Set := axum.serve.TowerToHyperService.t S.
    
    (*
        type Response = S::Response;
    *)
    Definition Response : Set := S::type["Response"].t.
    
    (*
        type Error = S::Error;
    *)
    Definition Error : Set := S::type["Error"].t.
    
    (*
        type Future = TowerToHyperServiceFuture<S, Request>;
    *)
    Definition Future : Set :=
      axum.serve.TowerToHyperServiceFuture.t
          S
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T).
    
    (*
        fn call(&self, req: Request<Incoming>) -> Self::Future {
            let req = req.map(Body::new);
            TowerToHyperServiceFuture {
                future: self.service.clone().oneshot(req),
            }
        }
    *)
    Definition call
        (self : ref Self)
        (req : ltac:(axum_core.extract.Request hyper.body.incoming.Incoming.t))
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      hyper.service.service.Service.Trait Self
        (Request := ltac:(axum_core.extract.Request
          hyper.body.incoming.Incoming.t)) := {
      hyper.service.service.Service.Response := Response;
      hyper.service.service.Service.Error := Error;
      hyper.service.service.Service.Future := Future;
      hyper.service.service.Service.call := call;
    }.
  End Impl_hyper_service_service_Service_axum_core_extract_Request_hyper_body_incoming_Incoming_t_for_axum_serve_TowerToHyperService_t_S.
  End Impl_hyper_service_service_Service_axum_core_extract_Request_hyper_body_incoming_Incoming_t_for_axum_serve_TowerToHyperService_t_S.
  
  Module  TowerToHyperServiceFuture.
  Section TowerToHyperServiceFuture.
    Context (S R : Set).
    
    Context {ℋ_0 : tower_service.Service.Trait S (Request := R)}.
    Record t : Set := {
      future : tower.util.oneshot.Oneshot.t S R;
    }.
    
    Definition Get_future :=
      Ref.map
        (fun α => Some α.(future))
        (fun β α => Some (α <| future := β |>)).
  End TowerToHyperServiceFuture.
  End TowerToHyperServiceFuture.
  
  Module  Impl_core_future_future_Future_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
  Section Impl_core_future_future_Future_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
    Context {S R : Set}.
    
    Context {ℋ_0 : tower_service.Service.Trait S (Request := R)}.
    
    Definition Self : Set := axum.serve.TowerToHyperServiceFuture.t S R.
    
    (*
        type Output = Result<S::Response, S::Error>;
    *)
    Definition Output : Set :=
      core.result.Result.t S::type["Response"].t S::type["Error"].t.
    
    (*
        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            self.project().future.poll(cx)
        }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
  End Impl_core_future_future_Future_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
  
  Module  IncomingStream.
  Section IncomingStream.
    Record t : Set := {
      tcp_stream :
        ref (hyper_util.rt.tokio.TokioIo.t tokio.net.tcp.stream.TcpStream.t);
      remote_addr : core.net.socket_addr.SocketAddr.t;
    }.
    
    Definition Get_tcp_stream :=
      Ref.map
        (fun α => Some α.(tcp_stream))
        (fun β α => Some (α <| tcp_stream := β |>)).
    Definition Get_remote_addr :=
      Ref.map
        (fun α => Some α.(remote_addr))
        (fun β α => Some (α <| remote_addr := β |>)).
  End IncomingStream.
  End IncomingStream.
  
  Module  Impl_core_fmt_Debug_for_axum_serve_IncomingStream_t.
  Section Impl_core_fmt_Debug_for_axum_serve_IncomingStream_t.
    Definition Self : Set := axum.serve.IncomingStream.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_serve_IncomingStream_t.
  End Impl_core_fmt_Debug_for_axum_serve_IncomingStream_t.
  
  Module  Impl_axum_serve_IncomingStream_t.
  Section Impl_axum_serve_IncomingStream_t.
    Definition Self : Set := axum.serve.IncomingStream.t.
    
    (*
        pub fn local_addr(&self) -> std::io::Result<SocketAddr> {
            self.tcp_stream.inner().local_addr()
        }
    *)
    Definition local_addr
        (self : ref Self)
        : M ltac:(std.io.error.Result core.net.socket_addr.SocketAddr.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_local_addr :
      Notations.DoubleColon Self "local_addr" := {
      Notations.double_colon := local_addr;
    }.
    
    (*
        pub fn remote_addr(&self) -> SocketAddr {
            self.remote_addr
        }
    *)
    Definition remote_addr
        (self : ref Self)
        : M core.net.socket_addr.SocketAddr.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_remote_addr :
      Notations.DoubleColon Self "remote_addr" := {
      Notations.double_colon := remote_addr;
    }.
  End Impl_axum_serve_IncomingStream_t.
  End Impl_axum_serve_IncomingStream_t.
End serve.

(*
pub fn serve<M, S>(tcp_listener: TcpListener, make_service: M) -> Serve<M, S>
where
    M: for<'a> Service<IncomingStream<'a>, Error = Infallible, Response = S>,
    S: Service<Request, Response = Response, Error = Infallible> + Clone + Send + 'static,
    S::Future: Send,
{
    Serve {
        tcp_listener,
        make_service,
        _marker: PhantomData,
    }
}
*)
Definition serve
    {M S : Set}
    {ℋ_0 :
      tower_service.Service.Trait M (Request := axum.serve.IncomingStream.t)}
    {ℋ_1 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_2 : core.clone.Clone.Trait S}
    {ℋ_3 : core.marker.Send.Trait S}
    {ℋ_4 : core.marker.Send.Trait S::type["Future"].t}
    (tcp_listener : tokio.net.tcp.listener.TcpListener.t)
    (make_service : M)
    : M (axum.serve.Serve.t M S) :=
  let* tcp_listener := M.alloc tcp_listener in
  let* make_service := M.alloc make_service in
  M.read foo.

Module  Serve.
Section Serve.
  Context (M S : Set).
  
  Record t : Set := {
    tcp_listener : tokio.net.tcp.listener.TcpListener.t;
    make_service : M;
    _marker : core.marker.PhantomData.t S;
  }.
  
  Definition Get_tcp_listener :=
    Ref.map
      (fun α => Some α.(tcp_listener))
      (fun β α => Some (α <| tcp_listener := β |>)).
  Definition Get_make_service :=
    Ref.map
      (fun α => Some α.(make_service))
      (fun β α => Some (α <| make_service := β |>)).
  Definition Get__marker :=
    Ref.map
      (fun α => Some α.(_marker))
      (fun β α => Some (α <| _marker := β |>)).
End Serve.
End Serve.

Module  Impl_axum_serve_Serve_t_M_S_2.
Section Impl_axum_serve_Serve_t_M_S_2.
  Context {M S : Set}.
  
  Definition Self : Set := axum.serve.Serve.t M S.
  
  (*
      pub fn with_graceful_shutdown<F>(self, signal: F) -> WithGracefulShutdown<M, S, F>
      where
          F: Future<Output = ()> + Send + 'static,
      {
          WithGracefulShutdown {
              tcp_listener: self.tcp_listener,
              make_service: self.make_service,
              signal,
              _marker: PhantomData,
          }
      }
  *)
  Definition with_graceful_shutdown
      {F : Set}
      {ℋ_0 : core.future.future.Future.Trait F}
      {ℋ_1 : core.marker.Send.Trait F}
      (self : Self)
      (signal : F)
      : M (axum.serve.WithGracefulShutdown.t M S F) :=
    let* self := M.alloc self in
    let* signal := M.alloc signal in
    M.read foo.
  
  Global Instance AssociatedFunction_with_graceful_shutdown
      {F : Set}
      {ℋ_0 : core.future.future.Future.Trait F}
      {ℋ_1 : core.marker.Send.Trait F} :
    Notations.DoubleColon Self "with_graceful_shutdown" := {
    Notations.double_colon := with_graceful_shutdown (F := F);
  }.
End Impl_axum_serve_Serve_t_M_S_2.
End Impl_axum_serve_Serve_t_M_S_2.

Module  Impl_core_fmt_Debug_for_axum_serve_Serve_t_M_S.
Section Impl_core_fmt_Debug_for_axum_serve_Serve_t_M_S.
  Context {M S : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait M}.
  
  Definition Self : Set := axum.serve.Serve.t M S.
  
  (*
      fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
          let Self {
              tcp_listener,
              make_service,
              _marker: _,
          } = self;
  
          f.debug_struct("Serve")
              .field("tcp_listener", tcp_listener)
              .field("make_service", make_service)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_serve_Serve_t_M_S.
End Impl_core_fmt_Debug_for_axum_serve_Serve_t_M_S.

Module  Impl_core_future_into_future_IntoFuture_for_axum_serve_Serve_t_M_S.
Section Impl_core_future_into_future_IntoFuture_for_axum_serve_Serve_t_M_S.
  Context {M S : Set}.
  
  Context
    {ℋ_0 :
      tower_service.Service.Trait M (Request := axum.serve.IncomingStream.t)}
    {ℋ_1 : core.marker.Send.Trait M}
    {ℋ_2 :
      core.marker.Send.Trait
          (tower_service.Service.Future (Self := M) (Trait := ltac:(refine _)))}
    {ℋ_3 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_4 : core.clone.Clone.Trait S}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}.
  
  Definition Self : Set := axum.serve.Serve.t M S.
  
  (*
      type Output = io::Result<()>;
  *)
  Definition Output : Set := ltac:(std.io.error.Result unit).
  
  (*
      type IntoFuture = private::ServeFuture;
  *)
  Definition IntoFuture : Set := axum.serve.private.ServeFuture.t.
  
  (*
      fn into_future(self) -> Self::IntoFuture {
          private::ServeFuture(Box::pin(async move {
              let Self {
                  tcp_listener,
                  mut make_service,
                  _marker: _,
              } = self;
  
              loop {
                  let (tcp_stream, remote_addr) = match tcp_accept(&tcp_listener).await {
                      Some(conn) => conn,
                      None => continue,
                  };
                  let tcp_stream = TokioIo::new(tcp_stream);
  
                  poll_fn(|cx| make_service.poll_ready(cx))
                      .await
                      .unwrap_or_else(|err| match err {});
  
                  let tower_service = make_service
                      .call(IncomingStream {
                          tcp_stream: &tcp_stream,
                          remote_addr,
                      })
                      .await
                      .unwrap_or_else(|err| match err {});
  
                  let hyper_service = TowerToHyperService {
                      service: tower_service,
                  };
  
                  tokio::spawn(async move {
                      match Builder::new(TokioExecutor::new())
                          // upgrades needed for websockets
                          .serve_connection_with_upgrades(tcp_stream, hyper_service)
                          .await
                      {
                          Ok(()) => {}
                          Err(_err) => {
                              // This error only appears when the client doesn't send a request and
                              // terminate the connection.
                              //
                              // If client sends one request then terminate connection whenever, it doesn't
                              // appear.
                          }
                      }
                  });
              }
          }))
      }
  *)
  Definition into_future (self : Self) : M IntoFuture :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_future :
    Notations.DoubleColon Self "into_future" := {
    Notations.double_colon := into_future;
  }.
  
  Global Instance ℐ : core.future.into_future.IntoFuture.Trait Self := {
    core.future.into_future.IntoFuture.Output := Output;
    core.future.into_future.IntoFuture.IntoFuture := IntoFuture;
    core.future.into_future.IntoFuture.into_future := into_future;
  }.
End Impl_core_future_into_future_IntoFuture_for_axum_serve_Serve_t_M_S.
End Impl_core_future_into_future_IntoFuture_for_axum_serve_Serve_t_M_S.

Module  WithGracefulShutdown.
Section WithGracefulShutdown.
  Context (M S F : Set).
  
  Record t : Set := {
    tcp_listener : tokio.net.tcp.listener.TcpListener.t;
    make_service : M;
    signal : F;
    _marker : core.marker.PhantomData.t S;
  }.
  
  Definition Get_tcp_listener :=
    Ref.map
      (fun α => Some α.(tcp_listener))
      (fun β α => Some (α <| tcp_listener := β |>)).
  Definition Get_make_service :=
    Ref.map
      (fun α => Some α.(make_service))
      (fun β α => Some (α <| make_service := β |>)).
  Definition Get_signal :=
    Ref.map (fun α => Some α.(signal)) (fun β α => Some (α <| signal := β |>)).
  Definition Get__marker :=
    Ref.map
      (fun α => Some α.(_marker))
      (fun β α => Some (α <| _marker := β |>)).
End WithGracefulShutdown.
End WithGracefulShutdown.

Module  Impl_core_fmt_Debug_for_axum_serve_WithGracefulShutdown_t_M_S_F.
Section Impl_core_fmt_Debug_for_axum_serve_WithGracefulShutdown_t_M_S_F.
  Context {M S F : Set}.
  
  Context
    {ℋ_0 : core.fmt.Debug.Trait M}
    {ℋ_1 : core.fmt.Debug.Trait S}
    {ℋ_2 : core.fmt.Debug.Trait F}.
  
  Definition Self : Set := axum.serve.WithGracefulShutdown.t M S F.
  
  (*
      fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
          let Self {
              tcp_listener,
              make_service,
              signal,
              _marker: _,
          } = self;
  
          f.debug_struct("WithGracefulShutdown")
              .field("tcp_listener", tcp_listener)
              .field("make_service", make_service)
              .field("signal", signal)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_serve_WithGracefulShutdown_t_M_S_F.
End Impl_core_fmt_Debug_for_axum_serve_WithGracefulShutdown_t_M_S_F.

Module  Impl_core_future_into_future_IntoFuture_for_axum_serve_WithGracefulShutdown_t_M_S_F.
Section Impl_core_future_into_future_IntoFuture_for_axum_serve_WithGracefulShutdown_t_M_S_F.
  Context {M S F : Set}.
  
  Context
    {ℋ_0 :
      tower_service.Service.Trait M (Request := axum.serve.IncomingStream.t)}
    {ℋ_1 : core.marker.Send.Trait M}
    {ℋ_2 :
      core.marker.Send.Trait
          (tower_service.Service.Future (Self := M) (Trait := ltac:(refine _)))}
    {ℋ_3 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_4 : core.clone.Clone.Trait S}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Send.Trait S::type["Future"].t}
    {ℋ_7 : core.future.future.Future.Trait F}
    {ℋ_8 : core.marker.Send.Trait F}.
  
  Definition Self : Set := axum.serve.WithGracefulShutdown.t M S F.
  
  (*
      type Output = io::Result<()>;
  *)
  Definition Output : Set := ltac:(std.io.error.Result unit).
  
  (*
      type IntoFuture = private::ServeFuture;
  *)
  Definition IntoFuture : Set := axum.serve.private.ServeFuture.t.
  
  (*
      fn into_future(self) -> Self::IntoFuture {
          let Self {
              tcp_listener,
              mut make_service,
              signal,
              _marker: _,
          } = self;
  
          let (signal_tx, signal_rx) = watch::channel(());
          let signal_tx = Arc::new(signal_tx);
          tokio::spawn(async move {
              signal.await;
              trace!("received graceful shutdown signal. Telling tasks to shutdown");
              drop(signal_rx);
          });
  
          let (close_tx, close_rx) = watch::channel(());
  
          private::ServeFuture(Box::pin(async move {
              loop {
                  let (tcp_stream, remote_addr) = tokio::select! {
                      conn = tcp_accept(&tcp_listener) => {
                          match conn {
                              Some(conn) => conn,
                              None => continue,
                          }
                      }
                      _ = signal_tx.closed() => {
                          trace!("signal received, not accepting new connections");
                          break;
                      }
                  };
                  let tcp_stream = TokioIo::new(tcp_stream);
  
                  trace!("connection {remote_addr} accepted");
  
                  poll_fn(|cx| make_service.poll_ready(cx))
                      .await
                      .unwrap_or_else(|err| match err {});
  
                  let tower_service = make_service
                      .call(IncomingStream {
                          tcp_stream: &tcp_stream,
                          remote_addr,
                      })
                      .await
                      .unwrap_or_else(|err| match err {});
  
                  let hyper_service = TowerToHyperService {
                      service: tower_service,
                  };
  
                  let signal_tx = Arc::clone(&signal_tx);
  
                  let close_rx = close_rx.clone();
  
                  tokio::spawn(async move {
                      let builder = Builder::new(TokioExecutor::new());
                      let conn = builder.serve_connection_with_upgrades(tcp_stream, hyper_service);
                      pin_mut!(conn);
  
                      let signal_closed = signal_tx.closed().fuse();
                      pin_mut!(signal_closed);
  
                      loop {
                          tokio::select! {
                              result = conn.as_mut() => {
                                  if let Err(_err) = result {
                                      trace!("failed to serve connection: {_err:#}");
                                  }
                                  break;
                              }
                              _ = &mut signal_closed => {
                                  trace!("signal received in task, starting graceful shutdown");
                                  conn.as_mut().graceful_shutdown();
                              }
                          }
                      }
  
                      trace!("connection {remote_addr} closed");
  
                      drop(close_rx);
                  });
              }
  
              drop(close_rx);
              drop(tcp_listener);
  
              trace!(
                  "waiting for {} task(s) to finish",
                  close_tx.receiver_count()
              );
              close_tx.closed().await;
  
              Ok(())
          }))
      }
  *)
  Definition into_future (self : Self) : M IntoFuture :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_future :
    Notations.DoubleColon Self "into_future" := {
    Notations.double_colon := into_future;
  }.
  
  Global Instance ℐ : core.future.into_future.IntoFuture.Trait Self := {
    core.future.into_future.IntoFuture.Output := Output;
    core.future.into_future.IntoFuture.IntoFuture := IntoFuture;
    core.future.into_future.IntoFuture.into_future := into_future;
  }.
End Impl_core_future_into_future_IntoFuture_for_axum_serve_WithGracefulShutdown_t_M_S_F.
End Impl_core_future_into_future_IntoFuture_for_axum_serve_WithGracefulShutdown_t_M_S_F.

Module __tokio_select_util.
  Module Out.
    Inductive t (_0 : Set) (_1 : Set) : Set :=
    | _0 (_ : _0)
    | _1 (_ : _1)
    | Disabled.
    
    Definition Get__0_0 :=
      Ref.map
        (fun α => match α with | _0 α0 => Some α0 | _ => None end)
        (fun β α => match α with | _0 _ => Some (_0 β) | _ => None end).
    
    Definition Get__1_0 :=
      Ref.map
        (fun α => match α with | _1 α0 => Some α0 | _ => None end)
        (fun β α => match α with | _1 _ => Some (_1 β) | _ => None end).
  End Out.
  
  Ltac Mask := exact u8.t.
End __tokio_select_util.

Module Out.
  Inductive t (_0 : Set) (_1 : Set) : Set :=
  | _0 (_ : _0)
  | _1 (_ : _1)
  | Disabled.
  
  Definition Get__0_0 :=
    Ref.map
      (fun α => match α with | _0 α0 => Some α0 | _ => None end)
      (fun β α => match α with | _0 _ => Some (_0 β) | _ => None end).
  
  Definition Get__1_0 :=
    Ref.map
      (fun α => match α with | _1 α0 => Some α0 | _ => None end)
      (fun β α => match α with | _1 _ => Some (_1 β) | _ => None end).
End Out.

Ltac Mask := exact u8.t.

Definition BRANCHES : M.Val u32.t := M.run (M.pure foo).

(*
fn is_connection_error(e: &io::Error) -> bool {
    matches!(
        e.kind(),
        io::ErrorKind::ConnectionRefused
            | io::ErrorKind::ConnectionAborted
            | io::ErrorKind::ConnectionReset
    )
}
*)
Definition is_connection_error (e : ref std.io.error.Error.t) : M bool.t :=
  let* e := M.alloc e in
  M.read foo.

(*
async fn tcp_accept(listener: &TcpListener) -> Option<(TcpStream, SocketAddr)> {
    match listener.accept().await {
        Ok(conn) => Some(conn),
        Err(e) => {
            if is_connection_error(&e) {
                return None;
            }

            // [From `hyper::Server` in 0.14](https://github.com/hyperium/hyper/blob/v0.14.27/src/server/tcp.rs#L186)
            //
            // > A possible scenario is that the process has hit the max open files
            // > allowed, and so trying to accept a new connection will fail with
            // > `EMFILE`. In some cases, it's preferable to just wait for some time, if
            // > the application will likely close some files (or connections), and try
            // > to accept the connection again. If this option is `true`, the error
            // > will be logged at the `error` level, since it is still a big deal,
            // > and then the listener will sleep for 1 second.
            //
            // hyper allowed customizing this but axum does not.
            error!("accept error: {e}");
            tokio::time::sleep(Duration::from_secs(1)).await;
            None
        }
    }
}
*)
Definition tcp_accept
    (listener : ref tokio.net.tcp.listener.TcpListener.t)
    : M OpaqueDef :=
  let* listener := M.alloc listener in
  M.read foo.

Module Wrap_private_2.
Module private.
  Module  ServeFuture.
  Section ServeFuture.
    Record t : Set := {
      x0 : ltac:(futures_core.future.BoxFuture ltac:(std.io.error.Result unit));
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End ServeFuture.
  End ServeFuture.
  
  Module  Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.
  Section Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.
    Definition Self : Set := axum.serve.private.ServeFuture.t.
    
    (*
            type Output = io::Result<()>;
    *)
    Definition Output : Set := ltac:(std.io.error.Result unit).
    
    (*
            fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
                self.0.as_mut().poll(cx)
            }
    *)
    Definition poll
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t Output) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll :
      Notations.DoubleColon Self "poll" := {
      Notations.double_colon := poll;
    }.
    
    Global Instance ℐ : core.future.future.Future.Trait Self := {
      core.future.future.Future.Output := Output;
      core.future.future.Future.poll := poll;
    }.
  End Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.
  End Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.
  
  Module  Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.
  Section Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.
    Definition Self : Set := axum.serve.private.ServeFuture.t.
    
    (*
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.debug_struct("ServeFuture").finish_non_exhaustive()
            }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.
  End Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.
End private.
End Wrap_private_2.
Import Wrap_private_2.

Module  ServeFuture.
Section ServeFuture.
  Record t : Set := {
    x0 : ltac:(futures_core.future.BoxFuture ltac:(std.io.error.Result unit));
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End ServeFuture.
End ServeFuture.

Module  Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.
Section Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.
  Definition Self : Set := axum.serve.private.ServeFuture.t.
  
  (*
          type Output = io::Result<()>;
  *)
  Definition Output : Set := ltac:(std.io.error.Result unit).
  
  (*
          fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
              self.0.as_mut().poll(cx)
          }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.
End Impl_core_future_future_Future_for_axum_serve_private_ServeFuture_t.

Module  Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.
Section Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.
  Definition Self : Set := axum.serve.private.ServeFuture.t.
  
  (*
          fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
              f.debug_struct("ServeFuture").finish_non_exhaustive()
          }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.
End Impl_core_fmt_Debug_for_axum_serve_private_ServeFuture_t.

Module  TowerToHyperService.
Section TowerToHyperService.
  Context (S : Set).
  
  Record t : Set := {
    service : S;
  }.
  
  Definition Get_service :=
    Ref.map
      (fun α => Some α.(service))
      (fun β α => Some (α <| service := β |>)).
End TowerToHyperService.
End TowerToHyperService.

Module  Impl_core_fmt_Debug_for_axum_serve_TowerToHyperService_t_S.
Section Impl_core_fmt_Debug_for_axum_serve_TowerToHyperService_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set := axum.serve.TowerToHyperService.t S.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_serve_TowerToHyperService_t_S.
End Impl_core_fmt_Debug_for_axum_serve_TowerToHyperService_t_S.

Module  Impl_core_marker_Copy_for_axum_serve_TowerToHyperService_t_S.
Section Impl_core_marker_Copy_for_axum_serve_TowerToHyperService_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait S}.
  
  Definition Self : Set := axum.serve.TowerToHyperService.t S.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_serve_TowerToHyperService_t_S.
End Impl_core_marker_Copy_for_axum_serve_TowerToHyperService_t_S.

Module  Impl_core_clone_Clone_for_axum_serve_TowerToHyperService_t_S.
Section Impl_core_clone_Clone_for_axum_serve_TowerToHyperService_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.serve.TowerToHyperService.t S.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M (axum.serve.TowerToHyperService.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_serve_TowerToHyperService_t_S.
End Impl_core_clone_Clone_for_axum_serve_TowerToHyperService_t_S.

Module  Impl_hyper_service_service_Service_axum_core_extract_Request_hyper_body_incoming_Incoming_t_for_axum_serve_TowerToHyperService_t_S.
Section Impl_hyper_service_service_Service_axum_core_extract_Request_hyper_body_incoming_Incoming_t_for_axum_serve_TowerToHyperService_t_S.
  Context {S : Set}.
  
  Context
    {ℋ_0 :
      tower_service.Service.Trait S
        (Request := ltac:(axum_core.extract.Request
          axum_core.extract.Request.Default.T))}
    {ℋ_1 : core.clone.Clone.Trait S}.
  
  Definition Self : Set := axum.serve.TowerToHyperService.t S.
  
  (*
      type Response = S::Response;
  *)
  Definition Response : Set := S::type["Response"].t.
  
  (*
      type Error = S::Error;
  *)
  Definition Error : Set := S::type["Error"].t.
  
  (*
      type Future = TowerToHyperServiceFuture<S, Request>;
  *)
  Definition Future : Set :=
    axum.serve.TowerToHyperServiceFuture.t
        S
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T).
  
  (*
      fn call(&self, req: Request<Incoming>) -> Self::Future {
          let req = req.map(Body::new);
          TowerToHyperServiceFuture {
              future: self.service.clone().oneshot(req),
          }
      }
  *)
  Definition call
      (self : ref Self)
      (req : ltac:(axum_core.extract.Request hyper.body.incoming.Incoming.t))
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    hyper.service.service.Service.Trait Self
      (Request := ltac:(axum_core.extract.Request
        hyper.body.incoming.Incoming.t)) := {
    hyper.service.service.Service.Response := Response;
    hyper.service.service.Service.Error := Error;
    hyper.service.service.Service.Future := Future;
    hyper.service.service.Service.call := call;
  }.
End Impl_hyper_service_service_Service_axum_core_extract_Request_hyper_body_incoming_Incoming_t_for_axum_serve_TowerToHyperService_t_S.
End Impl_hyper_service_service_Service_axum_core_extract_Request_hyper_body_incoming_Incoming_t_for_axum_serve_TowerToHyperService_t_S.

Module  TowerToHyperServiceFuture.
Section TowerToHyperServiceFuture.
  Context (S R : Set).
  
  Context {ℋ_0 : tower_service.Service.Trait S (Request := R)}.
  Record t : Set := {
    future : tower.util.oneshot.Oneshot.t S R;
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End TowerToHyperServiceFuture.
End TowerToHyperServiceFuture.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Context (S R : Set).
  
  Context {ℋ_0 : tower_service.Service.Trait S (Request := R)}.
  Record t : Set := {
    future : core.pin.Pin.t (mut_ref (tower.util.oneshot.Oneshot.t S R));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Context (S R : Set).
  
  Context {ℋ_0 : tower_service.Service.Trait S (Request := R)}.
  Record t : Set := {
    future : core.pin.Pin.t (ref (tower.util.oneshot.Oneshot.t S R));
  }.
  
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_serve_TowerToHyperServiceFuture_t_S_R.
Section Impl_axum_serve_TowerToHyperServiceFuture_t_S_R.
  Context {S R : Set}.
  
  Definition Self : Set := axum.serve.TowerToHyperServiceFuture.t S R.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum.serve._.Projection.t S R) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M (axum.serve._.ProjectionRef.t S R) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_serve_TowerToHyperServiceFuture_t_S_R.
End Impl_axum_serve_TowerToHyperServiceFuture_t_S_R.

Module  __Origin.
Section __Origin.
  Context (S R : Set).
  
  Context {ℋ_0 : tower_service.Service.Trait S (Request := R)}.
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    future : tower.util.oneshot.Oneshot.t S R;
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_future :=
    Ref.map (fun α => Some α.(future)) (fun β α => Some (α <| future := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
Section Impl_core_marker_Unpin_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
  Context {S R : Set}.
  
  Context
    {ℋ_0 : core.marker.Unpin.Trait (axum.serve._.__Origin.t S R)}
    {ℋ_1 : tower_service.Service.Trait S (Request := R)}.
  
  Definition Self : Set := axum.serve.TowerToHyperServiceFuture.t S R.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
End Impl_core_marker_Unpin_for_axum_serve_TowerToHyperServiceFuture_t_S_R.

Module  Impl_axum_serve___MustNotImplDrop_for_T.
Section Impl_axum_serve___MustNotImplDrop_for_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.ops.drop.Drop.Trait T}.
  
  Definition Self : Set := T.
  
  Global Instance ℐ : axum.serve._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_serve___MustNotImplDrop_for_T.
End Impl_axum_serve___MustNotImplDrop_for_T.

Module  Impl_axum_serve___MustNotImplDrop_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
Section Impl_axum_serve___MustNotImplDrop_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
  Context {S R : Set}.
  
  Context {ℋ_0 : tower_service.Service.Trait S (Request := R)}.
  
  Definition Self : Set := axum.serve.TowerToHyperServiceFuture.t S R.
  
  Global Instance ℐ : axum.serve._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_serve___MustNotImplDrop_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
End Impl_axum_serve___MustNotImplDrop_for_axum_serve_TowerToHyperServiceFuture_t_S_R.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    {S R : Set}
    {ℋ_0 : tower_service.Service.Trait S (Request := R)}
    (this : ref (axum.serve.TowerToHyperServiceFuture.t S R))
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module  Impl_core_future_future_Future_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
Section Impl_core_future_future_Future_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
  Context {S R : Set}.
  
  Context {ℋ_0 : tower_service.Service.Trait S (Request := R)}.
  
  Definition Self : Set := axum.serve.TowerToHyperServiceFuture.t S R.
  
  (*
      type Output = Result<S::Response, S::Error>;
  *)
  Definition Output : Set :=
    core.result.Result.t S::type["Response"].t S::type["Error"].t.
  
  (*
      fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
          self.project().future.poll(cx)
      }
  *)
  Definition poll
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t Output) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll :
    Notations.DoubleColon Self "poll" := {
    Notations.double_colon := poll;
  }.
  
  Global Instance ℐ : core.future.future.Future.Trait Self := {
    core.future.future.Future.Output := Output;
    core.future.future.Future.poll := poll;
  }.
End Impl_core_future_future_Future_for_axum_serve_TowerToHyperServiceFuture_t_S_R.
End Impl_core_future_future_Future_for_axum_serve_TowerToHyperServiceFuture_t_S_R.

Module  IncomingStream.
Section IncomingStream.
  Record t : Set := {
    tcp_stream :
      ref (hyper_util.rt.tokio.TokioIo.t tokio.net.tcp.stream.TcpStream.t);
    remote_addr : core.net.socket_addr.SocketAddr.t;
  }.
  
  Definition Get_tcp_stream :=
    Ref.map
      (fun α => Some α.(tcp_stream))
      (fun β α => Some (α <| tcp_stream := β |>)).
  Definition Get_remote_addr :=
    Ref.map
      (fun α => Some α.(remote_addr))
      (fun β α => Some (α <| remote_addr := β |>)).
End IncomingStream.
End IncomingStream.

Module  Impl_core_fmt_Debug_for_axum_serve_IncomingStream_t.
Section Impl_core_fmt_Debug_for_axum_serve_IncomingStream_t.
  Definition Self : Set := axum.serve.IncomingStream.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_serve_IncomingStream_t.
End Impl_core_fmt_Debug_for_axum_serve_IncomingStream_t.

Module  Impl_axum_serve_IncomingStream_t_2.
Section Impl_axum_serve_IncomingStream_t_2.
  Definition Self : Set := axum.serve.IncomingStream.t.
  
  (*
      pub fn local_addr(&self) -> std::io::Result<SocketAddr> {
          self.tcp_stream.inner().local_addr()
      }
  *)
  Definition local_addr
      (self : ref Self)
      : M ltac:(std.io.error.Result core.net.socket_addr.SocketAddr.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_local_addr :
    Notations.DoubleColon Self "local_addr" := {
    Notations.double_colon := local_addr;
  }.
  
  (*
      pub fn remote_addr(&self) -> SocketAddr {
          self.remote_addr
      }
  *)
  Definition remote_addr
      (self : ref Self)
      : M core.net.socket_addr.SocketAddr.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_remote_addr :
    Notations.DoubleColon Self "remote_addr" := {
    Notations.double_colon := remote_addr;
  }.
End Impl_axum_serve_IncomingStream_t_2.
End Impl_axum_serve_IncomingStream_t_2.
