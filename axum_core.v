(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module error.
  Module  Error.
  Section Error.
    Record t : Set := {
      inner : ltac:(axum_core.BoxError);
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  End Error.
  End Error.
  
  Module  Impl_core_fmt_Debug_for_axum_core_error_Error_t.
  Section Impl_core_fmt_Debug_for_axum_core_error_Error_t.
    Definition Self : Set := axum_core.error.Error.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_error_Error_t.
  End Impl_core_fmt_Debug_for_axum_core_error_Error_t.
  
  Module  Impl_axum_core_error_Error_t.
  Section Impl_axum_core_error_Error_t.
    Definition Self : Set := axum_core.error.Error.t.
    
    (*
        pub fn new(error: impl Into<BoxError>) -> Self {
            Self {
                inner: error.into(),
            }
        }
    *)
    Definition new
        {impl Into<BoxError> : Set}
        {ℋ_0 :
          core.convert.Into.Trait impl Into<BoxError>
            (T := ltac:(axum_core.BoxError))}
        (error : impl Into<BoxError>)
        : M Self :=
      let* error := M.alloc error in
      M.read foo.
    
    Global Instance AssociatedFunction_new
        {impl Into<BoxError> : Set}
        {ℋ_0 :
          core.convert.Into.Trait impl Into<BoxError>
            (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon :=
        new (impl Into<BoxError> := impl Into<BoxError>);
    }.
    
    (*
        pub fn into_inner(self) -> BoxError {
            self.inner
        }
    *)
    Definition into_inner (self : Self) : M ltac:(axum_core.BoxError) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_inner :
      Notations.DoubleColon Self "into_inner" := {
      Notations.double_colon := into_inner;
    }.
  End Impl_axum_core_error_Error_t.
  End Impl_axum_core_error_Error_t.
  
  Module  Impl_core_fmt_Display_for_axum_core_error_Error_t.
  Section Impl_core_fmt_Display_for_axum_core_error_Error_t.
    Definition Self : Set := axum_core.error.Error.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.inner.fmt(f)
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_core_error_Error_t.
  End Impl_core_fmt_Display_for_axum_core_error_Error_t.
  
  Module  Impl_core_error_Error_for_axum_core_error_Error_t.
  Section Impl_core_error_Error_for_axum_core_error_Error_t.
    Definition Self : Set := axum_core.error.Error.t.
    
    (*
        fn source(&self) -> Option<&(dyn StdError + 'static)> {
            Some(&*self.inner)
        }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_core_error_Error_t.
  End Impl_core_error_Error_for_axum_core_error_Error_t.
End error.

Module  Error.
Section Error.
  Record t : Set := {
    inner : ltac:(axum_core.BoxError);
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
End Error.
End Error.

Module  Impl_core_fmt_Debug_for_axum_core_error_Error_t.
Section Impl_core_fmt_Debug_for_axum_core_error_Error_t.
  Definition Self : Set := axum_core.error.Error.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_error_Error_t.
End Impl_core_fmt_Debug_for_axum_core_error_Error_t.

Module  Impl_axum_core_error_Error_t_2.
Section Impl_axum_core_error_Error_t_2.
  Definition Self : Set := axum_core.error.Error.t.
  
  (*
      pub fn new(error: impl Into<BoxError>) -> Self {
          Self {
              inner: error.into(),
          }
      }
  *)
  Definition new
      {impl Into<BoxError> : Set}
      {ℋ_0 :
        core.convert.Into.Trait impl Into<BoxError>
          (T := ltac:(axum_core.BoxError))}
      (error : impl Into<BoxError>)
      : M Self :=
    let* error := M.alloc error in
    M.read foo.
  
  Global Instance AssociatedFunction_new
      {impl Into<BoxError> : Set}
      {ℋ_0 :
        core.convert.Into.Trait impl Into<BoxError>
          (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "new" := {
    Notations.double_colon := new (impl Into<BoxError> := impl Into<BoxError>);
  }.
  
  (*
      pub fn into_inner(self) -> BoxError {
          self.inner
      }
  *)
  Definition into_inner (self : Self) : M ltac:(axum_core.BoxError) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_inner :
    Notations.DoubleColon Self "into_inner" := {
    Notations.double_colon := into_inner;
  }.
End Impl_axum_core_error_Error_t_2.
End Impl_axum_core_error_Error_t_2.

Module  Impl_core_fmt_Display_for_axum_core_error_Error_t.
Section Impl_core_fmt_Display_for_axum_core_error_Error_t.
  Definition Self : Set := axum_core.error.Error.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          self.inner.fmt(f)
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_core_error_Error_t.
End Impl_core_fmt_Display_for_axum_core_error_Error_t.

Module  Impl_core_error_Error_for_axum_core_error_Error_t.
Section Impl_core_error_Error_for_axum_core_error_Error_t.
  Definition Self : Set := axum_core.error.Error.t.
  
  (*
      fn source(&self) -> Option<&(dyn StdError + 'static)> {
          Some(&*self.inner)
      }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_core_error_Error_t.
End Impl_core_error_Error_for_axum_core_error_Error_t.

Module ext_traits.
  Module request.
    Module sealed.
      Module  Sealed.
      Section Sealed.
        Unset Primitive Projections.
        Class Trait (Self : Set) : Type := {
        }.
        Global Set Primitive Projections.
      End Sealed.
      End Sealed.
      
      Module  Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
      Section Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
        Definition Self : Set := http.request.Request.t axum_core.body.Body.t.
        
        Global Instance ℐ :
          axum_core.ext_traits.request.sealed.Sealed.Trait Self := {
        }.
      End Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
      End Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
    End sealed.
    
    Module  RequestExt.
    Section RequestExt.
      Class Trait (Self : Set) : Type := {
        ℒ_0 :: axum_core.ext_traits.request.sealed.Sealed.Trait Self;
        extract
          {E M : Set}
          {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)} :
          Self ->
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t));
        extract_with_state
          {E S M : Set}
          {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
          Self ->
            (ref S) ->
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t));
        extract_parts
          {E : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
          (mut_ref Self) ->
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t));
        extract_parts_with_state
          {E S : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
          (mut_ref Self) ->
            (ref S) ->
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t));
        with_limited_body :
          Self ->
            M
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T);
        into_limited_body : Self -> M axum_core.body.Body.t;
      }.
      
    End RequestExt.
    End RequestExt.
    
    Module  Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
    Section Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
      Definition Self : Set :=
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T).
      
      (*
          fn extract<E, M>(self) -> BoxFuture<'static, Result<E, E::Rejection>>
          where
              E: FromRequest<(), M> + 'static,
              M: 'static,
          {
              self.extract_with_state(&())
          }
      *)
      Definition extract
          {E M : Set}
          {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)}
          (self : Self)
          :
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t)) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_extract
          {E M : Set}
          {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)} :
        Notations.DoubleColon Self "extract" := {
        Notations.double_colon := extract (E := E) (M := M);
      }.
      
      (*
          fn extract_with_state<E, S, M>(self, state: &S) -> BoxFuture<'_, Result<E, E::Rejection>>
          where
              E: FromRequest<S, M> + 'static,
              S: Send + Sync,
          {
              E::from_request(self, state)
          }
      *)
      Definition extract_with_state
          {E S M : Set}
          {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : Self)
          (state : ref S)
          :
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t)) :=
        let* self := M.alloc self in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_extract_with_state
          {E S M : Set}
          {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "extract_with_state" := {
        Notations.double_colon := extract_with_state (E := E) (S := S) (M := M);
      }.
      
      (*
          fn extract_parts<E>(&mut self) -> BoxFuture<'_, Result<E, E::Rejection>>
          where
              E: FromRequestParts<()> + 'static,
          {
              self.extract_parts_with_state(&())
          }
      *)
      Definition extract_parts
          {E : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)}
          (self : mut_ref Self)
          :
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t)) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_extract_parts
          {E : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
        Notations.DoubleColon Self "extract_parts" := {
        Notations.double_colon := extract_parts (E := E);
      }.
      
      (*
          fn extract_parts_with_state<'a, E, S>(
              &'a mut self,
              state: &'a S,
          ) -> BoxFuture<'a, Result<E, E::Rejection>>
          where
              E: FromRequestParts<S> + 'static,
              S: Send + Sync,
          {
              let mut req = Request::new(());
              *req.version_mut() = self.version();
              *req.method_mut() = self.method().clone();
              *req.uri_mut() = self.uri().clone();
              *req.headers_mut() = std::mem::take(self.headers_mut());
              *req.extensions_mut() = std::mem::take(self.extensions_mut());
              let (mut parts, ()) = req.into_parts();
      
              Box::pin(async move {
                  let result = E::from_request_parts(&mut parts, state).await;
      
                  *self.version_mut() = parts.version;
                  *self.method_mut() = parts.method.clone();
                  *self.uri_mut() = parts.uri.clone();
                  *self.headers_mut() = std::mem::take(&mut parts.headers);
                  *self.extensions_mut() = std::mem::take(&mut parts.extensions);
      
                  result
              })
          }
      *)
      Definition extract_parts_with_state
          {E S : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : mut_ref Self)
          (state : ref S)
          :
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t)) :=
        let* self := M.alloc self in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_extract_parts_with_state
          {E S : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "extract_parts_with_state" := {
        Notations.double_colon := extract_parts_with_state (E := E) (S := S);
      }.
      
      (*
          fn with_limited_body(self) -> Request {
              // update docs in `axum-core/src/extract/default_body_limit.rs` and
              // `axum/src/docs/extract.md` if this changes
              const DEFAULT_LIMIT: usize = 2_097_152; // 2 mb
      
              match self.extensions().get::<DefaultBodyLimitKind>().copied() {
                  Some(DefaultBodyLimitKind::Disable) => self,
                  Some(DefaultBodyLimitKind::Limit(limit)) => {
                      self.map(|b| Body::new(http_body_util::Limited::new(b, limit)))
                  }
                  None => self.map(|b| Body::new(http_body_util::Limited::new(b, DEFAULT_LIMIT))),
              }
          }
      *)
      Definition with_limited_body
          (self : Self)
          :
            M
              ltac:(axum_core.extract.Request
                axum_core.extract.Request.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_with_limited_body :
        Notations.DoubleColon Self "with_limited_body" := {
        Notations.double_colon := with_limited_body;
      }.
      
      (*
          fn into_limited_body(self) -> Body {
              self.with_limited_body().into_body()
          }
      *)
      Definition into_limited_body (self : Self) : M axum_core.body.Body.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_limited_body :
        Notations.DoubleColon Self "into_limited_body" := {
        Notations.double_colon := into_limited_body;
      }.
      
      Global Instance ℐ :
        axum_core.ext_traits.request.RequestExt.Trait Self := {
        axum_core.ext_traits.request.RequestExt.extract
          {E M : Set}
          {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)} :=
          extract (E := E) (M := M);
        axum_core.ext_traits.request.RequestExt.extract_with_state
          {E S M : Set}
          {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :=
          extract_with_state (E := E) (S := S) (M := M);
        axum_core.ext_traits.request.RequestExt.extract_parts
          {E : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :=
          extract_parts (E := E);
        axum_core.ext_traits.request.RequestExt.extract_parts_with_state
          {E S : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :=
          extract_parts_with_state (E := E) (S := S);
        axum_core.ext_traits.request.RequestExt.with_limited_body :=
          with_limited_body;
        axum_core.ext_traits.request.RequestExt.into_limited_body :=
          into_limited_body;
      }.
    End Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
    End Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
  End request.
  
  Module request_parts.
    Module sealed.
      Module  Sealed.
      Section Sealed.
        Unset Primitive Projections.
        Class Trait (Self : Set) : Type := {
        }.
        Global Set Primitive Projections.
      End Sealed.
      End Sealed.
      
      Module  Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
      Section Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
        Definition Self : Set := http.request.Parts.t.
        
        Global Instance ℐ :
          axum_core.ext_traits.request_parts.sealed.Sealed.Trait Self := {
        }.
      End Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
      End Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
    End sealed.
    
    Module  RequestPartsExt.
    Section RequestPartsExt.
      Class Trait (Self : Set) : Type := {
        ℒ_0 :: axum_core.ext_traits.request_parts.sealed.Sealed.Trait Self;
        extract
          {E : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
          (mut_ref Self) ->
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t));
        extract_with_state
          {E S : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
          (mut_ref Self) ->
            (ref S) ->
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t));
      }.
      
    End RequestPartsExt.
    End RequestPartsExt.
    
    Module  Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.
    Section Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.
      Definition Self : Set := http.request.Parts.t.
      
      (*
          fn extract<E>(&mut self) -> BoxFuture<'_, Result<E, E::Rejection>>
          where
              E: FromRequestParts<()> + 'static,
          {
              self.extract_with_state(&())
          }
      *)
      Definition extract
          {E : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)}
          (self : mut_ref Self)
          :
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t)) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_extract
          {E : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
        Notations.DoubleColon Self "extract" := {
        Notations.double_colon := extract (E := E);
      }.
      
      (*
          fn extract_with_state<'a, E, S>(
              &'a mut self,
              state: &'a S,
          ) -> BoxFuture<'a, Result<E, E::Rejection>>
          where
              E: FromRequestParts<S> + 'static,
              S: Send + Sync,
          {
              E::from_request_parts(self, state)
          }
      *)
      Definition extract_with_state
          {E S : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S}
          (self : mut_ref Self)
          (state : ref S)
          :
            M
              ltac:(futures_core.future.BoxFuture
                (core.result.Result.t E E::type["Rejection"].t)) :=
        let* self := M.alloc self in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_extract_with_state
          {E S : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :
        Notations.DoubleColon Self "extract_with_state" := {
        Notations.double_colon := extract_with_state (E := E) (S := S);
      }.
      
      Global Instance ℐ :
        axum_core.ext_traits.request_parts.RequestPartsExt.Trait Self := {
        axum_core.ext_traits.request_parts.RequestPartsExt.extract
          {E : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :=
          extract (E := E);
        axum_core.ext_traits.request_parts.RequestPartsExt.extract_with_state
          {E S : Set}
          {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
          {ℋ_1 : core.marker.Send.Trait S}
          {ℋ_2 : core.marker.Sync.Trait S} :=
          extract_with_state (E := E) (S := S);
      }.
    End Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.
    End Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.
  End request_parts.
End ext_traits.

Module request.
  Module sealed.
    Module  Sealed.
    Section Sealed.
      Unset Primitive Projections.
      Class Trait (Self : Set) : Type := {
      }.
      Global Set Primitive Projections.
    End Sealed.
    End Sealed.
    
    Module  Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
    Section Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
      Definition Self : Set := http.request.Request.t axum_core.body.Body.t.
      
      Global Instance ℐ :
        axum_core.ext_traits.request.sealed.Sealed.Trait Self := {
      }.
    End Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
    End Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
  End sealed.
  
  Module  RequestExt.
  Section RequestExt.
    Class Trait (Self : Set) : Type := {
      ℒ_0 :: axum_core.ext_traits.request.sealed.Sealed.Trait Self;
      extract
        {E M : Set}
        {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)} :
        Self ->
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t));
      extract_with_state
        {E S M : Set}
        {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
        Self ->
          (ref S) ->
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t));
      extract_parts
        {E : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
        (mut_ref Self) ->
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t));
      extract_parts_with_state
        {E S : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
        (mut_ref Self) ->
          (ref S) ->
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t));
      with_limited_body :
        Self ->
          M
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T);
      into_limited_body : Self -> M axum_core.body.Body.t;
    }.
    
  End RequestExt.
  End RequestExt.
  
  Module  Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
  Section Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
    Definition Self : Set :=
      ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T).
    
    (*
        fn extract<E, M>(self) -> BoxFuture<'static, Result<E, E::Rejection>>
        where
            E: FromRequest<(), M> + 'static,
            M: 'static,
        {
            self.extract_with_state(&())
        }
    *)
    Definition extract
        {E M : Set}
        {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)}
        (self : Self)
        :
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_extract
        {E M : Set}
        {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)} :
      Notations.DoubleColon Self "extract" := {
      Notations.double_colon := extract (E := E) (M := M);
    }.
    
    (*
        fn extract_with_state<E, S, M>(self, state: &S) -> BoxFuture<'_, Result<E, E::Rejection>>
        where
            E: FromRequest<S, M> + 'static,
            S: Send + Sync,
        {
            E::from_request(self, state)
        }
    *)
    Definition extract_with_state
        {E S M : Set}
        {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : Self)
        (state : ref S)
        :
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t)) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_extract_with_state
        {E S M : Set}
        {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "extract_with_state" := {
      Notations.double_colon := extract_with_state (E := E) (S := S) (M := M);
    }.
    
    (*
        fn extract_parts<E>(&mut self) -> BoxFuture<'_, Result<E, E::Rejection>>
        where
            E: FromRequestParts<()> + 'static,
        {
            self.extract_parts_with_state(&())
        }
    *)
    Definition extract_parts
        {E : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)}
        (self : mut_ref Self)
        :
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_extract_parts
        {E : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
      Notations.DoubleColon Self "extract_parts" := {
      Notations.double_colon := extract_parts (E := E);
    }.
    
    (*
        fn extract_parts_with_state<'a, E, S>(
            &'a mut self,
            state: &'a S,
        ) -> BoxFuture<'a, Result<E, E::Rejection>>
        where
            E: FromRequestParts<S> + 'static,
            S: Send + Sync,
        {
            let mut req = Request::new(());
            *req.version_mut() = self.version();
            *req.method_mut() = self.method().clone();
            *req.uri_mut() = self.uri().clone();
            *req.headers_mut() = std::mem::take(self.headers_mut());
            *req.extensions_mut() = std::mem::take(self.extensions_mut());
            let (mut parts, ()) = req.into_parts();
    
            Box::pin(async move {
                let result = E::from_request_parts(&mut parts, state).await;
    
                *self.version_mut() = parts.version;
                *self.method_mut() = parts.method.clone();
                *self.uri_mut() = parts.uri.clone();
                *self.headers_mut() = std::mem::take(&mut parts.headers);
                *self.extensions_mut() = std::mem::take(&mut parts.extensions);
    
                result
            })
        }
    *)
    Definition extract_parts_with_state
        {E S : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : mut_ref Self)
        (state : ref S)
        :
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t)) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_extract_parts_with_state
        {E S : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "extract_parts_with_state" := {
      Notations.double_colon := extract_parts_with_state (E := E) (S := S);
    }.
    
    (*
        fn with_limited_body(self) -> Request {
            // update docs in `axum-core/src/extract/default_body_limit.rs` and
            // `axum/src/docs/extract.md` if this changes
            const DEFAULT_LIMIT: usize = 2_097_152; // 2 mb
    
            match self.extensions().get::<DefaultBodyLimitKind>().copied() {
                Some(DefaultBodyLimitKind::Disable) => self,
                Some(DefaultBodyLimitKind::Limit(limit)) => {
                    self.map(|b| Body::new(http_body_util::Limited::new(b, limit)))
                }
                None => self.map(|b| Body::new(http_body_util::Limited::new(b, DEFAULT_LIMIT))),
            }
        }
    *)
    Definition with_limited_body
        (self : Self)
        :
          M
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_with_limited_body :
      Notations.DoubleColon Self "with_limited_body" := {
      Notations.double_colon := with_limited_body;
    }.
    
    (*
        fn into_limited_body(self) -> Body {
            self.with_limited_body().into_body()
        }
    *)
    Definition into_limited_body (self : Self) : M axum_core.body.Body.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_limited_body :
      Notations.DoubleColon Self "into_limited_body" := {
      Notations.double_colon := into_limited_body;
    }.
    
    Global Instance ℐ : axum_core.ext_traits.request.RequestExt.Trait Self := {
      axum_core.ext_traits.request.RequestExt.extract
        {E M : Set}
        {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)} :=
        extract (E := E) (M := M);
      axum_core.ext_traits.request.RequestExt.extract_with_state
        {E S M : Set}
        {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :=
        extract_with_state (E := E) (S := S) (M := M);
      axum_core.ext_traits.request.RequestExt.extract_parts
        {E : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :=
        extract_parts (E := E);
      axum_core.ext_traits.request.RequestExt.extract_parts_with_state
        {E S : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :=
        extract_parts_with_state (E := E) (S := S);
      axum_core.ext_traits.request.RequestExt.with_limited_body :=
        with_limited_body;
      axum_core.ext_traits.request.RequestExt.into_limited_body :=
        into_limited_body;
    }.
  End Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
  End Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
End request.

Module sealed.
  Module  Sealed.
  Section Sealed.
    Unset Primitive Projections.
    Class Trait (Self : Set) : Type := {
    }.
    Global Set Primitive Projections.
  End Sealed.
  End Sealed.
  
  Module  Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
  Section Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
    Definition Self : Set := http.request.Request.t axum_core.body.Body.t.
    
    Global Instance ℐ :
      axum_core.ext_traits.request.sealed.Sealed.Trait Self := {
    }.
  End Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
  End Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
End sealed.

Module  Sealed.
Section Sealed.
  Unset Primitive Projections.
  Class Trait (Self : Set) : Type := {
  }.
  Global Set Primitive Projections.
End Sealed.
End Sealed.

Module  Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
Section Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
  Definition Self : Set := http.request.Request.t axum_core.body.Body.t.
  
  Global Instance ℐ : axum_core.ext_traits.request.sealed.Sealed.Trait Self := {
  }.
End Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.
End Impl_axum_core_ext_traits_request_sealed_Sealed_for_http_request_Request_t_axum_core_body_Body_t.

Module  RequestExt.
Section RequestExt.
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: axum_core.ext_traits.request.sealed.Sealed.Trait Self;
    extract
      {E M : Set}
      {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)} :
      Self ->
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t));
    extract_with_state
      {E S M : Set}
      {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
      Self ->
        (ref S) ->
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t));
    extract_parts
      {E : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
      (mut_ref Self) ->
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t));
    extract_parts_with_state
      {E S : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
      (mut_ref Self) ->
        (ref S) ->
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t));
    with_limited_body :
      Self ->
        M ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T);
    into_limited_body : Self -> M axum_core.body.Body.t;
  }.
  
End RequestExt.
End RequestExt.

Module  Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
Section Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
  Definition Self : Set :=
    ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T).
  
  (*
      fn extract<E, M>(self) -> BoxFuture<'static, Result<E, E::Rejection>>
      where
          E: FromRequest<(), M> + 'static,
          M: 'static,
      {
          self.extract_with_state(&())
      }
  *)
  Definition extract
      {E M : Set}
      {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)}
      (self : Self)
      :
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_extract
      {E M : Set}
      {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)} :
    Notations.DoubleColon Self "extract" := {
    Notations.double_colon := extract (E := E) (M := M);
  }.
  
  (*
      fn extract_with_state<E, S, M>(self, state: &S) -> BoxFuture<'_, Result<E, E::Rejection>>
      where
          E: FromRequest<S, M> + 'static,
          S: Send + Sync,
      {
          E::from_request(self, state)
      }
  *)
  Definition extract_with_state
      {E S M : Set}
      {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : Self)
      (state : ref S)
      :
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t)) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_extract_with_state
      {E S M : Set}
      {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "extract_with_state" := {
    Notations.double_colon := extract_with_state (E := E) (S := S) (M := M);
  }.
  
  (*
      fn extract_parts<E>(&mut self) -> BoxFuture<'_, Result<E, E::Rejection>>
      where
          E: FromRequestParts<()> + 'static,
      {
          self.extract_parts_with_state(&())
      }
  *)
  Definition extract_parts
      {E : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)}
      (self : mut_ref Self)
      :
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_extract_parts
      {E : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
    Notations.DoubleColon Self "extract_parts" := {
    Notations.double_colon := extract_parts (E := E);
  }.
  
  (*
      fn extract_parts_with_state<'a, E, S>(
          &'a mut self,
          state: &'a S,
      ) -> BoxFuture<'a, Result<E, E::Rejection>>
      where
          E: FromRequestParts<S> + 'static,
          S: Send + Sync,
      {
          let mut req = Request::new(());
          *req.version_mut() = self.version();
          *req.method_mut() = self.method().clone();
          *req.uri_mut() = self.uri().clone();
          *req.headers_mut() = std::mem::take(self.headers_mut());
          *req.extensions_mut() = std::mem::take(self.extensions_mut());
          let (mut parts, ()) = req.into_parts();
  
          Box::pin(async move {
              let result = E::from_request_parts(&mut parts, state).await;
  
              *self.version_mut() = parts.version;
              *self.method_mut() = parts.method.clone();
              *self.uri_mut() = parts.uri.clone();
              *self.headers_mut() = std::mem::take(&mut parts.headers);
              *self.extensions_mut() = std::mem::take(&mut parts.extensions);
  
              result
          })
      }
  *)
  Definition extract_parts_with_state
      {E S : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : mut_ref Self)
      (state : ref S)
      :
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t)) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_extract_parts_with_state
      {E S : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "extract_parts_with_state" := {
    Notations.double_colon := extract_parts_with_state (E := E) (S := S);
  }.
  
  (*
      fn with_limited_body(self) -> Request {
          // update docs in `axum-core/src/extract/default_body_limit.rs` and
          // `axum/src/docs/extract.md` if this changes
          const DEFAULT_LIMIT: usize = 2_097_152; // 2 mb
  
          match self.extensions().get::<DefaultBodyLimitKind>().copied() {
              Some(DefaultBodyLimitKind::Disable) => self,
              Some(DefaultBodyLimitKind::Limit(limit)) => {
                  self.map(|b| Body::new(http_body_util::Limited::new(b, limit)))
              }
              None => self.map(|b| Body::new(http_body_util::Limited::new(b, DEFAULT_LIMIT))),
          }
      }
  *)
  Definition with_limited_body
      (self : Self)
      :
        M
          ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_with_limited_body :
    Notations.DoubleColon Self "with_limited_body" := {
    Notations.double_colon := with_limited_body;
  }.
  
  (*
      fn into_limited_body(self) -> Body {
          self.with_limited_body().into_body()
      }
  *)
  Definition into_limited_body (self : Self) : M axum_core.body.Body.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_limited_body :
    Notations.DoubleColon Self "into_limited_body" := {
    Notations.double_colon := into_limited_body;
  }.
  
  Global Instance ℐ : axum_core.ext_traits.request.RequestExt.Trait Self := {
    axum_core.ext_traits.request.RequestExt.extract
      {E M : Set}
      {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := unit) (M := M)} :=
      extract (E := E) (M := M);
    axum_core.ext_traits.request.RequestExt.extract_with_state
      {E S M : Set}
      {ℋ_0 : axum_core.extract.FromRequest.Trait E (S := S) (M := M)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :=
      extract_with_state (E := E) (S := S) (M := M);
    axum_core.ext_traits.request.RequestExt.extract_parts
      {E : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :=
      extract_parts (E := E);
    axum_core.ext_traits.request.RequestExt.extract_parts_with_state
      {E S : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :=
      extract_parts_with_state (E := E) (S := S);
    axum_core.ext_traits.request.RequestExt.with_limited_body :=
      with_limited_body;
    axum_core.ext_traits.request.RequestExt.into_limited_body :=
      into_limited_body;
  }.
End Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
End Impl_axum_core_ext_traits_request_RequestExt_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.

Definition DEFAULT_LIMIT : M.Val usize.t := M.run (M.pure foo).

Module request_parts.
  Module sealed.
    Module  Sealed.
    Section Sealed.
      Unset Primitive Projections.
      Class Trait (Self : Set) : Type := {
      }.
      Global Set Primitive Projections.
    End Sealed.
    End Sealed.
    
    Module  Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
    Section Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
      Definition Self : Set := http.request.Parts.t.
      
      Global Instance ℐ :
        axum_core.ext_traits.request_parts.sealed.Sealed.Trait Self := {
      }.
    End Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
    End Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
  End sealed.
  
  Module  RequestPartsExt.
  Section RequestPartsExt.
    Class Trait (Self : Set) : Type := {
      ℒ_0 :: axum_core.ext_traits.request_parts.sealed.Sealed.Trait Self;
      extract
        {E : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
        (mut_ref Self) ->
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t));
      extract_with_state
        {E S : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
        (mut_ref Self) ->
          (ref S) ->
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t));
    }.
    
  End RequestPartsExt.
  End RequestPartsExt.
  
  Module  Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.
  Section Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.
    Definition Self : Set := http.request.Parts.t.
    
    (*
        fn extract<E>(&mut self) -> BoxFuture<'_, Result<E, E::Rejection>>
        where
            E: FromRequestParts<()> + 'static,
        {
            self.extract_with_state(&())
        }
    *)
    Definition extract
        {E : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)}
        (self : mut_ref Self)
        :
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_extract
        {E : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
      Notations.DoubleColon Self "extract" := {
      Notations.double_colon := extract (E := E);
    }.
    
    (*
        fn extract_with_state<'a, E, S>(
            &'a mut self,
            state: &'a S,
        ) -> BoxFuture<'a, Result<E, E::Rejection>>
        where
            E: FromRequestParts<S> + 'static,
            S: Send + Sync,
        {
            E::from_request_parts(self, state)
        }
    *)
    Definition extract_with_state
        {E S : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S}
        (self : mut_ref Self)
        (state : ref S)
        :
          M
            ltac:(futures_core.future.BoxFuture
              (core.result.Result.t E E::type["Rejection"].t)) :=
      let* self := M.alloc self in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_extract_with_state
        {E S : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :
      Notations.DoubleColon Self "extract_with_state" := {
      Notations.double_colon := extract_with_state (E := E) (S := S);
    }.
    
    Global Instance ℐ :
      axum_core.ext_traits.request_parts.RequestPartsExt.Trait Self := {
      axum_core.ext_traits.request_parts.RequestPartsExt.extract
        {E : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :=
        extract (E := E);
      axum_core.ext_traits.request_parts.RequestPartsExt.extract_with_state
        {E S : Set}
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 : core.marker.Sync.Trait S} :=
        extract_with_state (E := E) (S := S);
    }.
  End Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.
  End Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.
End request_parts.

Module Wrap_sealed_1.
Module sealed.
  Module  Sealed.
  Section Sealed.
    Unset Primitive Projections.
    Class Trait (Self : Set) : Type := {
    }.
    Global Set Primitive Projections.
  End Sealed.
  End Sealed.
  
  Module  Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
  Section Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
    Definition Self : Set := http.request.Parts.t.
    
    Global Instance ℐ :
      axum_core.ext_traits.request_parts.sealed.Sealed.Trait Self := {
    }.
  End Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
  End Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
End sealed.
End Wrap_sealed_1.
Import Wrap_sealed_1.

Module  Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
Section Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
  Definition Self : Set := http.request.Parts.t.
  
  Global Instance ℐ :
    axum_core.ext_traits.request_parts.sealed.Sealed.Trait Self := {
  }.
End Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.
End Impl_axum_core_ext_traits_request_parts_sealed_Sealed_for_http_request_Parts_t.

Module  RequestPartsExt.
Section RequestPartsExt.
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: axum_core.ext_traits.request_parts.sealed.Sealed.Trait Self;
    extract
      {E : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
      (mut_ref Self) ->
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t));
    extract_with_state
      {E S : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
      (mut_ref Self) ->
        (ref S) ->
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t));
  }.
  
End RequestPartsExt.
End RequestPartsExt.

Module  Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.
Section Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.
  Definition Self : Set := http.request.Parts.t.
  
  (*
      fn extract<E>(&mut self) -> BoxFuture<'_, Result<E, E::Rejection>>
      where
          E: FromRequestParts<()> + 'static,
      {
          self.extract_with_state(&())
      }
  *)
  Definition extract
      {E : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)}
      (self : mut_ref Self)
      :
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_extract
      {E : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :
    Notations.DoubleColon Self "extract" := {
    Notations.double_colon := extract (E := E);
  }.
  
  (*
      fn extract_with_state<'a, E, S>(
          &'a mut self,
          state: &'a S,
      ) -> BoxFuture<'a, Result<E, E::Rejection>>
      where
          E: FromRequestParts<S> + 'static,
          S: Send + Sync,
      {
          E::from_request_parts(self, state)
      }
  *)
  Definition extract_with_state
      {E S : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (self : mut_ref Self)
      (state : ref S)
      :
        M
          ltac:(futures_core.future.BoxFuture
            (core.result.Result.t E E::type["Rejection"].t)) :=
    let* self := M.alloc self in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_extract_with_state
      {E S : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :
    Notations.DoubleColon Self "extract_with_state" := {
    Notations.double_colon := extract_with_state (E := E) (S := S);
  }.
  
  Global Instance ℐ :
    axum_core.ext_traits.request_parts.RequestPartsExt.Trait Self := {
    axum_core.ext_traits.request_parts.RequestPartsExt.extract
      {E : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := unit)} :=
      extract (E := E);
    axum_core.ext_traits.request_parts.RequestPartsExt.extract_with_state
      {E S : Set}
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S} :=
      extract_with_state (E := E) (S := S);
  }.
End Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.
End Impl_axum_core_ext_traits_request_parts_RequestPartsExt_for_http_request_Parts_t.

Module body.
  Ltac BoxBody :=
    exact
      (http_body_util.combinators.box_body.UnsyncBoxBody.t
        bytes.bytes.Bytes.t
        axum_core.error.Error.t).
  
  (*
  fn boxed<B>(body: B) -> BoxBody
  where
      B: http_body::Body<Data = Bytes> + Send + 'static,
      B::Error: Into<BoxError>,
  {
      try_downcast(body).unwrap_or_else(|body| body.map_err(Error::new).boxed_unsync())
  }
  *)
  Definition boxed
      {B : Set}
      {ℋ_0 : http_body.Body.Trait B}
      {ℋ_1 : core.marker.Send.Trait B}
      {ℋ_2 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      (body : B)
      : M ltac:(axum_core.body.BoxBody) :=
    let* body := M.alloc body in
    M.read foo.
  
  (*
  pub(crate) fn try_downcast<T, K>(k: K) -> Result<T, K>
  where
      T: 'static,
      K: Send + 'static,
  {
      let mut k = Some(k);
      if let Some(k) = <dyn std::any::Any>::downcast_mut::<Option<T>>(&mut k) {
          Ok(k.take().unwrap())
      } else {
          Err(k.unwrap())
      }
  }
  *)
  Definition try_downcast
      {T K : Set}
      {ℋ_0 : core.marker.Send.Trait K}
      (k : K)
      : M (core.result.Result.t T K) :=
    let* k := M.alloc k in
    M.read foo.
  
  Module  Body.
  Section Body.
    Record t : Set := {
      x0 : ltac:(axum_core.body.BoxBody);
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Body.
  End Body.
  
  Module  Impl_core_fmt_Debug_for_axum_core_body_Body_t.
  Section Impl_core_fmt_Debug_for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_body_Body_t.
  End Impl_core_fmt_Debug_for_axum_core_body_Body_t.
  
  Module  Impl_axum_core_body_Body_t.
  Section Impl_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
        pub fn new<B>(body: B) -> Self
        where
            B: http_body::Body<Data = Bytes> + Send + 'static,
            B::Error: Into<BoxError>,
        {
            try_downcast(body).unwrap_or_else(|body| Self(boxed(body)))
        }
    *)
    Definition new
        {B : Set}
        {ℋ_0 : http_body.Body.Trait B}
        {ℋ_1 : core.marker.Send.Trait B}
        {ℋ_2 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        (body : B)
        : M Self :=
      let* body := M.alloc body in
      M.read foo.
    
    Global Instance AssociatedFunction_new
        {B : Set}
        {ℋ_0 : http_body.Body.Trait B}
        {ℋ_1 : core.marker.Send.Trait B}
        {ℋ_2 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new (B := B);
    }.
    
    (*
        pub fn empty() -> Self {
            Self::new(http_body_util::Empty::new())
        }
    *)
    Definition empty : M Self := M.read foo.
    
    Global Instance AssociatedFunction_empty :
      Notations.DoubleColon Self "empty" := {
      Notations.double_colon := empty;
    }.
    
    (*
        pub fn from_stream<S>(stream: S) -> Self
        where
            S: TryStream + Send + 'static,
            S::Ok: Into<Bytes>,
            S::Error: Into<BoxError>,
        {
            Self::new(StreamBody {
                stream: SyncWrapper::new(stream),
            })
        }
    *)
    Definition from_stream
        {S : Set}
        {ℋ_0 : futures_core.stream.TryStream.Trait S}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 :
          core.convert.Into.Trait S::type["Ok"].t (T := bytes.bytes.Bytes.t)}
        {ℋ_3 :
          core.convert.Into.Trait S::type["Error"].t
            (T := ltac:(axum_core.BoxError))}
        (stream : S)
        : M Self :=
      let* stream := M.alloc stream in
      M.read foo.
    
    Global Instance AssociatedFunction_from_stream
        {S : Set}
        {ℋ_0 : futures_core.stream.TryStream.Trait S}
        {ℋ_1 : core.marker.Send.Trait S}
        {ℋ_2 :
          core.convert.Into.Trait S::type["Ok"].t (T := bytes.bytes.Bytes.t)}
        {ℋ_3 :
          core.convert.Into.Trait S::type["Error"].t
            (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "from_stream" := {
      Notations.double_colon := from_stream (S := S);
    }.
    
    (*
        pub fn into_data_stream(self) -> BodyDataStream {
            BodyDataStream { inner: self }
        }
    *)
    Definition into_data_stream
        (self : Self)
        : M axum_core.body.BodyDataStream.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_data_stream :
      Notations.DoubleColon Self "into_data_stream" := {
      Notations.double_colon := into_data_stream;
    }.
  End Impl_axum_core_body_Body_t.
  End Impl_axum_core_body_Body_t.
  
  Module  Impl_core_default_Default_for_axum_core_body_Body_t.
  Section Impl_core_default_Default_for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
        fn default() -> Self {
            Self::empty()
        }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_core_body_Body_t.
  End Impl_core_default_Default_for_axum_core_body_Body_t.
  
  Module  Impl_core_convert_From_Tuple__for_axum_core_body_Body_t.
  Section Impl_core_convert_From_Tuple__for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
        fn from(_: ()) -> Self {
            Self::empty()
        }
    *)
    Definition from (Pattern : unit) : M Self :=
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := unit) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_Tuple__for_axum_core_body_Body_t.
  End Impl_core_convert_From_Tuple__for_axum_core_body_Body_t.
  
  Module  Impl_core_convert_From_ref_slice_u8_t_for_axum_core_body_Body_t.
  Section Impl_core_convert_From_ref_slice_u8_t_for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
                fn from(buf: $ty) -> Self {
                    Self::new(http_body_util::Full::from(buf))
                }
    *)
    Definition from (buf : ref (slice u8.t)) : M Self :=
      let* buf := M.alloc buf in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := ref (slice u8.t)) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_ref_slice_u8_t_for_axum_core_body_Body_t.
  End Impl_core_convert_From_ref_slice_u8_t_for_axum_core_body_Body_t.
  
  Module  Impl_core_convert_From_alloc_borrow_Cow_t_slice_u8_t_for_axum_core_body_Body_t.
  Section Impl_core_convert_From_alloc_borrow_Cow_t_slice_u8_t_for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
                fn from(buf: $ty) -> Self {
                    Self::new(http_body_util::Full::from(buf))
                }
    *)
    Definition from (buf : alloc.borrow.Cow.t (slice u8.t)) : M Self :=
      let* buf := M.alloc buf in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := alloc.borrow.Cow.t (slice u8.t)) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_alloc_borrow_Cow_t_slice_u8_t_for_axum_core_body_Body_t.
  End Impl_core_convert_From_alloc_borrow_Cow_t_slice_u8_t_for_axum_core_body_Body_t.
  
  Module  Impl_core_convert_From_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A_for_axum_core_body_Body_t.
  Section Impl_core_convert_From_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A_for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
                fn from(buf: $ty) -> Self {
                    Self::new(http_body_util::Full::from(buf))
                }
    *)
    Definition from
        (buf : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
        : M Self :=
      let* buf := M.alloc buf in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A_for_axum_core_body_Body_t.
  End Impl_core_convert_From_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A_for_axum_core_body_Body_t.
  
  Module  Impl_core_convert_From_ref_str_t_for_axum_core_body_Body_t.
  Section Impl_core_convert_From_ref_str_t_for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
                fn from(buf: $ty) -> Self {
                    Self::new(http_body_util::Full::from(buf))
                }
    *)
    Definition from (buf : ref str.t) : M Self :=
      let* buf := M.alloc buf in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := ref str.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_ref_str_t_for_axum_core_body_Body_t.
  End Impl_core_convert_From_ref_str_t_for_axum_core_body_Body_t.
  
  Module  Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_axum_core_body_Body_t.
  Section Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
                fn from(buf: $ty) -> Self {
                    Self::new(http_body_util::Full::from(buf))
                }
    *)
    Definition from (buf : alloc.borrow.Cow.t str.t) : M Self :=
      let* buf := M.alloc buf in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := alloc.borrow.Cow.t str.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_axum_core_body_Body_t.
  End Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_axum_core_body_Body_t.
  
  Module  Impl_core_convert_From_alloc_string_String_t_for_axum_core_body_Body_t.
  Section Impl_core_convert_From_alloc_string_String_t_for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
                fn from(buf: $ty) -> Self {
                    Self::new(http_body_util::Full::from(buf))
                }
    *)
    Definition from (buf : alloc.string.String.t) : M Self :=
      let* buf := M.alloc buf in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := alloc.string.String.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_alloc_string_String_t_for_axum_core_body_Body_t.
  End Impl_core_convert_From_alloc_string_String_t_for_axum_core_body_Body_t.
  
  Module  Impl_core_convert_From_bytes_bytes_Bytes_t_for_axum_core_body_Body_t.
  Section Impl_core_convert_From_bytes_bytes_Bytes_t_for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
                fn from(buf: $ty) -> Self {
                    Self::new(http_body_util::Full::from(buf))
                }
    *)
    Definition from (buf : bytes.bytes.Bytes.t) : M Self :=
      let* buf := M.alloc buf in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := bytes.bytes.Bytes.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_bytes_bytes_Bytes_t_for_axum_core_body_Body_t.
  End Impl_core_convert_From_bytes_bytes_Bytes_t_for_axum_core_body_Body_t.
  
  Module  Impl_http_body_Body_for_axum_core_body_Body_t.
  Section Impl_http_body_Body_for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
        type Data = Bytes;
    *)
    Definition Data : Set := bytes.bytes.Bytes.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := axum_core.error.Error.t.
    
    (*
        fn poll_frame(
            mut self: Pin<&mut Self>,
            cx: &mut Context<'_>,
        ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
            Pin::new(&mut self.0).poll_frame(cx)
        }
    *)
    Definition poll_frame
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        :
          M
            (core.task.poll.Poll.t
              (core.option.Option.t
                (core.result.Result.t (http_body.frame.Frame.t Data) Error))) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_frame :
      Notations.DoubleColon Self "poll_frame" := {
      Notations.double_colon := poll_frame;
    }.
    
    (*
        fn size_hint(&self) -> http_body::SizeHint {
            self.0.size_hint()
        }
    *)
    Definition size_hint (self : ref Self) : M http_body.size_hint.SizeHint.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    (*
        fn is_end_stream(&self) -> bool {
            self.0.is_end_stream()
        }
    *)
    Definition is_end_stream (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_end_stream :
      Notations.DoubleColon Self "is_end_stream" := {
      Notations.double_colon := is_end_stream;
    }.
    
    Global Instance ℐ : http_body.Body.Required.Trait Self := {
      http_body.Body.Data := Data;
      http_body.Body.Error := Error;
      http_body.Body.poll_frame := poll_frame;
      http_body.Body.size_hint := Datatypes.Some size_hint;
      http_body.Body.is_end_stream := Datatypes.Some is_end_stream;
    }.
  End Impl_http_body_Body_for_axum_core_body_Body_t.
  End Impl_http_body_Body_for_axum_core_body_Body_t.
  
  Module  BodyDataStream.
  Section BodyDataStream.
    Record t : Set := {
      inner : axum_core.body.Body.t;
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  End BodyDataStream.
  End BodyDataStream.
  
  Module  Impl_core_fmt_Debug_for_axum_core_body_BodyDataStream_t.
  Section Impl_core_fmt_Debug_for_axum_core_body_BodyDataStream_t.
    Definition Self : Set := axum_core.body.BodyDataStream.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_body_BodyDataStream_t.
  End Impl_core_fmt_Debug_for_axum_core_body_BodyDataStream_t.
  
  Module  Impl_futures_core_stream_Stream_for_axum_core_body_BodyDataStream_t.
  Section Impl_futures_core_stream_Stream_for_axum_core_body_BodyDataStream_t.
    Definition Self : Set := axum_core.body.BodyDataStream.t.
    
    (*
        type Item = Result<Bytes, Error>;
    *)
    Definition Item : Set :=
      core.result.Result.t bytes.bytes.Bytes.t axum_core.error.Error.t.
    
    (*
        fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
            loop {
                match futures_util::ready!(Pin::new(&mut self.inner).poll_frame(cx)?) {
                    Some(frame) => match frame.into_data() {
                        Ok(data) => return Poll::Ready(Some(Ok(data))),
                        Err(_frame) => {}
                    },
                    None => return Poll::Ready(None),
                }
            }
        }
    *)
    Definition poll_next
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.option.Option.t Item)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_next :
      Notations.DoubleColon Self "poll_next" := {
      Notations.double_colon := poll_next;
    }.
    
    Global Instance ℐ : futures_core.stream.Stream.Required.Trait Self := {
      futures_core.stream.Stream.Item := Item;
      futures_core.stream.Stream.poll_next := poll_next;
      futures_core.stream.Stream.size_hint := Datatypes.None;
    }.
  End Impl_futures_core_stream_Stream_for_axum_core_body_BodyDataStream_t.
  End Impl_futures_core_stream_Stream_for_axum_core_body_BodyDataStream_t.
  
  Module  Impl_http_body_Body_for_axum_core_body_BodyDataStream_t.
  Section Impl_http_body_Body_for_axum_core_body_BodyDataStream_t.
    Definition Self : Set := axum_core.body.BodyDataStream.t.
    
    (*
        type Data = Bytes;
    *)
    Definition Data : Set := bytes.bytes.Bytes.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := axum_core.error.Error.t.
    
    (*
        fn poll_frame(
            mut self: Pin<&mut Self>,
            cx: &mut Context<'_>,
        ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
            Pin::new(&mut self.inner).poll_frame(cx)
        }
    *)
    Definition poll_frame
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        :
          M
            (core.task.poll.Poll.t
              (core.option.Option.t
                (core.result.Result.t (http_body.frame.Frame.t Data) Error))) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_frame :
      Notations.DoubleColon Self "poll_frame" := {
      Notations.double_colon := poll_frame;
    }.
    
    (*
        fn is_end_stream(&self) -> bool {
            self.inner.is_end_stream()
        }
    *)
    Definition is_end_stream (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_end_stream :
      Notations.DoubleColon Self "is_end_stream" := {
      Notations.double_colon := is_end_stream;
    }.
    
    (*
        fn size_hint(&self) -> http_body::SizeHint {
            self.inner.size_hint()
        }
    *)
    Definition size_hint (self : ref Self) : M http_body.size_hint.SizeHint.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ : http_body.Body.Required.Trait Self := {
      http_body.Body.Data := Data;
      http_body.Body.Error := Error;
      http_body.Body.poll_frame := poll_frame;
      http_body.Body.is_end_stream := Datatypes.Some is_end_stream;
      http_body.Body.size_hint := Datatypes.Some size_hint;
    }.
  End Impl_http_body_Body_for_axum_core_body_BodyDataStream_t.
  End Impl_http_body_Body_for_axum_core_body_BodyDataStream_t.
  
  Module  StreamBody.
  Section StreamBody.
    Context (S : Set).
    
    Record t : Set := {
      stream : sync_wrapper.SyncWrapper.t S;
    }.
    
    Definition Get_stream :=
      Ref.map
        (fun α => Some α.(stream))
        (fun β α => Some (α <| stream := β |>)).
  End StreamBody.
  End StreamBody.
  
  Module  Impl_http_body_Body_for_axum_core_body_StreamBody_t_S.
  Section Impl_http_body_Body_for_axum_core_body_StreamBody_t_S.
    Context {S : Set}.
    
    Context
      {ℋ_0 : futures_core.stream.TryStream.Trait S}
      {ℋ_1 : core.convert.Into.Trait S::type["Ok"].t (T := bytes.bytes.Bytes.t)}
      {ℋ_2 :
        core.convert.Into.Trait S::type["Error"].t
          (T := ltac:(axum_core.BoxError))}.
    
    Definition Self : Set := axum_core.body.StreamBody.t S.
    
    (*
        type Data = Bytes;
    *)
    Definition Data : Set := bytes.bytes.Bytes.t.
    
    (*
        type Error = Error;
    *)
    Definition Error : Set := axum_core.error.Error.t.
    
    (*
        fn poll_frame(
            self: Pin<&mut Self>,
            cx: &mut Context<'_>,
        ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
            let stream = self.project().stream.get_pin_mut();
            match futures_util::ready!(stream.try_poll_next(cx)) {
                Some(Ok(chunk)) => Poll::Ready(Some(Ok(Frame::data(chunk.into())))),
                Some(Err(err)) => Poll::Ready(Some(Err(Error::new(err)))),
                None => Poll::Ready(None),
            }
        }
    *)
    Definition poll_frame
        (self : core.pin.Pin.t (mut_ref Self))
        (cx : mut_ref core.task.wake.Context.t)
        :
          M
            (core.task.poll.Poll.t
              (core.option.Option.t
                (core.result.Result.t (http_body.frame.Frame.t Data) Error))) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_frame :
      Notations.DoubleColon Self "poll_frame" := {
      Notations.double_colon := poll_frame;
    }.
    
    Global Instance ℐ : http_body.Body.Required.Trait Self := {
      http_body.Body.Data := Data;
      http_body.Body.Error := Error;
      http_body.Body.poll_frame := poll_frame;
      http_body.Body.is_end_stream := Datatypes.None;
      http_body.Body.size_hint := Datatypes.None;
    }.
  End Impl_http_body_Body_for_axum_core_body_StreamBody_t_S.
  End Impl_http_body_Body_for_axum_core_body_StreamBody_t_S.
End body.

Ltac BoxBody :=
  exact
    (http_body_util.combinators.box_body.UnsyncBoxBody.t
      bytes.bytes.Bytes.t
      axum_core.error.Error.t).

(*
fn boxed<B>(body: B) -> BoxBody
where
    B: http_body::Body<Data = Bytes> + Send + 'static,
    B::Error: Into<BoxError>,
{
    try_downcast(body).unwrap_or_else(|body| body.map_err(Error::new).boxed_unsync())
}
*)
Definition boxed
    {B : Set}
    {ℋ_0 : http_body.Body.Trait B}
    {ℋ_1 : core.marker.Send.Trait B}
    {ℋ_2 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}
    (body : B)
    : M ltac:(axum_core.body.BoxBody) :=
  let* body := M.alloc body in
  M.read foo.

(*
pub(crate) fn try_downcast<T, K>(k: K) -> Result<T, K>
where
    T: 'static,
    K: Send + 'static,
{
    let mut k = Some(k);
    if let Some(k) = <dyn std::any::Any>::downcast_mut::<Option<T>>(&mut k) {
        Ok(k.take().unwrap())
    } else {
        Err(k.unwrap())
    }
}
*)
Definition try_downcast
    {T K : Set}
    {ℋ_0 : core.marker.Send.Trait K}
    (k : K)
    : M (core.result.Result.t T K) :=
  let* k := M.alloc k in
  M.read foo.

Module  Body.
Section Body.
  Record t : Set := {
    x0 : ltac:(axum_core.body.BoxBody);
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Body.
End Body.

Module  Impl_core_fmt_Debug_for_axum_core_body_Body_t.
Section Impl_core_fmt_Debug_for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_body_Body_t.
End Impl_core_fmt_Debug_for_axum_core_body_Body_t.

Module  Impl_axum_core_body_Body_t_2.
Section Impl_axum_core_body_Body_t_2.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
      pub fn new<B>(body: B) -> Self
      where
          B: http_body::Body<Data = Bytes> + Send + 'static,
          B::Error: Into<BoxError>,
      {
          try_downcast(body).unwrap_or_else(|body| Self(boxed(body)))
      }
  *)
  Definition new
      {B : Set}
      {ℋ_0 : http_body.Body.Trait B}
      {ℋ_1 : core.marker.Send.Trait B}
      {ℋ_2 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      (body : B)
      : M Self :=
    let* body := M.alloc body in
    M.read foo.
  
  Global Instance AssociatedFunction_new
      {B : Set}
      {ℋ_0 : http_body.Body.Trait B}
      {ℋ_1 : core.marker.Send.Trait B}
      {ℋ_2 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "new" := {
    Notations.double_colon := new (B := B);
  }.
  
  (*
      pub fn empty() -> Self {
          Self::new(http_body_util::Empty::new())
      }
  *)
  Definition empty : M Self := M.read foo.
  
  Global Instance AssociatedFunction_empty :
    Notations.DoubleColon Self "empty" := {
    Notations.double_colon := empty;
  }.
  
  (*
      pub fn from_stream<S>(stream: S) -> Self
      where
          S: TryStream + Send + 'static,
          S::Ok: Into<Bytes>,
          S::Error: Into<BoxError>,
      {
          Self::new(StreamBody {
              stream: SyncWrapper::new(stream),
          })
      }
  *)
  Definition from_stream
      {S : Set}
      {ℋ_0 : futures_core.stream.TryStream.Trait S}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.convert.Into.Trait S::type["Ok"].t (T := bytes.bytes.Bytes.t)}
      {ℋ_3 :
        core.convert.Into.Trait S::type["Error"].t
          (T := ltac:(axum_core.BoxError))}
      (stream : S)
      : M Self :=
    let* stream := M.alloc stream in
    M.read foo.
  
  Global Instance AssociatedFunction_from_stream
      {S : Set}
      {ℋ_0 : futures_core.stream.TryStream.Trait S}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.convert.Into.Trait S::type["Ok"].t (T := bytes.bytes.Bytes.t)}
      {ℋ_3 :
        core.convert.Into.Trait S::type["Error"].t
          (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "from_stream" := {
    Notations.double_colon := from_stream (S := S);
  }.
  
  (*
      pub fn into_data_stream(self) -> BodyDataStream {
          BodyDataStream { inner: self }
      }
  *)
  Definition into_data_stream
      (self : Self)
      : M axum_core.body.BodyDataStream.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_data_stream :
    Notations.DoubleColon Self "into_data_stream" := {
    Notations.double_colon := into_data_stream;
  }.
End Impl_axum_core_body_Body_t_2.
End Impl_axum_core_body_Body_t_2.

Module  Impl_core_default_Default_for_axum_core_body_Body_t.
Section Impl_core_default_Default_for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
      fn default() -> Self {
          Self::empty()
      }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_core_body_Body_t.
End Impl_core_default_Default_for_axum_core_body_Body_t.

Module  Impl_core_convert_From_Tuple__for_axum_core_body_Body_t.
Section Impl_core_convert_From_Tuple__for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
      fn from(_: ()) -> Self {
          Self::empty()
      }
  *)
  Definition from (Pattern : unit) : M Self :=
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := unit) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_Tuple__for_axum_core_body_Body_t.
End Impl_core_convert_From_Tuple__for_axum_core_body_Body_t.

Module  Impl_core_convert_From_ref_slice_u8_t_for_axum_core_body_Body_t.
Section Impl_core_convert_From_ref_slice_u8_t_for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
              fn from(buf: $ty) -> Self {
                  Self::new(http_body_util::Full::from(buf))
              }
  *)
  Definition from (buf : ref (slice u8.t)) : M Self :=
    let* buf := M.alloc buf in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := ref (slice u8.t)) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_ref_slice_u8_t_for_axum_core_body_Body_t.
End Impl_core_convert_From_ref_slice_u8_t_for_axum_core_body_Body_t.

Module  Impl_core_convert_From_alloc_borrow_Cow_t_slice_u8_t_for_axum_core_body_Body_t.
Section Impl_core_convert_From_alloc_borrow_Cow_t_slice_u8_t_for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
              fn from(buf: $ty) -> Self {
                  Self::new(http_body_util::Full::from(buf))
              }
  *)
  Definition from (buf : alloc.borrow.Cow.t (slice u8.t)) : M Self :=
    let* buf := M.alloc buf in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self (T := alloc.borrow.Cow.t (slice u8.t)) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_alloc_borrow_Cow_t_slice_u8_t_for_axum_core_body_Body_t.
End Impl_core_convert_From_alloc_borrow_Cow_t_slice_u8_t_for_axum_core_body_Body_t.

Module  Impl_core_convert_From_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A_for_axum_core_body_Body_t.
Section Impl_core_convert_From_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A_for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
              fn from(buf: $ty) -> Self {
                  Self::new(http_body_util::Full::from(buf))
              }
  *)
  Definition from
      (buf : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
      : M Self :=
    let* buf := M.alloc buf in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A_for_axum_core_body_Body_t.
End Impl_core_convert_From_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A_for_axum_core_body_Body_t.

Module  Impl_core_convert_From_ref_str_t_for_axum_core_body_Body_t.
Section Impl_core_convert_From_ref_str_t_for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
              fn from(buf: $ty) -> Self {
                  Self::new(http_body_util::Full::from(buf))
              }
  *)
  Definition from (buf : ref str.t) : M Self :=
    let* buf := M.alloc buf in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := ref str.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_ref_str_t_for_axum_core_body_Body_t.
End Impl_core_convert_From_ref_str_t_for_axum_core_body_Body_t.

Module  Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_axum_core_body_Body_t.
Section Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
              fn from(buf: $ty) -> Self {
                  Self::new(http_body_util::Full::from(buf))
              }
  *)
  Definition from (buf : alloc.borrow.Cow.t str.t) : M Self :=
    let* buf := M.alloc buf in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self (T := alloc.borrow.Cow.t str.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_axum_core_body_Body_t.
End Impl_core_convert_From_alloc_borrow_Cow_t_str_t_for_axum_core_body_Body_t.

Module  Impl_core_convert_From_alloc_string_String_t_for_axum_core_body_Body_t.
Section Impl_core_convert_From_alloc_string_String_t_for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
              fn from(buf: $ty) -> Self {
                  Self::new(http_body_util::Full::from(buf))
              }
  *)
  Definition from (buf : alloc.string.String.t) : M Self :=
    let* buf := M.alloc buf in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self (T := alloc.string.String.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_alloc_string_String_t_for_axum_core_body_Body_t.
End Impl_core_convert_From_alloc_string_String_t_for_axum_core_body_Body_t.

Module  Impl_core_convert_From_bytes_bytes_Bytes_t_for_axum_core_body_Body_t.
Section Impl_core_convert_From_bytes_bytes_Bytes_t_for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
              fn from(buf: $ty) -> Self {
                  Self::new(http_body_util::Full::from(buf))
              }
  *)
  Definition from (buf : bytes.bytes.Bytes.t) : M Self :=
    let* buf := M.alloc buf in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self (T := bytes.bytes.Bytes.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_bytes_bytes_Bytes_t_for_axum_core_body_Body_t.
End Impl_core_convert_From_bytes_bytes_Bytes_t_for_axum_core_body_Body_t.

Module  Impl_http_body_Body_for_axum_core_body_Body_t.
Section Impl_http_body_Body_for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
      type Data = Bytes;
  *)
  Definition Data : Set := bytes.bytes.Bytes.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := axum_core.error.Error.t.
  
  (*
      fn poll_frame(
          mut self: Pin<&mut Self>,
          cx: &mut Context<'_>,
      ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
          Pin::new(&mut self.0).poll_frame(cx)
      }
  *)
  Definition poll_frame
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      :
        M
          (core.task.poll.Poll.t
            (core.option.Option.t
              (core.result.Result.t (http_body.frame.Frame.t Data) Error))) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_frame :
    Notations.DoubleColon Self "poll_frame" := {
    Notations.double_colon := poll_frame;
  }.
  
  (*
      fn size_hint(&self) -> http_body::SizeHint {
          self.0.size_hint()
      }
  *)
  Definition size_hint (self : ref Self) : M http_body.size_hint.SizeHint.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  (*
      fn is_end_stream(&self) -> bool {
          self.0.is_end_stream()
      }
  *)
  Definition is_end_stream (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_end_stream :
    Notations.DoubleColon Self "is_end_stream" := {
    Notations.double_colon := is_end_stream;
  }.
  
  Global Instance ℐ : http_body.Body.Required.Trait Self := {
    http_body.Body.Data := Data;
    http_body.Body.Error := Error;
    http_body.Body.poll_frame := poll_frame;
    http_body.Body.size_hint := Datatypes.Some size_hint;
    http_body.Body.is_end_stream := Datatypes.Some is_end_stream;
  }.
End Impl_http_body_Body_for_axum_core_body_Body_t.
End Impl_http_body_Body_for_axum_core_body_Body_t.

Module  BodyDataStream.
Section BodyDataStream.
  Record t : Set := {
    inner : axum_core.body.Body.t;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
End BodyDataStream.
End BodyDataStream.

Module  Impl_core_fmt_Debug_for_axum_core_body_BodyDataStream_t.
Section Impl_core_fmt_Debug_for_axum_core_body_BodyDataStream_t.
  Definition Self : Set := axum_core.body.BodyDataStream.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_body_BodyDataStream_t.
End Impl_core_fmt_Debug_for_axum_core_body_BodyDataStream_t.

Module  Impl_futures_core_stream_Stream_for_axum_core_body_BodyDataStream_t.
Section Impl_futures_core_stream_Stream_for_axum_core_body_BodyDataStream_t.
  Definition Self : Set := axum_core.body.BodyDataStream.t.
  
  (*
      type Item = Result<Bytes, Error>;
  *)
  Definition Item : Set :=
    core.result.Result.t bytes.bytes.Bytes.t axum_core.error.Error.t.
  
  (*
      fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
          loop {
              match futures_util::ready!(Pin::new(&mut self.inner).poll_frame(cx)?) {
                  Some(frame) => match frame.into_data() {
                      Ok(data) => return Poll::Ready(Some(Ok(data))),
                      Err(_frame) => {}
                  },
                  None => return Poll::Ready(None),
              }
          }
      }
  *)
  Definition poll_next
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.option.Option.t Item)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_next :
    Notations.DoubleColon Self "poll_next" := {
    Notations.double_colon := poll_next;
  }.
  
  Global Instance ℐ : futures_core.stream.Stream.Required.Trait Self := {
    futures_core.stream.Stream.Item := Item;
    futures_core.stream.Stream.poll_next := poll_next;
    futures_core.stream.Stream.size_hint := Datatypes.None;
  }.
End Impl_futures_core_stream_Stream_for_axum_core_body_BodyDataStream_t.
End Impl_futures_core_stream_Stream_for_axum_core_body_BodyDataStream_t.

Module  Impl_http_body_Body_for_axum_core_body_BodyDataStream_t.
Section Impl_http_body_Body_for_axum_core_body_BodyDataStream_t.
  Definition Self : Set := axum_core.body.BodyDataStream.t.
  
  (*
      type Data = Bytes;
  *)
  Definition Data : Set := bytes.bytes.Bytes.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := axum_core.error.Error.t.
  
  (*
      fn poll_frame(
          mut self: Pin<&mut Self>,
          cx: &mut Context<'_>,
      ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
          Pin::new(&mut self.inner).poll_frame(cx)
      }
  *)
  Definition poll_frame
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      :
        M
          (core.task.poll.Poll.t
            (core.option.Option.t
              (core.result.Result.t (http_body.frame.Frame.t Data) Error))) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_frame :
    Notations.DoubleColon Self "poll_frame" := {
    Notations.double_colon := poll_frame;
  }.
  
  (*
      fn is_end_stream(&self) -> bool {
          self.inner.is_end_stream()
      }
  *)
  Definition is_end_stream (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_end_stream :
    Notations.DoubleColon Self "is_end_stream" := {
    Notations.double_colon := is_end_stream;
  }.
  
  (*
      fn size_hint(&self) -> http_body::SizeHint {
          self.inner.size_hint()
      }
  *)
  Definition size_hint (self : ref Self) : M http_body.size_hint.SizeHint.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ : http_body.Body.Required.Trait Self := {
    http_body.Body.Data := Data;
    http_body.Body.Error := Error;
    http_body.Body.poll_frame := poll_frame;
    http_body.Body.is_end_stream := Datatypes.Some is_end_stream;
    http_body.Body.size_hint := Datatypes.Some size_hint;
  }.
End Impl_http_body_Body_for_axum_core_body_BodyDataStream_t.
End Impl_http_body_Body_for_axum_core_body_BodyDataStream_t.

Module  StreamBody.
Section StreamBody.
  Context (S : Set).
  
  Record t : Set := {
    stream : sync_wrapper.SyncWrapper.t S;
  }.
  
  Definition Get_stream :=
    Ref.map (fun α => Some α.(stream)) (fun β α => Some (α <| stream := β |>)).
End StreamBody.
End StreamBody.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  Projection.
Section Projection.
  Context (S : Set).
  
  Record t : Set := {
    stream : core.pin.Pin.t (mut_ref (sync_wrapper.SyncWrapper.t S));
  }.
  
  Definition Get_stream :=
    Ref.map (fun α => Some α.(stream)) (fun β α => Some (α <| stream := β |>)).
End Projection.
End Projection.

(* #[allow(dead_code)] - struct was ignored by the compiler *)
Module  ProjectionRef.
Section ProjectionRef.
  Context (S : Set).
  
  Record t : Set := {
    stream : core.pin.Pin.t (ref (sync_wrapper.SyncWrapper.t S));
  }.
  
  Definition Get_stream :=
    Ref.map (fun α => Some α.(stream)) (fun β α => Some (α <| stream := β |>)).
End ProjectionRef.
End ProjectionRef.

Module  Impl_axum_core_body_StreamBody_t_S.
Section Impl_axum_core_body_StreamBody_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum_core.body.StreamBody.t S.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project
      (self : core.pin.Pin.t (mut_ref Self))
      : M (axum_core.body._.Projection.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project :
    Notations.DoubleColon Self "project" := {
    Notations.double_colon := project;
  }.
  
  (*
          $proj_vis fn $method_ident<'__pin>(
              self: $crate::__private::Pin<&'__pin $($mut)? Self>,
          ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
              unsafe {
                  let Self { $($field),* } = self.$get_method();
                  $proj_ty_ident {
                      $(
                          $field: $crate::__pin_project_make_unsafe_field_proj!(
                              $(#[$pin])? $field
                          )
                      ),+
                  }
              }
          }
  *)
  Definition project_ref
      (self : core.pin.Pin.t (ref Self))
      : M (axum_core.body._.ProjectionRef.t S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_project_ref :
    Notations.DoubleColon Self "project_ref" := {
    Notations.double_colon := project_ref;
  }.
End Impl_axum_core_body_StreamBody_t_S.
End Impl_axum_core_body_StreamBody_t_S.

Module  __Origin.
Section __Origin.
  Context (S : Set).
  
  Record t : Set := {
    __dummy_lifetime : core.marker.PhantomData.t (ref unit);
    stream : sync_wrapper.SyncWrapper.t S;
  }.
  
  Definition Get___dummy_lifetime :=
    Ref.map
      (fun α => Some α.(__dummy_lifetime))
      (fun β α => Some (α <| __dummy_lifetime := β |>)).
  Definition Get_stream :=
    Ref.map (fun α => Some α.(stream)) (fun β α => Some (α <| stream := β |>)).
End __Origin.
End __Origin.

Module  Impl_core_marker_Unpin_for_axum_core_body_StreamBody_t_S.
Section Impl_core_marker_Unpin_for_axum_core_body_StreamBody_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Unpin.Trait (axum_core.body._.__Origin.t S)}.
  
  Definition Self : Set := axum_core.body.StreamBody.t S.
  
  Global Instance ℐ : core.marker.Unpin.Trait Self := {
  }.
End Impl_core_marker_Unpin_for_axum_core_body_StreamBody_t_S.
End Impl_core_marker_Unpin_for_axum_core_body_StreamBody_t_S.

Module  MustNotImplDrop.
Section MustNotImplDrop.
  Unset Primitive Projections.
  Class Trait (Self : Set) : Type := {
  }.
  Global Set Primitive Projections.
End MustNotImplDrop.
End MustNotImplDrop.

Module  Impl_axum_core_body___MustNotImplDrop_for_T.
Section Impl_axum_core_body___MustNotImplDrop_for_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.ops.drop.Drop.Trait T}.
  
  Definition Self : Set := T.
  
  Global Instance ℐ : axum_core.body._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_core_body___MustNotImplDrop_for_T.
End Impl_axum_core_body___MustNotImplDrop_for_T.

Module  Impl_axum_core_body___MustNotImplDrop_for_axum_core_body_StreamBody_t_S.
Section Impl_axum_core_body___MustNotImplDrop_for_axum_core_body_StreamBody_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum_core.body.StreamBody.t S.
  
  Global Instance ℐ : axum_core.body._.MustNotImplDrop.Trait Self := {
  }.
End Impl_axum_core_body___MustNotImplDrop_for_axum_core_body_StreamBody_t_S.
End Impl_axum_core_body___MustNotImplDrop_for_axum_core_body_StreamBody_t_S.

(*
            fn __assert_not_repr_packed <$($impl_generics)*> (this: &$ident <$($ty_generics)*>)
            $(where
                $($where_clause)* )?
            {
                $(
                    let _ = &this.$field;
                )+
            }
*)
Definition __assert_not_repr_packed
    {S : Set}
    (this : ref (axum_core.body.StreamBody.t S))
    : M unit :=
  let* this := M.alloc this in
  M.read foo.

Module  Impl_http_body_Body_for_axum_core_body_StreamBody_t_S.
Section Impl_http_body_Body_for_axum_core_body_StreamBody_t_S.
  Context {S : Set}.
  
  Context
    {ℋ_0 : futures_core.stream.TryStream.Trait S}
    {ℋ_1 : core.convert.Into.Trait S::type["Ok"].t (T := bytes.bytes.Bytes.t)}
    {ℋ_2 :
      core.convert.Into.Trait S::type["Error"].t
        (T := ltac:(axum_core.BoxError))}.
  
  Definition Self : Set := axum_core.body.StreamBody.t S.
  
  (*
      type Data = Bytes;
  *)
  Definition Data : Set := bytes.bytes.Bytes.t.
  
  (*
      type Error = Error;
  *)
  Definition Error : Set := axum_core.error.Error.t.
  
  (*
      fn poll_frame(
          self: Pin<&mut Self>,
          cx: &mut Context<'_>,
      ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
          let stream = self.project().stream.get_pin_mut();
          match futures_util::ready!(stream.try_poll_next(cx)) {
              Some(Ok(chunk)) => Poll::Ready(Some(Ok(Frame::data(chunk.into())))),
              Some(Err(err)) => Poll::Ready(Some(Err(Error::new(err)))),
              None => Poll::Ready(None),
          }
      }
  *)
  Definition poll_frame
      (self : core.pin.Pin.t (mut_ref Self))
      (cx : mut_ref core.task.wake.Context.t)
      :
        M
          (core.task.poll.Poll.t
            (core.option.Option.t
              (core.result.Result.t (http_body.frame.Frame.t Data) Error))) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_frame :
    Notations.DoubleColon Self "poll_frame" := {
    Notations.double_colon := poll_frame;
  }.
  
  Global Instance ℐ : http_body.Body.Required.Trait Self := {
    http_body.Body.Data := Data;
    http_body.Body.Error := Error;
    http_body.Body.poll_frame := poll_frame;
    http_body.Body.is_end_stream := Datatypes.None;
    http_body.Body.size_hint := Datatypes.None;
  }.
End Impl_http_body_Body_for_axum_core_body_StreamBody_t_S.
End Impl_http_body_Body_for_axum_core_body_StreamBody_t_S.

Module extract.
  Module rejection.
    Module FailedToBufferBody.
      Inductive t : Set :=
      | LengthLimitError (_ : axum_core.extract.rejection.LengthLimitError.t)
      | UnknownBodyError (_ : axum_core.extract.rejection.UnknownBodyError.t).
      
      Definition Get_LengthLimitError_0 :=
        Ref.map
          (fun α =>
            match α with | LengthLimitError α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | LengthLimitError _ => Some (LengthLimitError β)
            | _ => None
            end).
      
      Definition Get_UnknownBodyError_0 :=
        Ref.map
          (fun α =>
            match α with | UnknownBodyError α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | UnknownBodyError _ => Some (UnknownBodyError β)
            | _ => None
            end).
    End FailedToBufferBody.
    
    Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.
      Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.
      Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.
    
    Module  Impl_axum_core_extract_rejection_FailedToBufferBody_t.
    Section Impl_axum_core_extract_rejection_FailedToBufferBody_t.
      Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_core_extract_rejection_FailedToBufferBody_t.
    End Impl_axum_core_extract_rejection_FailedToBufferBody_t.
    
    Module  Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Section Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
      Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum_core.extract.rejection.LengthLimitError.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum_core.extract.rejection.LengthLimitError.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
    End Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
    
    Module  Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Section Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
      Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum_core.extract.rejection.UnknownBodyError.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum_core.extract.rejection.UnknownBodyError.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
    End Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
    
    Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Section Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.
      Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.
    
    Module  Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Section Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.
      Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.
    End Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.
    
    Module  Impl_axum_core_extract_rejection_FailedToBufferBody_t_2.
    Section Impl_axum_core_extract_rejection_FailedToBufferBody_t_2.
      Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
      
      (*
          pub(crate) fn from_err<E>(err: E) -> Self
          where
              E: Into<BoxError>,
          {
              // two layers of boxes here because `with_limited_body`
              // wraps the `http_body_util::Limited` in a `axum_core::Body`
              // which also wraps the error type
              let box_error = match err.into().downcast::<Error>() {
                  Ok(err) => err.into_inner(),
                  Err(err) => err,
              };
              let box_error = match box_error.downcast::<Error>() {
                  Ok(err) => err.into_inner(),
                  Err(err) => err,
              };
              match box_error.downcast::<http_body_util::LengthLimitError>() {
                  Ok(err) => Self::LengthLimitError(LengthLimitError::from_err(err)),
                  Err(err) => Self::UnknownBodyError(UnknownBodyError::from_err(err)),
              }
          }
      *)
      Definition from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
          (err : E)
          : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
        Notations.DoubleColon Self "from_err" := {
        Notations.double_colon := from_err (E := E);
      }.
    End Impl_axum_core_extract_rejection_FailedToBufferBody_t_2.
    End Impl_axum_core_extract_rejection_FailedToBufferBody_t_2.
    
    Module  LengthLimitError.
    Section LengthLimitError.
      Record t : Set := {
        x0 : axum_core.error.Error.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End LengthLimitError.
    End LengthLimitError.
    
    Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.
    Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.
      Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.
    
    Module  Impl_axum_core_extract_rejection_LengthLimitError_t.
    Section Impl_axum_core_extract_rejection_LengthLimitError_t.
      Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
      
      (*
                  pub(crate) fn from_err<E>(err: E) -> Self
                  where
                      E: Into<$crate::BoxError>,
                  {
                      Self($crate::Error::new(err))
                  }
      *)
      Definition from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
          (err : E)
          : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
        Notations.DoubleColon Self "from_err" := {
        Notations.double_colon := from_err (E := E);
      }.
    End Impl_axum_core_extract_rejection_LengthLimitError_t.
    End Impl_axum_core_extract_rejection_LengthLimitError_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.
      Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = self.body_text(),
                          status = http::StatusCode::$status,
                      );
                      (self.status(), self.body_text()).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.
    
    Module  Impl_axum_core_extract_rejection_LengthLimitError_t_2.
    Section Impl_axum_core_extract_rejection_LengthLimitError_t_2.
      Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      format!(concat!($body, ": {}"), self.0).into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_core_extract_rejection_LengthLimitError_t_2.
    End Impl_axum_core_extract_rejection_LengthLimitError_t_2.
    
    Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.
    Section Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.
      Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.
    
    Module  Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.
    Section Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.
      Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      Some(&self.0)
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.
    End Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.
    
    Module  UnknownBodyError.
    Section UnknownBodyError.
      Record t : Set := {
        x0 : axum_core.error.Error.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End UnknownBodyError.
    End UnknownBodyError.
    
    Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.
    Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.
      Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.
    
    Module  Impl_axum_core_extract_rejection_UnknownBodyError_t.
    Section Impl_axum_core_extract_rejection_UnknownBodyError_t.
      Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
      
      (*
                  pub(crate) fn from_err<E>(err: E) -> Self
                  where
                      E: Into<$crate::BoxError>,
                  {
                      Self($crate::Error::new(err))
                  }
      *)
      Definition from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
          (err : E)
          : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
        Notations.DoubleColon Self "from_err" := {
        Notations.double_colon := from_err (E := E);
      }.
    End Impl_axum_core_extract_rejection_UnknownBodyError_t.
    End Impl_axum_core_extract_rejection_UnknownBodyError_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.
      Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = self.body_text(),
                          status = http::StatusCode::$status,
                      );
                      (self.status(), self.body_text()).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.
    
    Module  Impl_axum_core_extract_rejection_UnknownBodyError_t_2.
    Section Impl_axum_core_extract_rejection_UnknownBodyError_t_2.
      Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      format!(concat!($body, ": {}"), self.0).into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_core_extract_rejection_UnknownBodyError_t_2.
    End Impl_axum_core_extract_rejection_UnknownBodyError_t_2.
    
    Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.
    Section Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.
      Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.
    
    Module  Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.
    Section Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.
      Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      Some(&self.0)
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.
    End Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.
    
    Module  InvalidUtf8.
    Section InvalidUtf8.
      Record t : Set := {
        x0 : axum_core.error.Error.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End InvalidUtf8.
    End InvalidUtf8.
    
    Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.
    Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.
      Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.
    
    Module  Impl_axum_core_extract_rejection_InvalidUtf8_t.
    Section Impl_axum_core_extract_rejection_InvalidUtf8_t.
      Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
      
      (*
                  pub(crate) fn from_err<E>(err: E) -> Self
                  where
                      E: Into<$crate::BoxError>,
                  {
                      Self($crate::Error::new(err))
                  }
      *)
      Definition from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
          (err : E)
          : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_from_err
          {E : Set}
          {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
        Notations.DoubleColon Self "from_err" := {
        Notations.double_colon := from_err (E := E);
      }.
    End Impl_axum_core_extract_rejection_InvalidUtf8_t.
    End Impl_axum_core_extract_rejection_InvalidUtf8_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.
      Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      $crate::__log_rejection!(
                          rejection_type = $name,
                          body_text = self.body_text(),
                          status = http::StatusCode::$status,
                      );
                      (self.status(), self.body_text()).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.
    
    Module  Impl_axum_core_extract_rejection_InvalidUtf8_t_2.
    Section Impl_axum_core_extract_rejection_InvalidUtf8_t_2.
      Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      format!(concat!($body, ": {}"), self.0).into()
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      http::StatusCode::$status
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_core_extract_rejection_InvalidUtf8_t_2.
    End Impl_axum_core_extract_rejection_InvalidUtf8_t_2.
    
    Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.
    Section Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.
      Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      write!(f, "{}", $body)
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.
    
    Module  Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.
    Section Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.
      Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      Some(&self.0)
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.
    End Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.
    
    Module BytesRejection.
      Inductive t : Set :=
      |
        FailedToBufferBody
        (_ : axum_core.extract.rejection.FailedToBufferBody.t).
      
      Definition Get_FailedToBufferBody_0 :=
        Ref.map
          (fun α => match α with | FailedToBufferBody α0 => Some α0 end)
          (fun β α =>
            match α with
            | FailedToBufferBody _ => Some (FailedToBufferBody β)
            end).
    End BytesRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.
    Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.
      Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.
      Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.
    
    Module  Impl_axum_core_extract_rejection_BytesRejection_t.
    Section Impl_axum_core_extract_rejection_BytesRejection_t.
      Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_core_extract_rejection_BytesRejection_t.
    End Impl_axum_core_extract_rejection_BytesRejection_t.
    
    Module  Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.
    Section Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.
      Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum_core.extract.rejection.FailedToBufferBody.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum_core.extract.rejection.FailedToBufferBody.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.
    End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.
    Section Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.
      Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.
    
    Module  Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.
    Section Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.
      Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.
    End Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.
    
    Module StringRejection.
      Inductive t : Set :=
      |
        FailedToBufferBody
        (_ : axum_core.extract.rejection.FailedToBufferBody.t)
      | InvalidUtf8 (_ : axum_core.extract.rejection.InvalidUtf8.t).
      
      Definition Get_FailedToBufferBody_0 :=
        Ref.map
          (fun α =>
            match α with | FailedToBufferBody α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | FailedToBufferBody _ => Some (FailedToBufferBody β)
            | _ => None
            end).
      
      Definition Get_InvalidUtf8_0 :=
        Ref.map
          (fun α => match α with | InvalidUtf8 α0 => Some α0 | _ => None end)
          (fun β α =>
            match α with
            | InvalidUtf8 _ => Some (InvalidUtf8 β)
            | _ => None
            end).
    End StringRejection.
    
    Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.
    Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.
      Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
      
      (*
              Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.
    End Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.
      Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
      
      (*
                  fn into_response(self) -> $crate::response::Response {
                      match self {
                          $(
                              Self::$variant(inner) => inner.into_response(),
                          )+
                      }
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.
    
    Module  Impl_axum_core_extract_rejection_StringRejection_t.
    Section Impl_axum_core_extract_rejection_StringRejection_t.
      Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
      
      (*
                  pub fn body_text(&self) -> String {
                      match self {
                          $(
                              Self::$variant(inner) => inner.body_text(),
                          )+
                      }
                  }
      *)
      Definition body_text (self : ref Self) : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_body_text :
        Notations.DoubleColon Self "body_text" := {
        Notations.double_colon := body_text;
      }.
      
      (*
                  pub fn status(&self) -> http::StatusCode {
                      match self {
                          $(
                              Self::$variant(inner) => inner.status(),
                          )+
                      }
                  }
      *)
      Definition status (self : ref Self) : M http.status.StatusCode.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_status :
        Notations.DoubleColon Self "status" := {
        Notations.double_colon := status;
      }.
    End Impl_axum_core_extract_rejection_StringRejection_t.
    End Impl_axum_core_extract_rejection_StringRejection_t.
    
    Module  Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.
    Section Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.
      Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum_core.extract.rejection.FailedToBufferBody.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum_core.extract.rejection.FailedToBufferBody.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.
    End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.
    
    Module  Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.
    Section Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.
      Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
      
      (*
                      fn from(inner: $variant) -> Self {
                          Self::$variant(inner)
                      }
      *)
      Definition from
          (inner : axum_core.extract.rejection.InvalidUtf8.t)
          : M Self :=
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum_core.extract.rejection.InvalidUtf8.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.
    End Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.
    
    Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.
    Section Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.
      Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
      
      (*
                  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                      match self {
                          $(
                              Self::$variant(inner) => write!(f, "{inner}"),
                          )+
                      }
                  }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.
    End Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.
    
    Module  Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.
    Section Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.
      Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
      
      (*
                  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                      match self {
                          $(
                              Self::$variant(inner) => inner.source(),
                          )+
                      }
                  }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.
    End Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.
  End rejection.
  
  Module default_body_limit.
    Module  DefaultBodyLimit.
    Section DefaultBodyLimit.
      Record t : Set := {
        kind : axum_core.extract.default_body_limit.DefaultBodyLimitKind.t;
      }.
      
      Definition Get_kind :=
        Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
    End DefaultBodyLimit.
    End DefaultBodyLimit.
    
    Module  Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    Section Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
      Definition Self : Set :=
        axum_core.extract.default_body_limit.DefaultBodyLimit.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    
    Module  Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    Section Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
      Definition Self : Set :=
        axum_core.extract.default_body_limit.DefaultBodyLimit.t.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum_core.extract.default_body_limit.DefaultBodyLimit.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    
    Module DefaultBodyLimitKind.
      Inductive t : Set :=
      | Disable
      | Limit (_ : usize.t).
      
      Definition Get_Limit_0 :=
        Ref.map
          (fun α => match α with | Limit α0 => Some α0 | _ => None end)
          (fun β α => match α with | Limit _ => Some (Limit β) | _ => None end).
    End DefaultBodyLimitKind.
    
    Module  Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    Section Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
      Definition Self : Set :=
        axum_core.extract.default_body_limit.DefaultBodyLimitKind.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    
    Module  Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    Section Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
      Definition Self : Set :=
        axum_core.extract.default_body_limit.DefaultBodyLimitKind.t.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum_core.extract.default_body_limit.DefaultBodyLimitKind.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    
    Module  Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    Section Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
      Definition Self : Set :=
        axum_core.extract.default_body_limit.DefaultBodyLimitKind.t.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    
    Module  Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    Section Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
      Definition Self : Set :=
        axum_core.extract.default_body_limit.DefaultBodyLimit.t.
      
      (*
          pub fn disable() -> Self {
              Self {
                  kind: DefaultBodyLimitKind::Disable,
              }
          }
      *)
      Definition disable : M Self := M.read foo.
      
      Global Instance AssociatedFunction_disable :
        Notations.DoubleColon Self "disable" := {
        Notations.double_colon := disable;
      }.
      
      (*
          pub fn max(limit: usize) -> Self {
              Self {
                  kind: DefaultBodyLimitKind::Limit(limit),
              }
          }
      *)
      Definition max (limit : usize.t) : M Self :=
        let* limit := M.alloc limit in
        M.read foo.
      
      Global Instance AssociatedFunction_max :
        Notations.DoubleColon Self "max" := {
        Notations.double_colon := max;
      }.
    End Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    End Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    
    Module  Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    Section Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
      Context {S : Set}.
      
      Definition Self : Set :=
        axum_core.extract.default_body_limit.DefaultBodyLimit.t.
      
      (*
          type Service = DefaultBodyLimitService<S>;
      *)
      Definition Service : Set :=
        axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
            S.
      
      (*
          fn layer(&self, inner: S) -> Self::Service {
              DefaultBodyLimitService {
                  inner,
                  kind: self.kind,
              }
          }
      *)
      Definition layer (self : ref Self) (inner : S) : M Service :=
        let* self := M.alloc self in
        let* inner := M.alloc inner in
        M.read foo.
      
      Global Instance AssociatedFunction_layer :
        Notations.DoubleColon Self "layer" := {
        Notations.double_colon := layer;
      }.
      
      Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
        tower_layer.Layer.Service := Service;
        tower_layer.Layer.layer := layer;
      }.
    End Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    End Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    
    Module private.
      Module  DefaultBodyLimitService.
      Section DefaultBodyLimitService.
        Context (S : Set).
        
        Record t : Set := {
          inner : S;
          kind : axum_core.extract.default_body_limit.DefaultBodyLimitKind.t;
        }.
        
        Definition Get_inner :=
          Ref.map
            (fun α => Some α.(inner))
            (fun β α => Some (α <| inner := β |>)).
        Definition Get_kind :=
          Ref.map
            (fun α => Some α.(kind))
            (fun β α => Some (α <| kind := β |>)).
      End DefaultBodyLimitService.
      End DefaultBodyLimitService.
      
      Module  Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      Section Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
        Context {S : Set}.
        
        Context {ℋ_0 : core.fmt.Debug.Trait S}.
        
        Definition Self : Set :=
          axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
            S.
        
        (*
            Debug
        *)
        Definition fmt
            (self : ref Self)
            (f : mut_ref core.fmt.Formatter.t)
            : M ltac:(core.fmt.Result) :=
          let* self := M.alloc self in
          let* f := M.alloc f in
          M.read foo.
        
        Global Instance AssociatedFunction_fmt :
          Notations.DoubleColon Self "fmt" := {
          Notations.double_colon := fmt;
        }.
        
        Global Instance ℐ : core.fmt.Debug.Trait Self := {
          core.fmt.Debug.fmt := fmt;
        }.
      End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      
      Module  Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      Section Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
        Context {S : Set}.
        
        Context {ℋ_0 : core.clone.Clone.Trait S}.
        
        Definition Self : Set :=
          axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
            S.
        
        (*
            Clone
        *)
        Definition clone
            (self : ref Self)
            :
              M
                (axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
                  S) :=
          let* self := M.alloc self in
          M.read foo.
        
        Global Instance AssociatedFunction_clone :
          Notations.DoubleColon Self "clone" := {
          Notations.double_colon := clone;
        }.
        
        Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
          core.clone.Clone.clone := clone;
          core.clone.Clone.clone_from := Datatypes.None;
        }.
      End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      
      Module  Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      Section Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
        Context {S : Set}.
        
        Context {ℋ_0 : core.marker.Copy.Trait S}.
        
        Definition Self : Set :=
          axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
            S.
        
        Global Instance ℐ : core.marker.Copy.Trait Self := {
        }.
      End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      
      Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
        Context {B S : Set}.
        
        Context
          {ℋ_0 :
            tower_service.Service.Trait S
              (Request := http.request.Request.t B)}.
        
        Definition Self : Set :=
          axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
            S.
        
        (*
                type Response = S::Response;
        *)
        Definition Response : Set := S::type["Response"].t.
        
        (*
                type Error = S::Error;
        *)
        Definition Error : Set := S::type["Error"].t.
        
        (*
                type Future = S::Future;
        *)
        Definition Future : Set := S::type["Future"].t.
        
        (*
                fn poll_ready(&mut self, cx: &mut Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
                    self.inner.poll_ready(cx)
                }
        *)
        Definition poll_ready
            (self : mut_ref Self)
            (cx : mut_ref core.task.wake.Context.t)
            : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
          let* self := M.alloc self in
          let* cx := M.alloc cx in
          M.read foo.
        
        Global Instance AssociatedFunction_poll_ready :
          Notations.DoubleColon Self "poll_ready" := {
          Notations.double_colon := poll_ready;
        }.
        
        (*
                fn call(&mut self, mut req: Request<B>) -> Self::Future {
                    req.extensions_mut().insert(self.kind);
                    self.inner.call(req)
                }
        *)
        Definition call
            (self : mut_ref Self)
            (req : http.request.Request.t B)
            : M Future :=
          let* self := M.alloc self in
          let* req := M.alloc req in
          M.read foo.
        
        Global Instance AssociatedFunction_call :
          Notations.DoubleColon Self "call" := {
          Notations.double_colon := call;
        }.
        
        Global Instance ℐ :
          tower_service.Service.Trait Self
            (Request := http.request.Request.t B) := {
          tower_service.Service.Response := Response;
          tower_service.Service.Error := Error;
          tower_service.Service.Future := Future;
          tower_service.Service.poll_ready := poll_ready;
          tower_service.Service.call := call;
        }.
      End Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      End Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    End private.
  End default_body_limit.
  
  Module from_ref.
    Module  FromRef.
    Section FromRef.
      Class Trait (Self : Set) {T : Set} : Type := {
        from_ref : (ref T) -> M Self;
      }.
      
    End FromRef.
    End FromRef.
    
    Module  Impl_axum_core_extract_from_ref_FromRef_T_for_T.
    Section Impl_axum_core_extract_from_ref_FromRef_T_for_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait T}.
      
      Definition Self : Set := T.
      
      (*
          fn from_ref(input: &T) -> Self {
              input.clone()
          }
      *)
      Definition from_ref (input : ref T) : M Self :=
        let* input := M.alloc input in
        M.read foo.
      
      Global Instance AssociatedFunction_from_ref :
        Notations.DoubleColon Self "from_ref" := {
        Notations.double_colon := from_ref;
      }.
      
      Global Instance ℐ :
        axum_core.extract.from_ref.FromRef.Trait Self (T := T) := {
        axum_core.extract.from_ref.FromRef.from_ref := from_ref;
      }.
    End Impl_axum_core_extract_from_ref_FromRef_T_for_T.
    End Impl_axum_core_extract_from_ref_FromRef_T_for_T.
  End from_ref.
  
  Module request_parts.
    Module  Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
    Section Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T).
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
              Ok(req)
          }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (Pattern : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
    End Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.
    Section Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := http.method.Method.t.
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
              Ok(parts.method.clone())
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (Pattern : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.
    Section Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := http.uri.Uri.t.
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
              Ok(parts.uri.clone())
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (Pattern : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.
    Section Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := http.version.Version.t.
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
              Ok(parts.version)
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (Pattern : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    Section Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T.
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
              Ok(parts.headers.clone())
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (Pattern : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.
    Section Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := bytes.bytes.Bytes.t.
      
      (*
          type Rejection = BytesRejection;
      *)
      Definition Rejection : Set :=
        axum_core.extract.rejection.BytesRejection.t.
      
      (*
          async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
              let bytes = req
                  .into_limited_body()
                  .collect()
                  .await
                  .map_err(FailedToBufferBody::from_err)?
                  .to_bytes();
      
              Ok(bytes)
          }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (Pattern : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.
    End Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.
    Section Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := alloc.string.String.t.
      
      (*
          type Rejection = StringRejection;
      *)
      Definition Rejection : Set :=
        axum_core.extract.rejection.StringRejection.t.
      
      (*
          async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
              let bytes = Bytes::from_request(req, state)
                  .await
                  .map_err(|err| match err {
                      BytesRejection::FailedToBufferBody(inner) => {
                          StringRejection::FailedToBufferBody(inner)
                      }
                  })?;
      
              let string = std::str::from_utf8(&bytes)
                  .map_err(InvalidUtf8::from_err)?
                  .to_owned();
      
              Ok(string)
          }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.
    End Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.
    Section Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := http.request.Parts.t.
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
              Ok(parts.clone())
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (_state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* _state := M.alloc _state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.
    Section Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := http.extensions.Extensions.t.
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
              Ok(parts.extensions.clone())
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (_state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* _state := M.alloc _state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.
    End Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.
    Section Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum_core.body.Body.t.
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
              Ok(req.into_body())
          }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (Pattern : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.
    End Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.
  End request_parts.
  
  Module tuple.
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := unit.
      
      (*
          type Rejection = Infallible;
      *)
      Definition Rejection : Set := core.convert.Infallible.t.
      
      (*
          async fn from_request_parts(_: &mut Parts, _: &S) -> Result<(), Self::Rejection> {
              Ok(())
          }
      *)
      Definition from_request_parts
          (Pattern : mut_ref http.request.Parts.t)
          (Pattern : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* Pattern := M.alloc Pattern in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.
      Context {S T1 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := T1.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.
      Context {S T1 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.extract.FromRequest.Trait T1
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T1)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := T1.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.
      Context {S T1 T2 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : core.marker.Send.Trait S}
        {ℋ_5 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := T1 * T2.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.
      Context {S T1 T2 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 :
          axum_core.extract.FromRequest.Trait T2
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T2)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : core.marker.Send.Trait S}
        {ℋ_5 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := T1 * T2.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.
      Context {S T1 T2 T3 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : core.marker.Send.Trait S}
        {ℋ_7 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := (T1 * T2) * T3.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.
      Context {S T1 T2 T3 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 :
          axum_core.extract.FromRequest.Trait T3
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T3)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : core.marker.Send.Trait S}
        {ℋ_7 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := (T1 * T2) * T3.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.
      Context {S T1 T2 T3 T4 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : core.marker.Send.Trait S}
        {ℋ_9 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := ((T1 * T2) * T3) * T4.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.
      Context {S T1 T2 T3 T4 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 :
          axum_core.extract.FromRequest.Trait T4
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T4)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : core.marker.Send.Trait S}
        {ℋ_9 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := ((T1 * T2) * T3) * T4.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.
      Context {S T1 T2 T3 T4 T5 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : core.marker.Send.Trait S}
        {ℋ_11 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := (((T1 * T2) * T3) * T4) * T5.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.
      Context {S T1 T2 T3 T4 T5 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 :
          axum_core.extract.FromRequest.Trait T5
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T5)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : core.marker.Send.Trait S}
        {ℋ_11 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := (((T1 * T2) * T3) * T4) * T5.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
      Context {S T1 T2 T3 T4 T5 T6 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : core.marker.Send.Trait S}
        {ℋ_13 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * T6.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
      Context {S T1 T2 T3 T4 T5 T6 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 :
          axum_core.extract.FromRequest.Trait T6
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T6)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : core.marker.Send.Trait S}
        {ℋ_13 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * T6.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
      Context {S T1 T2 T3 T4 T5 T6 T7 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : core.marker.Send.Trait S}
        {ℋ_15 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
      Context {S T1 T2 T3 T4 T5 T6 T7 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 :
          axum_core.extract.FromRequest.Trait T7
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T7)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : core.marker.Send.Trait S}
        {ℋ_15 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : core.marker.Send.Trait S}
        {ℋ_17 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 :
          axum_core.extract.FromRequest.Trait T8
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T8)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : core.marker.Send.Trait S}
        {ℋ_17 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : core.marker.Send.Trait S}
        {ℋ_19 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 :
          axum_core.extract.FromRequest.Trait T9
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T9)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : core.marker.Send.Trait S}
        {ℋ_19 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : core.marker.Send.Trait S}
        {ℋ_21 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 :
          axum_core.extract.FromRequest.Trait T10
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T10)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : core.marker.Send.Trait S}
        {ℋ_21 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 : core.marker.Send.Trait S}
        {ℋ_23 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 :
          axum_core.extract.FromRequest.Trait T11
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T11)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 : core.marker.Send.Trait S}
        {ℋ_23 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_23 : core.marker.Send.Trait T12}
        {ℋ_24 : core.marker.Send.Trait S}
        {ℋ_25 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 :
          axum_core.extract.FromRequest.Trait T12
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T12)}
        {ℋ_23 : core.marker.Send.Trait T12}
        {ℋ_24 : core.marker.Send.Trait S}
        {ℋ_25 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_23 : core.marker.Send.Trait T12}
        {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_25 : core.marker.Send.Trait T13}
        {ℋ_26 : core.marker.Send.Trait S}
        {ℋ_27 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_23 : core.marker.Send.Trait T12}
        {ℋ_24 :
          axum_core.extract.FromRequest.Trait T13
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T13)}
        {ℋ_25 : core.marker.Send.Trait T13}
        {ℋ_26 : core.marker.Send.Trait S}
        {ℋ_27 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_23 : core.marker.Send.Trait T12}
        {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_25 : core.marker.Send.Trait T13}
        {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_27 : core.marker.Send.Trait T14}
        {ℋ_28 : core.marker.Send.Trait S}
        {ℋ_29 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_23 : core.marker.Send.Trait T12}
        {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_25 : core.marker.Send.Trait T13}
        {ℋ_26 :
          axum_core.extract.FromRequest.Trait T14
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T14)}
        {ℋ_27 : core.marker.Send.Trait T14}
        {ℋ_28 : core.marker.Send.Trait S}
        {ℋ_29 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_23 : core.marker.Send.Trait T12}
        {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_25 : core.marker.Send.Trait T13}
        {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_27 : core.marker.Send.Trait T14}
        {ℋ_28 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
        {ℋ_29 : core.marker.Send.Trait T15}
        {ℋ_30 : core.marker.Send.Trait S}
        {ℋ_31 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_23 : core.marker.Send.Trait T12}
        {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_25 : core.marker.Send.Trait T13}
        {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_27 : core.marker.Send.Trait T14}
        {ℋ_28 :
          axum_core.extract.FromRequest.Trait T15
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T15)}
        {ℋ_29 : core.marker.Send.Trait T15}
        {ℋ_30 : core.marker.Send.Trait S}
        {ℋ_31 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_23 : core.marker.Send.Trait T12}
        {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_25 : core.marker.Send.Trait T13}
        {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_27 : core.marker.Send.Trait T14}
        {ℋ_28 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
        {ℋ_29 : core.marker.Send.Trait T15}
        {ℋ_30 : axum_core.extract.FromRequestParts.Trait T16 (S := S)}
        {ℋ_31 : core.marker.Send.Trait T16}
        {ℋ_32 : core.marker.Send.Trait S}
        {ℋ_33 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                      $(
                          let $ty = $ty::from_request_parts(parts, state)
                              .await
                              .map_err(|err| err.into_response())?;
                      )*
                      let $last = $last::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
      Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
      
      Context
        {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
        {ℋ_1 : core.marker.Send.Trait T1}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
        {ℋ_3 : core.marker.Send.Trait T2}
        {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
        {ℋ_5 : core.marker.Send.Trait T3}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
        {ℋ_7 : core.marker.Send.Trait T4}
        {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
        {ℋ_9 : core.marker.Send.Trait T5}
        {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
        {ℋ_11 : core.marker.Send.Trait T6}
        {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
        {ℋ_13 : core.marker.Send.Trait T7}
        {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
        {ℋ_15 : core.marker.Send.Trait T8}
        {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
        {ℋ_17 : core.marker.Send.Trait T9}
        {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
        {ℋ_19 : core.marker.Send.Trait T10}
        {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
        {ℋ_21 : core.marker.Send.Trait T11}
        {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
        {ℋ_23 : core.marker.Send.Trait T12}
        {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
        {ℋ_25 : core.marker.Send.Trait T13}
        {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
        {ℋ_27 : core.marker.Send.Trait T14}
        {ℋ_28 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
        {ℋ_29 : core.marker.Send.Trait T15}
        {ℋ_30 :
          axum_core.extract.FromRequest.Trait T16
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M T16)}
        {ℋ_31 : core.marker.Send.Trait T16}
        {ℋ_32 : core.marker.Send.Trait S}
        {ℋ_33 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16.
      
      (*
                  type Rejection = Response;
      *)
      Definition Rejection : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                      let (mut parts, body) = req.into_parts();
      
                      $(
                          let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                      )*
      
                      let req = Request::from_parts(parts, body);
      
                      let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
      
                      Ok(($($ty,)* $last,))
                  }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  End tuple.
  
  Ltac Request T := exact (http.request.Request.t T).
  
  Module private.
    Module ViaParts.
      Inductive t : Set :=
      .
    End ViaParts.
    
    Module  Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.
    Section Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.
      Definition Self : Set := axum_core.extract.private.ViaParts.t.
      
      (*
          Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.
    End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.
    
    Module  Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.
    Section Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.
      Definition Self : Set := axum_core.extract.private.ViaParts.t.
      
      (*
          Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum_core.extract.private.ViaParts.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.
    End Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.
    
    Module  Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.
    Section Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.
      Definition Self : Set := axum_core.extract.private.ViaParts.t.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.
    End Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.
    
    Module ViaRequest.
      Inductive t : Set :=
      .
    End ViaRequest.
    
    Module  Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.
    Section Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.
      Definition Self : Set := axum_core.extract.private.ViaRequest.t.
      
      (*
          Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.
    End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.
    
    Module  Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.
    Section Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.
      Definition Self : Set := axum_core.extract.private.ViaRequest.t.
      
      (*
          Clone
      *)
      Definition clone
          (self : ref Self)
          : M axum_core.extract.private.ViaRequest.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.
    End Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.
    
    Module  Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.
    Section Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.
      Definition Self : Set := axum_core.extract.private.ViaRequest.t.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.
    End Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.
  End private.
  
  Module  FromRequestParts.
  Section FromRequestParts.
    Class Trait (Self : Set) {S : Set} : Type := {
      Rejection : Set;
      ℒ_0 :: axum_core.response.into_response.IntoResponse.Trait Rejection;
      from_request_parts :
        (mut_ref http.request.Parts.t) ->
          (ref S) ->
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A));
    }.
    
    Global Instance Method_Rejection `(Trait) :
      Notations.DoubleColonType Self "Rejection" := {
      Notations.double_colon_type := Rejection;
    }.
  End FromRequestParts.
  End FromRequestParts.
  
  Module  FromRequest.
  Section FromRequest.
    Class Trait (Self : Set) {S (* TODO *) M : Set} : Type := {
      Rejection : Set;
      ℒ_0 :: axum_core.response.into_response.IntoResponse.Trait Rejection;
      from_request :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T) ->
          (ref S) ->
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A));
    }.
    
    Global Instance Method_Rejection `(Trait) :
      Notations.DoubleColonType Self "Rejection" := {
      Notations.double_colon_type := Rejection;
    }.
  End FromRequest.
  End FromRequest.
  
  Module  Impl_axum_core_extract_FromRequest_S_axum_core_extract_private_ViaParts_t_for_T.
  Section Impl_axum_core_extract_FromRequest_S_axum_core_extract_private_ViaParts_t_for_T.
    Context {S T : Set}.
    
    Context
      {ℋ_0 : core.marker.Send.Trait S}
      {ℋ_1 : core.marker.Sync.Trait S}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T (S := S)}.
    
    Definition Self : Set := T.
    
    (*
        type Rejection = <Self as FromRequestParts<S>>::Rejection;
    *)
    Definition Rejection : Set :=
      axum_core.extract.FromRequestParts.Rejection
          (Self := Self)
          (Trait := ltac:(refine _)).
    
    (*
        async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
            let (mut parts, _) = req.into_parts();
            Self::from_request_parts(&mut parts, state).await
        }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.private.ViaParts.t) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_axum_core_extract_private_ViaParts_t_for_T.
  End Impl_axum_core_extract_FromRequest_S_axum_core_extract_private_ViaParts_t_for_T.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_core_option_Option_t_T.
  Section Impl_axum_core_extract_FromRequestParts_S_for_core_option_Option_t_T.
    Context {S T : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := core.option.Option.t T.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(
            parts: &mut Parts,
            state: &S,
        ) -> Result<Option<T>, Self::Rejection> {
            Ok(T::from_request_parts(parts, state).await.ok())
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_core_option_Option_t_T.
  End Impl_axum_core_extract_FromRequestParts_S_for_core_option_Option_t_T.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_core_option_Option_t_T.
  Section Impl_axum_core_extract_FromRequest_S_for_core_option_Option_t_T.
    Context {S T : Set}.
    
    Context
      {ℋ_0 :
        axum_core.extract.FromRequest.Trait T
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := core.option.Option.t T.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request(req: Request, state: &S) -> Result<Option<T>, Self::Rejection> {
            Ok(T::from_request(req, state).await.ok())
        }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_core_option_Option_t_T.
  End Impl_axum_core_extract_FromRequest_S_for_core_option_Option_t_T.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
    Context {S T : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T (S := S)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := core.result.Result.t T T::type["Rejection"].t.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
            Ok(T::from_request_parts(parts, state).await)
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
  Section Impl_axum_core_extract_FromRequest_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
    Context {S T : Set}.
    
    Context
      {ℋ_0 :
        axum_core.extract.FromRequest.Trait T
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T)}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := core.result.Result.t T T::type["Rejection"].t.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
            Ok(T::from_request(req, state).await)
        }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
  End Impl_axum_core_extract_FromRequest_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
End extract.

Module rejection.
  Module FailedToBufferBody.
    Inductive t : Set :=
    | LengthLimitError (_ : axum_core.extract.rejection.LengthLimitError.t)
    | UnknownBodyError (_ : axum_core.extract.rejection.UnknownBodyError.t).
    
    Definition Get_LengthLimitError_0 :=
      Ref.map
        (fun α => match α with | LengthLimitError α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | LengthLimitError _ => Some (LengthLimitError β)
          | _ => None
          end).
    
    Definition Get_UnknownBodyError_0 :=
      Ref.map
        (fun α => match α with | UnknownBodyError α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | UnknownBodyError _ => Some (UnknownBodyError β)
          | _ => None
          end).
  End FailedToBufferBody.
  
  Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.
  
  Module  Impl_axum_core_extract_rejection_FailedToBufferBody_t_3.
  Section Impl_axum_core_extract_rejection_FailedToBufferBody_t_3.
    Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_core_extract_rejection_FailedToBufferBody_t_3.
  End Impl_axum_core_extract_rejection_FailedToBufferBody_t_3.
  
  Module  Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Section Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum_core.extract.rejection.LengthLimitError.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum_core.extract.rejection.LengthLimitError.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
  End Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
  
  Module  Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Section Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum_core.extract.rejection.UnknownBodyError.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum_core.extract.rejection.UnknownBodyError.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
  End Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
  
  Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Section Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.
  
  Module  Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Section Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.
    Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.
  End Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.
  
  Module  Impl_axum_core_extract_rejection_FailedToBufferBody_t_4.
  Section Impl_axum_core_extract_rejection_FailedToBufferBody_t_4.
    Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
    
    (*
        pub(crate) fn from_err<E>(err: E) -> Self
        where
            E: Into<BoxError>,
        {
            // two layers of boxes here because `with_limited_body`
            // wraps the `http_body_util::Limited` in a `axum_core::Body`
            // which also wraps the error type
            let box_error = match err.into().downcast::<Error>() {
                Ok(err) => err.into_inner(),
                Err(err) => err,
            };
            let box_error = match box_error.downcast::<Error>() {
                Ok(err) => err.into_inner(),
                Err(err) => err,
            };
            match box_error.downcast::<http_body_util::LengthLimitError>() {
                Ok(err) => Self::LengthLimitError(LengthLimitError::from_err(err)),
                Err(err) => Self::UnknownBodyError(UnknownBodyError::from_err(err)),
            }
        }
    *)
    Definition from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
        (err : E)
        : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "from_err" := {
      Notations.double_colon := from_err (E := E);
    }.
  End Impl_axum_core_extract_rejection_FailedToBufferBody_t_4.
  End Impl_axum_core_extract_rejection_FailedToBufferBody_t_4.
  
  Module  LengthLimitError.
  Section LengthLimitError.
    Record t : Set := {
      x0 : axum_core.error.Error.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End LengthLimitError.
  End LengthLimitError.
  
  Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.
  Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.
    Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.
  
  Module  Impl_axum_core_extract_rejection_LengthLimitError_t_3.
  Section Impl_axum_core_extract_rejection_LengthLimitError_t_3.
    Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
    
    (*
                pub(crate) fn from_err<E>(err: E) -> Self
                where
                    E: Into<$crate::BoxError>,
                {
                    Self($crate::Error::new(err))
                }
    *)
    Definition from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
        (err : E)
        : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "from_err" := {
      Notations.double_colon := from_err (E := E);
    }.
  End Impl_axum_core_extract_rejection_LengthLimitError_t_3.
  End Impl_axum_core_extract_rejection_LengthLimitError_t_3.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.
    Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = self.body_text(),
                        status = http::StatusCode::$status,
                    );
                    (self.status(), self.body_text()).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.
  
  Module  Impl_axum_core_extract_rejection_LengthLimitError_t_4.
  Section Impl_axum_core_extract_rejection_LengthLimitError_t_4.
    Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
    
    (*
                pub fn body_text(&self) -> String {
                    format!(concat!($body, ": {}"), self.0).into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_core_extract_rejection_LengthLimitError_t_4.
  End Impl_axum_core_extract_rejection_LengthLimitError_t_4.
  
  Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.
  Section Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.
    Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.
  
  Module  Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.
  Section Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.
    Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    Some(&self.0)
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.
  End Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.
  
  Module  UnknownBodyError.
  Section UnknownBodyError.
    Record t : Set := {
      x0 : axum_core.error.Error.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End UnknownBodyError.
  End UnknownBodyError.
  
  Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.
  Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.
    Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.
  
  Module  Impl_axum_core_extract_rejection_UnknownBodyError_t_3.
  Section Impl_axum_core_extract_rejection_UnknownBodyError_t_3.
    Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
    
    (*
                pub(crate) fn from_err<E>(err: E) -> Self
                where
                    E: Into<$crate::BoxError>,
                {
                    Self($crate::Error::new(err))
                }
    *)
    Definition from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
        (err : E)
        : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "from_err" := {
      Notations.double_colon := from_err (E := E);
    }.
  End Impl_axum_core_extract_rejection_UnknownBodyError_t_3.
  End Impl_axum_core_extract_rejection_UnknownBodyError_t_3.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.
    Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = self.body_text(),
                        status = http::StatusCode::$status,
                    );
                    (self.status(), self.body_text()).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.
  
  Module  Impl_axum_core_extract_rejection_UnknownBodyError_t_4.
  Section Impl_axum_core_extract_rejection_UnknownBodyError_t_4.
    Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
    
    (*
                pub fn body_text(&self) -> String {
                    format!(concat!($body, ": {}"), self.0).into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_core_extract_rejection_UnknownBodyError_t_4.
  End Impl_axum_core_extract_rejection_UnknownBodyError_t_4.
  
  Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.
  Section Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.
    Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.
  
  Module  Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.
  Section Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.
    Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    Some(&self.0)
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.
  End Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.
  
  Module  InvalidUtf8.
  Section InvalidUtf8.
    Record t : Set := {
      x0 : axum_core.error.Error.t;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End InvalidUtf8.
  End InvalidUtf8.
  
  Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.
  Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.
    Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.
  
  Module  Impl_axum_core_extract_rejection_InvalidUtf8_t_3.
  Section Impl_axum_core_extract_rejection_InvalidUtf8_t_3.
    Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
    
    (*
                pub(crate) fn from_err<E>(err: E) -> Self
                where
                    E: Into<$crate::BoxError>,
                {
                    Self($crate::Error::new(err))
                }
    *)
    Definition from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
        (err : E)
        : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_from_err
        {E : Set}
        {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
      Notations.DoubleColon Self "from_err" := {
      Notations.double_colon := from_err (E := E);
    }.
  End Impl_axum_core_extract_rejection_InvalidUtf8_t_3.
  End Impl_axum_core_extract_rejection_InvalidUtf8_t_3.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.
    Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    $crate::__log_rejection!(
                        rejection_type = $name,
                        body_text = self.body_text(),
                        status = http::StatusCode::$status,
                    );
                    (self.status(), self.body_text()).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.
  
  Module  Impl_axum_core_extract_rejection_InvalidUtf8_t_4.
  Section Impl_axum_core_extract_rejection_InvalidUtf8_t_4.
    Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
    
    (*
                pub fn body_text(&self) -> String {
                    format!(concat!($body, ": {}"), self.0).into()
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    http::StatusCode::$status
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_core_extract_rejection_InvalidUtf8_t_4.
  End Impl_axum_core_extract_rejection_InvalidUtf8_t_4.
  
  Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.
  Section Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.
    Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", $body)
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.
  
  Module  Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.
  Section Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.
    Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    Some(&self.0)
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.
  End Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.
  
  Module BytesRejection.
    Inductive t : Set :=
    | FailedToBufferBody (_ : axum_core.extract.rejection.FailedToBufferBody.t).
    
    Definition Get_FailedToBufferBody_0 :=
      Ref.map
        (fun α => match α with | FailedToBufferBody α0 => Some α0 end)
        (fun β α =>
          match α with
          | FailedToBufferBody _ => Some (FailedToBufferBody β)
          end).
  End BytesRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.
  Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.
    Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.
    Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.
  
  Module  Impl_axum_core_extract_rejection_BytesRejection_t_2.
  Section Impl_axum_core_extract_rejection_BytesRejection_t_2.
    Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_core_extract_rejection_BytesRejection_t_2.
  End Impl_axum_core_extract_rejection_BytesRejection_t_2.
  
  Module  Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.
  Section Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.
    Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum_core.extract.rejection.FailedToBufferBody.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum_core.extract.rejection.FailedToBufferBody.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.
  End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.
  
  Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.
  Section Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.
    Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.
  
  Module  Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.
  Section Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.
    Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.
  End Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.
  
  Module StringRejection.
    Inductive t : Set :=
    | FailedToBufferBody (_ : axum_core.extract.rejection.FailedToBufferBody.t)
    | InvalidUtf8 (_ : axum_core.extract.rejection.InvalidUtf8.t).
    
    Definition Get_FailedToBufferBody_0 :=
      Ref.map
        (fun α =>
          match α with | FailedToBufferBody α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | FailedToBufferBody _ => Some (FailedToBufferBody β)
          | _ => None
          end).
    
    Definition Get_InvalidUtf8_0 :=
      Ref.map
        (fun α => match α with | InvalidUtf8 α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with | InvalidUtf8 _ => Some (InvalidUtf8 β) | _ => None end).
  End StringRejection.
  
  Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.
  Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.
    Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.
  End Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.
    Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
    
    (*
                fn into_response(self) -> $crate::response::Response {
                    match self {
                        $(
                            Self::$variant(inner) => inner.into_response(),
                        )+
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.
  
  Module  Impl_axum_core_extract_rejection_StringRejection_t_2.
  Section Impl_axum_core_extract_rejection_StringRejection_t_2.
    Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
    
    (*
                pub fn body_text(&self) -> String {
                    match self {
                        $(
                            Self::$variant(inner) => inner.body_text(),
                        )+
                    }
                }
    *)
    Definition body_text (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_body_text :
      Notations.DoubleColon Self "body_text" := {
      Notations.double_colon := body_text;
    }.
    
    (*
                pub fn status(&self) -> http::StatusCode {
                    match self {
                        $(
                            Self::$variant(inner) => inner.status(),
                        )+
                    }
                }
    *)
    Definition status (self : ref Self) : M http.status.StatusCode.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_status :
      Notations.DoubleColon Self "status" := {
      Notations.double_colon := status;
    }.
  End Impl_axum_core_extract_rejection_StringRejection_t_2.
  End Impl_axum_core_extract_rejection_StringRejection_t_2.
  
  Module  Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.
  Section Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.
    Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum_core.extract.rejection.FailedToBufferBody.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum_core.extract.rejection.FailedToBufferBody.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.
  End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.
  
  Module  Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.
  Section Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.
    Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
    
    (*
                    fn from(inner: $variant) -> Self {
                        Self::$variant(inner)
                    }
    *)
    Definition from
        (inner : axum_core.extract.rejection.InvalidUtf8.t)
        : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum_core.extract.rejection.InvalidUtf8.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.
  End Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.
  
  Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.
  Section Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.
    Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
    
    (*
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        $(
                            Self::$variant(inner) => write!(f, "{inner}"),
                        )+
                    }
                }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.
  End Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.
  
  Module  Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.
  Section Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.
    Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
    
    (*
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    match self {
                        $(
                            Self::$variant(inner) => inner.source(),
                        )+
                    }
                }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.
  End Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.
End rejection.

Module FailedToBufferBody.
  Inductive t : Set :=
  | LengthLimitError (_ : axum_core.extract.rejection.LengthLimitError.t)
  | UnknownBodyError (_ : axum_core.extract.rejection.UnknownBodyError.t).
  
  Definition Get_LengthLimitError_0 :=
    Ref.map
      (fun α => match α with | LengthLimitError α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | LengthLimitError _ => Some (LengthLimitError β)
        | _ => None
        end).
  
  Definition Get_UnknownBodyError_0 :=
    Ref.map
      (fun α => match α with | UnknownBodyError α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | UnknownBodyError _ => Some (UnknownBodyError β)
        | _ => None
        end).
End FailedToBufferBody.

Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.
Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_FailedToBufferBody_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_FailedToBufferBody_t.

Module  Impl_axum_core_extract_rejection_FailedToBufferBody_t_5.
Section Impl_axum_core_extract_rejection_FailedToBufferBody_t_5.
  Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_core_extract_rejection_FailedToBufferBody_t_5.
End Impl_axum_core_extract_rejection_FailedToBufferBody_t_5.

Module  Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
Section Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum_core.extract.rejection.LengthLimitError.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum_core.extract.rejection.LengthLimitError.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
End Impl_core_convert_From_axum_core_extract_rejection_LengthLimitError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.

Module  Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
Section Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum_core.extract.rejection.UnknownBodyError.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum_core.extract.rejection.UnknownBodyError.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.
End Impl_core_convert_From_axum_core_extract_rejection_UnknownBodyError_t_for_axum_core_extract_rejection_FailedToBufferBody_t.

Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.
Section Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_FailedToBufferBody_t.

Module  Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.
Section Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.
  Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.
End Impl_core_error_Error_for_axum_core_extract_rejection_FailedToBufferBody_t.

Module  Impl_axum_core_extract_rejection_FailedToBufferBody_t_6.
Section Impl_axum_core_extract_rejection_FailedToBufferBody_t_6.
  Definition Self : Set := axum_core.extract.rejection.FailedToBufferBody.t.
  
  (*
      pub(crate) fn from_err<E>(err: E) -> Self
      where
          E: Into<BoxError>,
      {
          // two layers of boxes here because `with_limited_body`
          // wraps the `http_body_util::Limited` in a `axum_core::Body`
          // which also wraps the error type
          let box_error = match err.into().downcast::<Error>() {
              Ok(err) => err.into_inner(),
              Err(err) => err,
          };
          let box_error = match box_error.downcast::<Error>() {
              Ok(err) => err.into_inner(),
              Err(err) => err,
          };
          match box_error.downcast::<http_body_util::LengthLimitError>() {
              Ok(err) => Self::LengthLimitError(LengthLimitError::from_err(err)),
              Err(err) => Self::UnknownBodyError(UnknownBodyError::from_err(err)),
          }
      }
  *)
  Definition from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
      (err : E)
      : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "from_err" := {
    Notations.double_colon := from_err (E := E);
  }.
End Impl_axum_core_extract_rejection_FailedToBufferBody_t_6.
End Impl_axum_core_extract_rejection_FailedToBufferBody_t_6.

Module  LengthLimitError.
Section LengthLimitError.
  Record t : Set := {
    x0 : axum_core.error.Error.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End LengthLimitError.
End LengthLimitError.

Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.
Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.
  Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_LengthLimitError_t.

Module  Impl_axum_core_extract_rejection_LengthLimitError_t_5.
Section Impl_axum_core_extract_rejection_LengthLimitError_t_5.
  Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
  
  (*
              pub(crate) fn from_err<E>(err: E) -> Self
              where
                  E: Into<$crate::BoxError>,
              {
                  Self($crate::Error::new(err))
              }
  *)
  Definition from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
      (err : E)
      : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "from_err" := {
    Notations.double_colon := from_err (E := E);
  }.
End Impl_axum_core_extract_rejection_LengthLimitError_t_5.
End Impl_axum_core_extract_rejection_LengthLimitError_t_5.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.
  Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = self.body_text(),
                      status = http::StatusCode::$status,
                  );
                  (self.status(), self.body_text()).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_LengthLimitError_t.

Definition __CALLSITE : M.Val (ref tracing_core.callsite.DefaultCallsite.t) :=
  M.run (M.alloc foo).

Definition META : M.Val (ref tracing_core.metadata.Metadata.t) :=
  M.run (M.alloc foo).

Module  Impl_axum_core_extract_rejection_LengthLimitError_t_6.
Section Impl_axum_core_extract_rejection_LengthLimitError_t_6.
  Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
  
  (*
              pub fn body_text(&self) -> String {
                  format!(concat!($body, ": {}"), self.0).into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_core_extract_rejection_LengthLimitError_t_6.
End Impl_axum_core_extract_rejection_LengthLimitError_t_6.

Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.
Section Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.
  Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_LengthLimitError_t.

Module  Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.
Section Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.
  Definition Self : Set := axum_core.extract.rejection.LengthLimitError.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  Some(&self.0)
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.
End Impl_core_error_Error_for_axum_core_extract_rejection_LengthLimitError_t.

Module  UnknownBodyError.
Section UnknownBodyError.
  Record t : Set := {
    x0 : axum_core.error.Error.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End UnknownBodyError.
End UnknownBodyError.

Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.
Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.
  Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_UnknownBodyError_t.

Module  Impl_axum_core_extract_rejection_UnknownBodyError_t_5.
Section Impl_axum_core_extract_rejection_UnknownBodyError_t_5.
  Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
  
  (*
              pub(crate) fn from_err<E>(err: E) -> Self
              where
                  E: Into<$crate::BoxError>,
              {
                  Self($crate::Error::new(err))
              }
  *)
  Definition from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
      (err : E)
      : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "from_err" := {
    Notations.double_colon := from_err (E := E);
  }.
End Impl_axum_core_extract_rejection_UnknownBodyError_t_5.
End Impl_axum_core_extract_rejection_UnknownBodyError_t_5.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.
  Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = self.body_text(),
                      status = http::StatusCode::$status,
                  );
                  (self.status(), self.body_text()).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_UnknownBodyError_t.

Module  Impl_axum_core_extract_rejection_UnknownBodyError_t_6.
Section Impl_axum_core_extract_rejection_UnknownBodyError_t_6.
  Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
  
  (*
              pub fn body_text(&self) -> String {
                  format!(concat!($body, ": {}"), self.0).into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_core_extract_rejection_UnknownBodyError_t_6.
End Impl_axum_core_extract_rejection_UnknownBodyError_t_6.

Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.
Section Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.
  Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_UnknownBodyError_t.

Module  Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.
Section Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.
  Definition Self : Set := axum_core.extract.rejection.UnknownBodyError.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  Some(&self.0)
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.
End Impl_core_error_Error_for_axum_core_extract_rejection_UnknownBodyError_t.

Module  InvalidUtf8.
Section InvalidUtf8.
  Record t : Set := {
    x0 : axum_core.error.Error.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End InvalidUtf8.
End InvalidUtf8.

Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.
Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.
  Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_InvalidUtf8_t.

Module  Impl_axum_core_extract_rejection_InvalidUtf8_t_5.
Section Impl_axum_core_extract_rejection_InvalidUtf8_t_5.
  Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
  
  (*
              pub(crate) fn from_err<E>(err: E) -> Self
              where
                  E: Into<$crate::BoxError>,
              {
                  Self($crate::Error::new(err))
              }
  *)
  Definition from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))}
      (err : E)
      : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_from_err
      {E : Set}
      {ℋ_0 : core.convert.Into.Trait E (T := ltac:(axum_core.BoxError))} :
    Notations.DoubleColon Self "from_err" := {
    Notations.double_colon := from_err (E := E);
  }.
End Impl_axum_core_extract_rejection_InvalidUtf8_t_5.
End Impl_axum_core_extract_rejection_InvalidUtf8_t_5.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.
  Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  $crate::__log_rejection!(
                      rejection_type = $name,
                      body_text = self.body_text(),
                      status = http::StatusCode::$status,
                  );
                  (self.status(), self.body_text()).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_InvalidUtf8_t.

Module  Impl_axum_core_extract_rejection_InvalidUtf8_t_6.
Section Impl_axum_core_extract_rejection_InvalidUtf8_t_6.
  Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
  
  (*
              pub fn body_text(&self) -> String {
                  format!(concat!($body, ": {}"), self.0).into()
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  http::StatusCode::$status
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_core_extract_rejection_InvalidUtf8_t_6.
End Impl_axum_core_extract_rejection_InvalidUtf8_t_6.

Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.
Section Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.
  Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  write!(f, "{}", $body)
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_InvalidUtf8_t.

Module  Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.
Section Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.
  Definition Self : Set := axum_core.extract.rejection.InvalidUtf8.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  Some(&self.0)
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.
End Impl_core_error_Error_for_axum_core_extract_rejection_InvalidUtf8_t.

Module BytesRejection.
  Inductive t : Set :=
  | FailedToBufferBody (_ : axum_core.extract.rejection.FailedToBufferBody.t).
  
  Definition Get_FailedToBufferBody_0 :=
    Ref.map
      (fun α => match α with | FailedToBufferBody α0 => Some α0 end)
      (fun β α =>
        match α with | FailedToBufferBody _ => Some (FailedToBufferBody β) end).
End BytesRejection.

Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.
Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.
  Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_BytesRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.
  Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_BytesRejection_t.

Module  Impl_axum_core_extract_rejection_BytesRejection_t_3.
Section Impl_axum_core_extract_rejection_BytesRejection_t_3.
  Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_core_extract_rejection_BytesRejection_t_3.
End Impl_axum_core_extract_rejection_BytesRejection_t_3.

Module  Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.
Section Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.
  Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum_core.extract.rejection.FailedToBufferBody.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum_core.extract.rejection.FailedToBufferBody.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.
End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_BytesRejection_t.

Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.
Section Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.
  Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_BytesRejection_t.

Module  Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.
Section Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.
  Definition Self : Set := axum_core.extract.rejection.BytesRejection.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.
End Impl_core_error_Error_for_axum_core_extract_rejection_BytesRejection_t.

Module StringRejection.
  Inductive t : Set :=
  | FailedToBufferBody (_ : axum_core.extract.rejection.FailedToBufferBody.t)
  | InvalidUtf8 (_ : axum_core.extract.rejection.InvalidUtf8.t).
  
  Definition Get_FailedToBufferBody_0 :=
    Ref.map
      (fun α => match α with | FailedToBufferBody α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | FailedToBufferBody _ => Some (FailedToBufferBody β)
        | _ => None
        end).
  
  Definition Get_InvalidUtf8_0 :=
    Ref.map
      (fun α => match α with | InvalidUtf8 α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | InvalidUtf8 _ => Some (InvalidUtf8 β) | _ => None end).
End StringRejection.

Module  Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.
Section Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.
  Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.
End Impl_core_fmt_Debug_for_axum_core_extract_rejection_StringRejection_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.
  Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
  
  (*
              fn into_response(self) -> $crate::response::Response {
                  match self {
                      $(
                          Self::$variant(inner) => inner.into_response(),
                      )+
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_extract_rejection_StringRejection_t.

Module  Impl_axum_core_extract_rejection_StringRejection_t_3.
Section Impl_axum_core_extract_rejection_StringRejection_t_3.
  Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
  
  (*
              pub fn body_text(&self) -> String {
                  match self {
                      $(
                          Self::$variant(inner) => inner.body_text(),
                      )+
                  }
              }
  *)
  Definition body_text (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_body_text :
    Notations.DoubleColon Self "body_text" := {
    Notations.double_colon := body_text;
  }.
  
  (*
              pub fn status(&self) -> http::StatusCode {
                  match self {
                      $(
                          Self::$variant(inner) => inner.status(),
                      )+
                  }
              }
  *)
  Definition status (self : ref Self) : M http.status.StatusCode.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_status :
    Notations.DoubleColon Self "status" := {
    Notations.double_colon := status;
  }.
End Impl_axum_core_extract_rejection_StringRejection_t_3.
End Impl_axum_core_extract_rejection_StringRejection_t_3.

Module  Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.
Section Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.
  Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum_core.extract.rejection.FailedToBufferBody.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum_core.extract.rejection.FailedToBufferBody.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.
End Impl_core_convert_From_axum_core_extract_rejection_FailedToBufferBody_t_for_axum_core_extract_rejection_StringRejection_t.

Module  Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.
Section Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.
  Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
  
  (*
                  fn from(inner: $variant) -> Self {
                      Self::$variant(inner)
                  }
  *)
  Definition from
      (inner : axum_core.extract.rejection.InvalidUtf8.t)
      : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum_core.extract.rejection.InvalidUtf8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.
End Impl_core_convert_From_axum_core_extract_rejection_InvalidUtf8_t_for_axum_core_extract_rejection_StringRejection_t.

Module  Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.
Section Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.
  Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
  
  (*
              fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                  match self {
                      $(
                          Self::$variant(inner) => write!(f, "{inner}"),
                      )+
                  }
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.
End Impl_core_fmt_Display_for_axum_core_extract_rejection_StringRejection_t.

Module  Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.
Section Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.
  Definition Self : Set := axum_core.extract.rejection.StringRejection.t.
  
  (*
              fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                  match self {
                      $(
                          Self::$variant(inner) => inner.source(),
                      )+
                  }
              }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.
End Impl_core_error_Error_for_axum_core_extract_rejection_StringRejection_t.

Module default_body_limit.
  Module  DefaultBodyLimit.
  Section DefaultBodyLimit.
    Record t : Set := {
      kind : axum_core.extract.default_body_limit.DefaultBodyLimitKind.t;
    }.
    
    Definition Get_kind :=
      Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
  End DefaultBodyLimit.
  End DefaultBodyLimit.
  
  Module  Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  Section Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    Definition Self : Set :=
      axum_core.extract.default_body_limit.DefaultBodyLimit.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  
  Module  Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  Section Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    Definition Self : Set :=
      axum_core.extract.default_body_limit.DefaultBodyLimit.t.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M axum_core.extract.default_body_limit.DefaultBodyLimit.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  
  Module DefaultBodyLimitKind.
    Inductive t : Set :=
    | Disable
    | Limit (_ : usize.t).
    
    Definition Get_Limit_0 :=
      Ref.map
        (fun α => match α with | Limit α0 => Some α0 | _ => None end)
        (fun β α => match α with | Limit _ => Some (Limit β) | _ => None end).
  End DefaultBodyLimitKind.
  
  Module  Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  Section Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    Definition Self : Set :=
      axum_core.extract.default_body_limit.DefaultBodyLimitKind.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  
  Module  Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  Section Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    Definition Self : Set :=
      axum_core.extract.default_body_limit.DefaultBodyLimitKind.t.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M axum_core.extract.default_body_limit.DefaultBodyLimitKind.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  
  Module  Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  Section Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
    Definition Self : Set :=
      axum_core.extract.default_body_limit.DefaultBodyLimitKind.t.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  
  Module  Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t_2.
  Section Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t_2.
    Definition Self : Set :=
      axum_core.extract.default_body_limit.DefaultBodyLimit.t.
    
    (*
        pub fn disable() -> Self {
            Self {
                kind: DefaultBodyLimitKind::Disable,
            }
        }
    *)
    Definition disable : M Self := M.read foo.
    
    Global Instance AssociatedFunction_disable :
      Notations.DoubleColon Self "disable" := {
      Notations.double_colon := disable;
    }.
    
    (*
        pub fn max(limit: usize) -> Self {
            Self {
                kind: DefaultBodyLimitKind::Limit(limit),
            }
        }
    *)
    Definition max (limit : usize.t) : M Self :=
      let* limit := M.alloc limit in
      M.read foo.
    
    Global Instance AssociatedFunction_max :
      Notations.DoubleColon Self "max" := {
      Notations.double_colon := max;
    }.
  End Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t_2.
  End Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t_2.
  
  Module  Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  Section Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
    Context {S : Set}.
    
    Definition Self : Set :=
      axum_core.extract.default_body_limit.DefaultBodyLimit.t.
    
    (*
        type Service = DefaultBodyLimitService<S>;
    *)
    Definition Service : Set :=
      axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t S.
    
    (*
        fn layer(&self, inner: S) -> Self::Service {
            DefaultBodyLimitService {
                inner,
                kind: self.kind,
            }
        }
    *)
    Definition layer (self : ref Self) (inner : S) : M Service :=
      let* self := M.alloc self in
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_layer :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer;
    }.
    
    Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
      tower_layer.Layer.Service := Service;
      tower_layer.Layer.layer := layer;
    }.
  End Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  End Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  
  Module private.
    Module  DefaultBodyLimitService.
    Section DefaultBodyLimitService.
      Context (S : Set).
      
      Record t : Set := {
        inner : S;
        kind : axum_core.extract.default_body_limit.DefaultBodyLimitKind.t;
      }.
      
      Definition Get_inner :=
        Ref.map
          (fun α => Some α.(inner))
          (fun β α => Some (α <| inner := β |>)).
      Definition Get_kind :=
        Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
    End DefaultBodyLimitService.
    End DefaultBodyLimitService.
    
    Module  Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    Section Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S}.
      
      Definition Self : Set :=
        axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
          S.
      
      (*
          Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    
    Module  Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    Section Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait S}.
      
      Definition Self : Set :=
        axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
          S.
      
      (*
          Clone
      *)
      Definition clone
          (self : ref Self)
          :
            M
              (axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
                S) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    
    Module  Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    Section Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.marker.Copy.Trait S}.
      
      Definition Self : Set :=
        axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
          S.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    
    Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
      Context {B S : Set}.
      
      Context
        {ℋ_0 :
          tower_service.Service.Trait S (Request := http.request.Request.t B)}.
      
      Definition Self : Set :=
        axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
          S.
      
      (*
              type Response = S::Response;
      *)
      Definition Response : Set := S::type["Response"].t.
      
      (*
              type Error = S::Error;
      *)
      Definition Error : Set := S::type["Error"].t.
      
      (*
              type Future = S::Future;
      *)
      Definition Future : Set := S::type["Future"].t.
      
      (*
              fn poll_ready(&mut self, cx: &mut Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
                  self.inner.poll_ready(cx)
              }
      *)
      Definition poll_ready
          (self : mut_ref Self)
          (cx : mut_ref core.task.wake.Context.t)
          : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
        let* self := M.alloc self in
        let* cx := M.alloc cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_ready :
        Notations.DoubleColon Self "poll_ready" := {
        Notations.double_colon := poll_ready;
      }.
      
      (*
              fn call(&mut self, mut req: Request<B>) -> Self::Future {
                  req.extensions_mut().insert(self.kind);
                  self.inner.call(req)
              }
      *)
      Definition call
          (self : mut_ref Self)
          (req : http.request.Request.t B)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        tower_service.Service.Trait Self
          (Request := http.request.Request.t B) := {
        tower_service.Service.Response := Response;
        tower_service.Service.Error := Error;
        tower_service.Service.Future := Future;
        tower_service.Service.poll_ready := poll_ready;
        tower_service.Service.call := call;
      }.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    End Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  End private.
End default_body_limit.

Module  DefaultBodyLimit.
Section DefaultBodyLimit.
  Record t : Set := {
    kind : axum_core.extract.default_body_limit.DefaultBodyLimitKind.t;
  }.
  
  Definition Get_kind :=
    Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
End DefaultBodyLimit.
End DefaultBodyLimit.

Module  Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
Section Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  Definition Self : Set :=
    axum_core.extract.default_body_limit.DefaultBodyLimit.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.

Module  Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
Section Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  Definition Self : Set :=
    axum_core.extract.default_body_limit.DefaultBodyLimit.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M axum_core.extract.default_body_limit.DefaultBodyLimit.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.

Module DefaultBodyLimitKind.
  Inductive t : Set :=
  | Disable
  | Limit (_ : usize.t).
  
  Definition Get_Limit_0 :=
    Ref.map
      (fun α => match α with | Limit α0 => Some α0 | _ => None end)
      (fun β α => match α with | Limit _ => Some (Limit β) | _ => None end).
End DefaultBodyLimitKind.

Module  Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
Section Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  Definition Self : Set :=
    axum_core.extract.default_body_limit.DefaultBodyLimitKind.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.

Module  Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
Section Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  Definition Self : Set :=
    axum_core.extract.default_body_limit.DefaultBodyLimitKind.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M axum_core.extract.default_body_limit.DefaultBodyLimitKind.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.

Module  Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
Section Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
  Definition Self : Set :=
    axum_core.extract.default_body_limit.DefaultBodyLimitKind.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.
End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_DefaultBodyLimitKind_t.

Module  Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t_3.
Section Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t_3.
  Definition Self : Set :=
    axum_core.extract.default_body_limit.DefaultBodyLimit.t.
  
  (*
      pub fn disable() -> Self {
          Self {
              kind: DefaultBodyLimitKind::Disable,
          }
      }
  *)
  Definition disable : M Self := M.read foo.
  
  Global Instance AssociatedFunction_disable :
    Notations.DoubleColon Self "disable" := {
    Notations.double_colon := disable;
  }.
  
  (*
      pub fn max(limit: usize) -> Self {
          Self {
              kind: DefaultBodyLimitKind::Limit(limit),
          }
      }
  *)
  Definition max (limit : usize.t) : M Self :=
    let* limit := M.alloc limit in
    M.read foo.
  
  Global Instance AssociatedFunction_max : Notations.DoubleColon Self "max" := {
    Notations.double_colon := max;
  }.
End Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t_3.
End Impl_axum_core_extract_default_body_limit_DefaultBodyLimit_t_3.

Module  Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
Section Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
  Context {S : Set}.
  
  Definition Self : Set :=
    axum_core.extract.default_body_limit.DefaultBodyLimit.t.
  
  (*
      type Service = DefaultBodyLimitService<S>;
  *)
  Definition Service : Set :=
    axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t S.
  
  (*
      fn layer(&self, inner: S) -> Self::Service {
          DefaultBodyLimitService {
              inner,
              kind: self.kind,
          }
      }
  *)
  Definition layer (self : ref Self) (inner : S) : M Service :=
    let* self := M.alloc self in
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_layer :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer;
  }.
  
  Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
    tower_layer.Layer.Service := Service;
    tower_layer.Layer.layer := layer;
  }.
End Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.
End Impl_tower_layer_Layer_S_for_axum_core_extract_default_body_limit_DefaultBodyLimit_t.

Module private.
  Module  DefaultBodyLimitService.
  Section DefaultBodyLimitService.
    Context (S : Set).
    
    Record t : Set := {
      inner : S;
      kind : axum_core.extract.default_body_limit.DefaultBodyLimitKind.t;
    }.
    
    Definition Get_inner :=
      Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
    Definition Get_kind :=
      Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
  End DefaultBodyLimitService.
  End DefaultBodyLimitService.
  
  Module  Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  Section Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set :=
      axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t S.
    
    (*
        Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  
  Module  Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  Section Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait S}.
    
    Definition Self : Set :=
      axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t S.
    
    (*
        Clone
    *)
    Definition clone
        (self : ref Self)
        :
          M
            (axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
              S) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  
  Module  Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  Section Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait S}.
    
    Definition Self : Set :=
      axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t S.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  
  Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
    Context {B S : Set}.
    
    Context
      {ℋ_0 :
        tower_service.Service.Trait S (Request := http.request.Request.t B)}.
    
    Definition Self : Set :=
      axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t S.
    
    (*
            type Response = S::Response;
    *)
    Definition Response : Set := S::type["Response"].t.
    
    (*
            type Error = S::Error;
    *)
    Definition Error : Set := S::type["Error"].t.
    
    (*
            type Future = S::Future;
    *)
    Definition Future : Set := S::type["Future"].t.
    
    (*
            fn poll_ready(&mut self, cx: &mut Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
                self.inner.poll_ready(cx)
            }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
            fn call(&mut self, mut req: Request<B>) -> Self::Future {
                req.extensions_mut().insert(self.kind);
                self.inner.call(req)
            }
    *)
    Definition call
        (self : mut_ref Self)
        (req : http.request.Request.t B)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      tower_service.Service.Trait Self
        (Request := http.request.Request.t B) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  End Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
End private.

Module  DefaultBodyLimitService.
Section DefaultBodyLimitService.
  Context (S : Set).
  
  Record t : Set := {
    inner : S;
    kind : axum_core.extract.default_body_limit.DefaultBodyLimitKind.t;
  }.
  
  Definition Get_inner :=
    Ref.map (fun α => Some α.(inner)) (fun β α => Some (α <| inner := β |>)).
  Definition Get_kind :=
    Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
End DefaultBodyLimitService.
End DefaultBodyLimitService.

Module  Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
Section Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set :=
    axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t S.
  
  (*
      Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
End Impl_core_fmt_Debug_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.

Module  Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
Section Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait S}.
  
  Definition Self : Set :=
    axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t S.
  
  (*
      Clone
  *)
  Definition clone
      (self : ref Self)
      :
        M
          (axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t
            S) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
End Impl_core_clone_Clone_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.

Module  Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
Section Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait S}.
  
  Definition Self : Set :=
    axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t S.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
End Impl_core_marker_Copy_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.

Module  Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
Section Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
  Context {B S : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait S (Request := http.request.Request.t B)}.
  
  Definition Self : Set :=
    axum_core.extract.default_body_limit.private.DefaultBodyLimitService.t S.
  
  (*
          type Response = S::Response;
  *)
  Definition Response : Set := S::type["Response"].t.
  
  (*
          type Error = S::Error;
  *)
  Definition Error : Set := S::type["Error"].t.
  
  (*
          type Future = S::Future;
  *)
  Definition Future : Set := S::type["Future"].t.
  
  (*
          fn poll_ready(&mut self, cx: &mut Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
              self.inner.poll_ready(cx)
          }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
          fn call(&mut self, mut req: Request<B>) -> Self::Future {
              req.extensions_mut().insert(self.kind);
              self.inner.call(req)
          }
  *)
  Definition call
      (self : mut_ref Self)
      (req : http.request.Request.t B)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    tower_service.Service.Trait Self (Request := http.request.Request.t B) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.
End Impl_tower_service_Service_http_request_Request_t_B_for_axum_core_extract_default_body_limit_private_DefaultBodyLimitService_t_S.

Module from_ref.
  Module  FromRef.
  Section FromRef.
    Class Trait (Self : Set) {T : Set} : Type := {
      from_ref : (ref T) -> M Self;
    }.
    
  End FromRef.
  End FromRef.
  
  Module  Impl_axum_core_extract_from_ref_FromRef_T_for_T.
  Section Impl_axum_core_extract_from_ref_FromRef_T_for_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := T.
    
    (*
        fn from_ref(input: &T) -> Self {
            input.clone()
        }
    *)
    Definition from_ref (input : ref T) : M Self :=
      let* input := M.alloc input in
      M.read foo.
    
    Global Instance AssociatedFunction_from_ref :
      Notations.DoubleColon Self "from_ref" := {
      Notations.double_colon := from_ref;
    }.
    
    Global Instance ℐ :
      axum_core.extract.from_ref.FromRef.Trait Self (T := T) := {
      axum_core.extract.from_ref.FromRef.from_ref := from_ref;
    }.
  End Impl_axum_core_extract_from_ref_FromRef_T_for_T.
  End Impl_axum_core_extract_from_ref_FromRef_T_for_T.
End from_ref.

Module  FromRef.
Section FromRef.
  Class Trait (Self : Set) {T : Set} : Type := {
    from_ref : (ref T) -> M Self;
  }.
  
End FromRef.
End FromRef.

Module  Impl_axum_core_extract_from_ref_FromRef_T_for_T.
Section Impl_axum_core_extract_from_ref_FromRef_T_for_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := T.
  
  (*
      fn from_ref(input: &T) -> Self {
          input.clone()
      }
  *)
  Definition from_ref (input : ref T) : M Self :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_from_ref :
    Notations.DoubleColon Self "from_ref" := {
    Notations.double_colon := from_ref;
  }.
  
  Global Instance ℐ :
    axum_core.extract.from_ref.FromRef.Trait Self (T := T) := {
    axum_core.extract.from_ref.FromRef.from_ref := from_ref;
  }.
End Impl_axum_core_extract_from_ref_FromRef_T_for_T.
End Impl_axum_core_extract_from_ref_FromRef_T_for_T.

Module Wrap_request_parts_1.
Module request_parts.
  Module  Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
  Section Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T).
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
            Ok(req)
        }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (Pattern : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
  End Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := http.method.Method.t.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
            Ok(parts.method.clone())
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (Pattern : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := http.uri.Uri.t.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
            Ok(parts.uri.clone())
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (Pattern : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := http.version.Version.t.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
            Ok(parts.version)
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (Pattern : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  Section Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
            Ok(parts.headers.clone())
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (Pattern : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.
  Section Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := bytes.bytes.Bytes.t.
    
    (*
        type Rejection = BytesRejection;
    *)
    Definition Rejection : Set := axum_core.extract.rejection.BytesRejection.t.
    
    (*
        async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
            let bytes = req
                .into_limited_body()
                .collect()
                .await
                .map_err(FailedToBufferBody::from_err)?
                .to_bytes();
    
            Ok(bytes)
        }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (Pattern : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.
  End Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.
  Section Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := alloc.string.String.t.
    
    (*
        type Rejection = StringRejection;
    *)
    Definition Rejection : Set := axum_core.extract.rejection.StringRejection.t.
    
    (*
        async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
            let bytes = Bytes::from_request(req, state)
                .await
                .map_err(|err| match err {
                    BytesRejection::FailedToBufferBody(inner) => {
                        StringRejection::FailedToBufferBody(inner)
                    }
                })?;
    
            let string = std::str::from_utf8(&bytes)
                .map_err(InvalidUtf8::from_err)?
                .to_owned();
    
            Ok(string)
        }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.
  End Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := http.request.Parts.t.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
            Ok(parts.clone())
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (_state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.
  Section Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := http.extensions.Extensions.t.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
            Ok(parts.extensions.clone())
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (_state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.
  End Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.
  Section Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
            Ok(req.into_body())
        }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (Pattern : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.
  End Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.
End request_parts.
End Wrap_request_parts_1.
Import Wrap_request_parts_1.

Module  Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
Section Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T).
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
          Ok(req)
      }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (Pattern : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.
End Impl_axum_core_extract_FromRequest_S_for_axum_core_extract_Request_axum_core_extract_Request_Default_T.

Module  Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := http.method.Method.t.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
          Ok(parts.method.clone())
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (Pattern : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.
End Impl_axum_core_extract_FromRequestParts_S_for_http_method_Method_t.

Module  Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := http.uri.Uri.t.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
          Ok(parts.uri.clone())
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (Pattern : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.
End Impl_axum_core_extract_FromRequestParts_S_for_http_uri_Uri_t.

Module  Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := http.version.Version.t.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
          Ok(parts.version)
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (Pattern : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.
End Impl_axum_core_extract_FromRequestParts_S_for_http_version_Version_t.

Module  Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
Section Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _: &S) -> Result<Self, Self::Rejection> {
          Ok(parts.headers.clone())
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (Pattern : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
End Impl_axum_core_extract_FromRequestParts_S_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.

Module  Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.
Section Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := bytes.bytes.Bytes.t.
  
  (*
      type Rejection = BytesRejection;
  *)
  Definition Rejection : Set := axum_core.extract.rejection.BytesRejection.t.
  
  (*
      async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
          let bytes = req
              .into_limited_body()
              .collect()
              .await
              .map_err(FailedToBufferBody::from_err)?
              .to_bytes();
  
          Ok(bytes)
      }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (Pattern : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.
End Impl_axum_core_extract_FromRequest_S_for_bytes_bytes_Bytes_t.

Module  Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.
Section Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := alloc.string.String.t.
  
  (*
      type Rejection = StringRejection;
  *)
  Definition Rejection : Set := axum_core.extract.rejection.StringRejection.t.
  
  (*
      async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
          let bytes = Bytes::from_request(req, state)
              .await
              .map_err(|err| match err {
                  BytesRejection::FailedToBufferBody(inner) => {
                      StringRejection::FailedToBufferBody(inner)
                  }
              })?;
  
          let string = std::str::from_utf8(&bytes)
              .map_err(InvalidUtf8::from_err)?
              .to_owned();
  
          Ok(string)
      }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.
End Impl_axum_core_extract_FromRequest_S_for_alloc_string_String_t.

Module  Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := http.request.Parts.t.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
          Ok(parts.clone())
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (_state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.
End Impl_axum_core_extract_FromRequestParts_S_for_http_request_Parts_t.

Module  Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := http.extensions.Extensions.t.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
          Ok(parts.extensions.clone())
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (_state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.
End Impl_axum_core_extract_FromRequestParts_S_for_http_extensions_Extensions_t.

Module  Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.
Section Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request(req: Request, _: &S) -> Result<Self, Self::Rejection> {
          Ok(req.into_body())
      }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (Pattern : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.
End Impl_axum_core_extract_FromRequest_S_for_axum_core_body_Body_t.

Module tuple.
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.
    Context {S : Set}.
    
    Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := unit.
    
    (*
        type Rejection = Infallible;
    *)
    Definition Rejection : Set := core.convert.Infallible.t.
    
    (*
        async fn from_request_parts(_: &mut Parts, _: &S) -> Result<(), Self::Rejection> {
            Ok(())
        }
    *)
    Definition from_request_parts
        (Pattern : mut_ref http.request.Parts.t)
        (Pattern : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* Pattern := M.alloc Pattern in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.
    Context {S T1 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := T1.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.
    Context {S T1 : Set}.
    
    Context
      {ℋ_0 :
        axum_core.extract.FromRequest.Trait T1
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T1)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := T1.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.
    Context {S T1 T2 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : core.marker.Send.Trait S}
      {ℋ_5 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := T1 * T2.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.
    Context {S T1 T2 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 :
        axum_core.extract.FromRequest.Trait T2
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T2)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : core.marker.Send.Trait S}
      {ℋ_5 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := T1 * T2.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.
    Context {S T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : core.marker.Send.Trait S}
      {ℋ_7 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := (T1 * T2) * T3.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.
    Context {S T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 :
        axum_core.extract.FromRequest.Trait T3
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T3)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : core.marker.Send.Trait S}
      {ℋ_7 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := (T1 * T2) * T3.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.
    Context {S T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : core.marker.Send.Trait S}
      {ℋ_9 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := ((T1 * T2) * T3) * T4.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.
    Context {S T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 :
        axum_core.extract.FromRequest.Trait T4
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T4)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : core.marker.Send.Trait S}
      {ℋ_9 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := ((T1 * T2) * T3) * T4.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.
    Context {S T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : core.marker.Send.Trait S}
      {ℋ_11 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := (((T1 * T2) * T3) * T4) * T5.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.
    Context {S T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 :
        axum_core.extract.FromRequest.Trait T5
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T5)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : core.marker.Send.Trait S}
      {ℋ_11 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := (((T1 * T2) * T3) * T4) * T5.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
    Context {S T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : core.marker.Send.Trait S}
      {ℋ_13 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * T6.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
    Context {S T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 :
        axum_core.extract.FromRequest.Trait T6
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T6)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : core.marker.Send.Trait S}
      {ℋ_13 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * T6.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Context {S T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : core.marker.Send.Trait S}
      {ℋ_15 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Context {S T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 :
        axum_core.extract.FromRequest.Trait T7
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T7)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : core.marker.Send.Trait S}
      {ℋ_15 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : core.marker.Send.Trait S}
      {ℋ_17 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 :
        axum_core.extract.FromRequest.Trait T8
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T8)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : core.marker.Send.Trait S}
      {ℋ_17 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : core.marker.Send.Trait S}
      {ℋ_19 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 :
        axum_core.extract.FromRequest.Trait T9
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T9)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : core.marker.Send.Trait S}
      {ℋ_19 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : core.marker.Send.Trait S}
      {ℋ_21 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 :
        axum_core.extract.FromRequest.Trait T10
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T10)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : core.marker.Send.Trait S}
      {ℋ_21 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 : core.marker.Send.Trait S}
      {ℋ_23 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 :
        axum_core.extract.FromRequest.Trait T11
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T11)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 : core.marker.Send.Trait S}
      {ℋ_23 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T12}
      {ℋ_24 : core.marker.Send.Trait S}
      {ℋ_25 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
      *
      T12.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 :
        axum_core.extract.FromRequest.Trait T12
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T12)}
      {ℋ_23 : core.marker.Send.Trait T12}
      {ℋ_24 : core.marker.Send.Trait S}
      {ℋ_25 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
      *
      T12.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T12}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T13}
      {ℋ_26 : core.marker.Send.Trait S}
      {ℋ_27 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T12}
      {ℋ_24 :
        axum_core.extract.FromRequest.Trait T13
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T13)}
      {ℋ_25 : core.marker.Send.Trait T13}
      {ℋ_26 : core.marker.Send.Trait S}
      {ℋ_27 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T12}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T13}
      {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_27 : core.marker.Send.Trait T14}
      {ℋ_28 : core.marker.Send.Trait S}
      {ℋ_29 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T12}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T13}
      {ℋ_26 :
        axum_core.extract.FromRequest.Trait T14
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T14)}
      {ℋ_27 : core.marker.Send.Trait T14}
      {ℋ_28 : core.marker.Send.Trait S}
      {ℋ_29 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T12}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T13}
      {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_27 : core.marker.Send.Trait T14}
      {ℋ_28 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
      {ℋ_29 : core.marker.Send.Trait T15}
      {ℋ_30 : core.marker.Send.Trait S}
      {ℋ_31 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T12}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T13}
      {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_27 : core.marker.Send.Trait T14}
      {ℋ_28 :
        axum_core.extract.FromRequest.Trait T15
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T15)}
      {ℋ_29 : core.marker.Send.Trait T15}
      {ℋ_30 : core.marker.Send.Trait S}
      {ℋ_31 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T12}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T13}
      {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_27 : core.marker.Send.Trait T14}
      {ℋ_28 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
      {ℋ_29 : core.marker.Send.Trait T15}
      {ℋ_30 : axum_core.extract.FromRequestParts.Trait T16 (S := S)}
      {ℋ_31 : core.marker.Send.Trait T16}
      {ℋ_32 : core.marker.Send.Trait S}
      {ℋ_33 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        let $ty = $ty::from_request_parts(parts, state)
                            .await
                            .map_err(|err| err.into_response())?;
                    )*
                    let $last = $last::from_request_parts(parts, state)
                        .await
                        .map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
      {ℋ_1 : core.marker.Send.Trait T1}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
      {ℋ_3 : core.marker.Send.Trait T2}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
      {ℋ_5 : core.marker.Send.Trait T3}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
      {ℋ_7 : core.marker.Send.Trait T4}
      {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
      {ℋ_9 : core.marker.Send.Trait T5}
      {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
      {ℋ_11 : core.marker.Send.Trait T6}
      {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
      {ℋ_13 : core.marker.Send.Trait T7}
      {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
      {ℋ_15 : core.marker.Send.Trait T8}
      {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
      {ℋ_17 : core.marker.Send.Trait T9}
      {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
      {ℋ_19 : core.marker.Send.Trait T10}
      {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
      {ℋ_21 : core.marker.Send.Trait T11}
      {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
      {ℋ_23 : core.marker.Send.Trait T12}
      {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
      {ℋ_25 : core.marker.Send.Trait T13}
      {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
      {ℋ_27 : core.marker.Send.Trait T14}
      {ℋ_28 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
      {ℋ_29 : core.marker.Send.Trait T15}
      {ℋ_30 :
        axum_core.extract.FromRequest.Trait T16
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T16)}
      {ℋ_31 : core.marker.Send.Trait T16}
      {ℋ_32 : core.marker.Send.Trait S}
      {ℋ_33 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16.
    
    (*
                type Rejection = Response;
    *)
    Definition Rejection : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                    let (mut parts, body) = req.into_parts();
    
                    $(
                        let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                    )*
    
                    let req = Request::from_parts(parts, body);
    
                    let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
    
                    Ok(($($ty,)* $last,))
                }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
End tuple.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.
  Context {S : Set}.
  
  Context {ℋ_0 : core.marker.Send.Trait S} {ℋ_1 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := unit.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(_: &mut Parts, _: &S) -> Result<(), Self::Rejection> {
          Ok(())
      }
  *)
  Definition from_request_parts
      (Pattern : mut_ref http.request.Parts.t)
      (Pattern : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* Pattern := M.alloc Pattern in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.
  Context {S T1 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := T1.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.
  Context {S T1 : Set}.
  
  Context
    {ℋ_0 :
      axum_core.extract.FromRequest.Trait T1
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T1)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := T1.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.
  Context {S T1 T2 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : core.marker.Send.Trait S}
    {ℋ_5 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := T1 * T2.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.
  Context {S T1 T2 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 :
      axum_core.extract.FromRequest.Trait T2
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T2)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : core.marker.Send.Trait S}
    {ℋ_5 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := T1 * T2.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.
  Context {S T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : core.marker.Send.Trait S}
    {ℋ_7 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := (T1 * T2) * T3.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.
  Context {S T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 :
      axum_core.extract.FromRequest.Trait T3
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T3)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : core.marker.Send.Trait S}
    {ℋ_7 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := (T1 * T2) * T3.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.
  Context {S T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : core.marker.Send.Trait S}
    {ℋ_9 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := ((T1 * T2) * T3) * T4.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.
  Context {S T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 :
      axum_core.extract.FromRequest.Trait T4
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T4)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : core.marker.Send.Trait S}
    {ℋ_9 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := ((T1 * T2) * T3) * T4.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.
  Context {S T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : core.marker.Send.Trait S}
    {ℋ_11 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := (((T1 * T2) * T3) * T4) * T5.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.
  Context {S T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 :
      axum_core.extract.FromRequest.Trait T5
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T5)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : core.marker.Send.Trait S}
    {ℋ_11 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := (((T1 * T2) * T3) * T4) * T5.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
  Context {S T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : core.marker.Send.Trait S}
    {ℋ_13 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * T6.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
  Context {S T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 :
      axum_core.extract.FromRequest.Trait T6
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T6)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : core.marker.Send.Trait S}
    {ℋ_13 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * T6.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Context {S T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : core.marker.Send.Trait S}
    {ℋ_15 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Context {S T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 :
      axum_core.extract.FromRequest.Trait T7
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T7)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : core.marker.Send.Trait S}
    {ℋ_15 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : core.marker.Send.Trait S}
    {ℋ_17 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 :
      axum_core.extract.FromRequest.Trait T8
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T8)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : core.marker.Send.Trait S}
    {ℋ_17 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : core.marker.Send.Trait S}
    {ℋ_19 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 :
      axum_core.extract.FromRequest.Trait T9
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T9)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : core.marker.Send.Trait S}
    {ℋ_19 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : core.marker.Send.Trait S}
    {ℋ_21 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 :
      axum_core.extract.FromRequest.Trait T10
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T10)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : core.marker.Send.Trait S}
    {ℋ_21 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 : core.marker.Send.Trait S}
    {ℋ_23 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 :
      axum_core.extract.FromRequest.Trait T11
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T11)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 : core.marker.Send.Trait S}
    {ℋ_23 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T12}
    {ℋ_24 : core.marker.Send.Trait S}
    {ℋ_25 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    T12.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 :
      axum_core.extract.FromRequest.Trait T12
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T12)}
    {ℋ_23 : core.marker.Send.Trait T12}
    {ℋ_24 : core.marker.Send.Trait S}
    {ℋ_25 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    T12.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T12}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T13}
    {ℋ_26 : core.marker.Send.Trait S}
    {ℋ_27 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    T12)
    *
    T13.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T12}
    {ℋ_24 :
      axum_core.extract.FromRequest.Trait T13
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T13)}
    {ℋ_25 : core.marker.Send.Trait T13}
    {ℋ_26 : core.marker.Send.Trait S}
    {ℋ_27 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    T12)
    *
    T13.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T12}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T13}
    {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_27 : core.marker.Send.Trait T14}
    {ℋ_28 : core.marker.Send.Trait S}
    {ℋ_29 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    T12)
    *
    T13)
    *
    T14.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T12}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T13}
    {ℋ_26 :
      axum_core.extract.FromRequest.Trait T14
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T14)}
    {ℋ_27 : core.marker.Send.Trait T14}
    {ℋ_28 : core.marker.Send.Trait S}
    {ℋ_29 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    T12)
    *
    T13)
    *
    T14.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T12}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T13}
    {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_27 : core.marker.Send.Trait T14}
    {ℋ_28 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
    {ℋ_29 : core.marker.Send.Trait T15}
    {ℋ_30 : core.marker.Send.Trait S}
    {ℋ_31 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T12}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T13}
    {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_27 : core.marker.Send.Trait T14}
    {ℋ_28 :
      axum_core.extract.FromRequest.Trait T15
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T15)}
    {ℋ_29 : core.marker.Send.Trait T15}
    {ℋ_30 : core.marker.Send.Trait S}
    {ℋ_31 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.

Module  Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
Section Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T12}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T13}
    {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_27 : core.marker.Send.Trait T14}
    {ℋ_28 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
    {ℋ_29 : core.marker.Send.Trait T15}
    {ℋ_30 : axum_core.extract.FromRequestParts.Trait T16 (S := S)}
    {ℋ_31 : core.marker.Send.Trait T16}
    {ℋ_32 : core.marker.Send.Trait S}
    {ℋ_33 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15)
    *
    T16.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      let $ty = $ty::from_request_parts(parts, state)
                          .await
                          .map_err(|err| err.into_response())?;
                  )*
                  let $last = $last::from_request_parts(parts, state)
                      .await
                      .map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
End Impl_axum_core_extract_FromRequestParts_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.

Module  Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
Section Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Context {S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T1 (S := S)}
    {ℋ_1 : core.marker.Send.Trait T1}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T2 (S := S)}
    {ℋ_3 : core.marker.Send.Trait T2}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait T3 (S := S)}
    {ℋ_5 : core.marker.Send.Trait T3}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait T4 (S := S)}
    {ℋ_7 : core.marker.Send.Trait T4}
    {ℋ_8 : axum_core.extract.FromRequestParts.Trait T5 (S := S)}
    {ℋ_9 : core.marker.Send.Trait T5}
    {ℋ_10 : axum_core.extract.FromRequestParts.Trait T6 (S := S)}
    {ℋ_11 : core.marker.Send.Trait T6}
    {ℋ_12 : axum_core.extract.FromRequestParts.Trait T7 (S := S)}
    {ℋ_13 : core.marker.Send.Trait T7}
    {ℋ_14 : axum_core.extract.FromRequestParts.Trait T8 (S := S)}
    {ℋ_15 : core.marker.Send.Trait T8}
    {ℋ_16 : axum_core.extract.FromRequestParts.Trait T9 (S := S)}
    {ℋ_17 : core.marker.Send.Trait T9}
    {ℋ_18 : axum_core.extract.FromRequestParts.Trait T10 (S := S)}
    {ℋ_19 : core.marker.Send.Trait T10}
    {ℋ_20 : axum_core.extract.FromRequestParts.Trait T11 (S := S)}
    {ℋ_21 : core.marker.Send.Trait T11}
    {ℋ_22 : axum_core.extract.FromRequestParts.Trait T12 (S := S)}
    {ℋ_23 : core.marker.Send.Trait T12}
    {ℋ_24 : axum_core.extract.FromRequestParts.Trait T13 (S := S)}
    {ℋ_25 : core.marker.Send.Trait T13}
    {ℋ_26 : axum_core.extract.FromRequestParts.Trait T14 (S := S)}
    {ℋ_27 : core.marker.Send.Trait T14}
    {ℋ_28 : axum_core.extract.FromRequestParts.Trait T15 (S := S)}
    {ℋ_29 : core.marker.Send.Trait T15}
    {ℋ_30 :
      axum_core.extract.FromRequest.Trait T16
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T16)}
    {ℋ_31 : core.marker.Send.Trait T16}
    {ℋ_32 : core.marker.Send.Trait S}
    {ℋ_33 : core.marker.Sync.Trait S}.
  
  Definition Self : Set :=
    ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15)
    *
    T16.
  
  (*
              type Rejection = Response;
  *)
  Definition Rejection : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
                  let (mut parts, body) = req.into_parts();
  
                  $(
                      let $ty = $ty::from_request_parts(&mut parts, state).await.map_err(|err| err.into_response())?;
                  )*
  
                  let req = Request::from_parts(parts, body);
  
                  let $last = $last::from_request(req, state).await.map_err(|err| err.into_response())?;
  
                  Ok(($($ty,)* $last,))
              }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
End Impl_axum_core_extract_FromRequest_S_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.

Ltac Request T := exact (http.request.Request.t T).

Module Wrap_private_1.
Module private.
  Module ViaParts.
    Inductive t : Set :=
    .
  End ViaParts.
  
  Module  Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.
  Section Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.
    Definition Self : Set := axum_core.extract.private.ViaParts.t.
    
    (*
        Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.
  End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.
  
  Module  Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.
  Section Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.
    Definition Self : Set := axum_core.extract.private.ViaParts.t.
    
    (*
        Clone
    *)
    Definition clone
        (self : ref Self)
        : M axum_core.extract.private.ViaParts.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.
  End Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.
  
  Module  Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.
  Section Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.
    Definition Self : Set := axum_core.extract.private.ViaParts.t.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.
  End Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.
  
  Module ViaRequest.
    Inductive t : Set :=
    .
  End ViaRequest.
  
  Module  Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.
  Section Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.
    Definition Self : Set := axum_core.extract.private.ViaRequest.t.
    
    (*
        Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.
  End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.
  
  Module  Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.
  Section Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.
    Definition Self : Set := axum_core.extract.private.ViaRequest.t.
    
    (*
        Clone
    *)
    Definition clone
        (self : ref Self)
        : M axum_core.extract.private.ViaRequest.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.
  End Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.
  
  Module  Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.
  Section Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.
    Definition Self : Set := axum_core.extract.private.ViaRequest.t.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.
  End Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.
End private.
End Wrap_private_1.
Import Wrap_private_1.

Module ViaParts.
  Inductive t : Set :=
  .
End ViaParts.

Module  Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.
Section Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.
  Definition Self : Set := axum_core.extract.private.ViaParts.t.
  
  (*
      Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.
End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaParts_t.

Module  Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.
Section Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.
  Definition Self : Set := axum_core.extract.private.ViaParts.t.
  
  (*
      Clone
  *)
  Definition clone (self : ref Self) : M axum_core.extract.private.ViaParts.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.
End Impl_core_clone_Clone_for_axum_core_extract_private_ViaParts_t.

Module  Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.
Section Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.
  Definition Self : Set := axum_core.extract.private.ViaParts.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.
End Impl_core_marker_Copy_for_axum_core_extract_private_ViaParts_t.

Module ViaRequest.
  Inductive t : Set :=
  .
End ViaRequest.

Module  Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.
Section Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.
  Definition Self : Set := axum_core.extract.private.ViaRequest.t.
  
  (*
      Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.
End Impl_core_fmt_Debug_for_axum_core_extract_private_ViaRequest_t.

Module  Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.
Section Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.
  Definition Self : Set := axum_core.extract.private.ViaRequest.t.
  
  (*
      Clone
  *)
  Definition clone
      (self : ref Self)
      : M axum_core.extract.private.ViaRequest.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.
End Impl_core_clone_Clone_for_axum_core_extract_private_ViaRequest_t.

Module  Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.
Section Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.
  Definition Self : Set := axum_core.extract.private.ViaRequest.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.
End Impl_core_marker_Copy_for_axum_core_extract_private_ViaRequest_t.

Module  FromRequestParts.
Section FromRequestParts.
  Class Trait (Self : Set) {S : Set} : Type := {
    Rejection : Set;
    ℒ_0 :: axum_core.response.into_response.IntoResponse.Trait Rejection;
    from_request_parts :
      (mut_ref http.request.Parts.t) ->
        (ref S) ->
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A));
  }.
  
  Global Instance Method_Rejection `(Trait) :
    Notations.DoubleColonType Self "Rejection" := {
    Notations.double_colon_type := Rejection;
  }.
End FromRequestParts.
End FromRequestParts.

Module  FromRequest.
Section FromRequest.
  Class Trait (Self : Set) {S (* TODO *) M : Set} : Type := {
    Rejection : Set;
    ℒ_0 :: axum_core.response.into_response.IntoResponse.Trait Rejection;
    from_request :
      ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T) ->
        (ref S) ->
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A));
  }.
  
  Global Instance Method_Rejection `(Trait) :
    Notations.DoubleColonType Self "Rejection" := {
    Notations.double_colon_type := Rejection;
  }.
End FromRequest.
End FromRequest.

Module  Impl_axum_core_extract_FromRequest_S_axum_core_extract_private_ViaParts_t_for_T.
Section Impl_axum_core_extract_FromRequest_S_axum_core_extract_private_ViaParts_t_for_T.
  Context {S T : Set}.
  
  Context
    {ℋ_0 : core.marker.Send.Trait S}
    {ℋ_1 : core.marker.Sync.Trait S}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T (S := S)}.
  
  Definition Self : Set := T.
  
  (*
      type Rejection = <Self as FromRequestParts<S>>::Rejection;
  *)
  Definition Rejection : Set :=
    axum_core.extract.FromRequestParts.Rejection
        (Self := Self)
        (Trait := ltac:(refine _)).
  
  (*
      async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
          let (mut parts, _) = req.into_parts();
          Self::from_request_parts(&mut parts, state).await
      }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.private.ViaParts.t) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_axum_core_extract_private_ViaParts_t_for_T.
End Impl_axum_core_extract_FromRequest_S_axum_core_extract_private_ViaParts_t_for_T.

Module  Impl_axum_core_extract_FromRequestParts_S_for_core_option_Option_t_T.
Section Impl_axum_core_extract_FromRequestParts_S_for_core_option_Option_t_T.
  Context {S T : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T (S := S)}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := core.option.Option.t T.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(
          parts: &mut Parts,
          state: &S,
      ) -> Result<Option<T>, Self::Rejection> {
          Ok(T::from_request_parts(parts, state).await.ok())
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_core_option_Option_t_T.
End Impl_axum_core_extract_FromRequestParts_S_for_core_option_Option_t_T.

Module  Impl_axum_core_extract_FromRequest_S_for_core_option_Option_t_T.
Section Impl_axum_core_extract_FromRequest_S_for_core_option_Option_t_T.
  Context {S T : Set}.
  
  Context
    {ℋ_0 :
      axum_core.extract.FromRequest.Trait T
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T)}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := core.option.Option.t T.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request(req: Request, state: &S) -> Result<Option<T>, Self::Rejection> {
          Ok(T::from_request(req, state).await.ok())
      }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_core_option_Option_t_T.
End Impl_axum_core_extract_FromRequest_S_for_core_option_Option_t_T.

Module  Impl_axum_core_extract_FromRequestParts_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
Section Impl_axum_core_extract_FromRequestParts_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
  Context {S T : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait T (S := S)}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := core.result.Result.t T T::type["Rejection"].t.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
          Ok(T::from_request_parts(parts, state).await)
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
End Impl_axum_core_extract_FromRequestParts_S_for_core_result_Result_t_T_T::type["Rejection"]_t.

Module  Impl_axum_core_extract_FromRequest_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
Section Impl_axum_core_extract_FromRequest_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
  Context {S T : Set}.
  
  Context
    {ℋ_0 :
      axum_core.extract.FromRequest.Trait T
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T)}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := core.result.Result.t T T::type["Rejection"].t.
  
  (*
      type Rejection = Infallible;
  *)
  Definition Rejection : Set := core.convert.Infallible.t.
  
  (*
      async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
          Ok(T::from_request(req, state).await)
      }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_core_result_Result_t_T_T::type["Rejection"]_t.
End Impl_axum_core_extract_FromRequest_S_for_core_result_Result_t_T_T::type["Rejection"]_t.

Module response.
  Module append_headers.
    Module  AppendHeaders.
    Section AppendHeaders.
      Context {I : Set}.
      
      Record t : Set := {
        x0 : I;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End AppendHeaders.
    End AppendHeaders.
    
    Module  Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.
    Section Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.
      Context {I : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait I}.
      
      Definition Self : Set :=
        axum_core.response.append_headers.AppendHeaders.t I.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.
    End Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.
      Context {I K V : Set}.
      
      Context
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
        {ℋ_1 :
          core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
        {ℋ_2 : core.fmt.Display.Trait K::type["Error"].t}
        {ℋ_3 :
          core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
        {ℋ_4 : core.fmt.Display.Trait V::type["Error"].t}.
      
      Definition Self : Set :=
        axum_core.response.append_headers.AppendHeaders.t I.
      
      (*
          fn into_response(self) -> Response {
              (self, ()).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.
      Context {I K V : Set}.
      
      Context
        {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
        {ℋ_1 :
          core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
        {ℋ_2 : core.fmt.Display.Trait K::type["Error"].t}
        {ℋ_3 :
          core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
        {ℋ_4 : core.fmt.Display.Trait V::type["Error"].t}.
      
      Definition Self : Set :=
        axum_core.response.append_headers.AppendHeaders.t I.
      
      (*
          type Error = TryIntoHeaderError<K::Error, V::Error>;
      *)
      Definition Error : Set :=
        axum_core.response.into_response_parts.TryIntoHeaderError.t
            K::type["Error"].t
            V::type["Error"].t.
      
      (*
          fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
              for (key, value) in self.0 {
                  let key = key.try_into().map_err(TryIntoHeaderError::key)?;
                  let value = value.try_into().map_err(TryIntoHeaderError::value)?;
                  res.headers_mut().append(key, value);
              }
      
              Ok(res)
          }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.
  End append_headers.
  
  Module into_response.
    Module  IntoResponse.
    Section IntoResponse.
      Class Trait (Self : Set) : Type := {
        into_response :
          Self ->
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T);
      }.
      
    End IntoResponse.
    End IntoResponse.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.
      Definition Self : Set := http.status.StatusCode.t.
      
      (*
          fn into_response(self) -> Response {
              let mut res = ().into_response();
              *res.status_mut() = self;
              res
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.
      Definition Self : Set := unit.
      
      (*
          fn into_response(self) -> Response {
              Body::empty().into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.
      Definition Self : Set := core.convert.Infallible.t.
      
      (*
          fn into_response(self) -> Response {
              match self {}
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.
    Section Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.
      Context {T E : Set}.
      
      Context
        {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}
        {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E}.
      
      Definition Self : Set := core.result.Result.t T E.
      
      (*
          fn into_response(self) -> Response {
              match self {
                  Ok(value) => value.into_response(),
                  Err(err) => err.into_response(),
              }
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.
    End Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.
      Context {B : Set}.
      
      Context
        {ℋ_0 : http_body.Body.Trait B}
        {ℋ_1 : core.marker.Send.Trait B}
        {ℋ_2 :
          core.convert.Into.Trait B::type["Error"].t
            (T := ltac:(axum_core.BoxError))}.
      
      Definition Self : Set := ltac:(axum_core.response.Response B).
      
      (*
          fn into_response(self) -> Response {
              self.map(Body::new)
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.
      Definition Self : Set := http.response.Parts.t.
      
      (*
          fn into_response(self) -> Response {
              Response::from_parts(self, Body::empty())
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.
      Definition Self : Set := axum_core.body.Body.t.
      
      (*
          fn into_response(self) -> Response {
              Response::new(self)
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.
      Definition Self : Set := ref str.t.
      
      (*
          fn into_response(self) -> Response {
              Cow::Borrowed(self).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.
      Definition Self : Set := alloc.string.String.t.
      
      (*
          fn into_response(self) -> Response {
              Cow::<'static, str>::Owned(self).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.
    Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.
      Definition Self : Set :=
        alloc.boxed.Box.t str.t alloc.boxed.Box.Default.A.
      
      (*
          fn into_response(self) -> Response {
              String::from(self).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.
      Definition Self : Set := alloc.borrow.Cow.t str.t.
      
      (*
          fn into_response(self) -> Response {
              let mut res = Body::from(self).into_response();
              res.headers_mut().insert(
                  header::CONTENT_TYPE,
                  HeaderValue::from_static(mime::TEXT_PLAIN_UTF_8.as_ref()),
              );
              res
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.
      Definition Self : Set := bytes.bytes.Bytes.t.
      
      (*
          fn into_response(self) -> Response {
              let mut res = Body::from(self).into_response();
              res.headers_mut().insert(
                  header::CONTENT_TYPE,
                  HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),
              );
              res
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.
      Definition Self : Set := bytes.bytes_mut.BytesMut.t.
      
      (*
          fn into_response(self) -> Response {
              self.freeze().into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.
    Section Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.
      Context {T U : Set}.
      
      Context
        {ℋ_0 : bytes.buf.buf_impl.Buf.Trait T}
        {ℋ_1 : core.marker.Unpin.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 : bytes.buf.buf_impl.Buf.Trait U}
        {ℋ_4 : core.marker.Unpin.Trait U}
        {ℋ_5 : core.marker.Send.Trait U}.
      
      Definition Self : Set := bytes.buf.chain.Chain.t T U.
      
      (*
          fn into_response(self) -> Response {
              let (first, second) = self.into_inner();
              let mut res = Response::new(Body::new(BytesChainBody {
                  first: Some(first),
                  second: Some(second),
              }));
              res.headers_mut().insert(
                  header::CONTENT_TYPE,
                  HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),
              );
              res
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.
    End Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.
    
    Module  BytesChainBody.
    Section BytesChainBody.
      Context (T U : Set).
      
      Record t : Set := {
        first : core.option.Option.t T;
        second : core.option.Option.t U;
      }.
      
      Definition Get_first :=
        Ref.map
          (fun α => Some α.(first))
          (fun β α => Some (α <| first := β |>)).
      Definition Get_second :=
        Ref.map
          (fun α => Some α.(second))
          (fun β α => Some (α <| second := β |>)).
    End BytesChainBody.
    End BytesChainBody.
    
    Module  Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.
    Section Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.
      Context {T U : Set}.
      
      Context
        {ℋ_0 : bytes.buf.buf_impl.Buf.Trait T}
        {ℋ_1 : core.marker.Unpin.Trait T}
        {ℋ_2 : bytes.buf.buf_impl.Buf.Trait U}
        {ℋ_3 : core.marker.Unpin.Trait U}.
      
      Definition Self : Set :=
        axum_core.response.into_response.BytesChainBody.t T U.
      
      (*
          type Data = Bytes;
      *)
      Definition Data : Set := bytes.bytes.Bytes.t.
      
      (*
          type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
          fn poll_frame(
              mut self: Pin<&mut Self>,
              _cx: &mut Context<'_>,
          ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
              if let Some(mut buf) = self.first.take() {
                  let bytes = buf.copy_to_bytes(buf.remaining());
                  return Poll::Ready(Some(Ok(Frame::data(bytes))));
              }
      
              if let Some(mut buf) = self.second.take() {
                  let bytes = buf.copy_to_bytes(buf.remaining());
                  return Poll::Ready(Some(Ok(Frame::data(bytes))));
              }
      
              Poll::Ready(None)
          }
      *)
      Definition poll_frame
          (self : core.pin.Pin.t (mut_ref Self))
          (_cx : mut_ref core.task.wake.Context.t)
          :
            M
              (core.task.poll.Poll.t
                (core.option.Option.t
                  (core.result.Result.t
                    (http_body.frame.Frame.t Data)
                    Error))) :=
        let* self := M.alloc self in
        let* _cx := M.alloc _cx in
        M.read foo.
      
      Global Instance AssociatedFunction_poll_frame :
        Notations.DoubleColon Self "poll_frame" := {
        Notations.double_colon := poll_frame;
      }.
      
      (*
          fn is_end_stream(&self) -> bool {
              self.first.is_none() && self.second.is_none()
          }
      *)
      Definition is_end_stream (self : ref Self) : M bool.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_is_end_stream :
        Notations.DoubleColon Self "is_end_stream" := {
        Notations.double_colon := is_end_stream;
      }.
      
      (*
          fn size_hint(&self) -> SizeHint {
              match (self.first.as_ref(), self.second.as_ref()) {
                  (Some(first), Some(second)) => {
                      let total_size = first.remaining() + second.remaining();
                      SizeHint::with_exact(total_size as u64)
                  }
                  (Some(buf), None) => SizeHint::with_exact(buf.remaining() as u64),
                  (None, Some(buf)) => SizeHint::with_exact(buf.remaining() as u64),
                  (None, None) => SizeHint::with_exact(0),
              }
          }
      *)
      Definition size_hint
          (self : ref Self)
          : M http_body.size_hint.SizeHint.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_size_hint :
        Notations.DoubleColon Self "size_hint" := {
        Notations.double_colon := size_hint;
      }.
      
      Global Instance ℐ : http_body.Body.Required.Trait Self := {
        http_body.Body.Data := Data;
        http_body.Body.Error := Error;
        http_body.Body.poll_frame := poll_frame;
        http_body.Body.is_end_stream := Datatypes.Some is_end_stream;
        http_body.Body.size_hint := Datatypes.Some size_hint;
      }.
    End Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.
    End Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.
      Definition Self : Set := ref (slice u8.t).
      
      (*
          fn into_response(self) -> Response {
              Cow::Borrowed(self).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.
      Definition Self : Set := ref (array u8.t).
      
      (*
          fn into_response(self) -> Response {
              self.as_slice().into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.
      Definition Self : Set := array u8.t.
      
      (*
          fn into_response(self) -> Response {
              self.to_vec().into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.
    Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.
      Definition Self : Set := alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A.
      
      (*
          fn into_response(self) -> Response {
              Cow::<'static, [u8]>::Owned(self).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.
    Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.
      Definition Self : Set :=
        alloc.boxed.Box.t (slice u8.t) alloc.boxed.Box.Default.A.
      
      (*
          fn into_response(self) -> Response {
              Vec::from(self).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.
      Definition Self : Set := alloc.borrow.Cow.t (slice u8.t).
      
      (*
          fn into_response(self) -> Response {
              let mut res = Body::from(self).into_response();
              res.headers_mut().insert(
                  header::CONTENT_TYPE,
                  HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),
              );
              res
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.
      Context {R : Set}.
      
      Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := http.status.StatusCode.t * R.
      
      (*
          fn into_response(self) -> Response {
              let mut res = self.1.into_response();
              *res.status_mut() = self.0;
              res
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    Section Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
      Definition Self : Set :=
        http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T.
      
      (*
          fn into_response(self) -> Response {
              let mut res = ().into_response();
              *res.headers_mut() = self;
              res
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    End Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.
    Section Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.
      Definition Self : Set := http.extensions.Extensions.t.
      
      (*
          fn into_response(self) -> Response {
              let mut res = ().into_response();
              *res.extensions_mut() = self;
              res
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.
    End Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.
      Context {K V : Set}.
      
      Context
        {ℋ_0 :
          core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
        {ℋ_1 : core.fmt.Display.Trait K::type["Error"].t}
        {ℋ_2 :
          core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
        {ℋ_3 : core.fmt.Display.Trait V::type["Error"].t}.
      
      Definition Self : Set := array (K * V).
      
      (*
          fn into_response(self) -> Response {
              (self, ()).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.
    End Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.
      Context {R : Set}.
      
      Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := http.response.Parts.t * R.
      
      (*
          fn into_response(self) -> Response {
              let (parts, res) = self;
              (parts.status, parts.headers, parts.extensions, res).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.
      Context {R : Set}.
      
      Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := (http.response.Response.t unit) * R.
      
      (*
          fn into_response(self) -> Response {
              let (template, res) = self;
              let (parts, ()) = template.into_parts();
              (parts, res).into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.
      Context {R : Set}.
      
      Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := R.
      
      (*
          fn into_response(self) -> Response {
              let (res,) = self;
              res.into_response()
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.
      Context {R T1 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := T1 * R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.
      Context {R T1 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := (http.status.StatusCode.t * T1) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.
      Context {R T1 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := (http.response.Parts.t * T1) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.
      Context {R T1 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := ((http.response.Response.t unit) * T1) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.
      Context {R T1 T2 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := (T1 * T2) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.
      Context {R T1 T2 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := ((http.status.StatusCode.t * T1) * T2) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.
      Context {R T1 T2 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := ((http.response.Parts.t * T1) * T2) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.
      Context {R T1 T2 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((http.response.Response.t unit) * T1) * T2) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.
      Context {R T1 T2 T3 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := ((T1 * T2) * T3) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.
      Context {R T1 T2 T3 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((http.status.StatusCode.t * T1) * T2) * T3) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.
      Context {R T1 T2 T3 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := (((http.response.Parts.t * T1) * T2) * T3) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.
      Context {R T1 T2 T3 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((http.response.Response.t unit) * T1) * T2) * T3) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.
      Context {R T1 T2 T3 T4 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := (((T1 * T2) * T3) * T4) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.
      Context {R T1 T2 T3 T4 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.
      Context {R T1 T2 T3 T4 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((http.response.Parts.t * T1) * T2) * T3) * T4) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.
      Context {R T1 T2 T3 T4 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.
      Context {R T1 T2 T3 T4 T5 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.
      Context {R T1 T2 T3 T4 T5 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.
      Context {R T1 T2 T3 T4 T5 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.
      Context {R T1 T2 T3 T4 T5 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.
      Context {R T1 T2 T3 T4 T5 T6 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.
      Context {R T1 T2 T3 T4 T5 T6 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.
      Context {R T1 T2 T3 T4 T5 T6 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.
      Context {R T1 T2 T3 T4 T5 T6 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
        *
        T6)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
        *
        T6)
        *
        T7)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        T8)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
        *
        T8)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
        *
        T8)
        *
        T9)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4)
        *
        T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4)
        *
        T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4)
        *
        T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
        {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
        {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
        {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
        {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4)
        *
        T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
        {ℋ_15 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
        {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let ($($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      parts.res
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
        {ℋ_15 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
        {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (status, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
      
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (status, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
        {ℋ_15 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
        {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        ((((((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (outer_parts, $($ty),*, res) = self;
      
                      let res = res.into_response();
                      let parts = ResponseParts { res };
                      $(
                          let parts = match $ty.into_response_parts(parts) {
                              Ok(parts) => parts,
                              Err(err) => {
                                  return err.into_response();
                              }
                          };
                      )*
      
                      (outer_parts, parts.res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
      Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
        {ℋ_15 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
        {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        (((((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4)
        *
        T5)
        *
        T6)
        *
        T7)
        *
        T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)
        *
        R.
      
      (*
                  fn into_response(self) -> Response {
                      let (template, $($ty),*, res) = self;
                      let (parts, ()) = template.into_parts();
                      (parts, $($ty),*, res).into_response()
                  }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  End into_response.
  
  Module into_response_parts.
    Module  IntoResponseParts.
    Section IntoResponseParts.
      Class Trait (Self : Set) : Type := {
        Error : Set;
        ℒ_0 :: axum_core.response.into_response.IntoResponse.Trait Error;
        into_response_parts :
          Self ->
            axum_core.response.into_response_parts.ResponseParts.t ->
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error.t);
      }.
      
      Global Instance Method_Error `(Trait) :
        Notations.DoubleColonType Self "Error" := {
        Notations.double_colon_type := Error;
      }.
    End IntoResponseParts.
    End IntoResponseParts.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.
      Context {T : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T}.
      
      Definition Self : Set := core.option.Option.t T.
      
      (*
          type Error = T::Error;
      *)
      Definition Error : Set := T::type["Error"].t.
      
      (*
          fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
              if let Some(inner) = self {
                  inner.into_response_parts(res)
              } else {
                  Ok(res)
              }
          }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.
    
    Module  ResponseParts.
    Section ResponseParts.
      Record t : Set := {
        res :
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T);
      }.
      
      Definition Get_res :=
        Ref.map (fun α => Some α.(res)) (fun β α => Some (α <| res := β |>)).
    End ResponseParts.
    End ResponseParts.
    
    Module  Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.
    Section Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.
      Definition Self : Set :=
        axum_core.response.into_response_parts.ResponseParts.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.
    End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.
    
    Module  Impl_axum_core_response_into_response_parts_ResponseParts_t.
    Section Impl_axum_core_response_into_response_parts_ResponseParts_t.
      Definition Self : Set :=
        axum_core.response.into_response_parts.ResponseParts.t.
      
      (*
          pub fn headers(&self) -> &HeaderMap {
              self.res.headers()
          }
      *)
      Definition headers
          (self : ref Self)
          :
            M
              (ref
                (http.header.map.HeaderMap.t
                  http.header.map.HeaderMap.Default.T)) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_headers :
        Notations.DoubleColon Self "headers" := {
        Notations.double_colon := headers;
      }.
      
      (*
          pub fn headers_mut(&mut self) -> &mut HeaderMap {
              self.res.headers_mut()
          }
      *)
      Definition headers_mut
          (self : mut_ref Self)
          :
            M
              (mut_ref
                (http.header.map.HeaderMap.t
                  http.header.map.HeaderMap.Default.T)) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_headers_mut :
        Notations.DoubleColon Self "headers_mut" := {
        Notations.double_colon := headers_mut;
      }.
      
      (*
          pub fn extensions(&self) -> &Extensions {
              self.res.extensions()
          }
      *)
      Definition extensions
          (self : ref Self)
          : M (ref http.extensions.Extensions.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_extensions :
        Notations.DoubleColon Self "extensions" := {
        Notations.double_colon := extensions;
      }.
      
      (*
          pub fn extensions_mut(&mut self) -> &mut Extensions {
              self.res.extensions_mut()
          }
      *)
      Definition extensions_mut
          (self : mut_ref Self)
          : M (mut_ref http.extensions.Extensions.t) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_extensions_mut :
        Notations.DoubleColon Self "extensions_mut" := {
        Notations.double_colon := extensions_mut;
      }.
    End Impl_axum_core_response_into_response_parts_ResponseParts_t.
    End Impl_axum_core_response_into_response_parts_ResponseParts_t.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
      Definition Self : Set :=
        http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T.
      
      (*
          type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
          fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
              res.headers_mut().extend(self);
              Ok(res)
          }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.
      Context {K V : Set}.
      
      Context
        {ℋ_0 :
          core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
        {ℋ_1 : core.fmt.Display.Trait K::type["Error"].t}
        {ℋ_2 :
          core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
        {ℋ_3 : core.fmt.Display.Trait V::type["Error"].t}.
      
      Definition Self : Set := array (K * V).
      
      (*
          type Error = TryIntoHeaderError<K::Error, V::Error>;
      *)
      Definition Error : Set :=
        axum_core.response.into_response_parts.TryIntoHeaderError.t
            K::type["Error"].t
            V::type["Error"].t.
      
      (*
          fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
              for (key, value) in self {
                  let key = key.try_into().map_err(TryIntoHeaderError::key)?;
                  let value = value.try_into().map_err(TryIntoHeaderError::value)?;
                  res.headers_mut().insert(key, value);
              }
      
              Ok(res)
          }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.
    
    Module  TryIntoHeaderError.
    Section TryIntoHeaderError.
      Context (K V : Set).
      
      Record t : Set := {
        kind :
          axum_core.response.into_response_parts.TryIntoHeaderErrorKind.t K V;
      }.
      
      Definition Get_kind :=
        Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
    End TryIntoHeaderError.
    End TryIntoHeaderError.
    
    Module  Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    Section Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
      Context {K V : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait K} {ℋ_1 : core.fmt.Debug.Trait V}.
      
      Definition Self : Set :=
        axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    
    Module  Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    Section Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
      Context {K V : Set}.
      
      Definition Self : Set :=
        axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
      
      (*
          pub(super) fn key(err: K) -> Self {
              Self {
                  kind: TryIntoHeaderErrorKind::Key(err),
              }
          }
      *)
      Definition key (err : K) : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_key :
        Notations.DoubleColon Self "key" := {
        Notations.double_colon := key;
      }.
      
      (*
          pub(super) fn value(err: V) -> Self {
              Self {
                  kind: TryIntoHeaderErrorKind::Value(err),
              }
          }
      *)
      Definition value (err : V) : M Self :=
        let* err := M.alloc err in
        M.read foo.
      
      Global Instance AssociatedFunction_value :
        Notations.DoubleColon Self "value" := {
        Notations.double_colon := value;
      }.
    End Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    End Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    
    Module TryIntoHeaderErrorKind.
      Inductive t (K : Set) (V : Set) : Set :=
      | Key (_ : K)
      | Value (_ : V).
      
      Definition Get_Key_0 :=
        Ref.map
          (fun α => match α with | Key α0 => Some α0 | _ => None end)
          (fun β α => match α with | Key _ => Some (Key β) | _ => None end).
      
      Definition Get_Value_0 :=
        Ref.map
          (fun α => match α with | Value α0 => Some α0 | _ => None end)
          (fun β α => match α with | Value _ => Some (Value β) | _ => None end).
    End TryIntoHeaderErrorKind.
    
    Module  Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.
    Section Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.
      Context {K V : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait K} {ℋ_1 : core.fmt.Debug.Trait V}.
      
      Definition Self : Set :=
        axum_core.response.into_response_parts.TryIntoHeaderErrorKind.t K V.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.
    End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.
    
    Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
      Context {K V : Set}.
      
      Context {ℋ_0 : core.fmt.Display.Trait K} {ℋ_1 : core.fmt.Display.Trait V}.
      
      Definition Self : Set :=
        axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
      
      (*
          fn into_response(self) -> Response {
              match self.kind {
                  TryIntoHeaderErrorKind::Key(inner) => {
                      (StatusCode::INTERNAL_SERVER_ERROR, inner.to_string()).into_response()
                  }
                  TryIntoHeaderErrorKind::Value(inner) => {
                      (StatusCode::INTERNAL_SERVER_ERROR, inner.to_string()).into_response()
                  }
              }
          }
      *)
      Definition into_response
          (self : Self)
          :
            M
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response :
        Notations.DoubleColon Self "into_response" := {
        Notations.double_colon := into_response;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response.IntoResponse.Trait Self := {
        axum_core.response.into_response.IntoResponse.into_response :=
          into_response;
      }.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    
    Module  Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    Section Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
      Context {K V : Set}.
      
      Definition Self : Set :=
        axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              match self.kind {
                  TryIntoHeaderErrorKind::Key(_) => write!(f, "failed to convert key to a header name"),
                  TryIntoHeaderErrorKind::Value(_) => {
                      write!(f, "failed to convert value to a header value")
                  }
              }
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    End Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    
    Module  Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    Section Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
      Context {K V : Set}.
      
      Context {ℋ_0 : core.error.Error.Trait K} {ℋ_1 : core.error.Error.Trait V}.
      
      Definition Self : Set :=
        axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
      
      (*
          fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
              match &self.kind {
                  TryIntoHeaderErrorKind::Key(inner) => Some(inner),
                  TryIntoHeaderErrorKind::Value(inner) => Some(inner),
              }
          }
      *)
      Definition source
          (self : ref Self)
          : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_source :
        Notations.DoubleColon Self "source" := {
        Notations.double_colon := source;
      }.
      
      Global Instance ℐ : core.error.Error.Required.Trait Self := {
        core.error.Error.source := Datatypes.Some source;
        core.error.Error.type_id := Datatypes.None;
        core.error.Error.description := Datatypes.None;
        core.error.Error.cause := Datatypes.None;
        core.error.Error.provide := Datatypes.None;
      }.
    End Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    End Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.
      Context {T1 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}.
      
      Definition Self : Set := T1.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.
      Context {T1 T2 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}.
      
      Definition Self : Set := T1 * T2.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.
      Context {T1 T2 T3 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}.
      
      Definition Self : Set := (T1 * T2) * T3.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.
      Context {T1 T2 T3 T4 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}.
      
      Definition Self : Set := ((T1 * T2) * T3) * T4.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.
      Context {T1 T2 T3 T4 T5 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}.
      
      Definition Self : Set := (((T1 * T2) * T3) * T4) * T5.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.
      Context {T1 T2 T3 T4 T5 T6 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}.
      
      Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * T6.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
      Context {T1 T2 T3 T4 T5 T6 T7 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}.
      
      Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
      Context {T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}.
      
      Definition Self : Set :=
        ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
      Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}.
      
      Definition Self : Set :=
        (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
      Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}.
      
      Definition Self : Set :=
        ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
      Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}.
      
      Definition Self : Set :=
        (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
      Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}.
      
      Definition Self : Set :=
        ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
      Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}.
      
      Definition Self : Set :=
        (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
      Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}.
      
      Definition Self : Set :=
        ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
      Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T15}.
      
      Definition Self : Set :=
        (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
      Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
      
      Context
        {ℋ_0 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
        {ℋ_1 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
        {ℋ_2 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
        {ℋ_3 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
        {ℋ_4 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
        {ℋ_5 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
        {ℋ_6 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
        {ℋ_7 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
        {ℋ_8 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
        {ℋ_9 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
        {ℋ_10 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
        {ℋ_11 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
        {ℋ_12 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
        {ℋ_13 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
        {ℋ_14 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
        {ℋ_15 :
          axum_core.response.into_response_parts.IntoResponseParts.Trait T16}.
      
      Definition Self : Set :=
        ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16.
      
      (*
                  type Error = Response;
      *)
      Definition Error : Set :=
        ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T).
      
      (*
                  fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                      let ($($ty,)* ) = self;
      
                      $(
                          let res = match $ty.into_response_parts(res) {
                              Ok(res) => res,
                              Err(err) => {
                                  return Err(err.into_response());
                              }
                          };
                      )*
      
                      Ok(res)
                  }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.
      Definition Self : Set := http.extensions.Extensions.t.
      
      (*
          type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
          fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
              res.extensions_mut().extend(self);
              Ok(res)
          }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.
    
    Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.
    Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.
      Definition Self : Set := unit.
      
      (*
          type Error = Infallible;
      *)
      Definition Error : Set := core.convert.Infallible.t.
      
      (*
          fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
              Ok(res)
          }
      *)
      Definition into_response_parts
          (self : Self)
          (res : axum_core.response.into_response_parts.ResponseParts.t)
          :
            M
              (core.result.Result.t
                axum_core.response.into_response_parts.ResponseParts.t
                Error) :=
        let* self := M.alloc self in
        let* res := M.alloc res in
        M.read foo.
      
      Global Instance AssociatedFunction_into_response_parts :
        Notations.DoubleColon Self "into_response_parts" := {
        Notations.double_colon := into_response_parts;
      }.
      
      Global Instance ℐ :
        axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
        axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
        axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
          into_response_parts;
      }.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.
    End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.
  End into_response_parts.
  
  Ltac Response T := exact (http.response.Response.t T).
  
  Ltac Result T E := exact (core.result.Result.t T E).
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Result_T_axum_core_response_Result_Default_E.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Result_T_axum_core_response_Result_Default_E.
    Context {T : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
    
    Definition Self : Set :=
      ltac:(axum_core.response.Result T axum_core.response.Result.Default.E).
    
    (*
        fn into_response(self) -> Response {
            match self {
                Ok(ok) => ok.into_response(),
                Err(err) => err.0,
            }
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Result_T_axum_core_response_Result_Default_E.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Result_T_axum_core_response_Result_Default_E.
  
  Module  ErrorResponse.
  Section ErrorResponse.
    Record t : Set := {
      x0 :
        ltac:(axum_core.response.Response
          axum_core.response.Response.Default.T);
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End ErrorResponse.
  End ErrorResponse.
  
  Module  Impl_core_fmt_Debug_for_axum_core_response_ErrorResponse_t.
  Section Impl_core_fmt_Debug_for_axum_core_response_ErrorResponse_t.
    Definition Self : Set := axum_core.response.ErrorResponse.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_response_ErrorResponse_t.
  End Impl_core_fmt_Debug_for_axum_core_response_ErrorResponse_t.
  
  Module  Impl_core_convert_From_T_for_axum_core_response_ErrorResponse_t.
  Section Impl_core_convert_From_T_for_axum_core_response_ErrorResponse_t.
    Context {T : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
    
    Definition Self : Set := axum_core.response.ErrorResponse.t.
    
    (*
        fn from(value: T) -> Self {
            Self(value.into_response())
        }
    *)
    Definition from (value : T) : M Self :=
      let* value := M.alloc value in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_T_for_axum_core_response_ErrorResponse_t.
  End Impl_core_convert_From_T_for_axum_core_response_ErrorResponse_t.
End response.

Module append_headers.
  Module  AppendHeaders.
  Section AppendHeaders.
    Context {I : Set}.
    
    Record t : Set := {
      x0 : I;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End AppendHeaders.
  End AppendHeaders.
  
  Module  Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.
  Section Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.
    Context {I : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait I}.
    
    Definition Self : Set :=
      axum_core.response.append_headers.AppendHeaders.t I.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.
  End Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.
    Context {I K V : Set}.
    
    Context
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
      {ℋ_1 : core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
      {ℋ_2 : core.fmt.Display.Trait K::type["Error"].t}
      {ℋ_3 :
        core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
      {ℋ_4 : core.fmt.Display.Trait V::type["Error"].t}.
    
    Definition Self : Set :=
      axum_core.response.append_headers.AppendHeaders.t I.
    
    (*
        fn into_response(self) -> Response {
            (self, ()).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.
    Context {I K V : Set}.
    
    Context
      {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
      {ℋ_1 : core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
      {ℋ_2 : core.fmt.Display.Trait K::type["Error"].t}
      {ℋ_3 :
        core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
      {ℋ_4 : core.fmt.Display.Trait V::type["Error"].t}.
    
    Definition Self : Set :=
      axum_core.response.append_headers.AppendHeaders.t I.
    
    (*
        type Error = TryIntoHeaderError<K::Error, V::Error>;
    *)
    Definition Error : Set :=
      axum_core.response.into_response_parts.TryIntoHeaderError.t
          K::type["Error"].t
          V::type["Error"].t.
    
    (*
        fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
            for (key, value) in self.0 {
                let key = key.try_into().map_err(TryIntoHeaderError::key)?;
                let value = value.try_into().map_err(TryIntoHeaderError::value)?;
                res.headers_mut().append(key, value);
            }
    
            Ok(res)
        }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.
End append_headers.

Module  AppendHeaders.
Section AppendHeaders.
  Context {I : Set}.
  
  Record t : Set := {
    x0 : I;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End AppendHeaders.
End AppendHeaders.

Module  Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.
Section Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.
  Context {I : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait I}.
  
  Definition Self : Set := axum_core.response.append_headers.AppendHeaders.t I.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.
End Impl_core_fmt_Debug_for_axum_core_response_append_headers_AppendHeaders_t_I.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.
  Context {I K V : Set}.
  
  Context
    {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
    {ℋ_1 : core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
    {ℋ_2 : core.fmt.Display.Trait K::type["Error"].t}
    {ℋ_3 : core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
    {ℋ_4 : core.fmt.Display.Trait V::type["Error"].t}.
  
  Definition Self : Set := axum_core.response.append_headers.AppendHeaders.t I.
  
  (*
      fn into_response(self) -> Response {
          (self, ()).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_append_headers_AppendHeaders_t_I.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.
  Context {I K V : Set}.
  
  Context
    {ℋ_0 : core.iter.traits.collect.IntoIterator.Trait I}
    {ℋ_1 : core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
    {ℋ_2 : core.fmt.Display.Trait K::type["Error"].t}
    {ℋ_3 : core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
    {ℋ_4 : core.fmt.Display.Trait V::type["Error"].t}.
  
  Definition Self : Set := axum_core.response.append_headers.AppendHeaders.t I.
  
  (*
      type Error = TryIntoHeaderError<K::Error, V::Error>;
  *)
  Definition Error : Set :=
    axum_core.response.into_response_parts.TryIntoHeaderError.t
        K::type["Error"].t
        V::type["Error"].t.
  
  (*
      fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
          for (key, value) in self.0 {
              let key = key.try_into().map_err(TryIntoHeaderError::key)?;
              let value = value.try_into().map_err(TryIntoHeaderError::value)?;
              res.headers_mut().append(key, value);
          }
  
          Ok(res)
      }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_axum_core_response_append_headers_AppendHeaders_t_I.

Module into_response.
  Module  IntoResponse.
  Section IntoResponse.
    Class Trait (Self : Set) : Type := {
      into_response :
        Self ->
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T);
    }.
    
  End IntoResponse.
  End IntoResponse.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.
    Definition Self : Set := http.status.StatusCode.t.
    
    (*
        fn into_response(self) -> Response {
            let mut res = ().into_response();
            *res.status_mut() = self;
            res
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.
    Definition Self : Set := unit.
    
    (*
        fn into_response(self) -> Response {
            Body::empty().into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.
    Definition Self : Set := core.convert.Infallible.t.
    
    (*
        fn into_response(self) -> Response {
            match self {}
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.
  Section Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.
    Context {T E : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E}.
    
    Definition Self : Set := core.result.Result.t T E.
    
    (*
        fn into_response(self) -> Response {
            match self {
                Ok(value) => value.into_response(),
                Err(err) => err.into_response(),
            }
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.
  End Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.
    Context {B : Set}.
    
    Context
      {ℋ_0 : http_body.Body.Trait B}
      {ℋ_1 : core.marker.Send.Trait B}
      {ℋ_2 :
        core.convert.Into.Trait B::type["Error"].t
          (T := ltac:(axum_core.BoxError))}.
    
    Definition Self : Set := ltac:(axum_core.response.Response B).
    
    (*
        fn into_response(self) -> Response {
            self.map(Body::new)
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.
    Definition Self : Set := http.response.Parts.t.
    
    (*
        fn into_response(self) -> Response {
            Response::from_parts(self, Body::empty())
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.
    Definition Self : Set := axum_core.body.Body.t.
    
    (*
        fn into_response(self) -> Response {
            Response::new(self)
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.
    Definition Self : Set := ref str.t.
    
    (*
        fn into_response(self) -> Response {
            Cow::Borrowed(self).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.
    Definition Self : Set := alloc.string.String.t.
    
    (*
        fn into_response(self) -> Response {
            Cow::<'static, str>::Owned(self).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.
  Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.
    Definition Self : Set := alloc.boxed.Box.t str.t alloc.boxed.Box.Default.A.
    
    (*
        fn into_response(self) -> Response {
            String::from(self).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.
    Definition Self : Set := alloc.borrow.Cow.t str.t.
    
    (*
        fn into_response(self) -> Response {
            let mut res = Body::from(self).into_response();
            res.headers_mut().insert(
                header::CONTENT_TYPE,
                HeaderValue::from_static(mime::TEXT_PLAIN_UTF_8.as_ref()),
            );
            res
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.
    Definition Self : Set := bytes.bytes.Bytes.t.
    
    (*
        fn into_response(self) -> Response {
            let mut res = Body::from(self).into_response();
            res.headers_mut().insert(
                header::CONTENT_TYPE,
                HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),
            );
            res
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.
    Definition Self : Set := bytes.bytes_mut.BytesMut.t.
    
    (*
        fn into_response(self) -> Response {
            self.freeze().into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.
  Section Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.
    Context {T U : Set}.
    
    Context
      {ℋ_0 : bytes.buf.buf_impl.Buf.Trait T}
      {ℋ_1 : core.marker.Unpin.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 : bytes.buf.buf_impl.Buf.Trait U}
      {ℋ_4 : core.marker.Unpin.Trait U}
      {ℋ_5 : core.marker.Send.Trait U}.
    
    Definition Self : Set := bytes.buf.chain.Chain.t T U.
    
    (*
        fn into_response(self) -> Response {
            let (first, second) = self.into_inner();
            let mut res = Response::new(Body::new(BytesChainBody {
                first: Some(first),
                second: Some(second),
            }));
            res.headers_mut().insert(
                header::CONTENT_TYPE,
                HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),
            );
            res
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.
  End Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.
  
  Module  BytesChainBody.
  Section BytesChainBody.
    Context (T U : Set).
    
    Record t : Set := {
      first : core.option.Option.t T;
      second : core.option.Option.t U;
    }.
    
    Definition Get_first :=
      Ref.map (fun α => Some α.(first)) (fun β α => Some (α <| first := β |>)).
    Definition Get_second :=
      Ref.map
        (fun α => Some α.(second))
        (fun β α => Some (α <| second := β |>)).
  End BytesChainBody.
  End BytesChainBody.
  
  Module  Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.
  Section Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.
    Context {T U : Set}.
    
    Context
      {ℋ_0 : bytes.buf.buf_impl.Buf.Trait T}
      {ℋ_1 : core.marker.Unpin.Trait T}
      {ℋ_2 : bytes.buf.buf_impl.Buf.Trait U}
      {ℋ_3 : core.marker.Unpin.Trait U}.
    
    Definition Self : Set :=
      axum_core.response.into_response.BytesChainBody.t T U.
    
    (*
        type Data = Bytes;
    *)
    Definition Data : Set := bytes.bytes.Bytes.t.
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        fn poll_frame(
            mut self: Pin<&mut Self>,
            _cx: &mut Context<'_>,
        ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
            if let Some(mut buf) = self.first.take() {
                let bytes = buf.copy_to_bytes(buf.remaining());
                return Poll::Ready(Some(Ok(Frame::data(bytes))));
            }
    
            if let Some(mut buf) = self.second.take() {
                let bytes = buf.copy_to_bytes(buf.remaining());
                return Poll::Ready(Some(Ok(Frame::data(bytes))));
            }
    
            Poll::Ready(None)
        }
    *)
    Definition poll_frame
        (self : core.pin.Pin.t (mut_ref Self))
        (_cx : mut_ref core.task.wake.Context.t)
        :
          M
            (core.task.poll.Poll.t
              (core.option.Option.t
                (core.result.Result.t (http_body.frame.Frame.t Data) Error))) :=
      let* self := M.alloc self in
      let* _cx := M.alloc _cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_frame :
      Notations.DoubleColon Self "poll_frame" := {
      Notations.double_colon := poll_frame;
    }.
    
    (*
        fn is_end_stream(&self) -> bool {
            self.first.is_none() && self.second.is_none()
        }
    *)
    Definition is_end_stream (self : ref Self) : M bool.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_is_end_stream :
      Notations.DoubleColon Self "is_end_stream" := {
      Notations.double_colon := is_end_stream;
    }.
    
    (*
        fn size_hint(&self) -> SizeHint {
            match (self.first.as_ref(), self.second.as_ref()) {
                (Some(first), Some(second)) => {
                    let total_size = first.remaining() + second.remaining();
                    SizeHint::with_exact(total_size as u64)
                }
                (Some(buf), None) => SizeHint::with_exact(buf.remaining() as u64),
                (None, Some(buf)) => SizeHint::with_exact(buf.remaining() as u64),
                (None, None) => SizeHint::with_exact(0),
            }
        }
    *)
    Definition size_hint (self : ref Self) : M http_body.size_hint.SizeHint.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ : http_body.Body.Required.Trait Self := {
      http_body.Body.Data := Data;
      http_body.Body.Error := Error;
      http_body.Body.poll_frame := poll_frame;
      http_body.Body.is_end_stream := Datatypes.Some is_end_stream;
      http_body.Body.size_hint := Datatypes.Some size_hint;
    }.
  End Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.
  End Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.
    Definition Self : Set := ref (slice u8.t).
    
    (*
        fn into_response(self) -> Response {
            Cow::Borrowed(self).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.
    Definition Self : Set := ref (array u8.t).
    
    (*
        fn into_response(self) -> Response {
            self.as_slice().into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.
    Definition Self : Set := array u8.t.
    
    (*
        fn into_response(self) -> Response {
            self.to_vec().into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.
  Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.
    Definition Self : Set := alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A.
    
    (*
        fn into_response(self) -> Response {
            Cow::<'static, [u8]>::Owned(self).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.
  Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.
    Definition Self : Set :=
      alloc.boxed.Box.t (slice u8.t) alloc.boxed.Box.Default.A.
    
    (*
        fn into_response(self) -> Response {
            Vec::from(self).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.
    Definition Self : Set := alloc.borrow.Cow.t (slice u8.t).
    
    (*
        fn into_response(self) -> Response {
            let mut res = Body::from(self).into_response();
            res.headers_mut().insert(
                header::CONTENT_TYPE,
                HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),
            );
            res
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.
    Context {R : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := http.status.StatusCode.t * R.
    
    (*
        fn into_response(self) -> Response {
            let mut res = self.1.into_response();
            *res.status_mut() = self.0;
            res
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  Section Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    Definition Self : Set :=
      http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T.
    
    (*
        fn into_response(self) -> Response {
            let mut res = ().into_response();
            *res.headers_mut() = self;
            res
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  End Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.
  Section Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.
    Definition Self : Set := http.extensions.Extensions.t.
    
    (*
        fn into_response(self) -> Response {
            let mut res = ().into_response();
            *res.extensions_mut() = self;
            res
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.
  End Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.
    Context {K V : Set}.
    
    Context
      {ℋ_0 : core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
      {ℋ_1 : core.fmt.Display.Trait K::type["Error"].t}
      {ℋ_2 :
        core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
      {ℋ_3 : core.fmt.Display.Trait V::type["Error"].t}.
    
    Definition Self : Set := array (K * V).
    
    (*
        fn into_response(self) -> Response {
            (self, ()).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.
  End Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.
    Context {R : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := http.response.Parts.t * R.
    
    (*
        fn into_response(self) -> Response {
            let (parts, res) = self;
            (parts.status, parts.headers, parts.extensions, res).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.
    Context {R : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := (http.response.Response.t unit) * R.
    
    (*
        fn into_response(self) -> Response {
            let (template, res) = self;
            let (parts, ()) = template.into_parts();
            (parts, res).into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.
    Context {R : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := R.
    
    (*
        fn into_response(self) -> Response {
            let (res,) = self;
            res.into_response()
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.
    Context {R T1 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := T1 * R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.
    Context {R T1 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := (http.status.StatusCode.t * T1) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.
    Context {R T1 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := (http.response.Parts.t * T1) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.
    Context {R T1 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := ((http.response.Response.t unit) * T1) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.
    Context {R T1 T2 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := (T1 * T2) * R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.
    Context {R T1 T2 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := ((http.status.StatusCode.t * T1) * T2) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.
    Context {R T1 T2 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := ((http.response.Parts.t * T1) * T2) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.
    Context {R T1 T2 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := (((http.response.Response.t unit) * T1) * T2) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.
    Context {R T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := ((T1 * T2) * T3) * R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.
    Context {R T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := (((http.status.StatusCode.t * T1) * T2) * T3) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.
    Context {R T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := (((http.response.Parts.t * T1) * T2) * T3) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.
    Context {R T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((http.response.Response.t unit) * T1) * T2) * T3) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.
    Context {R T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := (((T1 * T2) * T3) * T4) * R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.
    Context {R T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.
    Context {R T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((http.response.Parts.t * T1) * T2) * T3) * T4) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.
    Context {R T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.
    Context {R T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.
    Context {R T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.
    Context {R T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.
    Context {R T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.
    Context {R T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.
    Context {R T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.
    Context {R T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.
    Context {R T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5) * T6)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
      *
      T8)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
      *
      T8)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
      *
      T6)
      *
      T7)
      *
      T8)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
      *
      T8)
      *
      T9)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
      *
      T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
      *
      T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
      *
      T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
      *
      T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
      *
      T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4)
      *
      T5)
      *
      T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
      {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
      {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5)
      *
      T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
      {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
      {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4)
      *
      T5)
      *
      T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
      {ℋ_15 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
      {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let ($($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    parts.res
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
      {ℋ_15 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
      {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5)
      *
      T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (status, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
    
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (status, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
      {ℋ_15 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
      {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      ((((((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (outer_parts, $($ty),*, res) = self;
    
                    let res = res.into_response();
                    let parts = ResponseParts { res };
                    $(
                        let parts = match $ty.into_response_parts(parts) {
                            Ok(parts) => parts,
                            Err(err) => {
                                return err.into_response();
                            }
                        };
                    )*
    
                    (outer_parts, parts.res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
    Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
      {ℋ_15 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
      {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      (((((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4)
      *
      T5)
      *
      T6)
      *
      T7)
      *
      T8)
      *
      T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16)
      *
      R.
    
    (*
                fn into_response(self) -> Response {
                    let (template, $($ty),*, res) = self;
                    let (parts, ()) = template.into_parts();
                    (parts, $($ty),*, res).into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
End into_response.

Module  IntoResponse.
Section IntoResponse.
  Class Trait (Self : Set) : Type := {
    into_response :
      Self ->
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T);
  }.
  
End IntoResponse.
End IntoResponse.

Module  Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.
  Definition Self : Set := http.status.StatusCode.t.
  
  (*
      fn into_response(self) -> Response {
          let mut res = ().into_response();
          *res.status_mut() = self;
          res
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.
End Impl_axum_core_response_into_response_IntoResponse_for_http_status_StatusCode_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.
  Definition Self : Set := unit.
  
  (*
      fn into_response(self) -> Response {
          Body::empty().into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.
  Definition Self : Set := core.convert.Infallible.t.
  
  (*
      fn into_response(self) -> Response {
          match self {}
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.
End Impl_axum_core_response_into_response_IntoResponse_for_core_convert_Infallible_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.
Section Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.
  Context {T E : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E}.
  
  Definition Self : Set := core.result.Result.t T E.
  
  (*
      fn into_response(self) -> Response {
          match self {
              Ok(value) => value.into_response(),
              Err(err) => err.into_response(),
          }
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.
End Impl_axum_core_response_into_response_IntoResponse_for_core_result_Result_t_T_E.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.
  Context {B : Set}.
  
  Context
    {ℋ_0 : http_body.Body.Trait B}
    {ℋ_1 : core.marker.Send.Trait B}
    {ℋ_2 :
      core.convert.Into.Trait B::type["Error"].t
        (T := ltac:(axum_core.BoxError))}.
  
  Definition Self : Set := ltac:(axum_core.response.Response B).
  
  (*
      fn into_response(self) -> Response {
          self.map(Body::new)
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Response_B.

Module  Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.
  Definition Self : Set := http.response.Parts.t.
  
  (*
      fn into_response(self) -> Response {
          Response::from_parts(self, Body::empty())
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.
End Impl_axum_core_response_into_response_IntoResponse_for_http_response_Parts_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.
  Definition Self : Set := axum_core.body.Body.t.
  
  (*
      fn into_response(self) -> Response {
          Response::new(self)
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_body_Body_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.
  Definition Self : Set := ref str.t.
  
  (*
      fn into_response(self) -> Response {
          Cow::Borrowed(self).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.
End Impl_axum_core_response_into_response_IntoResponse_for_ref_str_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.
  Definition Self : Set := alloc.string.String.t.
  
  (*
      fn into_response(self) -> Response {
          Cow::<'static, str>::Owned(self).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_string_String_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.
Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.
  Definition Self : Set := alloc.boxed.Box.t str.t alloc.boxed.Box.Default.A.
  
  (*
      fn into_response(self) -> Response {
          String::from(self).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_str_t_alloc_boxed_Box_Default_A.

Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.
  Definition Self : Set := alloc.borrow.Cow.t str.t.
  
  (*
      fn into_response(self) -> Response {
          let mut res = Body::from(self).into_response();
          res.headers_mut().insert(
              header::CONTENT_TYPE,
              HeaderValue::from_static(mime::TEXT_PLAIN_UTF_8.as_ref()),
          );
          res
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_str_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.
  Definition Self : Set := bytes.bytes.Bytes.t.
  
  (*
      fn into_response(self) -> Response {
          let mut res = Body::from(self).into_response();
          res.headers_mut().insert(
              header::CONTENT_TYPE,
              HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),
          );
          res
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.
End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_Bytes_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.
  Definition Self : Set := bytes.bytes_mut.BytesMut.t.
  
  (*
      fn into_response(self) -> Response {
          self.freeze().into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.
End Impl_axum_core_response_into_response_IntoResponse_for_bytes_bytes_mut_BytesMut_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.
Section Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.
  Context {T U : Set}.
  
  Context
    {ℋ_0 : bytes.buf.buf_impl.Buf.Trait T}
    {ℋ_1 : core.marker.Unpin.Trait T}
    {ℋ_2 : core.marker.Send.Trait T}
    {ℋ_3 : bytes.buf.buf_impl.Buf.Trait U}
    {ℋ_4 : core.marker.Unpin.Trait U}
    {ℋ_5 : core.marker.Send.Trait U}.
  
  Definition Self : Set := bytes.buf.chain.Chain.t T U.
  
  (*
      fn into_response(self) -> Response {
          let (first, second) = self.into_inner();
          let mut res = Response::new(Body::new(BytesChainBody {
              first: Some(first),
              second: Some(second),
          }));
          res.headers_mut().insert(
              header::CONTENT_TYPE,
              HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),
          );
          res
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.
End Impl_axum_core_response_into_response_IntoResponse_for_bytes_buf_chain_Chain_t_T_U.

Module  BytesChainBody.
Section BytesChainBody.
  Context (T U : Set).
  
  Record t : Set := {
    first : core.option.Option.t T;
    second : core.option.Option.t U;
  }.
  
  Definition Get_first :=
    Ref.map (fun α => Some α.(first)) (fun β α => Some (α <| first := β |>)).
  Definition Get_second :=
    Ref.map (fun α => Some α.(second)) (fun β α => Some (α <| second := β |>)).
End BytesChainBody.
End BytesChainBody.

Module  Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.
Section Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.
  Context {T U : Set}.
  
  Context
    {ℋ_0 : bytes.buf.buf_impl.Buf.Trait T}
    {ℋ_1 : core.marker.Unpin.Trait T}
    {ℋ_2 : bytes.buf.buf_impl.Buf.Trait U}
    {ℋ_3 : core.marker.Unpin.Trait U}.
  
  Definition Self : Set :=
    axum_core.response.into_response.BytesChainBody.t T U.
  
  (*
      type Data = Bytes;
  *)
  Definition Data : Set := bytes.bytes.Bytes.t.
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      fn poll_frame(
          mut self: Pin<&mut Self>,
          _cx: &mut Context<'_>,
      ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
          if let Some(mut buf) = self.first.take() {
              let bytes = buf.copy_to_bytes(buf.remaining());
              return Poll::Ready(Some(Ok(Frame::data(bytes))));
          }
  
          if let Some(mut buf) = self.second.take() {
              let bytes = buf.copy_to_bytes(buf.remaining());
              return Poll::Ready(Some(Ok(Frame::data(bytes))));
          }
  
          Poll::Ready(None)
      }
  *)
  Definition poll_frame
      (self : core.pin.Pin.t (mut_ref Self))
      (_cx : mut_ref core.task.wake.Context.t)
      :
        M
          (core.task.poll.Poll.t
            (core.option.Option.t
              (core.result.Result.t (http_body.frame.Frame.t Data) Error))) :=
    let* self := M.alloc self in
    let* _cx := M.alloc _cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_frame :
    Notations.DoubleColon Self "poll_frame" := {
    Notations.double_colon := poll_frame;
  }.
  
  (*
      fn is_end_stream(&self) -> bool {
          self.first.is_none() && self.second.is_none()
      }
  *)
  Definition is_end_stream (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_is_end_stream :
    Notations.DoubleColon Self "is_end_stream" := {
    Notations.double_colon := is_end_stream;
  }.
  
  (*
      fn size_hint(&self) -> SizeHint {
          match (self.first.as_ref(), self.second.as_ref()) {
              (Some(first), Some(second)) => {
                  let total_size = first.remaining() + second.remaining();
                  SizeHint::with_exact(total_size as u64)
              }
              (Some(buf), None) => SizeHint::with_exact(buf.remaining() as u64),
              (None, Some(buf)) => SizeHint::with_exact(buf.remaining() as u64),
              (None, None) => SizeHint::with_exact(0),
          }
      }
  *)
  Definition size_hint (self : ref Self) : M http_body.size_hint.SizeHint.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ : http_body.Body.Required.Trait Self := {
    http_body.Body.Data := Data;
    http_body.Body.Error := Error;
    http_body.Body.poll_frame := poll_frame;
    http_body.Body.is_end_stream := Datatypes.Some is_end_stream;
    http_body.Body.size_hint := Datatypes.Some size_hint;
  }.
End Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.
End Impl_http_body_Body_for_axum_core_response_into_response_BytesChainBody_t_T_U.

Module  Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.
  Definition Self : Set := ref (slice u8.t).
  
  (*
      fn into_response(self) -> Response {
          Cow::Borrowed(self).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.
End Impl_axum_core_response_into_response_IntoResponse_for_ref_slice_u8_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.
  Definition Self : Set := ref (array u8.t).
  
  (*
      fn into_response(self) -> Response {
          self.as_slice().into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.
End Impl_axum_core_response_into_response_IntoResponse_for_ref_array_u8_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.
  Definition Self : Set := array u8.t.
  
  (*
      fn into_response(self) -> Response {
          self.to_vec().into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.
End Impl_axum_core_response_into_response_IntoResponse_for_array_u8_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.
Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.
  Definition Self : Set := alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A.
  
  (*
      fn into_response(self) -> Response {
          Cow::<'static, [u8]>::Owned(self).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_vec_Vec_t_u8_t_alloc_vec_Vec_Default_A.

Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.
Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.
  Definition Self : Set :=
    alloc.boxed.Box.t (slice u8.t) alloc.boxed.Box.Default.A.
  
  (*
      fn into_response(self) -> Response {
          Vec::from(self).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_boxed_Box_t_slice_u8_t_alloc_boxed_Box_Default_A.

Module  Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.
  Definition Self : Set := alloc.borrow.Cow.t (slice u8.t).
  
  (*
      fn into_response(self) -> Response {
          let mut res = Body::from(self).into_response();
          res.headers_mut().insert(
              header::CONTENT_TYPE,
              HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),
          );
          res
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.
End Impl_axum_core_response_into_response_IntoResponse_for_alloc_borrow_Cow_t_slice_u8_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.
  Context {R : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := http.status.StatusCode.t * R.
  
  (*
      fn into_response(self) -> Response {
          let mut res = self.1.into_response();
          *res.status_mut() = self.0;
          res
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
Section Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  Definition Self : Set :=
    http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T.
  
  (*
      fn into_response(self) -> Response {
          let mut res = ().into_response();
          *res.headers_mut() = self;
          res
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
End Impl_axum_core_response_into_response_IntoResponse_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.

Module  Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.
Section Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.
  Definition Self : Set := http.extensions.Extensions.t.
  
  (*
      fn into_response(self) -> Response {
          let mut res = ().into_response();
          *res.extensions_mut() = self;
          res
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.
End Impl_axum_core_response_into_response_IntoResponse_for_http_extensions_Extensions_t.

Module  Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.
Section Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
    {ℋ_1 : core.fmt.Display.Trait K::type["Error"].t}
    {ℋ_2 : core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
    {ℋ_3 : core.fmt.Display.Trait V::type["Error"].t}.
  
  Definition Self : Set := array (K * V).
  
  (*
      fn into_response(self) -> Response {
          (self, ()).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.
End Impl_axum_core_response_into_response_IntoResponse_for_array_Tuple_K_V_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.
  Context {R : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := http.response.Parts.t * R.
  
  (*
      fn into_response(self) -> Response {
          let (parts, res) = self;
          (parts.status, parts.headers, parts.extensions, res).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.
  Context {R : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := (http.response.Response.t unit) * R.
  
  (*
      fn into_response(self) -> Response {
          let (template, res) = self;
          let (parts, ()) = template.into_parts();
          (parts, res).into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.
  Context {R : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := R.
  
  (*
      fn into_response(self) -> Response {
          let (res,) = self;
          res.into_response()
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.
  Context {R T1 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := T1 * R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.
  Context {R T1 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := (http.status.StatusCode.t * T1) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.
  Context {R T1 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := (http.response.Parts.t * T1) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.
  Context {R T1 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := ((http.response.Response.t unit) * T1) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.
  Context {R T1 T2 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := (T1 * T2) * R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.
  Context {R T1 T2 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := ((http.status.StatusCode.t * T1) * T2) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.
  Context {R T1 T2 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := ((http.response.Parts.t * T1) * T2) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.
  Context {R T1 T2 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := (((http.response.Response.t unit) * T1) * T2) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.
  Context {R T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := ((T1 * T2) * T3) * R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.
  Context {R T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := (((http.status.StatusCode.t * T1) * T2) * T3) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.
  Context {R T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := (((http.response.Parts.t * T1) * T2) * T3) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.
  Context {R T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((http.response.Response.t unit) * T1) * T2) * T3) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.
  Context {R T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := (((T1 * T2) * T3) * T4) * R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.
  Context {R T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.
  Context {R T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((http.response.Parts.t * T1) * T2) * T3) * T4) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.
  Context {R T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.
  Context {R T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.
  Context {R T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.
  Context {R T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.
  Context {R T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.
  Context {R T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.
  Context {R T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.
  Context {R T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.
  Context {R T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5) * T6)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7) * R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
    *
    T8)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
    *
    T8)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    T8)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
    *
    T8)
    *
    T9)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
    *
    T8)
    *
    T9)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
    *
    T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
    *
    T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    T12)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
    *
    T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    T12)
    *
    T13)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6) * T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
    *
    T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
    *
    T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
    {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
    {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
    {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
    {ℋ_15 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4) * T5)
    *
    T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
    {ℋ_15 : axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
    {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15)
    *
    T16)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let ($($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  parts.res
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
    {ℋ_15 : axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
    {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((((((((http.status.StatusCode.t * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15)
    *
    T16)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (status, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
  
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (status, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_status_StatusCode_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
    {ℋ_15 : axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
    {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    ((((((((((((((((http.response.Parts.t * T1) * T2) * T3) * T4) * T5) * T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15)
    *
    T16)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (outer_parts, $($ty),*, res) = self;
  
                  let res = res.into_response();
                  let parts = ResponseParts { res };
                  $(
                      let parts = match $ty.into_response_parts(parts) {
                          Ok(parts) => parts,
                          Err(err) => {
                              return err.into_response();
                          }
                      };
                  )*
  
                  (outer_parts, parts.res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Parts_t_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.

Module  Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
Section Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
  Context {R T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
    {ℋ_15 : axum_core.response.into_response_parts.IntoResponseParts.Trait T16}
    {ℋ_16 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    (((((((((((((((((http.response.Response.t unit) * T1) * T2) * T3) * T4)
    *
    T5)
    *
    T6)
    *
    T7)
    *
    T8)
    *
    T9)
    *
    T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15)
    *
    T16)
    *
    R.
  
  (*
              fn into_response(self) -> Response {
                  let (template, $($ty),*, res) = self;
                  let (parts, ()) = template.into_parts();
                  (parts, $($ty),*, res).into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.
End Impl_axum_core_response_into_response_IntoResponse_for_Tuple_http_response_Response_t_Tuple__T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_R_.

Module into_response_parts.
  Module  IntoResponseParts.
  Section IntoResponseParts.
    Class Trait (Self : Set) : Type := {
      Error : Set;
      ℒ_0 :: axum_core.response.into_response.IntoResponse.Trait Error;
      into_response_parts :
        Self ->
          axum_core.response.into_response_parts.ResponseParts.t ->
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error.t);
    }.
    
    Global Instance Method_Error `(Trait) :
      Notations.DoubleColonType Self "Error" := {
      Notations.double_colon_type := Error;
    }.
  End IntoResponseParts.
  End IntoResponseParts.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.
    Context {T : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T}.
    
    Definition Self : Set := core.option.Option.t T.
    
    (*
        type Error = T::Error;
    *)
    Definition Error : Set := T::type["Error"].t.
    
    (*
        fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
            if let Some(inner) = self {
                inner.into_response_parts(res)
            } else {
                Ok(res)
            }
        }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.
  
  Module  ResponseParts.
  Section ResponseParts.
    Record t : Set := {
      res :
        ltac:(axum_core.response.Response
          axum_core.response.Response.Default.T);
    }.
    
    Definition Get_res :=
      Ref.map (fun α => Some α.(res)) (fun β α => Some (α <| res := β |>)).
  End ResponseParts.
  End ResponseParts.
  
  Module  Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.
  Section Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.
    Definition Self : Set :=
      axum_core.response.into_response_parts.ResponseParts.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.
  End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.
  
  Module  Impl_axum_core_response_into_response_parts_ResponseParts_t_2.
  Section Impl_axum_core_response_into_response_parts_ResponseParts_t_2.
    Definition Self : Set :=
      axum_core.response.into_response_parts.ResponseParts.t.
    
    (*
        pub fn headers(&self) -> &HeaderMap {
            self.res.headers()
        }
    *)
    Definition headers
        (self : ref Self)
        :
          M
            (ref
              (http.header.map.HeaderMap.t
                http.header.map.HeaderMap.Default.T)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_headers :
      Notations.DoubleColon Self "headers" := {
      Notations.double_colon := headers;
    }.
    
    (*
        pub fn headers_mut(&mut self) -> &mut HeaderMap {
            self.res.headers_mut()
        }
    *)
    Definition headers_mut
        (self : mut_ref Self)
        :
          M
            (mut_ref
              (http.header.map.HeaderMap.t
                http.header.map.HeaderMap.Default.T)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_headers_mut :
      Notations.DoubleColon Self "headers_mut" := {
      Notations.double_colon := headers_mut;
    }.
    
    (*
        pub fn extensions(&self) -> &Extensions {
            self.res.extensions()
        }
    *)
    Definition extensions
        (self : ref Self)
        : M (ref http.extensions.Extensions.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_extensions :
      Notations.DoubleColon Self "extensions" := {
      Notations.double_colon := extensions;
    }.
    
    (*
        pub fn extensions_mut(&mut self) -> &mut Extensions {
            self.res.extensions_mut()
        }
    *)
    Definition extensions_mut
        (self : mut_ref Self)
        : M (mut_ref http.extensions.Extensions.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_extensions_mut :
      Notations.DoubleColon Self "extensions_mut" := {
      Notations.double_colon := extensions_mut;
    }.
  End Impl_axum_core_response_into_response_parts_ResponseParts_t_2.
  End Impl_axum_core_response_into_response_parts_ResponseParts_t_2.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
    Definition Self : Set :=
      http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T.
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
            res.headers_mut().extend(self);
            Ok(res)
        }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.
    Context {K V : Set}.
    
    Context
      {ℋ_0 : core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
      {ℋ_1 : core.fmt.Display.Trait K::type["Error"].t}
      {ℋ_2 :
        core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
      {ℋ_3 : core.fmt.Display.Trait V::type["Error"].t}.
    
    Definition Self : Set := array (K * V).
    
    (*
        type Error = TryIntoHeaderError<K::Error, V::Error>;
    *)
    Definition Error : Set :=
      axum_core.response.into_response_parts.TryIntoHeaderError.t
          K::type["Error"].t
          V::type["Error"].t.
    
    (*
        fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
            for (key, value) in self {
                let key = key.try_into().map_err(TryIntoHeaderError::key)?;
                let value = value.try_into().map_err(TryIntoHeaderError::value)?;
                res.headers_mut().insert(key, value);
            }
    
            Ok(res)
        }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.
  
  Module  TryIntoHeaderError.
  Section TryIntoHeaderError.
    Context (K V : Set).
    
    Record t : Set := {
      kind :
        axum_core.response.into_response_parts.TryIntoHeaderErrorKind.t K V;
    }.
    
    Definition Get_kind :=
      Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
  End TryIntoHeaderError.
  End TryIntoHeaderError.
  
  Module  Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  Section Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    Context {K V : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait K} {ℋ_1 : core.fmt.Debug.Trait V}.
    
    Definition Self : Set :=
      axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  
  Module  Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V_2.
  Section Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V_2.
    Context {K V : Set}.
    
    Definition Self : Set :=
      axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
    
    (*
        pub(super) fn key(err: K) -> Self {
            Self {
                kind: TryIntoHeaderErrorKind::Key(err),
            }
        }
    *)
    Definition key (err : K) : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_key :
      Notations.DoubleColon Self "key" := {
      Notations.double_colon := key;
    }.
    
    (*
        pub(super) fn value(err: V) -> Self {
            Self {
                kind: TryIntoHeaderErrorKind::Value(err),
            }
        }
    *)
    Definition value (err : V) : M Self :=
      let* err := M.alloc err in
      M.read foo.
    
    Global Instance AssociatedFunction_value :
      Notations.DoubleColon Self "value" := {
      Notations.double_colon := value;
    }.
  End Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V_2.
  End Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V_2.
  
  Module TryIntoHeaderErrorKind.
    Inductive t (K : Set) (V : Set) : Set :=
    | Key (_ : K)
    | Value (_ : V).
    
    Definition Get_Key_0 :=
      Ref.map
        (fun α => match α with | Key α0 => Some α0 | _ => None end)
        (fun β α => match α with | Key _ => Some (Key β) | _ => None end).
    
    Definition Get_Value_0 :=
      Ref.map
        (fun α => match α with | Value α0 => Some α0 | _ => None end)
        (fun β α => match α with | Value _ => Some (Value β) | _ => None end).
  End TryIntoHeaderErrorKind.
  
  Module  Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.
  Section Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.
    Context {K V : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait K} {ℋ_1 : core.fmt.Debug.Trait V}.
    
    Definition Self : Set :=
      axum_core.response.into_response_parts.TryIntoHeaderErrorKind.t K V.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.
  End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    Context {K V : Set}.
    
    Context {ℋ_0 : core.fmt.Display.Trait K} {ℋ_1 : core.fmt.Display.Trait V}.
    
    Definition Self : Set :=
      axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
    
    (*
        fn into_response(self) -> Response {
            match self.kind {
                TryIntoHeaderErrorKind::Key(inner) => {
                    (StatusCode::INTERNAL_SERVER_ERROR, inner.to_string()).into_response()
                }
                TryIntoHeaderErrorKind::Value(inner) => {
                    (StatusCode::INTERNAL_SERVER_ERROR, inner.to_string()).into_response()
                }
            }
        }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  
  Module  Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  Section Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    Context {K V : Set}.
    
    Definition Self : Set :=
      axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self.kind {
                TryIntoHeaderErrorKind::Key(_) => write!(f, "failed to convert key to a header name"),
                TryIntoHeaderErrorKind::Value(_) => {
                    write!(f, "failed to convert value to a header value")
                }
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  End Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  
  Module  Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  Section Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
    Context {K V : Set}.
    
    Context {ℋ_0 : core.error.Error.Trait K} {ℋ_1 : core.error.Error.Trait V}.
    
    Definition Self : Set :=
      axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
    
    (*
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            match &self.kind {
                TryIntoHeaderErrorKind::Key(inner) => Some(inner),
                TryIntoHeaderErrorKind::Value(inner) => Some(inner),
            }
        }
    *)
    Definition source
        (self : ref Self)
        : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_source :
      Notations.DoubleColon Self "source" := {
      Notations.double_colon := source;
    }.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.Some source;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  End Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.
    Context {T1 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}.
    
    Definition Self : Set := T1.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.
    Context {T1 T2 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}.
    
    Definition Self : Set := T1 * T2.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.
    Context {T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}.
    
    Definition Self : Set := (T1 * T2) * T3.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.
    Context {T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}.
    
    Definition Self : Set := ((T1 * T2) * T3) * T4.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.
    Context {T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}.
    
    Definition Self : Set := (((T1 * T2) * T3) * T4) * T5.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.
    Context {T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}.
    
    Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * T6.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
    Context {T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}.
    
    Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
    Context {T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}.
    
    Definition Self : Set := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
    Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}.
    
    Definition Self : Set :=
      (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
    Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T10}.
    
    Definition Self : Set :=
      ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
    Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}.
    
    Definition Self : Set :=
      (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
    Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}.
    
    Definition Self : Set :=
      ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
      *
      T12.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
    Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}.
    
    Definition Self : Set :=
      (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
    Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}.
    
    Definition Self : Set :=
      ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
    Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T15}.
    
    Definition Self : Set :=
      (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
    Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
      {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
      {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
      {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
      {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
      {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
      {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
      {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
      {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
      {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
      {ℋ_10 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
      {ℋ_11 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
      {ℋ_12 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
      {ℋ_13 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
      {ℋ_14 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
      {ℋ_15 :
        axum_core.response.into_response_parts.IntoResponseParts.Trait T16}.
    
    Definition Self : Set :=
      ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16.
    
    (*
                type Error = Response;
    *)
    Definition Error : Set :=
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
    
    (*
                fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                    let ($($ty,)* ) = self;
    
                    $(
                        let res = match $ty.into_response_parts(res) {
                            Ok(res) => res,
                            Err(err) => {
                                return Err(err.into_response());
                            }
                        };
                    )*
    
                    Ok(res)
                }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.
    Definition Self : Set := http.extensions.Extensions.t.
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
            res.extensions_mut().extend(self);
            Ok(res)
        }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.
  
  Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.
  Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.
    Definition Self : Set := unit.
    
    (*
        type Error = Infallible;
    *)
    Definition Error : Set := core.convert.Infallible.t.
    
    (*
        fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
            Ok(res)
        }
    *)
    Definition into_response_parts
        (self : Self)
        (res : axum_core.response.into_response_parts.ResponseParts.t)
        :
          M
            (core.result.Result.t
              axum_core.response.into_response_parts.ResponseParts.t
              Error) :=
      let* self := M.alloc self in
      let* res := M.alloc res in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response_parts :
      Notations.DoubleColon Self "into_response_parts" := {
      Notations.double_colon := into_response_parts;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
      axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
      axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
        into_response_parts;
    }.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.
  End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.
End into_response_parts.

Module  IntoResponseParts.
Section IntoResponseParts.
  Class Trait (Self : Set) : Type := {
    Error : Set;
    ℒ_0 :: axum_core.response.into_response.IntoResponse.Trait Error;
    into_response_parts :
      Self ->
        axum_core.response.into_response_parts.ResponseParts.t ->
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error.t);
  }.
  
  Global Instance Method_Error `(Trait) :
    Notations.DoubleColonType Self "Error" := {
    Notations.double_colon_type := Error;
  }.
End IntoResponseParts.
End IntoResponseParts.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.
  Context {T : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T}.
  
  Definition Self : Set := core.option.Option.t T.
  
  (*
      type Error = T::Error;
  *)
  Definition Error : Set := T::type["Error"].t.
  
  (*
      fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
          if let Some(inner) = self {
              inner.into_response_parts(res)
          } else {
              Ok(res)
          }
      }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_core_option_Option_t_T.

Module  ResponseParts.
Section ResponseParts.
  Record t : Set := {
    res :
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T);
  }.
  
  Definition Get_res :=
    Ref.map (fun α => Some α.(res)) (fun β α => Some (α <| res := β |>)).
End ResponseParts.
End ResponseParts.

Module  Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.
Section Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.
  Definition Self : Set :=
    axum_core.response.into_response_parts.ResponseParts.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.
End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_ResponseParts_t.

Module  Impl_axum_core_response_into_response_parts_ResponseParts_t_3.
Section Impl_axum_core_response_into_response_parts_ResponseParts_t_3.
  Definition Self : Set :=
    axum_core.response.into_response_parts.ResponseParts.t.
  
  (*
      pub fn headers(&self) -> &HeaderMap {
          self.res.headers()
      }
  *)
  Definition headers
      (self : ref Self)
      :
        M
          (ref
            (http.header.map.HeaderMap.t
              http.header.map.HeaderMap.Default.T)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_headers :
    Notations.DoubleColon Self "headers" := {
    Notations.double_colon := headers;
  }.
  
  (*
      pub fn headers_mut(&mut self) -> &mut HeaderMap {
          self.res.headers_mut()
      }
  *)
  Definition headers_mut
      (self : mut_ref Self)
      :
        M
          (mut_ref
            (http.header.map.HeaderMap.t
              http.header.map.HeaderMap.Default.T)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_headers_mut :
    Notations.DoubleColon Self "headers_mut" := {
    Notations.double_colon := headers_mut;
  }.
  
  (*
      pub fn extensions(&self) -> &Extensions {
          self.res.extensions()
      }
  *)
  Definition extensions
      (self : ref Self)
      : M (ref http.extensions.Extensions.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_extensions :
    Notations.DoubleColon Self "extensions" := {
    Notations.double_colon := extensions;
  }.
  
  (*
      pub fn extensions_mut(&mut self) -> &mut Extensions {
          self.res.extensions_mut()
      }
  *)
  Definition extensions_mut
      (self : mut_ref Self)
      : M (mut_ref http.extensions.Extensions.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_extensions_mut :
    Notations.DoubleColon Self "extensions_mut" := {
    Notations.double_colon := extensions_mut;
  }.
End Impl_axum_core_response_into_response_parts_ResponseParts_t_3.
End Impl_axum_core_response_into_response_parts_ResponseParts_t_3.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
  Definition Self : Set :=
    http.header.map.HeaderMap.t http.header.map.HeaderMap.Default.T.
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
          res.headers_mut().extend(self);
          Ok(res)
      }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_header_map_HeaderMap_t_http_header_map_HeaderMap_Default_T.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.convert.TryInto.Trait K (T := http.header.name.HeaderName.t)}
    {ℋ_1 : core.fmt.Display.Trait K::type["Error"].t}
    {ℋ_2 : core.convert.TryInto.Trait V (T := http.header.value.HeaderValue.t)}
    {ℋ_3 : core.fmt.Display.Trait V::type["Error"].t}.
  
  Definition Self : Set := array (K * V).
  
  (*
      type Error = TryIntoHeaderError<K::Error, V::Error>;
  *)
  Definition Error : Set :=
    axum_core.response.into_response_parts.TryIntoHeaderError.t
        K::type["Error"].t
        V::type["Error"].t.
  
  (*
      fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
          for (key, value) in self {
              let key = key.try_into().map_err(TryIntoHeaderError::key)?;
              let value = value.try_into().map_err(TryIntoHeaderError::value)?;
              res.headers_mut().insert(key, value);
          }
  
          Ok(res)
      }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_array_Tuple_K_V_.

Module  TryIntoHeaderError.
Section TryIntoHeaderError.
  Context (K V : Set).
  
  Record t : Set := {
    kind : axum_core.response.into_response_parts.TryIntoHeaderErrorKind.t K V;
  }.
  
  Definition Get_kind :=
    Ref.map (fun α => Some α.(kind)) (fun β α => Some (α <| kind := β |>)).
End TryIntoHeaderError.
End TryIntoHeaderError.

Module  Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
Section Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  Context {K V : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait K} {ℋ_1 : core.fmt.Debug.Trait V}.
  
  Definition Self : Set :=
    axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.

Module  Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V_3.
Section Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V_3.
  Context {K V : Set}.
  
  Definition Self : Set :=
    axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
  
  (*
      pub(super) fn key(err: K) -> Self {
          Self {
              kind: TryIntoHeaderErrorKind::Key(err),
          }
      }
  *)
  Definition key (err : K) : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_key : Notations.DoubleColon Self "key" := {
    Notations.double_colon := key;
  }.
  
  (*
      pub(super) fn value(err: V) -> Self {
          Self {
              kind: TryIntoHeaderErrorKind::Value(err),
          }
      }
  *)
  Definition value (err : V) : M Self :=
    let* err := M.alloc err in
    M.read foo.
  
  Global Instance AssociatedFunction_value :
    Notations.DoubleColon Self "value" := {
    Notations.double_colon := value;
  }.
End Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V_3.
End Impl_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V_3.

Module TryIntoHeaderErrorKind.
  Inductive t (K : Set) (V : Set) : Set :=
  | Key (_ : K)
  | Value (_ : V).
  
  Definition Get_Key_0 :=
    Ref.map
      (fun α => match α with | Key α0 => Some α0 | _ => None end)
      (fun β α => match α with | Key _ => Some (Key β) | _ => None end).
  
  Definition Get_Value_0 :=
    Ref.map
      (fun α => match α with | Value α0 => Some α0 | _ => None end)
      (fun β α => match α with | Value _ => Some (Value β) | _ => None end).
End TryIntoHeaderErrorKind.

Module  Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.
Section Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.
  Context {K V : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait K} {ℋ_1 : core.fmt.Debug.Trait V}.
  
  Definition Self : Set :=
    axum_core.response.into_response_parts.TryIntoHeaderErrorKind.t K V.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.
End Impl_core_fmt_Debug_for_axum_core_response_into_response_parts_TryIntoHeaderErrorKind_t_K_V.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  Context {K V : Set}.
  
  Context {ℋ_0 : core.fmt.Display.Trait K} {ℋ_1 : core.fmt.Display.Trait V}.
  
  Definition Self : Set :=
    axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
  
  (*
      fn into_response(self) -> Response {
          match self.kind {
              TryIntoHeaderErrorKind::Key(inner) => {
                  (StatusCode::INTERNAL_SERVER_ERROR, inner.to_string()).into_response()
              }
              TryIntoHeaderErrorKind::Value(inner) => {
                  (StatusCode::INTERNAL_SERVER_ERROR, inner.to_string()).into_response()
              }
          }
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.

Module  Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
Section Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set :=
    axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          match self.kind {
              TryIntoHeaderErrorKind::Key(_) => write!(f, "failed to convert key to a header name"),
              TryIntoHeaderErrorKind::Value(_) => {
                  write!(f, "failed to convert value to a header value")
              }
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
End Impl_core_fmt_Display_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.

Module  Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
Section Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
  Context {K V : Set}.
  
  Context {ℋ_0 : core.error.Error.Trait K} {ℋ_1 : core.error.Error.Trait V}.
  
  Definition Self : Set :=
    axum_core.response.into_response_parts.TryIntoHeaderError.t K V.
  
  (*
      fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
          match &self.kind {
              TryIntoHeaderErrorKind::Key(inner) => Some(inner),
              TryIntoHeaderErrorKind::Value(inner) => Some(inner),
          }
      }
  *)
  Definition source
      (self : ref Self)
      : M (core.option.Option.t (ref (dyn [core.error.Error.Trait]))) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_source :
    Notations.DoubleColon Self "source" := {
    Notations.double_colon := source;
  }.
  
  Global Instance ℐ : core.error.Error.Required.Trait Self := {
    core.error.Error.source := Datatypes.Some source;
    core.error.Error.type_id := Datatypes.None;
    core.error.Error.description := Datatypes.None;
    core.error.Error.cause := Datatypes.None;
    core.error.Error.provide := Datatypes.None;
  }.
End Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.
End Impl_core_error_Error_for_axum_core_response_into_response_parts_TryIntoHeaderError_t_K_V.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.
  Context {T1 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}.
  
  Definition Self : Set := T1.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.
  Context {T1 T2 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}.
  
  Definition Self : Set := T1 * T2.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.
  Context {T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}.
  
  Definition Self : Set := (T1 * T2) * T3.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.
  Context {T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}.
  
  Definition Self : Set := ((T1 * T2) * T3) * T4.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.
  Context {T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}.
  
  Definition Self : Set := (((T1 * T2) * T3) * T4) * T5.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.
  Context {T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}.
  
  Definition Self : Set := ((((T1 * T2) * T3) * T4) * T5) * T6.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
  Context {T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}.
  
  Definition Self : Set := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
  Context {T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}.
  
  Definition Self : Set := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
  Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}.
  
  Definition Self : Set :=
    (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
  Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}.
  
  Definition Self : Set :=
    ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
  Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}.
  
  Definition Self : Set :=
    (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
  Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}.
  
  Definition Self : Set :=
    ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    T12.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
  Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}.
  
  Definition Self : Set :=
    (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    T12)
    *
    T13.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
  Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}.
  
  Definition Self : Set :=
    ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10) * T11)
    *
    T12)
    *
    T13)
    *
    T14.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
  Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response_parts.IntoResponseParts.Trait T15}.
  
  Definition Self : Set :=
    (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
  Context {T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response_parts.IntoResponseParts.Trait T1}
    {ℋ_1 : axum_core.response.into_response_parts.IntoResponseParts.Trait T2}
    {ℋ_2 : axum_core.response.into_response_parts.IntoResponseParts.Trait T3}
    {ℋ_3 : axum_core.response.into_response_parts.IntoResponseParts.Trait T4}
    {ℋ_4 : axum_core.response.into_response_parts.IntoResponseParts.Trait T5}
    {ℋ_5 : axum_core.response.into_response_parts.IntoResponseParts.Trait T6}
    {ℋ_6 : axum_core.response.into_response_parts.IntoResponseParts.Trait T7}
    {ℋ_7 : axum_core.response.into_response_parts.IntoResponseParts.Trait T8}
    {ℋ_8 : axum_core.response.into_response_parts.IntoResponseParts.Trait T9}
    {ℋ_9 : axum_core.response.into_response_parts.IntoResponseParts.Trait T10}
    {ℋ_10 : axum_core.response.into_response_parts.IntoResponseParts.Trait T11}
    {ℋ_11 : axum_core.response.into_response_parts.IntoResponseParts.Trait T12}
    {ℋ_12 : axum_core.response.into_response_parts.IntoResponseParts.Trait T13}
    {ℋ_13 : axum_core.response.into_response_parts.IntoResponseParts.Trait T14}
    {ℋ_14 : axum_core.response.into_response_parts.IntoResponseParts.Trait T15}
    {ℋ_15 : axum_core.response.into_response_parts.IntoResponseParts.Trait T16}.
  
  Definition Self : Set :=
    ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
    *
    T11)
    *
    T12)
    *
    T13)
    *
    T14)
    *
    T15)
    *
    T16.
  
  (*
              type Error = Response;
  *)
  Definition Error : Set :=
    ltac:(axum_core.response.Response axum_core.response.Response.Default.T).
  
  (*
              fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
                  let ($($ty,)* ) = self;
  
                  $(
                      let res = match $ty.into_response_parts(res) {
                          Ok(res) => res,
                          Err(err) => {
                              return Err(err.into_response());
                          }
                      };
                  )*
  
                  Ok(res)
              }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16_.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.
  Definition Self : Set := http.extensions.Extensions.t.
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
          res.extensions_mut().extend(self);
          Ok(res)
      }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_http_extensions_Extensions_t.

Module  Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.
Section Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.
  Definition Self : Set := unit.
  
  (*
      type Error = Infallible;
  *)
  Definition Error : Set := core.convert.Infallible.t.
  
  (*
      fn into_response_parts(self, res: ResponseParts) -> Result<ResponseParts, Self::Error> {
          Ok(res)
      }
  *)
  Definition into_response_parts
      (self : Self)
      (res : axum_core.response.into_response_parts.ResponseParts.t)
      :
        M
          (core.result.Result.t
            axum_core.response.into_response_parts.ResponseParts.t
            Error) :=
    let* self := M.alloc self in
    let* res := M.alloc res in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response_parts :
    Notations.DoubleColon Self "into_response_parts" := {
    Notations.double_colon := into_response_parts;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response_parts.IntoResponseParts.Trait Self := {
    axum_core.response.into_response_parts.IntoResponseParts.Error := Error;
    axum_core.response.into_response_parts.IntoResponseParts.into_response_parts :=
      into_response_parts;
  }.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.
End Impl_axum_core_response_into_response_parts_IntoResponseParts_for_Tuple_.

Ltac Response T := exact (http.response.Response.t T).

Ltac Result T E := exact (core.result.Result.t T E).

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Result_T_axum_core_response_Result_Default_E.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Result_T_axum_core_response_Result_Default_E.
  Context {T : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
  
  Definition Self : Set :=
    ltac:(axum_core.response.Result T axum_core.response.Result.Default.E).
  
  (*
      fn into_response(self) -> Response {
          match self {
              Ok(ok) => ok.into_response(),
              Err(err) => err.0,
          }
      }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Result_T_axum_core_response_Result_Default_E.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_core_response_Result_T_axum_core_response_Result_Default_E.

Module  ErrorResponse.
Section ErrorResponse.
  Record t : Set := {
    x0 :
      ltac:(axum_core.response.Response axum_core.response.Response.Default.T);
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End ErrorResponse.
End ErrorResponse.

Module  Impl_core_fmt_Debug_for_axum_core_response_ErrorResponse_t.
Section Impl_core_fmt_Debug_for_axum_core_response_ErrorResponse_t.
  Definition Self : Set := axum_core.response.ErrorResponse.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_core_response_ErrorResponse_t.
End Impl_core_fmt_Debug_for_axum_core_response_ErrorResponse_t.

Module  Impl_core_convert_From_T_for_axum_core_response_ErrorResponse_t.
Section Impl_core_convert_From_T_for_axum_core_response_ErrorResponse_t.
  Context {T : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
  
  Definition Self : Set := axum_core.response.ErrorResponse.t.
  
  (*
      fn from(value: T) -> Self {
          Self(value.into_response())
      }
  *)
  Definition from (value : T) : M Self :=
    let* value := M.alloc value in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_T_for_axum_core_response_ErrorResponse_t.
End Impl_core_convert_From_T_for_axum_core_response_ErrorResponse_t.

Ltac BoxError :=
  exact
    (alloc.boxed.Box.t
      (dyn
        [core.error.Error.Trait;
          core.marker.Send.Trait;
          core.marker.Sync.Trait])
      alloc.boxed.Box.Default.A).
