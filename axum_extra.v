(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module either.
  Module Either.
    Inductive t (E1 : Set) (E2 : Set) : Set :=
    | E1 (_ : E1)
    | E2 (_ : E2).
    
    Definition Get_E1_0 :=
      Ref.map
        (fun α => match α with | E1 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
    
    Definition Get_E2_0 :=
      Ref.map
        (fun α => match α with | E2 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
  End Either.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_either_Either_t_E1_E2.
  Section Impl_core_fmt_Debug_for_axum_extra_either_Either_t_E1_E2.
    Context {E1 E2 : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait E1} {ℋ_1 : core.fmt.Debug.Trait E2}.
    
    Definition Self : Set := axum_extra.either.Either.t E1 E2.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either_t_E1_E2.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either_t_E1_E2.
  
  Module  Impl_core_clone_Clone_for_axum_extra_either_Either_t_E1_E2.
  Section Impl_core_clone_Clone_for_axum_extra_either_Either_t_E1_E2.
    Context {E1 E2 : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait E1} {ℋ_1 : core.clone.Clone.Trait E2}.
    
    Definition Self : Set := axum_extra.either.Either.t E1 E2.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M (axum_extra.either.Either.t E1 E2) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_either_Either_t_E1_E2.
  End Impl_core_clone_Clone_for_axum_extra_either_Either_t_E1_E2.
  
  Module Either3.
    Inductive t (E1 : Set) (E2 : Set) (E3 : Set) : Set :=
    | E1 (_ : E1)
    | E2 (_ : E2)
    | E3 (_ : E3).
    
    Definition Get_E1_0 :=
      Ref.map
        (fun α => match α with | E1 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
    
    Definition Get_E2_0 :=
      Ref.map
        (fun α => match α with | E2 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
    
    Definition Get_E3_0 :=
      Ref.map
        (fun α => match α with | E3 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
  End Either3.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_either_Either3_t_E1_E2_E3.
  Section Impl_core_fmt_Debug_for_axum_extra_either_Either3_t_E1_E2_E3.
    Context {E1 E2 E3 : Set}.
    
    Context
      {ℋ_0 : core.fmt.Debug.Trait E1}
      {ℋ_1 : core.fmt.Debug.Trait E2}
      {ℋ_2 : core.fmt.Debug.Trait E3}.
    
    Definition Self : Set := axum_extra.either.Either3.t E1 E2 E3.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either3_t_E1_E2_E3.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either3_t_E1_E2_E3.
  
  Module  Impl_core_clone_Clone_for_axum_extra_either_Either3_t_E1_E2_E3.
  Section Impl_core_clone_Clone_for_axum_extra_either_Either3_t_E1_E2_E3.
    Context {E1 E2 E3 : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait E1}
      {ℋ_1 : core.clone.Clone.Trait E2}
      {ℋ_2 : core.clone.Clone.Trait E3}.
    
    Definition Self : Set := axum_extra.either.Either3.t E1 E2 E3.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum_extra.either.Either3.t E1 E2 E3) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_either_Either3_t_E1_E2_E3.
  End Impl_core_clone_Clone_for_axum_extra_either_Either3_t_E1_E2_E3.
  
  Module Either4.
    Inductive t (E1 : Set) (E2 : Set) (E3 : Set) (E4 : Set) : Set :=
    | E1 (_ : E1)
    | E2 (_ : E2)
    | E3 (_ : E3)
    | E4 (_ : E4).
    
    Definition Get_E1_0 :=
      Ref.map
        (fun α => match α with | E1 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
    
    Definition Get_E2_0 :=
      Ref.map
        (fun α => match α with | E2 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
    
    Definition Get_E3_0 :=
      Ref.map
        (fun α => match α with | E3 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
    
    Definition Get_E4_0 :=
      Ref.map
        (fun α => match α with | E4 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E4 _ => Some (E4 β) | _ => None end).
  End Either4.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  Section Impl_core_fmt_Debug_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
    Context {E1 E2 E3 E4 : Set}.
    
    Context
      {ℋ_0 : core.fmt.Debug.Trait E1}
      {ℋ_1 : core.fmt.Debug.Trait E2}
      {ℋ_2 : core.fmt.Debug.Trait E3}
      {ℋ_3 : core.fmt.Debug.Trait E4}.
    
    Definition Self : Set := axum_extra.either.Either4.t E1 E2 E3 E4.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  
  Module  Impl_core_clone_Clone_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  Section Impl_core_clone_Clone_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
    Context {E1 E2 E3 E4 : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait E1}
      {ℋ_1 : core.clone.Clone.Trait E2}
      {ℋ_2 : core.clone.Clone.Trait E3}
      {ℋ_3 : core.clone.Clone.Trait E4}.
    
    Definition Self : Set := axum_extra.either.Either4.t E1 E2 E3 E4.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum_extra.either.Either4.t E1 E2 E3 E4) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  End Impl_core_clone_Clone_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  
  Module Either5.
    Inductive t (E1 : Set) (E2 : Set) (E3 : Set) (E4 : Set) (E5 : Set) : Set :=
    | E1 (_ : E1)
    | E2 (_ : E2)
    | E3 (_ : E3)
    | E4 (_ : E4)
    | E5 (_ : E5).
    
    Definition Get_E1_0 :=
      Ref.map
        (fun α => match α with | E1 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
    
    Definition Get_E2_0 :=
      Ref.map
        (fun α => match α with | E2 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
    
    Definition Get_E3_0 :=
      Ref.map
        (fun α => match α with | E3 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
    
    Definition Get_E4_0 :=
      Ref.map
        (fun α => match α with | E4 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E4 _ => Some (E4 β) | _ => None end).
    
    Definition Get_E5_0 :=
      Ref.map
        (fun α => match α with | E5 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E5 _ => Some (E5 β) | _ => None end).
  End Either5.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  Section Impl_core_fmt_Debug_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
    Context {E1 E2 E3 E4 E5 : Set}.
    
    Context
      {ℋ_0 : core.fmt.Debug.Trait E1}
      {ℋ_1 : core.fmt.Debug.Trait E2}
      {ℋ_2 : core.fmt.Debug.Trait E3}
      {ℋ_3 : core.fmt.Debug.Trait E4}
      {ℋ_4 : core.fmt.Debug.Trait E5}.
    
    Definition Self : Set := axum_extra.either.Either5.t E1 E2 E3 E4 E5.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  
  Module  Impl_core_clone_Clone_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  Section Impl_core_clone_Clone_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
    Context {E1 E2 E3 E4 E5 : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait E1}
      {ℋ_1 : core.clone.Clone.Trait E2}
      {ℋ_2 : core.clone.Clone.Trait E3}
      {ℋ_3 : core.clone.Clone.Trait E4}
      {ℋ_4 : core.clone.Clone.Trait E5}.
    
    Definition Self : Set := axum_extra.either.Either5.t E1 E2 E3 E4 E5.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum_extra.either.Either5.t E1 E2 E3 E4 E5) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  End Impl_core_clone_Clone_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  
  Module Either6.
    Inductive
      t
      (E1 : Set)
      (E2 : Set)
      (E3 : Set)
      (E4 : Set)
      (E5 : Set)
      (E6 : Set) :
      Set :=
    | E1 (_ : E1)
    | E2 (_ : E2)
    | E3 (_ : E3)
    | E4 (_ : E4)
    | E5 (_ : E5)
    | E6 (_ : E6).
    
    Definition Get_E1_0 :=
      Ref.map
        (fun α => match α with | E1 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
    
    Definition Get_E2_0 :=
      Ref.map
        (fun α => match α with | E2 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
    
    Definition Get_E3_0 :=
      Ref.map
        (fun α => match α with | E3 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
    
    Definition Get_E4_0 :=
      Ref.map
        (fun α => match α with | E4 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E4 _ => Some (E4 β) | _ => None end).
    
    Definition Get_E5_0 :=
      Ref.map
        (fun α => match α with | E5 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E5 _ => Some (E5 β) | _ => None end).
    
    Definition Get_E6_0 :=
      Ref.map
        (fun α => match α with | E6 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E6 _ => Some (E6 β) | _ => None end).
  End Either6.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  Section Impl_core_fmt_Debug_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
    Context {E1 E2 E3 E4 E5 E6 : Set}.
    
    Context
      {ℋ_0 : core.fmt.Debug.Trait E1}
      {ℋ_1 : core.fmt.Debug.Trait E2}
      {ℋ_2 : core.fmt.Debug.Trait E3}
      {ℋ_3 : core.fmt.Debug.Trait E4}
      {ℋ_4 : core.fmt.Debug.Trait E5}
      {ℋ_5 : core.fmt.Debug.Trait E6}.
    
    Definition Self : Set := axum_extra.either.Either6.t E1 E2 E3 E4 E5 E6.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  
  Module  Impl_core_clone_Clone_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  Section Impl_core_clone_Clone_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
    Context {E1 E2 E3 E4 E5 E6 : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait E1}
      {ℋ_1 : core.clone.Clone.Trait E2}
      {ℋ_2 : core.clone.Clone.Trait E3}
      {ℋ_3 : core.clone.Clone.Trait E4}
      {ℋ_4 : core.clone.Clone.Trait E5}
      {ℋ_5 : core.clone.Clone.Trait E6}.
    
    Definition Self : Set := axum_extra.either.Either6.t E1 E2 E3 E4 E5 E6.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum_extra.either.Either6.t E1 E2 E3 E4 E5 E6) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  End Impl_core_clone_Clone_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  
  Module Either7.
    Inductive
      t
      (E1 : Set)
      (E2 : Set)
      (E3 : Set)
      (E4 : Set)
      (E5 : Set)
      (E6 : Set)
      (E7 : Set) :
      Set :=
    | E1 (_ : E1)
    | E2 (_ : E2)
    | E3 (_ : E3)
    | E4 (_ : E4)
    | E5 (_ : E5)
    | E6 (_ : E6)
    | E7 (_ : E7).
    
    Definition Get_E1_0 :=
      Ref.map
        (fun α => match α with | E1 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
    
    Definition Get_E2_0 :=
      Ref.map
        (fun α => match α with | E2 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
    
    Definition Get_E3_0 :=
      Ref.map
        (fun α => match α with | E3 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
    
    Definition Get_E4_0 :=
      Ref.map
        (fun α => match α with | E4 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E4 _ => Some (E4 β) | _ => None end).
    
    Definition Get_E5_0 :=
      Ref.map
        (fun α => match α with | E5 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E5 _ => Some (E5 β) | _ => None end).
    
    Definition Get_E6_0 :=
      Ref.map
        (fun α => match α with | E6 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E6 _ => Some (E6 β) | _ => None end).
    
    Definition Get_E7_0 :=
      Ref.map
        (fun α => match α with | E7 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E7 _ => Some (E7 β) | _ => None end).
  End Either7.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  Section Impl_core_fmt_Debug_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
    Context {E1 E2 E3 E4 E5 E6 E7 : Set}.
    
    Context
      {ℋ_0 : core.fmt.Debug.Trait E1}
      {ℋ_1 : core.fmt.Debug.Trait E2}
      {ℋ_2 : core.fmt.Debug.Trait E3}
      {ℋ_3 : core.fmt.Debug.Trait E4}
      {ℋ_4 : core.fmt.Debug.Trait E5}
      {ℋ_5 : core.fmt.Debug.Trait E6}
      {ℋ_6 : core.fmt.Debug.Trait E7}.
    
    Definition Self : Set := axum_extra.either.Either7.t E1 E2 E3 E4 E5 E6 E7.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  
  Module  Impl_core_clone_Clone_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  Section Impl_core_clone_Clone_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
    Context {E1 E2 E3 E4 E5 E6 E7 : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait E1}
      {ℋ_1 : core.clone.Clone.Trait E2}
      {ℋ_2 : core.clone.Clone.Trait E3}
      {ℋ_3 : core.clone.Clone.Trait E4}
      {ℋ_4 : core.clone.Clone.Trait E5}
      {ℋ_5 : core.clone.Clone.Trait E6}
      {ℋ_6 : core.clone.Clone.Trait E7}.
    
    Definition Self : Set := axum_extra.either.Either7.t E1 E2 E3 E4 E5 E6 E7.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum_extra.either.Either7.t E1 E2 E3 E4 E5 E6 E7) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  End Impl_core_clone_Clone_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  
  Module Either8.
    Inductive
      t
      (E1 : Set)
      (E2 : Set)
      (E3 : Set)
      (E4 : Set)
      (E5 : Set)
      (E6 : Set)
      (E7 : Set)
      (E8 : Set) :
      Set :=
    | E1 (_ : E1)
    | E2 (_ : E2)
    | E3 (_ : E3)
    | E4 (_ : E4)
    | E5 (_ : E5)
    | E6 (_ : E6)
    | E7 (_ : E7)
    | E8 (_ : E8).
    
    Definition Get_E1_0 :=
      Ref.map
        (fun α => match α with | E1 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
    
    Definition Get_E2_0 :=
      Ref.map
        (fun α => match α with | E2 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
    
    Definition Get_E3_0 :=
      Ref.map
        (fun α => match α with | E3 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
    
    Definition Get_E4_0 :=
      Ref.map
        (fun α => match α with | E4 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E4 _ => Some (E4 β) | _ => None end).
    
    Definition Get_E5_0 :=
      Ref.map
        (fun α => match α with | E5 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E5 _ => Some (E5 β) | _ => None end).
    
    Definition Get_E6_0 :=
      Ref.map
        (fun α => match α with | E6 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E6 _ => Some (E6 β) | _ => None end).
    
    Definition Get_E7_0 :=
      Ref.map
        (fun α => match α with | E7 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E7 _ => Some (E7 β) | _ => None end).
    
    Definition Get_E8_0 :=
      Ref.map
        (fun α => match α with | E8 α0 => Some α0 | _ => None end)
        (fun β α => match α with | E8 _ => Some (E8 β) | _ => None end).
  End Either8.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  Section Impl_core_fmt_Debug_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
    Context {E1 E2 E3 E4 E5 E6 E7 E8 : Set}.
    
    Context
      {ℋ_0 : core.fmt.Debug.Trait E1}
      {ℋ_1 : core.fmt.Debug.Trait E2}
      {ℋ_2 : core.fmt.Debug.Trait E3}
      {ℋ_3 : core.fmt.Debug.Trait E4}
      {ℋ_4 : core.fmt.Debug.Trait E5}
      {ℋ_5 : core.fmt.Debug.Trait E6}
      {ℋ_6 : core.fmt.Debug.Trait E7}
      {ℋ_7 : core.fmt.Debug.Trait E8}.
    
    Definition Self : Set :=
      axum_extra.either.Either8.t E1 E2 E3 E4 E5 E6 E7 E8.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  End Impl_core_fmt_Debug_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  
  Module  Impl_core_clone_Clone_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  Section Impl_core_clone_Clone_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
    Context {E1 E2 E3 E4 E5 E6 E7 E8 : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait E1}
      {ℋ_1 : core.clone.Clone.Trait E2}
      {ℋ_2 : core.clone.Clone.Trait E3}
      {ℋ_3 : core.clone.Clone.Trait E4}
      {ℋ_4 : core.clone.Clone.Trait E5}
      {ℋ_5 : core.clone.Clone.Trait E6}
      {ℋ_6 : core.clone.Clone.Trait E7}
      {ℋ_7 : core.clone.Clone.Trait E8}.
    
    Definition Self : Set :=
      axum_extra.either.Either8.t E1 E2 E3 E4 E5 E6 E7 E8.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum_extra.either.Either8.t E1 E2 E3 E4 E5 E6 E7 E8) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  End Impl_core_clone_Clone_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either_t_E1_E2.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either_t_E1_E2.
    Context {S E1 E2 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
      {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum_extra.either.Either.t E1 E2.
    
    (*
                type Rejection = $last::Rejection;
    *)
    Definition Rejection : Set := E2::type["Rejection"].t.
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                            return Ok(Self::$ident(value));
                        }
                    )*
    
                    FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either_t_E1_E2.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either_t_E1_E2.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either_t_E1_E2.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either_t_E1_E2.
    Context {E1 E2 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}.
    
    Definition Self : Set := axum_extra.either.Either.t E1 E2.
    
    (*
                fn into_response(self) -> Response {
                    match self {
                        $( Self::$ident(value) => value.into_response(), )*
                        Self::$last(value) => value.into_response(),
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either_t_E1_E2.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either_t_E1_E2.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either3_t_E1_E2_E3.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either3_t_E1_E2_E3.
    Context {S E1 E2 E3 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
      {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
      {ℋ_3 : core.marker.Send.Trait S}
      {ℋ_4 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum_extra.either.Either3.t E1 E2 E3.
    
    (*
                type Rejection = $last::Rejection;
    *)
    Definition Rejection : Set := E3::type["Rejection"].t.
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                            return Ok(Self::$ident(value));
                        }
                    )*
    
                    FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either3_t_E1_E2_E3.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either3_t_E1_E2_E3.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either3_t_E1_E2_E3.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either3_t_E1_E2_E3.
    Context {E1 E2 E3 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
      {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}.
    
    Definition Self : Set := axum_extra.either.Either3.t E1 E2 E3.
    
    (*
                fn into_response(self) -> Response {
                    match self {
                        $( Self::$ident(value) => value.into_response(), )*
                        Self::$last(value) => value.into_response(),
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either3_t_E1_E2_E3.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either3_t_E1_E2_E3.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
    Context {S E1 E2 E3 E4 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
      {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait E4 (S := S)}
      {ℋ_4 : core.marker.Send.Trait S}
      {ℋ_5 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum_extra.either.Either4.t E1 E2 E3 E4.
    
    (*
                type Rejection = $last::Rejection;
    *)
    Definition Rejection : Set := E4::type["Rejection"].t.
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                            return Ok(Self::$ident(value));
                        }
                    )*
    
                    FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
    Context {E1 E2 E3 E4 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
      {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}
      {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait E4}.
    
    Definition Self : Set := axum_extra.either.Either4.t E1 E2 E3 E4.
    
    (*
                fn into_response(self) -> Response {
                    match self {
                        $( Self::$ident(value) => value.into_response(), )*
                        Self::$last(value) => value.into_response(),
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
    Context {S E1 E2 E3 E4 E5 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
      {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait E4 (S := S)}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait E5 (S := S)}
      {ℋ_5 : core.marker.Send.Trait S}
      {ℋ_6 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum_extra.either.Either5.t E1 E2 E3 E4 E5.
    
    (*
                type Rejection = $last::Rejection;
    *)
    Definition Rejection : Set := E5::type["Rejection"].t.
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                            return Ok(Self::$ident(value));
                        }
                    )*
    
                    FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
    Context {E1 E2 E3 E4 E5 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
      {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}
      {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait E4}
      {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait E5}.
    
    Definition Self : Set := axum_extra.either.Either5.t E1 E2 E3 E4 E5.
    
    (*
                fn into_response(self) -> Response {
                    match self {
                        $( Self::$ident(value) => value.into_response(), )*
                        Self::$last(value) => value.into_response(),
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
    Context {S E1 E2 E3 E4 E5 E6 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
      {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait E4 (S := S)}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait E5 (S := S)}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait E6 (S := S)}
      {ℋ_6 : core.marker.Send.Trait S}
      {ℋ_7 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum_extra.either.Either6.t E1 E2 E3 E4 E5 E6.
    
    (*
                type Rejection = $last::Rejection;
    *)
    Definition Rejection : Set := E6::type["Rejection"].t.
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                            return Ok(Self::$ident(value));
                        }
                    )*
    
                    FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
    Context {E1 E2 E3 E4 E5 E6 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
      {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}
      {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait E4}
      {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait E5}
      {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait E6}.
    
    Definition Self : Set := axum_extra.either.Either6.t E1 E2 E3 E4 E5 E6.
    
    (*
                fn into_response(self) -> Response {
                    match self {
                        $( Self::$ident(value) => value.into_response(), )*
                        Self::$last(value) => value.into_response(),
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
    Context {S E1 E2 E3 E4 E5 E6 E7 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
      {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait E4 (S := S)}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait E5 (S := S)}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait E6 (S := S)}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait E7 (S := S)}
      {ℋ_7 : core.marker.Send.Trait S}
      {ℋ_8 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum_extra.either.Either7.t E1 E2 E3 E4 E5 E6 E7.
    
    (*
                type Rejection = $last::Rejection;
    *)
    Definition Rejection : Set := E7::type["Rejection"].t.
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                            return Ok(Self::$ident(value));
                        }
                    )*
    
                    FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
    Context {E1 E2 E3 E4 E5 E6 E7 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
      {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}
      {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait E4}
      {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait E5}
      {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait E6}
      {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait E7}.
    
    Definition Self : Set := axum_extra.either.Either7.t E1 E2 E3 E4 E5 E6 E7.
    
    (*
                fn into_response(self) -> Response {
                    match self {
                        $( Self::$ident(value) => value.into_response(), )*
                        Self::$last(value) => value.into_response(),
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
    Context {S E1 E2 E3 E4 E5 E6 E7 E8 : Set}.
    
    Context
      {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
      {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
      {ℋ_3 : axum_core.extract.FromRequestParts.Trait E4 (S := S)}
      {ℋ_4 : axum_core.extract.FromRequestParts.Trait E5 (S := S)}
      {ℋ_5 : axum_core.extract.FromRequestParts.Trait E6 (S := S)}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait E7 (S := S)}
      {ℋ_7 : axum_core.extract.FromRequestParts.Trait E8 (S := S)}
      {ℋ_8 : core.marker.Send.Trait S}
      {ℋ_9 : core.marker.Sync.Trait S}.
    
    Definition Self : Set :=
      axum_extra.either.Either8.t E1 E2 E3 E4 E5 E6 E7 E8.
    
    (*
                type Rejection = $last::Rejection;
    *)
    Definition Rejection : Set := E8::type["Rejection"].t.
    
    (*
                async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                    $(
                        if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                            return Ok(Self::$ident(value));
                        }
                    )*
    
                    FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
                }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
    Context {E1 E2 E3 E4 E5 E6 E7 E8 : Set}.
    
    Context
      {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
      {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
      {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}
      {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait E4}
      {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait E5}
      {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait E6}
      {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait E7}
      {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait E8}.
    
    Definition Self : Set :=
      axum_extra.either.Either8.t E1 E2 E3 E4 E5 E6 E7 E8.
    
    (*
                fn into_response(self) -> Response {
                    match self {
                        $( Self::$ident(value) => value.into_response(), )*
                        Self::$last(value) => value.into_response(),
                    }
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  
  Module  Impl_tower_layer_Layer_S_for_axum_extra_either_Either_t_E1_E2.
  Section Impl_tower_layer_Layer_S_for_axum_extra_either_Either_t_E1_E2.
    Context {E1 E2 S : Set}.
    
    Context
      {ℋ_0 : tower_layer.Layer.Trait E1 (S := S)}
      {ℋ_1 : tower_layer.Layer.Trait E2 (S := S)}.
    
    Definition Self : Set := axum_extra.either.Either.t E1 E2.
    
    (*
        type Service = Either<E1::Service, E2::Service>;
    *)
    Definition Service : Set :=
      axum_extra.either.Either.t E1::type["Service"].t E2::type["Service"].t.
    
    (*
        fn layer(&self, inner: S) -> Self::Service {
            match self {
                Either::E1(layer) => Either::E1(layer.layer(inner)),
                Either::E2(layer) => Either::E2(layer.layer(inner)),
            }
        }
    *)
    Definition layer (self : ref Self) (inner : S) : M Service :=
      let* self := M.alloc self in
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_layer :
      Notations.DoubleColon Self "layer" := {
      Notations.double_colon := layer;
    }.
    
    Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
      tower_layer.Layer.Service := Service;
      tower_layer.Layer.layer := layer;
    }.
  End Impl_tower_layer_Layer_S_for_axum_extra_either_Either_t_E1_E2.
  End Impl_tower_layer_Layer_S_for_axum_extra_either_Either_t_E1_E2.
  
  Module  Impl_tower_service_Service_R_for_axum_extra_either_Either_t_E1_E2.
  Section Impl_tower_service_Service_R_for_axum_extra_either_Either_t_E1_E2.
    Context {R E1 E2 : Set}.
    
    Context
      {ℋ_0 : tower_service.Service.Trait E1 (Request := R)}
      {ℋ_1 : tower_service.Service.Trait E2 (Request := R)}.
    
    Definition Self : Set := axum_extra.either.Either.t E1 E2.
    
    (*
        type Response = E1::Response;
    *)
    Definition Response : Set := E1::type["Response"].t.
    
    (*
        type Error = E1::Error;
    *)
    Definition Error : Set := E1::type["Error"].t.
    
    (*
        type Future = futures_util::future::Either<E1::Future, E2::Future>;
    *)
    Definition Future : Set :=
      futures_util.future.either.Either.t
          E1::type["Future"].t
          E2::type["Future"].t.
    
    (*
        fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            match self {
                Either::E1(inner) => inner.poll_ready(cx),
                Either::E2(inner) => inner.poll_ready(cx),
            }
        }
    *)
    Definition poll_ready
        (self : mut_ref Self)
        (cx : mut_ref core.task.wake.Context.t)
        : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
      let* self := M.alloc self in
      let* cx := M.alloc cx in
      M.read foo.
    
    Global Instance AssociatedFunction_poll_ready :
      Notations.DoubleColon Self "poll_ready" := {
      Notations.double_colon := poll_ready;
    }.
    
    (*
        fn call(&mut self, req: R) -> Self::Future {
            match self {
                Either::E1(inner) => futures_util::future::Either::Left(inner.call(req)),
                Either::E2(inner) => futures_util::future::Either::Right(inner.call(req)),
            }
        }
    *)
    Definition call (self : mut_ref Self) (req : R) : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ : tower_service.Service.Trait Self (Request := R) := {
      tower_service.Service.Response := Response;
      tower_service.Service.Error := Error;
      tower_service.Service.Future := Future;
      tower_service.Service.poll_ready := poll_ready;
      tower_service.Service.call := call;
    }.
  End Impl_tower_service_Service_R_for_axum_extra_either_Either_t_E1_E2.
  End Impl_tower_service_Service_R_for_axum_extra_either_Either_t_E1_E2.
End either.

Module Either.
  Inductive t (E1 : Set) (E2 : Set) : Set :=
  | E1 (_ : E1)
  | E2 (_ : E2).
  
  Definition Get_E1_0 :=
    Ref.map
      (fun α => match α with | E1 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
  
  Definition Get_E2_0 :=
    Ref.map
      (fun α => match α with | E2 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
End Either.

Module  Impl_core_fmt_Debug_for_axum_extra_either_Either_t_E1_E2.
Section Impl_core_fmt_Debug_for_axum_extra_either_Either_t_E1_E2.
  Context {E1 E2 : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait E1} {ℋ_1 : core.fmt.Debug.Trait E2}.
  
  Definition Self : Set := axum_extra.either.Either.t E1 E2.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_either_Either_t_E1_E2.
End Impl_core_fmt_Debug_for_axum_extra_either_Either_t_E1_E2.

Module  Impl_core_clone_Clone_for_axum_extra_either_Either_t_E1_E2.
Section Impl_core_clone_Clone_for_axum_extra_either_Either_t_E1_E2.
  Context {E1 E2 : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait E1} {ℋ_1 : core.clone.Clone.Trait E2}.
  
  Definition Self : Set := axum_extra.either.Either.t E1 E2.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M (axum_extra.either.Either.t E1 E2) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_either_Either_t_E1_E2.
End Impl_core_clone_Clone_for_axum_extra_either_Either_t_E1_E2.

Module Either3.
  Inductive t (E1 : Set) (E2 : Set) (E3 : Set) : Set :=
  | E1 (_ : E1)
  | E2 (_ : E2)
  | E3 (_ : E3).
  
  Definition Get_E1_0 :=
    Ref.map
      (fun α => match α with | E1 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
  
  Definition Get_E2_0 :=
    Ref.map
      (fun α => match α with | E2 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
  
  Definition Get_E3_0 :=
    Ref.map
      (fun α => match α with | E3 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
End Either3.

Module  Impl_core_fmt_Debug_for_axum_extra_either_Either3_t_E1_E2_E3.
Section Impl_core_fmt_Debug_for_axum_extra_either_Either3_t_E1_E2_E3.
  Context {E1 E2 E3 : Set}.
  
  Context
    {ℋ_0 : core.fmt.Debug.Trait E1}
    {ℋ_1 : core.fmt.Debug.Trait E2}
    {ℋ_2 : core.fmt.Debug.Trait E3}.
  
  Definition Self : Set := axum_extra.either.Either3.t E1 E2 E3.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_either_Either3_t_E1_E2_E3.
End Impl_core_fmt_Debug_for_axum_extra_either_Either3_t_E1_E2_E3.

Module  Impl_core_clone_Clone_for_axum_extra_either_Either3_t_E1_E2_E3.
Section Impl_core_clone_Clone_for_axum_extra_either_Either3_t_E1_E2_E3.
  Context {E1 E2 E3 : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait E1}
    {ℋ_1 : core.clone.Clone.Trait E2}
    {ℋ_2 : core.clone.Clone.Trait E3}.
  
  Definition Self : Set := axum_extra.either.Either3.t E1 E2 E3.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum_extra.either.Either3.t E1 E2 E3) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_either_Either3_t_E1_E2_E3.
End Impl_core_clone_Clone_for_axum_extra_either_Either3_t_E1_E2_E3.

Module Either4.
  Inductive t (E1 : Set) (E2 : Set) (E3 : Set) (E4 : Set) : Set :=
  | E1 (_ : E1)
  | E2 (_ : E2)
  | E3 (_ : E3)
  | E4 (_ : E4).
  
  Definition Get_E1_0 :=
    Ref.map
      (fun α => match α with | E1 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
  
  Definition Get_E2_0 :=
    Ref.map
      (fun α => match α with | E2 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
  
  Definition Get_E3_0 :=
    Ref.map
      (fun α => match α with | E3 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
  
  Definition Get_E4_0 :=
    Ref.map
      (fun α => match α with | E4 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E4 _ => Some (E4 β) | _ => None end).
End Either4.

Module  Impl_core_fmt_Debug_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
Section Impl_core_fmt_Debug_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  Context {E1 E2 E3 E4 : Set}.
  
  Context
    {ℋ_0 : core.fmt.Debug.Trait E1}
    {ℋ_1 : core.fmt.Debug.Trait E2}
    {ℋ_2 : core.fmt.Debug.Trait E3}
    {ℋ_3 : core.fmt.Debug.Trait E4}.
  
  Definition Self : Set := axum_extra.either.Either4.t E1 E2 E3 E4.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
End Impl_core_fmt_Debug_for_axum_extra_either_Either4_t_E1_E2_E3_E4.

Module  Impl_core_clone_Clone_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
Section Impl_core_clone_Clone_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  Context {E1 E2 E3 E4 : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait E1}
    {ℋ_1 : core.clone.Clone.Trait E2}
    {ℋ_2 : core.clone.Clone.Trait E3}
    {ℋ_3 : core.clone.Clone.Trait E4}.
  
  Definition Self : Set := axum_extra.either.Either4.t E1 E2 E3 E4.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum_extra.either.Either4.t E1 E2 E3 E4) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
End Impl_core_clone_Clone_for_axum_extra_either_Either4_t_E1_E2_E3_E4.

Module Either5.
  Inductive t (E1 : Set) (E2 : Set) (E3 : Set) (E4 : Set) (E5 : Set) : Set :=
  | E1 (_ : E1)
  | E2 (_ : E2)
  | E3 (_ : E3)
  | E4 (_ : E4)
  | E5 (_ : E5).
  
  Definition Get_E1_0 :=
    Ref.map
      (fun α => match α with | E1 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
  
  Definition Get_E2_0 :=
    Ref.map
      (fun α => match α with | E2 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
  
  Definition Get_E3_0 :=
    Ref.map
      (fun α => match α with | E3 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
  
  Definition Get_E4_0 :=
    Ref.map
      (fun α => match α with | E4 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E4 _ => Some (E4 β) | _ => None end).
  
  Definition Get_E5_0 :=
    Ref.map
      (fun α => match α with | E5 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E5 _ => Some (E5 β) | _ => None end).
End Either5.

Module  Impl_core_fmt_Debug_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
Section Impl_core_fmt_Debug_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  Context {E1 E2 E3 E4 E5 : Set}.
  
  Context
    {ℋ_0 : core.fmt.Debug.Trait E1}
    {ℋ_1 : core.fmt.Debug.Trait E2}
    {ℋ_2 : core.fmt.Debug.Trait E3}
    {ℋ_3 : core.fmt.Debug.Trait E4}
    {ℋ_4 : core.fmt.Debug.Trait E5}.
  
  Definition Self : Set := axum_extra.either.Either5.t E1 E2 E3 E4 E5.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
End Impl_core_fmt_Debug_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.

Module  Impl_core_clone_Clone_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
Section Impl_core_clone_Clone_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  Context {E1 E2 E3 E4 E5 : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait E1}
    {ℋ_1 : core.clone.Clone.Trait E2}
    {ℋ_2 : core.clone.Clone.Trait E3}
    {ℋ_3 : core.clone.Clone.Trait E4}
    {ℋ_4 : core.clone.Clone.Trait E5}.
  
  Definition Self : Set := axum_extra.either.Either5.t E1 E2 E3 E4 E5.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum_extra.either.Either5.t E1 E2 E3 E4 E5) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
End Impl_core_clone_Clone_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.

Module Either6.
  Inductive
    t
    (E1 : Set)
    (E2 : Set)
    (E3 : Set)
    (E4 : Set)
    (E5 : Set)
    (E6 : Set) :
    Set :=
  | E1 (_ : E1)
  | E2 (_ : E2)
  | E3 (_ : E3)
  | E4 (_ : E4)
  | E5 (_ : E5)
  | E6 (_ : E6).
  
  Definition Get_E1_0 :=
    Ref.map
      (fun α => match α with | E1 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
  
  Definition Get_E2_0 :=
    Ref.map
      (fun α => match α with | E2 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
  
  Definition Get_E3_0 :=
    Ref.map
      (fun α => match α with | E3 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
  
  Definition Get_E4_0 :=
    Ref.map
      (fun α => match α with | E4 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E4 _ => Some (E4 β) | _ => None end).
  
  Definition Get_E5_0 :=
    Ref.map
      (fun α => match α with | E5 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E5 _ => Some (E5 β) | _ => None end).
  
  Definition Get_E6_0 :=
    Ref.map
      (fun α => match α with | E6 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E6 _ => Some (E6 β) | _ => None end).
End Either6.

Module  Impl_core_fmt_Debug_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
Section Impl_core_fmt_Debug_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  Context {E1 E2 E3 E4 E5 E6 : Set}.
  
  Context
    {ℋ_0 : core.fmt.Debug.Trait E1}
    {ℋ_1 : core.fmt.Debug.Trait E2}
    {ℋ_2 : core.fmt.Debug.Trait E3}
    {ℋ_3 : core.fmt.Debug.Trait E4}
    {ℋ_4 : core.fmt.Debug.Trait E5}
    {ℋ_5 : core.fmt.Debug.Trait E6}.
  
  Definition Self : Set := axum_extra.either.Either6.t E1 E2 E3 E4 E5 E6.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
End Impl_core_fmt_Debug_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.

Module  Impl_core_clone_Clone_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
Section Impl_core_clone_Clone_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  Context {E1 E2 E3 E4 E5 E6 : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait E1}
    {ℋ_1 : core.clone.Clone.Trait E2}
    {ℋ_2 : core.clone.Clone.Trait E3}
    {ℋ_3 : core.clone.Clone.Trait E4}
    {ℋ_4 : core.clone.Clone.Trait E5}
    {ℋ_5 : core.clone.Clone.Trait E6}.
  
  Definition Self : Set := axum_extra.either.Either6.t E1 E2 E3 E4 E5 E6.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum_extra.either.Either6.t E1 E2 E3 E4 E5 E6) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
End Impl_core_clone_Clone_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.

Module Either7.
  Inductive
    t
    (E1 : Set)
    (E2 : Set)
    (E3 : Set)
    (E4 : Set)
    (E5 : Set)
    (E6 : Set)
    (E7 : Set) :
    Set :=
  | E1 (_ : E1)
  | E2 (_ : E2)
  | E3 (_ : E3)
  | E4 (_ : E4)
  | E5 (_ : E5)
  | E6 (_ : E6)
  | E7 (_ : E7).
  
  Definition Get_E1_0 :=
    Ref.map
      (fun α => match α with | E1 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
  
  Definition Get_E2_0 :=
    Ref.map
      (fun α => match α with | E2 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
  
  Definition Get_E3_0 :=
    Ref.map
      (fun α => match α with | E3 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
  
  Definition Get_E4_0 :=
    Ref.map
      (fun α => match α with | E4 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E4 _ => Some (E4 β) | _ => None end).
  
  Definition Get_E5_0 :=
    Ref.map
      (fun α => match α with | E5 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E5 _ => Some (E5 β) | _ => None end).
  
  Definition Get_E6_0 :=
    Ref.map
      (fun α => match α with | E6 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E6 _ => Some (E6 β) | _ => None end).
  
  Definition Get_E7_0 :=
    Ref.map
      (fun α => match α with | E7 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E7 _ => Some (E7 β) | _ => None end).
End Either7.

Module  Impl_core_fmt_Debug_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
Section Impl_core_fmt_Debug_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  Context {E1 E2 E3 E4 E5 E6 E7 : Set}.
  
  Context
    {ℋ_0 : core.fmt.Debug.Trait E1}
    {ℋ_1 : core.fmt.Debug.Trait E2}
    {ℋ_2 : core.fmt.Debug.Trait E3}
    {ℋ_3 : core.fmt.Debug.Trait E4}
    {ℋ_4 : core.fmt.Debug.Trait E5}
    {ℋ_5 : core.fmt.Debug.Trait E6}
    {ℋ_6 : core.fmt.Debug.Trait E7}.
  
  Definition Self : Set := axum_extra.either.Either7.t E1 E2 E3 E4 E5 E6 E7.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
End Impl_core_fmt_Debug_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.

Module  Impl_core_clone_Clone_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
Section Impl_core_clone_Clone_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  Context {E1 E2 E3 E4 E5 E6 E7 : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait E1}
    {ℋ_1 : core.clone.Clone.Trait E2}
    {ℋ_2 : core.clone.Clone.Trait E3}
    {ℋ_3 : core.clone.Clone.Trait E4}
    {ℋ_4 : core.clone.Clone.Trait E5}
    {ℋ_5 : core.clone.Clone.Trait E6}
    {ℋ_6 : core.clone.Clone.Trait E7}.
  
  Definition Self : Set := axum_extra.either.Either7.t E1 E2 E3 E4 E5 E6 E7.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum_extra.either.Either7.t E1 E2 E3 E4 E5 E6 E7) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
End Impl_core_clone_Clone_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.

Module Either8.
  Inductive
    t
    (E1 : Set)
    (E2 : Set)
    (E3 : Set)
    (E4 : Set)
    (E5 : Set)
    (E6 : Set)
    (E7 : Set)
    (E8 : Set) :
    Set :=
  | E1 (_ : E1)
  | E2 (_ : E2)
  | E3 (_ : E3)
  | E4 (_ : E4)
  | E5 (_ : E5)
  | E6 (_ : E6)
  | E7 (_ : E7)
  | E8 (_ : E8).
  
  Definition Get_E1_0 :=
    Ref.map
      (fun α => match α with | E1 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E1 _ => Some (E1 β) | _ => None end).
  
  Definition Get_E2_0 :=
    Ref.map
      (fun α => match α with | E2 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E2 _ => Some (E2 β) | _ => None end).
  
  Definition Get_E3_0 :=
    Ref.map
      (fun α => match α with | E3 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E3 _ => Some (E3 β) | _ => None end).
  
  Definition Get_E4_0 :=
    Ref.map
      (fun α => match α with | E4 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E4 _ => Some (E4 β) | _ => None end).
  
  Definition Get_E5_0 :=
    Ref.map
      (fun α => match α with | E5 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E5 _ => Some (E5 β) | _ => None end).
  
  Definition Get_E6_0 :=
    Ref.map
      (fun α => match α with | E6 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E6 _ => Some (E6 β) | _ => None end).
  
  Definition Get_E7_0 :=
    Ref.map
      (fun α => match α with | E7 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E7 _ => Some (E7 β) | _ => None end).
  
  Definition Get_E8_0 :=
    Ref.map
      (fun α => match α with | E8 α0 => Some α0 | _ => None end)
      (fun β α => match α with | E8 _ => Some (E8 β) | _ => None end).
End Either8.

Module  Impl_core_fmt_Debug_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
Section Impl_core_fmt_Debug_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  Context {E1 E2 E3 E4 E5 E6 E7 E8 : Set}.
  
  Context
    {ℋ_0 : core.fmt.Debug.Trait E1}
    {ℋ_1 : core.fmt.Debug.Trait E2}
    {ℋ_2 : core.fmt.Debug.Trait E3}
    {ℋ_3 : core.fmt.Debug.Trait E4}
    {ℋ_4 : core.fmt.Debug.Trait E5}
    {ℋ_5 : core.fmt.Debug.Trait E6}
    {ℋ_6 : core.fmt.Debug.Trait E7}
    {ℋ_7 : core.fmt.Debug.Trait E8}.
  
  Definition Self : Set := axum_extra.either.Either8.t E1 E2 E3 E4 E5 E6 E7 E8.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
End Impl_core_fmt_Debug_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.

Module  Impl_core_clone_Clone_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
Section Impl_core_clone_Clone_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  Context {E1 E2 E3 E4 E5 E6 E7 E8 : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait E1}
    {ℋ_1 : core.clone.Clone.Trait E2}
    {ℋ_2 : core.clone.Clone.Trait E3}
    {ℋ_3 : core.clone.Clone.Trait E4}
    {ℋ_4 : core.clone.Clone.Trait E5}
    {ℋ_5 : core.clone.Clone.Trait E6}
    {ℋ_6 : core.clone.Clone.Trait E7}
    {ℋ_7 : core.clone.Clone.Trait E8}.
  
  Definition Self : Set := axum_extra.either.Either8.t E1 E2 E3 E4 E5 E6 E7 E8.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum_extra.either.Either8.t E1 E2 E3 E4 E5 E6 E7 E8) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
End Impl_core_clone_Clone_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either_t_E1_E2.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either_t_E1_E2.
  Context {S E1 E2 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
    {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum_extra.either.Either.t E1 E2.
  
  (*
              type Rejection = $last::Rejection;
  *)
  Definition Rejection : Set := E2::type["Rejection"].t.
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                          return Ok(Self::$ident(value));
                      }
                  )*
  
                  FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either_t_E1_E2.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either_t_E1_E2.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either_t_E1_E2.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either_t_E1_E2.
  Context {E1 E2 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}.
  
  Definition Self : Set := axum_extra.either.Either.t E1 E2.
  
  (*
              fn into_response(self) -> Response {
                  match self {
                      $( Self::$ident(value) => value.into_response(), )*
                      Self::$last(value) => value.into_response(),
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either_t_E1_E2.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either_t_E1_E2.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either3_t_E1_E2_E3.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either3_t_E1_E2_E3.
  Context {S E1 E2 E3 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
    {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
    {ℋ_3 : core.marker.Send.Trait S}
    {ℋ_4 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum_extra.either.Either3.t E1 E2 E3.
  
  (*
              type Rejection = $last::Rejection;
  *)
  Definition Rejection : Set := E3::type["Rejection"].t.
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                          return Ok(Self::$ident(value));
                      }
                  )*
  
                  FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either3_t_E1_E2_E3.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either3_t_E1_E2_E3.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either3_t_E1_E2_E3.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either3_t_E1_E2_E3.
  Context {E1 E2 E3 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
    {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}.
  
  Definition Self : Set := axum_extra.either.Either3.t E1 E2 E3.
  
  (*
              fn into_response(self) -> Response {
                  match self {
                      $( Self::$ident(value) => value.into_response(), )*
                      Self::$last(value) => value.into_response(),
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either3_t_E1_E2_E3.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either3_t_E1_E2_E3.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  Context {S E1 E2 E3 E4 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
    {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait E4 (S := S)}
    {ℋ_4 : core.marker.Send.Trait S}
    {ℋ_5 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum_extra.either.Either4.t E1 E2 E3 E4.
  
  (*
              type Rejection = $last::Rejection;
  *)
  Definition Rejection : Set := E4::type["Rejection"].t.
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                          return Ok(Self::$ident(value));
                      }
                  )*
  
                  FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either4_t_E1_E2_E3_E4.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
  Context {E1 E2 E3 E4 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
    {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}
    {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait E4}.
  
  Definition Self : Set := axum_extra.either.Either4.t E1 E2 E3 E4.
  
  (*
              fn into_response(self) -> Response {
                  match self {
                      $( Self::$ident(value) => value.into_response(), )*
                      Self::$last(value) => value.into_response(),
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either4_t_E1_E2_E3_E4.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either4_t_E1_E2_E3_E4.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  Context {S E1 E2 E3 E4 E5 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
    {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait E4 (S := S)}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait E5 (S := S)}
    {ℋ_5 : core.marker.Send.Trait S}
    {ℋ_6 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum_extra.either.Either5.t E1 E2 E3 E4 E5.
  
  (*
              type Rejection = $last::Rejection;
  *)
  Definition Rejection : Set := E5::type["Rejection"].t.
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                          return Ok(Self::$ident(value));
                      }
                  )*
  
                  FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
  Context {E1 E2 E3 E4 E5 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
    {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}
    {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait E4}
    {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait E5}.
  
  Definition Self : Set := axum_extra.either.Either5.t E1 E2 E3 E4 E5.
  
  (*
              fn into_response(self) -> Response {
                  match self {
                      $( Self::$ident(value) => value.into_response(), )*
                      Self::$last(value) => value.into_response(),
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either5_t_E1_E2_E3_E4_E5.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  Context {S E1 E2 E3 E4 E5 E6 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
    {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait E4 (S := S)}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait E5 (S := S)}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait E6 (S := S)}
    {ℋ_6 : core.marker.Send.Trait S}
    {ℋ_7 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum_extra.either.Either6.t E1 E2 E3 E4 E5 E6.
  
  (*
              type Rejection = $last::Rejection;
  *)
  Definition Rejection : Set := E6::type["Rejection"].t.
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                          return Ok(Self::$ident(value));
                      }
                  )*
  
                  FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
  Context {E1 E2 E3 E4 E5 E6 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
    {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}
    {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait E4}
    {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait E5}
    {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait E6}.
  
  Definition Self : Set := axum_extra.either.Either6.t E1 E2 E3 E4 E5 E6.
  
  (*
              fn into_response(self) -> Response {
                  match self {
                      $( Self::$ident(value) => value.into_response(), )*
                      Self::$last(value) => value.into_response(),
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either6_t_E1_E2_E3_E4_E5_E6.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  Context {S E1 E2 E3 E4 E5 E6 E7 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
    {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait E4 (S := S)}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait E5 (S := S)}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait E6 (S := S)}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait E7 (S := S)}
    {ℋ_7 : core.marker.Send.Trait S}
    {ℋ_8 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum_extra.either.Either7.t E1 E2 E3 E4 E5 E6 E7.
  
  (*
              type Rejection = $last::Rejection;
  *)
  Definition Rejection : Set := E7::type["Rejection"].t.
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                          return Ok(Self::$ident(value));
                      }
                  )*
  
                  FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
  Context {E1 E2 E3 E4 E5 E6 E7 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
    {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}
    {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait E4}
    {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait E5}
    {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait E6}
    {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait E7}.
  
  Definition Self : Set := axum_extra.either.Either7.t E1 E2 E3 E4 E5 E6 E7.
  
  (*
              fn into_response(self) -> Response {
                  match self {
                      $( Self::$ident(value) => value.into_response(), )*
                      Self::$last(value) => value.into_response(),
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either7_t_E1_E2_E3_E4_E5_E6_E7.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  Context {S E1 E2 E3 E4 E5 E6 E7 E8 : Set}.
  
  Context
    {ℋ_0 : axum_core.extract.FromRequestParts.Trait E1 (S := S)}
    {ℋ_1 : axum_core.extract.FromRequestParts.Trait E2 (S := S)}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait E3 (S := S)}
    {ℋ_3 : axum_core.extract.FromRequestParts.Trait E4 (S := S)}
    {ℋ_4 : axum_core.extract.FromRequestParts.Trait E5 (S := S)}
    {ℋ_5 : axum_core.extract.FromRequestParts.Trait E6 (S := S)}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait E7 (S := S)}
    {ℋ_7 : axum_core.extract.FromRequestParts.Trait E8 (S := S)}
    {ℋ_8 : core.marker.Send.Trait S}
    {ℋ_9 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum_extra.either.Either8.t E1 E2 E3 E4 E5 E6 E7 E8.
  
  (*
              type Rejection = $last::Rejection;
  *)
  Definition Rejection : Set := E8::type["Rejection"].t.
  
  (*
              async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
                  $(
                      if let Ok(value) = FromRequestParts::from_request_parts(parts, state).await {
                          return Ok(Self::$ident(value));
                      }
                  )*
  
                  FromRequestParts::from_request_parts(parts, state).await.map(Self::$last)
              }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
  Context {E1 E2 E3 E4 E5 E6 E7 E8 : Set}.
  
  Context
    {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait E1}
    {ℋ_1 : axum_core.response.into_response.IntoResponse.Trait E2}
    {ℋ_2 : axum_core.response.into_response.IntoResponse.Trait E3}
    {ℋ_3 : axum_core.response.into_response.IntoResponse.Trait E4}
    {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait E5}
    {ℋ_5 : axum_core.response.into_response.IntoResponse.Trait E6}
    {ℋ_6 : axum_core.response.into_response.IntoResponse.Trait E7}
    {ℋ_7 : axum_core.response.into_response.IntoResponse.Trait E8}.
  
  Definition Self : Set := axum_extra.either.Either8.t E1 E2 E3 E4 E5 E6 E7 E8.
  
  (*
              fn into_response(self) -> Response {
                  match self {
                      $( Self::$ident(value) => value.into_response(), )*
                      Self::$last(value) => value.into_response(),
                  }
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_either_Either8_t_E1_E2_E3_E4_E5_E6_E7_E8.

Module  Impl_tower_layer_Layer_S_for_axum_extra_either_Either_t_E1_E2.
Section Impl_tower_layer_Layer_S_for_axum_extra_either_Either_t_E1_E2.
  Context {E1 E2 S : Set}.
  
  Context
    {ℋ_0 : tower_layer.Layer.Trait E1 (S := S)}
    {ℋ_1 : tower_layer.Layer.Trait E2 (S := S)}.
  
  Definition Self : Set := axum_extra.either.Either.t E1 E2.
  
  (*
      type Service = Either<E1::Service, E2::Service>;
  *)
  Definition Service : Set :=
    axum_extra.either.Either.t E1::type["Service"].t E2::type["Service"].t.
  
  (*
      fn layer(&self, inner: S) -> Self::Service {
          match self {
              Either::E1(layer) => Either::E1(layer.layer(inner)),
              Either::E2(layer) => Either::E2(layer.layer(inner)),
          }
      }
  *)
  Definition layer (self : ref Self) (inner : S) : M Service :=
    let* self := M.alloc self in
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_layer :
    Notations.DoubleColon Self "layer" := {
    Notations.double_colon := layer;
  }.
  
  Global Instance ℐ : tower_layer.Layer.Trait Self (S := S) := {
    tower_layer.Layer.Service := Service;
    tower_layer.Layer.layer := layer;
  }.
End Impl_tower_layer_Layer_S_for_axum_extra_either_Either_t_E1_E2.
End Impl_tower_layer_Layer_S_for_axum_extra_either_Either_t_E1_E2.

Module  Impl_tower_service_Service_R_for_axum_extra_either_Either_t_E1_E2.
Section Impl_tower_service_Service_R_for_axum_extra_either_Either_t_E1_E2.
  Context {R E1 E2 : Set}.
  
  Context
    {ℋ_0 : tower_service.Service.Trait E1 (Request := R)}
    {ℋ_1 : tower_service.Service.Trait E2 (Request := R)}.
  
  Definition Self : Set := axum_extra.either.Either.t E1 E2.
  
  (*
      type Response = E1::Response;
  *)
  Definition Response : Set := E1::type["Response"].t.
  
  (*
      type Error = E1::Error;
  *)
  Definition Error : Set := E1::type["Error"].t.
  
  (*
      type Future = futures_util::future::Either<E1::Future, E2::Future>;
  *)
  Definition Future : Set :=
    futures_util.future.either.Either.t
        E1::type["Future"].t
        E2::type["Future"].t.
  
  (*
      fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
          match self {
              Either::E1(inner) => inner.poll_ready(cx),
              Either::E2(inner) => inner.poll_ready(cx),
          }
      }
  *)
  Definition poll_ready
      (self : mut_ref Self)
      (cx : mut_ref core.task.wake.Context.t)
      : M (core.task.poll.Poll.t (core.result.Result.t unit Error)) :=
    let* self := M.alloc self in
    let* cx := M.alloc cx in
    M.read foo.
  
  Global Instance AssociatedFunction_poll_ready :
    Notations.DoubleColon Self "poll_ready" := {
    Notations.double_colon := poll_ready;
  }.
  
  (*
      fn call(&mut self, req: R) -> Self::Future {
          match self {
              Either::E1(inner) => futures_util::future::Either::Left(inner.call(req)),
              Either::E2(inner) => futures_util::future::Either::Right(inner.call(req)),
          }
      }
  *)
  Definition call (self : mut_ref Self) (req : R) : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ : tower_service.Service.Trait Self (Request := R) := {
    tower_service.Service.Response := Response;
    tower_service.Service.Error := Error;
    tower_service.Service.Future := Future;
    tower_service.Service.poll_ready := poll_ready;
    tower_service.Service.call := call;
  }.
End Impl_tower_service_Service_R_for_axum_extra_either_Either_t_E1_E2.
End Impl_tower_service_Service_R_for_axum_extra_either_Either_t_E1_E2.

Module extract.
  Module cached.
    Module  Cached.
    Section Cached.
      Context {T : Set}.
      
      Record t : Set := {
        x0 : T;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End Cached.
    End Cached.
    
    Module  Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.
    Section Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait T}.
      
      Definition Self : Set := axum_extra.extract.cached.Cached.t T.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.
    End Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.
    
    Module  Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.
    Section Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait T}.
      
      Definition Self : Set := axum_extra.extract.cached.Cached.t T.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M (axum_extra.extract.cached.Cached.t T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.
    End Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.
    
    Module  Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.
    Section Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.default.Default.Trait T}.
      
      Definition Self : Set := axum_extra.extract.cached.Cached.t T.
      
      (*
      Default
      *)
      Definition default : M (axum_extra.extract.cached.Cached.t T) :=
        M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.
    End Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.
    
    Module  CachedEntry.
    Section CachedEntry.
      Context {T : Set}.
      
      Record t : Set := {
        x0 : T;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End CachedEntry.
    End CachedEntry.
    
    Module  Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.
    Section Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait T}.
      
      Definition Self : Set := axum_extra.extract.cached.CachedEntry.t T.
      
      (*
      Clone
      *)
      Definition clone
          (self : ref Self)
          : M (axum_extra.extract.cached.CachedEntry.t T) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.
    End Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.
      Context {S T : Set}.
      
      Context
        {ℋ_0 : core.marker.Send.Trait S}
        {ℋ_1 : core.marker.Sync.Trait S}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait T (S := S)}
        {ℋ_3 : core.clone.Clone.Trait T}
        {ℋ_4 : core.marker.Send.Trait T}
        {ℋ_5 : core.marker.Sync.Trait T}.
      
      Definition Self : Set := axum_extra.extract.cached.Cached.t T.
      
      (*
          type Rejection = T::Rejection;
      *)
      Definition Rejection : Set := T::type["Rejection"].t.
      
      (*
          async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
              match Extension::<CachedEntry<T>>::from_request_parts(parts, state).await {
                  Ok(Extension(CachedEntry(value))) => Ok(Self(value)),
                  Err(_) => {
                      let value = T::from_request_parts(parts, state).await?;
                      parts.extensions.insert(CachedEntry(value.clone()));
                      Ok(Self(value))
                  }
              }
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.
    
    Module  Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.
    Section Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.
      Context {T : Set}.
      
      Definition Self : Set := axum_extra.extract.cached.Cached.t T.
      
      (*
                  type Target = T;
      *)
      Definition Target : Set := T.
      
      (*
                  fn deref(&self) -> &Self::Target {
                      &self.0
                  }
      *)
      Definition deref (self : ref Self) : M (ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref :
        Notations.DoubleColon Self "deref" := {
        Notations.double_colon := deref;
      }.
      
      Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
        core.ops.deref.Deref.Target := Target;
        core.ops.deref.Deref.deref := deref;
      }.
    End Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.
    End Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.
    
    Module  Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.
    Section Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.
      Context {T : Set}.
      
      Definition Self : Set := axum_extra.extract.cached.Cached.t T.
      
      (*
                  fn deref_mut(&mut self) -> &mut Self::Target {
                      &mut self.0
                  }
      *)
      Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref_mut :
        Notations.DoubleColon Self "deref_mut" := {
        Notations.double_colon := deref_mut;
      }.
      
      Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
        core.ops.deref.DerefMut.deref_mut := deref_mut;
      }.
    End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.
    End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.
  End cached.
  
  Module optional_path.
    Module  OptionalPath.
    Section OptionalPath.
      Context {T : Set}.
      
      Record t : Set := {
        x0 : core.option.Option.t T;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End OptionalPath.
    End OptionalPath.
    
    Module  Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.
    Section Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.
      Context {T : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait T}.
      
      Definition Self : Set :=
        axum_extra.extract.optional_path.OptionalPath.t T.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.
    End Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.
      Context {T S : Set}.
      
      Context
        {ℋ_0 : serde.de.DeserializeOwned.Trait T}
        {ℋ_1 : core.marker.Send.Trait T}
        {ℋ_2 : core.marker.Send.Trait S}
        {ℋ_3 : core.marker.Sync.Trait S}.
      
      Definition Self : Set :=
        axum_extra.extract.optional_path.OptionalPath.t T.
      
      (*
          type Rejection = PathRejection;
      *)
      Definition Rejection : Set := axum.extract.rejection.PathRejection.t.
      
      (*
          async fn from_request_parts(
              parts: &mut http::request::Parts,
              _: &S,
          ) -> Result<Self, Self::Rejection> {
              match parts.extract::<Path<T>>().await {
                  Ok(Path(params)) => Ok(Self(Some(params))),
                  Err(PathRejection::FailedToDeserializePathParams(e))
                      if matches!(e.kind(), ErrorKind::WrongNumberOfParameters { got: 0, .. }) =>
                  {
                      Ok(Self(None))
                  }
                  Err(e) => Err(e),
              }
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (Pattern : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* Pattern := M.alloc Pattern in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.
  End optional_path.
  
  Module with_rejection.
    Module  WithRejection.
    Section WithRejection.
      Context {E R : Set}.
      
      Record t : Set := {
        x0 : E;
        x1 : core.marker.PhantomData.t R;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
      Definition Get_1 :=
        Ref.map (fun α => Some α.(x1)) (fun β α => Some (α <| x1 := β |>)).
    End WithRejection.
    End WithRejection.
    
    Module  Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Section Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R.
      Context {E R : Set}.
      
      Definition Self : Set :=
        axum_extra.extract.with_rejection.WithRejection.t E R.
      
      (*
          pub fn into_inner(self) -> E {
              self.0
          }
      *)
      Definition into_inner (self : Self) : M E :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_into_inner :
        Notations.DoubleColon Self "into_inner" := {
        Notations.double_colon := into_inner;
      }.
    End Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    End Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    
    Module  Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Section Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
      Context {E R : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait E}.
      
      Definition Self : Set :=
        axum_extra.extract.with_rejection.WithRejection.t E R.
      
      (*
          fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
              f.debug_tuple("WithRejection")
                  .field(&self.0)
                  .field(&self.1)
                  .finish()
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    End Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    
    Module  Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Section Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
      Context {E R : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait E}.
      
      Definition Self : Set :=
        axum_extra.extract.with_rejection.WithRejection.t E R.
      
      (*
          fn clone(&self) -> Self {
              Self(self.0.clone(), self.1)
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    End Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    
    Module  Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Section Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
      Context {E R : Set}.
      
      Context {ℋ_0 : core.marker.Copy.Trait E}.
      
      Definition Self : Set :=
        axum_extra.extract.with_rejection.WithRejection.t E R.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    End Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    
    Module  Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Section Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
      Context {E R : Set}.
      
      Context {ℋ_0 : core.default.Default.Trait E}.
      
      Definition Self : Set :=
        axum_extra.extract.with_rejection.WithRejection.t E R.
      
      (*
          fn default() -> Self {
              Self(Default::default(), Default::default())
          }
      *)
      Definition default : M Self := M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    End Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    
    Module  Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Section Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
      Context {E R : Set}.
      
      Definition Self : Set :=
        axum_extra.extract.with_rejection.WithRejection.t E R.
      
      (*
          type Target = E;
      *)
      Definition Target : Set := E.
      
      (*
          fn deref(&self) -> &Self::Target {
              &self.0
          }
      *)
      Definition deref (self : ref Self) : M (ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref :
        Notations.DoubleColon Self "deref" := {
        Notations.double_colon := deref;
      }.
      
      Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
        core.ops.deref.Deref.Target := Target;
        core.ops.deref.Deref.deref := deref;
      }.
    End Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    End Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    
    Module  Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Section Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
      Context {E R : Set}.
      
      Definition Self : Set :=
        axum_extra.extract.with_rejection.WithRejection.t E R.
      
      (*
          fn deref_mut(&mut self) -> &mut Self::Target {
              &mut self.0
          }
      *)
      Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_deref_mut :
        Notations.DoubleColon Self "deref_mut" := {
        Notations.double_colon := deref_mut;
      }.
      
      Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
        core.ops.deref.DerefMut.deref_mut := deref_mut;
      }.
    End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    
    Module  Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Section Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
      Context {E R S : Set}.
      
      Context
        {ℋ_0 : core.marker.Send.Trait S}
        {ℋ_1 : core.marker.Sync.Trait S}
        {ℋ_2 :
          axum_core.extract.FromRequest.Trait E
            (S := S)
            (M := axum_core.extract.FromRequest.Default.M E)}
        {ℋ_3 : core.convert.From.Trait R (T := E::type["Rejection"].t)}
        {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        axum_extra.extract.with_rejection.WithRejection.t E R.
      
      (*
          type Rejection = R;
      *)
      Definition Rejection : Set := R.
      
      (*
          async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
              let extractor = E::from_request(req, state).await?;
              Ok(WithRejection(extractor, PhantomData))
          }
      *)
      Definition from_request
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request :
        Notations.DoubleColon Self "from_request" := {
        Notations.double_colon := from_request;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequest.Trait Self
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M Self) := {
        axum_core.extract.FromRequest.Rejection := Rejection;
        axum_core.extract.FromRequest.from_request := from_request;
      }.
    End Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    End Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    
    Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
      Context {E R S : Set}.
      
      Context
        {ℋ_0 : core.marker.Send.Trait S}
        {ℋ_1 : core.marker.Sync.Trait S}
        {ℋ_2 : axum_core.extract.FromRequestParts.Trait E (S := S)}
        {ℋ_3 : core.convert.From.Trait R (T := E::type["Rejection"].t)}
        {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
      
      Definition Self : Set :=
        axum_extra.extract.with_rejection.WithRejection.t E R.
      
      (*
          type Rejection = R;
      *)
      Definition Rejection : Set := R.
      
      (*
          async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
              let extractor = E::from_request_parts(parts, state).await?;
              Ok(WithRejection(extractor, PhantomData))
          }
      *)
      Definition from_request_parts
          (parts : mut_ref http.request.Parts.t)
          (state : ref S)
          :
            M
              (core.pin.Pin.t
                (alloc.boxed.Box.t
                  (dyn
                    [core.future.future.Future.Trait; core.marker.Send.Trait])
                  alloc.boxed.Box.Default.A)) :=
        let* parts := M.alloc parts in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_from_request_parts :
        Notations.DoubleColon Self "from_request_parts" := {
        Notations.double_colon := from_request_parts;
      }.
      
      Global Instance ℐ :
        axum_core.extract.FromRequestParts.Trait Self (S := S) := {
        axum_core.extract.FromRequestParts.Rejection := Rejection;
        axum_core.extract.FromRequestParts.from_request_parts :=
          from_request_parts;
      }.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    
    Module  Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Section Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
      Context {E R : Set}.
      
      Context {ℋ_0 : core.fmt.Display.Trait E}.
      
      Definition Self : Set :=
        axum_extra.extract.with_rejection.WithRejection.t E R.
      
      (*
          fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
              write!(f, "{}", self.0)
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    End Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  End with_rejection.
End extract.

Module cached.
  Module  Cached.
  Section Cached.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Cached.
  End Cached.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.
  Section Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum_extra.extract.cached.Cached.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.
  End Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.
  
  Module  Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.
  Section Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum_extra.extract.cached.Cached.t T.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum_extra.extract.cached.Cached.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.
  End Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.
  
  Module  Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.
  Section Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.default.Default.Trait T}.
    
    Definition Self : Set := axum_extra.extract.cached.Cached.t T.
    
    (*
    Default
    *)
    Definition default : M (axum_extra.extract.cached.Cached.t T) := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.
  End Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.
  
  Module  CachedEntry.
  Section CachedEntry.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End CachedEntry.
  End CachedEntry.
  
  Module  Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.
  Section Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum_extra.extract.cached.CachedEntry.t T.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum_extra.extract.cached.CachedEntry.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.
  End Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.
    Context {S T : Set}.
    
    Context
      {ℋ_0 : core.marker.Send.Trait S}
      {ℋ_1 : core.marker.Sync.Trait S}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait T (S := S)}
      {ℋ_3 : core.clone.Clone.Trait T}
      {ℋ_4 : core.marker.Send.Trait T}
      {ℋ_5 : core.marker.Sync.Trait T}.
    
    Definition Self : Set := axum_extra.extract.cached.Cached.t T.
    
    (*
        type Rejection = T::Rejection;
    *)
    Definition Rejection : Set := T::type["Rejection"].t.
    
    (*
        async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
            match Extension::<CachedEntry<T>>::from_request_parts(parts, state).await {
                Ok(Extension(CachedEntry(value))) => Ok(Self(value)),
                Err(_) => {
                    let value = T::from_request_parts(parts, state).await?;
                    parts.extensions.insert(CachedEntry(value.clone()));
                    Ok(Self(value))
                }
            }
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.
  
  Module  Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.
  Section Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum_extra.extract.cached.Cached.t T.
    
    (*
                type Target = T;
    *)
    Definition Target : Set := T.
    
    (*
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.
  End Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.
  
  Module  Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.
  Section Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum_extra.extract.cached.Cached.t T.
    
    (*
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
    *)
    Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref_mut :
      Notations.DoubleColon Self "deref_mut" := {
      Notations.double_colon := deref_mut;
    }.
    
    Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
      core.ops.deref.DerefMut.deref_mut := deref_mut;
    }.
  End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.
  End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.
End cached.

Module  Cached.
Section Cached.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Cached.
End Cached.

Module  Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.
Section Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum_extra.extract.cached.Cached.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.
End Impl_core_fmt_Debug_for_axum_extra_extract_cached_Cached_t_T.

Module  Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.
Section Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum_extra.extract.cached.Cached.t T.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum_extra.extract.cached.Cached.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.
End Impl_core_clone_Clone_for_axum_extra_extract_cached_Cached_t_T.

Module  Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.
Section Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.default.Default.Trait T}.
  
  Definition Self : Set := axum_extra.extract.cached.Cached.t T.
  
  (*
  Default
  *)
  Definition default : M (axum_extra.extract.cached.Cached.t T) := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.
End Impl_core_default_Default_for_axum_extra_extract_cached_Cached_t_T.

Module  CachedEntry.
Section CachedEntry.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End CachedEntry.
End CachedEntry.

Module  Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.
Section Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum_extra.extract.cached.CachedEntry.t T.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum_extra.extract.cached.CachedEntry.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.
End Impl_core_clone_Clone_for_axum_extra_extract_cached_CachedEntry_t_T.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.
  Context {S T : Set}.
  
  Context
    {ℋ_0 : core.marker.Send.Trait S}
    {ℋ_1 : core.marker.Sync.Trait S}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait T (S := S)}
    {ℋ_3 : core.clone.Clone.Trait T}
    {ℋ_4 : core.marker.Send.Trait T}
    {ℋ_5 : core.marker.Sync.Trait T}.
  
  Definition Self : Set := axum_extra.extract.cached.Cached.t T.
  
  (*
      type Rejection = T::Rejection;
  *)
  Definition Rejection : Set := T::type["Rejection"].t.
  
  (*
      async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
          match Extension::<CachedEntry<T>>::from_request_parts(parts, state).await {
              Ok(Extension(CachedEntry(value))) => Ok(Self(value)),
              Err(_) => {
                  let value = T::from_request_parts(parts, state).await?;
                  parts.extensions.insert(CachedEntry(value.clone()));
                  Ok(Self(value))
              }
          }
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_cached_Cached_t_T.

Module  Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.
Section Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum_extra.extract.cached.Cached.t T.
  
  (*
              type Target = T;
  *)
  Definition Target : Set := T.
  
  (*
              fn deref(&self) -> &Self::Target {
                  &self.0
              }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.
End Impl_core_ops_deref_Deref_for_axum_extra_extract_cached_Cached_t_T.

Module  Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.
Section Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum_extra.extract.cached.Cached.t T.
  
  (*
              fn deref_mut(&mut self) -> &mut Self::Target {
                  &mut self.0
              }
  *)
  Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref_mut :
    Notations.DoubleColon Self "deref_mut" := {
    Notations.double_colon := deref_mut;
  }.
  
  Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
    core.ops.deref.DerefMut.deref_mut := deref_mut;
  }.
End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.
End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_cached_Cached_t_T.

Module optional_path.
  Module  OptionalPath.
  Section OptionalPath.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : core.option.Option.t T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End OptionalPath.
  End OptionalPath.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.
  Section Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum_extra.extract.optional_path.OptionalPath.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.
  End Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.
    Context {T S : Set}.
    
    Context
      {ℋ_0 : serde.de.DeserializeOwned.Trait T}
      {ℋ_1 : core.marker.Send.Trait T}
      {ℋ_2 : core.marker.Send.Trait S}
      {ℋ_3 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum_extra.extract.optional_path.OptionalPath.t T.
    
    (*
        type Rejection = PathRejection;
    *)
    Definition Rejection : Set := axum.extract.rejection.PathRejection.t.
    
    (*
        async fn from_request_parts(
            parts: &mut http::request::Parts,
            _: &S,
        ) -> Result<Self, Self::Rejection> {
            match parts.extract::<Path<T>>().await {
                Ok(Path(params)) => Ok(Self(Some(params))),
                Err(PathRejection::FailedToDeserializePathParams(e))
                    if matches!(e.kind(), ErrorKind::WrongNumberOfParameters { got: 0, .. }) =>
                {
                    Ok(Self(None))
                }
                Err(e) => Err(e),
            }
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (Pattern : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* Pattern := M.alloc Pattern in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.
End optional_path.

Module  OptionalPath.
Section OptionalPath.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : core.option.Option.t T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End OptionalPath.
End OptionalPath.

Module  Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.
Section Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum_extra.extract.optional_path.OptionalPath.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.
End Impl_core_fmt_Debug_for_axum_extra_extract_optional_path_OptionalPath_t_T.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.
  Context {T S : Set}.
  
  Context
    {ℋ_0 : serde.de.DeserializeOwned.Trait T}
    {ℋ_1 : core.marker.Send.Trait T}
    {ℋ_2 : core.marker.Send.Trait S}
    {ℋ_3 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum_extra.extract.optional_path.OptionalPath.t T.
  
  (*
      type Rejection = PathRejection;
  *)
  Definition Rejection : Set := axum.extract.rejection.PathRejection.t.
  
  (*
      async fn from_request_parts(
          parts: &mut http::request::Parts,
          _: &S,
      ) -> Result<Self, Self::Rejection> {
          match parts.extract::<Path<T>>().await {
              Ok(Path(params)) => Ok(Self(Some(params))),
              Err(PathRejection::FailedToDeserializePathParams(e))
                  if matches!(e.kind(), ErrorKind::WrongNumberOfParameters { got: 0, .. }) =>
              {
                  Ok(Self(None))
              }
              Err(e) => Err(e),
          }
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (Pattern : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* Pattern := M.alloc Pattern in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_optional_path_OptionalPath_t_T.

Module with_rejection.
  Module  WithRejection.
  Section WithRejection.
    Context {E R : Set}.
    
    Record t : Set := {
      x0 : E;
      x1 : core.marker.PhantomData.t R;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    Definition Get_1 :=
      Ref.map (fun α => Some α.(x1)) (fun β α => Some (α <| x1 := β |>)).
  End WithRejection.
  End WithRejection.
  
  Module  Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R_2.
  Section Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R_2.
    Context {E R : Set}.
    
    Definition Self : Set :=
      axum_extra.extract.with_rejection.WithRejection.t E R.
    
    (*
        pub fn into_inner(self) -> E {
            self.0
        }
    *)
    Definition into_inner (self : Self) : M E :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_inner :
      Notations.DoubleColon Self "into_inner" := {
      Notations.double_colon := into_inner;
    }.
  End Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R_2.
  End Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R_2.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Section Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Context {E R : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait E}.
    
    Definition Self : Set :=
      axum_extra.extract.with_rejection.WithRejection.t E R.
    
    (*
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.debug_tuple("WithRejection")
                .field(&self.0)
                .field(&self.1)
                .finish()
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  End Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  
  Module  Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Section Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Context {E R : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait E}.
    
    Definition Self : Set :=
      axum_extra.extract.with_rejection.WithRejection.t E R.
    
    (*
        fn clone(&self) -> Self {
            Self(self.0.clone(), self.1)
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  End Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  
  Module  Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Section Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Context {E R : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait E}.
    
    Definition Self : Set :=
      axum_extra.extract.with_rejection.WithRejection.t E R.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  End Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  
  Module  Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Section Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Context {E R : Set}.
    
    Context {ℋ_0 : core.default.Default.Trait E}.
    
    Definition Self : Set :=
      axum_extra.extract.with_rejection.WithRejection.t E R.
    
    (*
        fn default() -> Self {
            Self(Default::default(), Default::default())
        }
    *)
    Definition default : M Self := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  End Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  
  Module  Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Section Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Context {E R : Set}.
    
    Definition Self : Set :=
      axum_extra.extract.with_rejection.WithRejection.t E R.
    
    (*
        type Target = E;
    *)
    Definition Target : Set := E.
    
    (*
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    *)
    Definition deref (self : ref Self) : M (ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref :
      Notations.DoubleColon Self "deref" := {
      Notations.double_colon := deref;
    }.
    
    Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
      core.ops.deref.Deref.Target := Target;
      core.ops.deref.Deref.deref := deref;
    }.
  End Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  End Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  
  Module  Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Section Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Context {E R : Set}.
    
    Definition Self : Set :=
      axum_extra.extract.with_rejection.WithRejection.t E R.
    
    (*
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    *)
    Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_deref_mut :
      Notations.DoubleColon Self "deref_mut" := {
      Notations.double_colon := deref_mut;
    }.
    
    Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
      core.ops.deref.DerefMut.deref_mut := deref_mut;
    }.
  End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  
  Module  Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Section Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Context {E R S : Set}.
    
    Context
      {ℋ_0 : core.marker.Send.Trait S}
      {ℋ_1 : core.marker.Sync.Trait S}
      {ℋ_2 :
        axum_core.extract.FromRequest.Trait E
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M E)}
      {ℋ_3 : core.convert.From.Trait R (T := E::type["Rejection"].t)}
      {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      axum_extra.extract.with_rejection.WithRejection.t E R.
    
    (*
        type Rejection = R;
    *)
    Definition Rejection : Set := R.
    
    (*
        async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
            let extractor = E::from_request(req, state).await?;
            Ok(WithRejection(extractor, PhantomData))
        }
    *)
    Definition from_request
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request :
      Notations.DoubleColon Self "from_request" := {
      Notations.double_colon := from_request;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequest.Trait Self
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M Self) := {
      axum_core.extract.FromRequest.Rejection := Rejection;
      axum_core.extract.FromRequest.from_request := from_request;
    }.
  End Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  End Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  
  Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Context {E R S : Set}.
    
    Context
      {ℋ_0 : core.marker.Send.Trait S}
      {ℋ_1 : core.marker.Sync.Trait S}
      {ℋ_2 : axum_core.extract.FromRequestParts.Trait E (S := S)}
      {ℋ_3 : core.convert.From.Trait R (T := E::type["Rejection"].t)}
      {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
    
    Definition Self : Set :=
      axum_extra.extract.with_rejection.WithRejection.t E R.
    
    (*
        type Rejection = R;
    *)
    Definition Rejection : Set := R.
    
    (*
        async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
            let extractor = E::from_request_parts(parts, state).await?;
            Ok(WithRejection(extractor, PhantomData))
        }
    *)
    Definition from_request_parts
        (parts : mut_ref http.request.Parts.t)
        (state : ref S)
        :
          M
            (core.pin.Pin.t
              (alloc.boxed.Box.t
                (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
                alloc.boxed.Box.Default.A)) :=
      let* parts := M.alloc parts in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_from_request_parts :
      Notations.DoubleColon Self "from_request_parts" := {
      Notations.double_colon := from_request_parts;
    }.
    
    Global Instance ℐ :
      axum_core.extract.FromRequestParts.Trait Self (S := S) := {
      axum_core.extract.FromRequestParts.Rejection := Rejection;
      axum_core.extract.FromRequestParts.from_request_parts :=
        from_request_parts;
    }.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  
  Module  Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Section Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
    Context {E R : Set}.
    
    Context {ℋ_0 : core.fmt.Display.Trait E}.
    
    Definition Self : Set :=
      axum_extra.extract.with_rejection.WithRejection.t E R.
    
    (*
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.0)
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  End Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
End with_rejection.

Module  WithRejection.
Section WithRejection.
  Context {E R : Set}.
  
  Record t : Set := {
    x0 : E;
    x1 : core.marker.PhantomData.t R;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  Definition Get_1 :=
    Ref.map (fun α => Some α.(x1)) (fun β α => Some (α <| x1 := β |>)).
End WithRejection.
End WithRejection.

Module  Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R_3.
Section Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R_3.
  Context {E R : Set}.
  
  Definition Self : Set :=
    axum_extra.extract.with_rejection.WithRejection.t E R.
  
  (*
      pub fn into_inner(self) -> E {
          self.0
      }
  *)
  Definition into_inner (self : Self) : M E :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_inner :
    Notations.DoubleColon Self "into_inner" := {
    Notations.double_colon := into_inner;
  }.
End Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R_3.
End Impl_axum_extra_extract_with_rejection_WithRejection_t_E_R_3.

Module  Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
Section Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Context {E R : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait E}.
  
  Definition Self : Set :=
    axum_extra.extract.with_rejection.WithRejection.t E R.
  
  (*
      fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
          f.debug_tuple("WithRejection")
              .field(&self.0)
              .field(&self.1)
              .finish()
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
End Impl_core_fmt_Debug_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.

Module  Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
Section Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Context {E R : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait E}.
  
  Definition Self : Set :=
    axum_extra.extract.with_rejection.WithRejection.t E R.
  
  (*
      fn clone(&self) -> Self {
          Self(self.0.clone(), self.1)
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
End Impl_core_clone_Clone_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.

Module  Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
Section Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Context {E R : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait E}.
  
  Definition Self : Set :=
    axum_extra.extract.with_rejection.WithRejection.t E R.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
End Impl_core_marker_Copy_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.

Module  Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
Section Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Context {E R : Set}.
  
  Context {ℋ_0 : core.default.Default.Trait E}.
  
  Definition Self : Set :=
    axum_extra.extract.with_rejection.WithRejection.t E R.
  
  (*
      fn default() -> Self {
          Self(Default::default(), Default::default())
      }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
End Impl_core_default_Default_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.

Module  Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
Section Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Context {E R : Set}.
  
  Definition Self : Set :=
    axum_extra.extract.with_rejection.WithRejection.t E R.
  
  (*
      type Target = E;
  *)
  Definition Target : Set := E.
  
  (*
      fn deref(&self) -> &Self::Target {
          &self.0
      }
  *)
  Definition deref (self : ref Self) : M (ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref :
    Notations.DoubleColon Self "deref" := {
    Notations.double_colon := deref;
  }.
  
  Global Instance ℐ : core.ops.deref.Deref.Trait Self := {
    core.ops.deref.Deref.Target := Target;
    core.ops.deref.Deref.deref := deref;
  }.
End Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
End Impl_core_ops_deref_Deref_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.

Module  Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
Section Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Context {E R : Set}.
  
  Definition Self : Set :=
    axum_extra.extract.with_rejection.WithRejection.t E R.
  
  (*
      fn deref_mut(&mut self) -> &mut Self::Target {
          &mut self.0
      }
  *)
  Definition deref_mut (self : mut_ref Self) : M (mut_ref Target) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_deref_mut :
    Notations.DoubleColon Self "deref_mut" := {
    Notations.double_colon := deref_mut;
  }.
  
  Global Instance ℐ : core.ops.deref.DerefMut.Trait Self := {
    core.ops.deref.DerefMut.deref_mut := deref_mut;
  }.
End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
End Impl_core_ops_deref_DerefMut_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.

Module  Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
Section Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Context {E R S : Set}.
  
  Context
    {ℋ_0 : core.marker.Send.Trait S}
    {ℋ_1 : core.marker.Sync.Trait S}
    {ℋ_2 :
      axum_core.extract.FromRequest.Trait E
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M E)}
    {ℋ_3 : core.convert.From.Trait R (T := E::type["Rejection"].t)}
    {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    axum_extra.extract.with_rejection.WithRejection.t E R.
  
  (*
      type Rejection = R;
  *)
  Definition Rejection : Set := R.
  
  (*
      async fn from_request(req: Request, state: &S) -> Result<Self, Self::Rejection> {
          let extractor = E::from_request(req, state).await?;
          Ok(WithRejection(extractor, PhantomData))
      }
  *)
  Definition from_request
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request :
    Notations.DoubleColon Self "from_request" := {
    Notations.double_colon := from_request;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequest.Trait Self
      (S := S)
      (M := axum_core.extract.FromRequest.Default.M Self) := {
    axum_core.extract.FromRequest.Rejection := Rejection;
    axum_core.extract.FromRequest.from_request := from_request;
  }.
End Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
End Impl_axum_core_extract_FromRequest_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.

Module  Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
Section Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Context {E R S : Set}.
  
  Context
    {ℋ_0 : core.marker.Send.Trait S}
    {ℋ_1 : core.marker.Sync.Trait S}
    {ℋ_2 : axum_core.extract.FromRequestParts.Trait E (S := S)}
    {ℋ_3 : core.convert.From.Trait R (T := E::type["Rejection"].t)}
    {ℋ_4 : axum_core.response.into_response.IntoResponse.Trait R}.
  
  Definition Self : Set :=
    axum_extra.extract.with_rejection.WithRejection.t E R.
  
  (*
      type Rejection = R;
  *)
  Definition Rejection : Set := R.
  
  (*
      async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
          let extractor = E::from_request_parts(parts, state).await?;
          Ok(WithRejection(extractor, PhantomData))
      }
  *)
  Definition from_request_parts
      (parts : mut_ref http.request.Parts.t)
      (state : ref S)
      :
        M
          (core.pin.Pin.t
            (alloc.boxed.Box.t
              (dyn [core.future.future.Future.Trait; core.marker.Send.Trait])
              alloc.boxed.Box.Default.A)) :=
    let* parts := M.alloc parts in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_from_request_parts :
    Notations.DoubleColon Self "from_request_parts" := {
    Notations.double_colon := from_request_parts;
  }.
  
  Global Instance ℐ :
    axum_core.extract.FromRequestParts.Trait Self (S := S) := {
    axum_core.extract.FromRequestParts.Rejection := Rejection;
    axum_core.extract.FromRequestParts.from_request_parts := from_request_parts;
  }.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
End Impl_axum_core_extract_FromRequestParts_S_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.

Module  Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
Section Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
  Context {E R : Set}.
  
  Context {ℋ_0 : core.fmt.Display.Trait E}.
  
  Definition Self : Set :=
    axum_extra.extract.with_rejection.WithRejection.t E R.
  
  (*
      fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
          write!(f, "{}", self.0)
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.
End Impl_core_fmt_Display_for_axum_extra_extract_with_rejection_WithRejection_t_E_R.

Module handler.
  Module or.
    Module  Or.
    Section Or.
      Context (L R Lt Rt S : Set).
      
      Record t : Set := {
        lhs : L;
        rhs : R;
        _marker : core.marker.PhantomData.t ((Lt * Rt) * S);
      }.
      
      Definition Get_lhs :=
        Ref.map (fun α => Some α.(lhs)) (fun β α => Some (α <| lhs := β |>)).
      Definition Get_rhs :=
        Ref.map (fun α => Some α.(rhs)) (fun β α => Some (α <| rhs := β |>)).
      Definition Get__marker :=
        Ref.map
          (fun α => Some α.(_marker))
          (fun β α => Some (α <| _marker := β |>)).
    End Or.
    End Or.
    
    Module  Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    Section Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
      Context {S L R Lt Rt : Set}.
      
      Context
        {ℋ_0 :
          axum_extra.handler.HandlerCallWithExtractors.Trait L
            (T := Lt)
            (S := S)}
        {ℋ_1 : core.marker.Send.Trait L}
        {ℋ_2 :
          axum_extra.handler.HandlerCallWithExtractors.Trait R
            (T := Rt)
            (S := S)}
        {ℋ_3 : core.marker.Send.Trait R}
        {ℋ_4 : core.marker.Send.Trait Rt}
        {ℋ_5 : core.marker.Send.Trait Lt}.
      
      Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
      
      (*
          type Future = EitherFuture<
              Map<L::Future, fn(<L::Future as Future>::Output) -> Response>,
              Map<R::Future, fn(<R::Future as Future>::Output) -> Response>,
          >;
      *)
      Definition Future : Set :=
        futures_util.future.either.Either.t
            (futures_util.future.future.Map.t
              L::type["Future"].t
              ((core.future.future.Future.Output
                  (Self := L::type["Future"].t)
                  (Trait := ltac:(refine _)))
                ->
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T)))
            (futures_util.future.future.Map.t
              R::type["Future"].t
              ((core.future.future.Future.Output
                  (Self := R::type["Future"].t)
                  (Trait := ltac:(refine _)))
                ->
                ltac:(axum_core.response.Response
                  axum_core.response.Response.Default.T))).
      
      (*
          fn call(
              self,
              extractors: Either<Lt, Rt>,
              state: S,
          ) -> <Self as HandlerCallWithExtractors<Either<Lt, Rt>, S>>::Future {
              match extractors {
                  Either::E1(lt) => self
                      .lhs
                      .call(lt, state)
                      .map(IntoResponse::into_response as _)
                      .left_future(),
                  Either::E2(rt) => self
                      .rhs
                      .call(rt, state)
                      .map(IntoResponse::into_response as _)
                      .right_future(),
              }
          }
      *)
      Definition call
          (self : Self)
          (extractors : axum_extra.either.Either.t Lt Rt)
          (state : S)
          :
            M
              (axum_extra.handler.HandlerCallWithExtractors.Future
                (Self := Self)
                (Trait := ltac:(refine _))) :=
        let* self := M.alloc self in
        let* extractors := M.alloc extractors in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
          (T := axum_extra.either.Either.t Lt Rt)
          (S := S) := {
        axum_extra.handler.HandlerCallWithExtractors.Future := Future;
        axum_extra.handler.HandlerCallWithExtractors.call := call;
        axum_extra.handler.HandlerCallWithExtractors.into_handler :=
          Datatypes.None;
        axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
      }.
    End Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    End Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    
    Module  Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    Section Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
      Context {S L R Lt Rt M : Set}.
      
      Context
        {ℋ_0 :
          axum_extra.handler.HandlerCallWithExtractors.Trait L
            (T := Lt)
            (S := S)}
        {ℋ_1 : core.clone.Clone.Trait L}
        {ℋ_2 : core.marker.Send.Trait L}
        {ℋ_3 :
          axum_extra.handler.HandlerCallWithExtractors.Trait R
            (T := Rt)
            (S := S)}
        {ℋ_4 : core.clone.Clone.Trait R}
        {ℋ_5 : core.marker.Send.Trait R}
        {ℋ_6 : axum_core.extract.FromRequestParts.Trait Lt (S := S)}
        {ℋ_7 : core.marker.Send.Trait Lt}
        {ℋ_8 : axum_core.extract.FromRequest.Trait Rt (S := S) (M := M)}
        {ℋ_9 : core.marker.Send.Trait Rt}
        {ℋ_10 : core.marker.Send.Trait Lt::type["Rejection"].t}
        {ℋ_11 : core.marker.Send.Trait Rt::type["Rejection"].t}
        {ℋ_12 : core.marker.Send.Trait S}
        {ℋ_13 : core.marker.Sync.Trait S}.
      
      Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
      
      (*
          type Future = BoxFuture<'static, Response>;
      *)
      Definition Future : Set :=
        ltac:(futures_core.future.BoxFuture
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
      
      (*
          fn call(self, req: Request, state: S) -> Self::Future {
              Box::pin(async move {
                  let (mut parts, body) = req.into_parts();
      
                  if let Ok(lt) = Lt::from_request_parts(&mut parts, &state).await {
                      return self.lhs.call(lt, state).await;
                  }
      
                  let req = Request::from_parts(parts, body);
      
                  match Rt::from_request(req, &state).await {
                      Ok(rt) => self.rhs.call(rt, state).await,
                      Err(rejection) => rejection.into_response(),
                  }
              })
          }
      *)
      Definition call
          (self : Self)
          (req
            :
            ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))
          (state : S)
          : M Future :=
        let* self := M.alloc self in
        let* req := M.alloc req in
        let* state := M.alloc state in
        M.read foo.
      
      Global Instance AssociatedFunction_call :
        Notations.DoubleColon Self "call" := {
        Notations.double_colon := call;
      }.
      
      Global Instance ℐ :
        axum.handler.Handler.Required.Trait Self
          (T := (M * Lt) * Rt)
          (S := S) := {
        axum.handler.Handler.Future := Future;
        axum.handler.Handler.call := call;
        axum.handler.Handler.layer := Datatypes.None;
        axum.handler.Handler.with_state := Datatypes.None;
      }.
    End Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    End Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    
    Module  Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    Section Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
      Context {L R Lt Rt S : Set}.
      
      Context {ℋ_0 : core.marker.Copy.Trait L} {ℋ_1 : core.marker.Copy.Trait R}.
      
      Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    End Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    
    Module  Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    Section Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
      Context {L R Lt Rt S : Set}.
      
      Context {ℋ_0 : core.clone.Clone.Trait L} {ℋ_1 : core.clone.Clone.Trait R}.
      
      Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
      
      (*
          fn clone(&self) -> Self {
              Self {
                  lhs: self.lhs.clone(),
                  rhs: self.rhs.clone(),
                  _marker: self._marker,
              }
          }
      *)
      Definition clone (self : ref Self) : M Self :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    End Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  End or.
  
  Module  HandlerCallWithExtractors.
  Section HandlerCallWithExtractors.
    Class Trait (Self : Set) {T S : Set} : Type := {
      Future : Set;
      ℒ_0 :: core.future.future.Future.Trait Future;
      ℒ_1 :: core.marker.Send.Trait Future;
      call :
        Self ->
          T ->
          S ->
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _)));
    }.
    
    Global Instance Method_Future `(Trait) :
      Notations.DoubleColonType Self "Future" := {
      Notations.double_colon_type := Future;
    }.
  End HandlerCallWithExtractors.
  End HandlerCallWithExtractors.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple__S_for_F.
    Context {F Fut S : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := unit)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern : unit)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := unit)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1__S_for_F.
    Context {F Fut S T1 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := T1)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern : T1)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := T1)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2__S_for_F.
    Context {F Fut S T1 T2 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := T1 * T2)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern : T1 * T2)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := T1 * T2)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3__S_for_F.
    Context {F Fut S T1 T2 T3 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := (T1 * T2) * T3)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern : (T1 * T2) * T3)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := (T1 * T2) * T3)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4__S_for_F.
    Context {F Fut S T1 T2 T3 T4 : Set}.
    
    Context
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := ((T1 * T2) * T3) * T4)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern : ((T1 * T2) * T3) * T4)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := ((T1 * T2) * T3) * T4)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5__S_for_F.
    Context {F Fut S T1 T2 T3 T4 T5 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F (Args := (((T1 * T2) * T3) * T4) * T5)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern : (((T1 * T2) * T3) * T4) * T5)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := (((T1 * T2) * T3) * T4) * T5)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6__S_for_F.
    Context {F Fut S T1 T2 T3 T4 T5 T6 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((T1 * T2) * T3) * T4) * T5) * T6)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern : ((((T1 * T2) * T3) * T4) * T5) * T6)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := ((((T1 * T2) * T3) * T4) * T5) * T6)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7__S_for_F.
    Context {F Fut S T1 T2 T3 T4 T5 T6 T7 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern : (((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
    Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern : ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
    Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern : (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
    Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern
          :
          ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
    Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern
          :
          (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
    Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern
          :
          ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
    Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern
          :
          (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12)
          *
          T13)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
    Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern
          :
          ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
    Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern
          :
          (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
    Context
      {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
    
    Context
      {ℋ_0 :
        core.ops.function.FnOnce.Trait F
          (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
          *
          T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          T16)}
      {ℋ_1 : core.future.future.Future.Trait Fut}
      {ℋ_2 : core.marker.Send.Trait Fut}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            Fut::type["Output"].t}.
    
    Definition Self : Set := F.
    
    (*
                 type Future = Map<Fut, fn(Fut::Output) -> Response>;
    *)
    Definition Future : Set :=
      futures_util.future.future.Map.t
          Fut
          (Fut::type["Output"].t ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)).
    
    (*
                 fn call(
                     self,
                     ($($ty,)* ): ($($ty,)* ),
                     _state: S,
                 ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                     self($($ty,)* ).map(IntoResponse::into_response)
                 }
    *)
    Definition call
        (self : Self)
        (Pattern
          :
          ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
          *
          T10)
          *
          T11)
          *
          T12)
          *
          T13)
          *
          T14)
          *
          T15)
          *
          T16)
        (_state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* Pattern := M.alloc Pattern in
      let* _state := M.alloc _state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
  
  Module  IntoHandler.
  Section IntoHandler.
    Context (H T S : Set).
    
    Record t : Set := {
      handler : H;
      _marker : core.marker.PhantomData.t (T * S);
    }.
    
    Definition Get_handler :=
      Ref.map
        (fun α => Some α.(handler))
        (fun β α => Some (α <| handler := β |>)).
    Definition Get__marker :=
      Ref.map
        (fun α => Some α.(_marker))
        (fun β α => Some (α <| _marker := β |>)).
  End IntoHandler.
  End IntoHandler.
  
  Module  Impl_axum_handler_Handler_T_S_for_axum_extra_handler_IntoHandler_t_H_T_S.
  Section Impl_axum_handler_Handler_T_S_for_axum_extra_handler_IntoHandler_t_H_T_S.
    Context {H T S : Set}.
    
    Context
      {ℋ_0 :
        axum_extra.handler.HandlerCallWithExtractors.Trait H (T := T) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait H}
      {ℋ_2 : core.marker.Send.Trait H}
      {ℋ_3 :
        axum_core.extract.FromRequest.Trait T
          (S := S)
          (M := axum_core.extract.FromRequest.Default.M T)}
      {ℋ_4 : core.marker.Send.Trait T}
      {ℋ_5 : core.marker.Send.Trait T::type["Rejection"].t}
      {ℋ_6 : core.marker.Send.Trait S}
      {ℋ_7 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum_extra.handler.IntoHandler.t H T S.
    
    (*
        type Future = BoxFuture<'static, Response>;
    *)
    Definition Future : Set :=
      ltac:(futures_core.future.BoxFuture
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
    
    (*
        fn call(self, req: Request, state: S) -> Self::Future {
            let req = req.map(Body::new);
            Box::pin(async move {
                match T::from_request(req, &state).await {
                    Ok(t) => self.handler.call(t, state).await,
                    Err(rejection) => rejection.into_response(),
                }
            })
        }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self (T := T) (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_T_S_for_axum_extra_handler_IntoHandler_t_H_T_S.
  End Impl_axum_handler_Handler_T_S_for_axum_extra_handler_IntoHandler_t_H_T_S.
  
  Module  Impl_core_marker_Copy_for_axum_extra_handler_IntoHandler_t_H_T_S.
  Section Impl_core_marker_Copy_for_axum_extra_handler_IntoHandler_t_H_T_S.
    Context {H T S : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait H}.
    
    Definition Self : Set := axum_extra.handler.IntoHandler.t H T S.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extra_handler_IntoHandler_t_H_T_S.
  End Impl_core_marker_Copy_for_axum_extra_handler_IntoHandler_t_H_T_S.
  
  Module  Impl_core_clone_Clone_for_axum_extra_handler_IntoHandler_t_H_T_S.
  Section Impl_core_clone_Clone_for_axum_extra_handler_IntoHandler_t_H_T_S.
    Context {H T S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait H}.
    
    Definition Self : Set := axum_extra.handler.IntoHandler.t H T S.
    
    (*
        fn clone(&self) -> Self {
            Self {
                handler: self.handler.clone(),
                _marker: self._marker,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_handler_IntoHandler_t_H_T_S.
  End Impl_core_clone_Clone_for_axum_extra_handler_IntoHandler_t_H_T_S.
End handler.

Module or.
  Module  Or.
  Section Or.
    Context (L R Lt Rt S : Set).
    
    Record t : Set := {
      lhs : L;
      rhs : R;
      _marker : core.marker.PhantomData.t ((Lt * Rt) * S);
    }.
    
    Definition Get_lhs :=
      Ref.map (fun α => Some α.(lhs)) (fun β α => Some (α <| lhs := β |>)).
    Definition Get_rhs :=
      Ref.map (fun α => Some α.(rhs)) (fun β α => Some (α <| rhs := β |>)).
    Definition Get__marker :=
      Ref.map
        (fun α => Some α.(_marker))
        (fun β α => Some (α <| _marker := β |>)).
  End Or.
  End Or.
  
  Module  Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  Section Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    Context {S L R Lt Rt : Set}.
    
    Context
      {ℋ_0 :
        axum_extra.handler.HandlerCallWithExtractors.Trait L (T := Lt) (S := S)}
      {ℋ_1 : core.marker.Send.Trait L}
      {ℋ_2 :
        axum_extra.handler.HandlerCallWithExtractors.Trait R (T := Rt) (S := S)}
      {ℋ_3 : core.marker.Send.Trait R}
      {ℋ_4 : core.marker.Send.Trait Rt}
      {ℋ_5 : core.marker.Send.Trait Lt}.
    
    Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
    
    (*
        type Future = EitherFuture<
            Map<L::Future, fn(<L::Future as Future>::Output) -> Response>,
            Map<R::Future, fn(<R::Future as Future>::Output) -> Response>,
        >;
    *)
    Definition Future : Set :=
      futures_util.future.either.Either.t
          (futures_util.future.future.Map.t
            L::type["Future"].t
            ((core.future.future.Future.Output
                (Self := L::type["Future"].t)
                (Trait := ltac:(refine _)))
              ->
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T)))
          (futures_util.future.future.Map.t
            R::type["Future"].t
            ((core.future.future.Future.Output
                (Self := R::type["Future"].t)
                (Trait := ltac:(refine _)))
              ->
              ltac:(axum_core.response.Response
                axum_core.response.Response.Default.T))).
    
    (*
        fn call(
            self,
            extractors: Either<Lt, Rt>,
            state: S,
        ) -> <Self as HandlerCallWithExtractors<Either<Lt, Rt>, S>>::Future {
            match extractors {
                Either::E1(lt) => self
                    .lhs
                    .call(lt, state)
                    .map(IntoResponse::into_response as _)
                    .left_future(),
                Either::E2(rt) => self
                    .rhs
                    .call(rt, state)
                    .map(IntoResponse::into_response as _)
                    .right_future(),
            }
        }
    *)
    Definition call
        (self : Self)
        (extractors : axum_extra.either.Either.t Lt Rt)
        (state : S)
        :
          M
            (axum_extra.handler.HandlerCallWithExtractors.Future
              (Self := Self)
              (Trait := ltac:(refine _))) :=
      let* self := M.alloc self in
      let* extractors := M.alloc extractors in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
        (T := axum_extra.either.Either.t Lt Rt)
        (S := S) := {
      axum_extra.handler.HandlerCallWithExtractors.Future := Future;
      axum_extra.handler.HandlerCallWithExtractors.call := call;
      axum_extra.handler.HandlerCallWithExtractors.into_handler :=
        Datatypes.None;
      axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
    }.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  End Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  
  Module  Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  Section Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    Context {S L R Lt Rt M : Set}.
    
    Context
      {ℋ_0 :
        axum_extra.handler.HandlerCallWithExtractors.Trait L (T := Lt) (S := S)}
      {ℋ_1 : core.clone.Clone.Trait L}
      {ℋ_2 : core.marker.Send.Trait L}
      {ℋ_3 :
        axum_extra.handler.HandlerCallWithExtractors.Trait R (T := Rt) (S := S)}
      {ℋ_4 : core.clone.Clone.Trait R}
      {ℋ_5 : core.marker.Send.Trait R}
      {ℋ_6 : axum_core.extract.FromRequestParts.Trait Lt (S := S)}
      {ℋ_7 : core.marker.Send.Trait Lt}
      {ℋ_8 : axum_core.extract.FromRequest.Trait Rt (S := S) (M := M)}
      {ℋ_9 : core.marker.Send.Trait Rt}
      {ℋ_10 : core.marker.Send.Trait Lt::type["Rejection"].t}
      {ℋ_11 : core.marker.Send.Trait Rt::type["Rejection"].t}
      {ℋ_12 : core.marker.Send.Trait S}
      {ℋ_13 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
    
    (*
        type Future = BoxFuture<'static, Response>;
    *)
    Definition Future : Set :=
      ltac:(futures_core.future.BoxFuture
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
    
    (*
        fn call(self, req: Request, state: S) -> Self::Future {
            Box::pin(async move {
                let (mut parts, body) = req.into_parts();
    
                if let Ok(lt) = Lt::from_request_parts(&mut parts, &state).await {
                    return self.lhs.call(lt, state).await;
                }
    
                let req = Request::from_parts(parts, body);
    
                match Rt::from_request(req, &state).await {
                    Ok(rt) => self.rhs.call(rt, state).await,
                    Err(rejection) => rejection.into_response(),
                }
            })
        }
    *)
    Definition call
        (self : Self)
        (req
          :
          ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
        (state : S)
        : M Future :=
      let* self := M.alloc self in
      let* req := M.alloc req in
      let* state := M.alloc state in
      M.read foo.
    
    Global Instance AssociatedFunction_call :
      Notations.DoubleColon Self "call" := {
      Notations.double_colon := call;
    }.
    
    Global Instance ℐ :
      axum.handler.Handler.Required.Trait Self
        (T := (M * Lt) * Rt)
        (S := S) := {
      axum.handler.Handler.Future := Future;
      axum.handler.Handler.call := call;
      axum.handler.Handler.layer := Datatypes.None;
      axum.handler.Handler.with_state := Datatypes.None;
    }.
  End Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  End Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  
  Module  Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  Section Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    Context {L R Lt Rt S : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait L} {ℋ_1 : core.marker.Copy.Trait R}.
    
    Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  End Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  
  Module  Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  Section Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
    Context {L R Lt Rt S : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait L} {ℋ_1 : core.clone.Clone.Trait R}.
    
    Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
    
    (*
        fn clone(&self) -> Self {
            Self {
                lhs: self.lhs.clone(),
                rhs: self.rhs.clone(),
                _marker: self._marker,
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  End Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
End or.

Module  Or.
Section Or.
  Context (L R Lt Rt S : Set).
  
  Record t : Set := {
    lhs : L;
    rhs : R;
    _marker : core.marker.PhantomData.t ((Lt * Rt) * S);
  }.
  
  Definition Get_lhs :=
    Ref.map (fun α => Some α.(lhs)) (fun β α => Some (α <| lhs := β |>)).
  Definition Get_rhs :=
    Ref.map (fun α => Some α.(rhs)) (fun β α => Some (α <| rhs := β |>)).
  Definition Get__marker :=
    Ref.map
      (fun α => Some α.(_marker))
      (fun β α => Some (α <| _marker := β |>)).
End Or.
End Or.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  Context {S L R Lt Rt : Set}.
  
  Context
    {ℋ_0 :
      axum_extra.handler.HandlerCallWithExtractors.Trait L (T := Lt) (S := S)}
    {ℋ_1 : core.marker.Send.Trait L}
    {ℋ_2 :
      axum_extra.handler.HandlerCallWithExtractors.Trait R (T := Rt) (S := S)}
    {ℋ_3 : core.marker.Send.Trait R}
    {ℋ_4 : core.marker.Send.Trait Rt}
    {ℋ_5 : core.marker.Send.Trait Lt}.
  
  Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
  
  (*
      type Future = EitherFuture<
          Map<L::Future, fn(<L::Future as Future>::Output) -> Response>,
          Map<R::Future, fn(<R::Future as Future>::Output) -> Response>,
      >;
  *)
  Definition Future : Set :=
    futures_util.future.either.Either.t
        (futures_util.future.future.Map.t
          L::type["Future"].t
          ((core.future.future.Future.Output
              (Self := L::type["Future"].t)
              (Trait := ltac:(refine _)))
            ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T)))
        (futures_util.future.future.Map.t
          R::type["Future"].t
          ((core.future.future.Future.Output
              (Self := R::type["Future"].t)
              (Trait := ltac:(refine _)))
            ->
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T))).
  
  (*
      fn call(
          self,
          extractors: Either<Lt, Rt>,
          state: S,
      ) -> <Self as HandlerCallWithExtractors<Either<Lt, Rt>, S>>::Future {
          match extractors {
              Either::E1(lt) => self
                  .lhs
                  .call(lt, state)
                  .map(IntoResponse::into_response as _)
                  .left_future(),
              Either::E2(rt) => self
                  .rhs
                  .call(rt, state)
                  .map(IntoResponse::into_response as _)
                  .right_future(),
          }
      }
  *)
  Definition call
      (self : Self)
      (extractors : axum_extra.either.Either.t Lt Rt)
      (state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* extractors := M.alloc extractors in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := axum_extra.either.Either.t Lt Rt)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
End Impl_axum_extra_handler_HandlerCallWithExtractors_axum_extra_either_Either_t_Lt_Rt_S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.

Module  Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
Section Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  Context {S L R Lt Rt M : Set}.
  
  Context
    {ℋ_0 :
      axum_extra.handler.HandlerCallWithExtractors.Trait L (T := Lt) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait L}
    {ℋ_2 : core.marker.Send.Trait L}
    {ℋ_3 :
      axum_extra.handler.HandlerCallWithExtractors.Trait R (T := Rt) (S := S)}
    {ℋ_4 : core.clone.Clone.Trait R}
    {ℋ_5 : core.marker.Send.Trait R}
    {ℋ_6 : axum_core.extract.FromRequestParts.Trait Lt (S := S)}
    {ℋ_7 : core.marker.Send.Trait Lt}
    {ℋ_8 : axum_core.extract.FromRequest.Trait Rt (S := S) (M := M)}
    {ℋ_9 : core.marker.Send.Trait Rt}
    {ℋ_10 : core.marker.Send.Trait Lt::type["Rejection"].t}
    {ℋ_11 : core.marker.Send.Trait Rt::type["Rejection"].t}
    {ℋ_12 : core.marker.Send.Trait S}
    {ℋ_13 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
  
  (*
      type Future = BoxFuture<'static, Response>;
  *)
  Definition Future : Set :=
    ltac:(futures_core.future.BoxFuture
        ltac:(axum_core.response.Response
          axum_core.response.Response.Default.T)).
  
  (*
      fn call(self, req: Request, state: S) -> Self::Future {
          Box::pin(async move {
              let (mut parts, body) = req.into_parts();
  
              if let Ok(lt) = Lt::from_request_parts(&mut parts, &state).await {
                  return self.lhs.call(lt, state).await;
              }
  
              let req = Request::from_parts(parts, body);
  
              match Rt::from_request(req, &state).await {
                  Ok(rt) => self.rhs.call(rt, state).await,
                  Err(rejection) => rejection.into_response(),
              }
          })
      }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self (T := (M * Lt) * Rt) (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
End Impl_axum_handler_Handler_Tuple_M_Lt_Rt__S_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.

Module  Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
Section Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  Context {L R Lt Rt S : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait L} {ℋ_1 : core.marker.Copy.Trait R}.
  
  Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
End Impl_core_marker_Copy_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.

Module  Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
Section Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
  Context {L R Lt Rt S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait L} {ℋ_1 : core.clone.Clone.Trait R}.
  
  Definition Self : Set := axum_extra.handler.or.Or.t L R Lt Rt S.
  
  (*
      fn clone(&self) -> Self {
          Self {
              lhs: self.lhs.clone(),
              rhs: self.rhs.clone(),
              _marker: self._marker,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.
End Impl_core_clone_Clone_for_axum_extra_handler_or_Or_t_L_R_Lt_Rt_S.

Module  HandlerCallWithExtractors.
Section HandlerCallWithExtractors.
  Class Trait (Self : Set) {T S : Set} : Type := {
    Future : Set;
    ℒ_0 :: core.future.future.Future.Trait Future;
    ℒ_1 :: core.marker.Send.Trait Future;
    call :
      Self ->
        T ->
        S ->
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _)));
  }.
  
  Global Instance Method_Future `(Trait) :
    Notations.DoubleColonType Self "Future" := {
    Notations.double_colon_type := Future;
  }.
End HandlerCallWithExtractors.
End HandlerCallWithExtractors.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple__S_for_F.
  Context {F Fut S : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := unit)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern : unit)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := unit)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1__S_for_F.
  Context {F Fut S T1 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := T1)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern : T1)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := T1)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2__S_for_F.
  Context {F Fut S T1 T2 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := T1 * T2)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern : T1 * T2)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := T1 * T2)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3__S_for_F.
  Context {F Fut S T1 T2 T3 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := (T1 * T2) * T3)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern : (T1 * T2) * T3)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := (T1 * T2) * T3)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4__S_for_F.
  Context {F Fut S T1 T2 T3 T4 : Set}.
  
  Context
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := ((T1 * T2) * T3) * T4)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern : ((T1 * T2) * T3) * T4)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := ((T1 * T2) * T3) * T4)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5__S_for_F.
  Context {F Fut S T1 T2 T3 T4 T5 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F (Args := (((T1 * T2) * T3) * T4) * T5)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern : (((T1 * T2) * T3) * T4) * T5)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := (((T1 * T2) * T3) * T4) * T5)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6__S_for_F.
  Context {F Fut S T1 T2 T3 T4 T5 T6 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((T1 * T2) * T3) * T4) * T5) * T6)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern : ((((T1 * T2) * T3) * T4) * T5) * T6)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := ((((T1 * T2) * T3) * T4) * T5) * T6)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7__S_for_F.
  Context {F Fut S T1 T2 T3 T4 T5 T6 T7 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern : (((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := (((((T1 * T2) * T3) * T4) * T5) * T6) * T7)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
  Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern : ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := ((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
  Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern : (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := (((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
  Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern
        :
        ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := ((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
  Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern
        :
        (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := (((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
  Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern
        :
        ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := ((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
  Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern
        :
        (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := (((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
      *
      T11)
      *
      T12)
      *
      T13)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
  Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern
        :
        ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := ((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
  Context {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern
        :
        (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := (((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15__S_for_F.

Module  Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
Section Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
  Context
    {F Fut S T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 : Set}.
  
  Context
    {ℋ_0 :
      core.ops.function.FnOnce.Trait F
        (Args := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8)
        *
        T9)
        *
        T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)}
    {ℋ_1 : core.future.future.Future.Trait Fut}
    {ℋ_2 : core.marker.Send.Trait Fut}
    {ℋ_3 :
      axum_core.response.into_response.IntoResponse.Trait
          Fut::type["Output"].t}.
  
  Definition Self : Set := F.
  
  (*
               type Future = Map<Fut, fn(Fut::Output) -> Response>;
  *)
  Definition Future : Set :=
    futures_util.future.future.Map.t
        Fut
        (Fut::type["Output"].t ->
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T)).
  
  (*
               fn call(
                   self,
                   ($($ty,)* ): ($($ty,)* ),
                   _state: S,
               ) -> <Self as HandlerCallWithExtractors<($($ty,)* ), S>>::Future {
                   self($($ty,)* ).map(IntoResponse::into_response)
               }
  *)
  Definition call
      (self : Self)
      (Pattern
        :
        ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9) * T10)
        *
        T11)
        *
        T12)
        *
        T13)
        *
        T14)
        *
        T15)
        *
        T16)
      (_state : S)
      :
        M
          (axum_extra.handler.HandlerCallWithExtractors.Future
            (Self := Self)
            (Trait := ltac:(refine _))) :=
    let* self := M.alloc self in
    let* Pattern := M.alloc Pattern in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum_extra.handler.HandlerCallWithExtractors.Required.Trait Self
      (T := ((((((((((((((T1 * T2) * T3) * T4) * T5) * T6) * T7) * T8) * T9)
      *
      T10)
      *
      T11)
      *
      T12)
      *
      T13)
      *
      T14)
      *
      T15)
      *
      T16)
      (S := S) := {
    axum_extra.handler.HandlerCallWithExtractors.Future := Future;
    axum_extra.handler.HandlerCallWithExtractors.call := call;
    axum_extra.handler.HandlerCallWithExtractors.into_handler := Datatypes.None;
    axum_extra.handler.HandlerCallWithExtractors.or := Datatypes.None;
  }.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.
End Impl_axum_extra_handler_HandlerCallWithExtractors_Tuple_T1_T2_T3_T4_T5_T6_T7_T8_T9_T10_T11_T12_T13_T14_T15_T16__S_for_F.

Module  IntoHandler.
Section IntoHandler.
  Context (H T S : Set).
  
  Record t : Set := {
    handler : H;
    _marker : core.marker.PhantomData.t (T * S);
  }.
  
  Definition Get_handler :=
    Ref.map
      (fun α => Some α.(handler))
      (fun β α => Some (α <| handler := β |>)).
  Definition Get__marker :=
    Ref.map
      (fun α => Some α.(_marker))
      (fun β α => Some (α <| _marker := β |>)).
End IntoHandler.
End IntoHandler.

Module  Impl_axum_handler_Handler_T_S_for_axum_extra_handler_IntoHandler_t_H_T_S.
Section Impl_axum_handler_Handler_T_S_for_axum_extra_handler_IntoHandler_t_H_T_S.
  Context {H T S : Set}.
  
  Context
    {ℋ_0 :
      axum_extra.handler.HandlerCallWithExtractors.Trait H (T := T) (S := S)}
    {ℋ_1 : core.clone.Clone.Trait H}
    {ℋ_2 : core.marker.Send.Trait H}
    {ℋ_3 :
      axum_core.extract.FromRequest.Trait T
        (S := S)
        (M := axum_core.extract.FromRequest.Default.M T)}
    {ℋ_4 : core.marker.Send.Trait T}
    {ℋ_5 : core.marker.Send.Trait T::type["Rejection"].t}
    {ℋ_6 : core.marker.Send.Trait S}
    {ℋ_7 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum_extra.handler.IntoHandler.t H T S.
  
  (*
      type Future = BoxFuture<'static, Response>;
  *)
  Definition Future : Set :=
    ltac:(futures_core.future.BoxFuture
        ltac:(axum_core.response.Response
          axum_core.response.Response.Default.T)).
  
  (*
      fn call(self, req: Request, state: S) -> Self::Future {
          let req = req.map(Body::new);
          Box::pin(async move {
              match T::from_request(req, &state).await {
                  Ok(t) => self.handler.call(t, state).await,
                  Err(rejection) => rejection.into_response(),
              }
          })
      }
  *)
  Definition call
      (self : Self)
      (req
        :
        ltac:(axum_core.extract.Request axum_core.extract.Request.Default.T))
      (state : S)
      : M Future :=
    let* self := M.alloc self in
    let* req := M.alloc req in
    let* state := M.alloc state in
    M.read foo.
  
  Global Instance AssociatedFunction_call :
    Notations.DoubleColon Self "call" := {
    Notations.double_colon := call;
  }.
  
  Global Instance ℐ :
    axum.handler.Handler.Required.Trait Self (T := T) (S := S) := {
    axum.handler.Handler.Future := Future;
    axum.handler.Handler.call := call;
    axum.handler.Handler.layer := Datatypes.None;
    axum.handler.Handler.with_state := Datatypes.None;
  }.
End Impl_axum_handler_Handler_T_S_for_axum_extra_handler_IntoHandler_t_H_T_S.
End Impl_axum_handler_Handler_T_S_for_axum_extra_handler_IntoHandler_t_H_T_S.

Module  Impl_core_marker_Copy_for_axum_extra_handler_IntoHandler_t_H_T_S.
Section Impl_core_marker_Copy_for_axum_extra_handler_IntoHandler_t_H_T_S.
  Context {H T S : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait H}.
  
  Definition Self : Set := axum_extra.handler.IntoHandler.t H T S.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extra_handler_IntoHandler_t_H_T_S.
End Impl_core_marker_Copy_for_axum_extra_handler_IntoHandler_t_H_T_S.

Module  Impl_core_clone_Clone_for_axum_extra_handler_IntoHandler_t_H_T_S.
Section Impl_core_clone_Clone_for_axum_extra_handler_IntoHandler_t_H_T_S.
  Context {H T S : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait H}.
  
  Definition Self : Set := axum_extra.handler.IntoHandler.t H T S.
  
  (*
      fn clone(&self) -> Self {
          Self {
              handler: self.handler.clone(),
              _marker: self._marker,
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_handler_IntoHandler_t_H_T_S.
End Impl_core_clone_Clone_for_axum_extra_handler_IntoHandler_t_H_T_S.

Module middleware.
  (*
  pub fn option_layer<L>(layer: Option<L>) -> Either<L, Identity> {
      layer
          .map(Either::E1)
          .unwrap_or_else(|| Either::E2(Identity::new()))
  }
  *)
  Definition option_layer
      {L : Set}
      (layer : core.option.Option.t L)
      : M (axum_extra.either.Either.t L tower_layer.identity.Identity.t) :=
    let* layer := M.alloc layer in
    M.read foo.
End middleware.

(*
pub fn option_layer<L>(layer: Option<L>) -> Either<L, Identity> {
    layer
        .map(Either::E1)
        .unwrap_or_else(|| Either::E2(Identity::new()))
}
*)
Definition option_layer
    {L : Set}
    (layer : core.option.Option.t L)
    : M (axum_extra.either.Either.t L tower_layer.identity.Identity.t) :=
  let* layer := M.alloc layer in
  M.read foo.

Module response.
  Module  Html.
  Section Html.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Html.
  End Html.
  
  Module  Impl_core_clone_Clone_for_axum_extra_response_Html_t_T.
  Section Impl_core_clone_Clone_for_axum_extra_response_Html_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum_extra.response.Html.t T.
    
    (*
            Clone
    *)
    Definition clone (self : ref Self) : M (axum_extra.response.Html.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_response_Html_t_T.
  End Impl_core_clone_Clone_for_axum_extra_response_Html_t_T.
  
  Module  Impl_core_marker_Copy_for_axum_extra_response_Html_t_T.
  Section Impl_core_marker_Copy_for_axum_extra_response_Html_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum_extra.response.Html.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extra_response_Html_t_T.
  End Impl_core_marker_Copy_for_axum_extra_response_Html_t_T.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_response_Html_t_T.
  Section Impl_core_fmt_Debug_for_axum_extra_response_Html_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum_extra.response.Html.t T.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_response_Html_t_T.
  End Impl_core_fmt_Debug_for_axum_extra_response_Html_t_T.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Html_t_T.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Html_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
    
    Definition Self : Set := axum_extra.response.Html.t T.
    
    (*
                fn into_response(self) -> axum::response::Response {
                    (
                        [(
                            http::header::CONTENT_TYPE,
                            http::HeaderValue::from_static($mime),
                        )],
                        self.0,
                    )
                        .into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Html_t_T.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Html_t_T.
  
  Module  Impl_core_convert_From_T_for_axum_extra_response_Html_t_T.
  Section Impl_core_convert_From_T_for_axum_extra_response_Html_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum_extra.response.Html.t T.
    
    (*
                fn from(inner: T) -> Self {
                    Self(inner)
                }
    *)
    Definition from (inner : T) : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_T_for_axum_extra_response_Html_t_T.
  End Impl_core_convert_From_T_for_axum_extra_response_Html_t_T.
  
  Module  JavaScript.
  Section JavaScript.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End JavaScript.
  End JavaScript.
  
  Module  Impl_core_clone_Clone_for_axum_extra_response_JavaScript_t_T.
  Section Impl_core_clone_Clone_for_axum_extra_response_JavaScript_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum_extra.response.JavaScript.t T.
    
    (*
            Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum_extra.response.JavaScript.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_response_JavaScript_t_T.
  End Impl_core_clone_Clone_for_axum_extra_response_JavaScript_t_T.
  
  Module  Impl_core_marker_Copy_for_axum_extra_response_JavaScript_t_T.
  Section Impl_core_marker_Copy_for_axum_extra_response_JavaScript_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum_extra.response.JavaScript.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extra_response_JavaScript_t_T.
  End Impl_core_marker_Copy_for_axum_extra_response_JavaScript_t_T.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_response_JavaScript_t_T.
  Section Impl_core_fmt_Debug_for_axum_extra_response_JavaScript_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum_extra.response.JavaScript.t T.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_response_JavaScript_t_T.
  End Impl_core_fmt_Debug_for_axum_extra_response_JavaScript_t_T.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_JavaScript_t_T.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_JavaScript_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
    
    Definition Self : Set := axum_extra.response.JavaScript.t T.
    
    (*
                fn into_response(self) -> axum::response::Response {
                    (
                        [(
                            http::header::CONTENT_TYPE,
                            http::HeaderValue::from_static($mime),
                        )],
                        self.0,
                    )
                        .into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_JavaScript_t_T.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_JavaScript_t_T.
  
  Module  Impl_core_convert_From_T_for_axum_extra_response_JavaScript_t_T.
  Section Impl_core_convert_From_T_for_axum_extra_response_JavaScript_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum_extra.response.JavaScript.t T.
    
    (*
                fn from(inner: T) -> Self {
                    Self(inner)
                }
    *)
    Definition from (inner : T) : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_T_for_axum_extra_response_JavaScript_t_T.
  End Impl_core_convert_From_T_for_axum_extra_response_JavaScript_t_T.
  
  Module  Css.
  Section Css.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Css.
  End Css.
  
  Module  Impl_core_clone_Clone_for_axum_extra_response_Css_t_T.
  Section Impl_core_clone_Clone_for_axum_extra_response_Css_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum_extra.response.Css.t T.
    
    (*
            Clone
    *)
    Definition clone (self : ref Self) : M (axum_extra.response.Css.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_response_Css_t_T.
  End Impl_core_clone_Clone_for_axum_extra_response_Css_t_T.
  
  Module  Impl_core_marker_Copy_for_axum_extra_response_Css_t_T.
  Section Impl_core_marker_Copy_for_axum_extra_response_Css_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum_extra.response.Css.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extra_response_Css_t_T.
  End Impl_core_marker_Copy_for_axum_extra_response_Css_t_T.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_response_Css_t_T.
  Section Impl_core_fmt_Debug_for_axum_extra_response_Css_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum_extra.response.Css.t T.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_response_Css_t_T.
  End Impl_core_fmt_Debug_for_axum_extra_response_Css_t_T.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Css_t_T.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Css_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
    
    Definition Self : Set := axum_extra.response.Css.t T.
    
    (*
                fn into_response(self) -> axum::response::Response {
                    (
                        [(
                            http::header::CONTENT_TYPE,
                            http::HeaderValue::from_static($mime),
                        )],
                        self.0,
                    )
                        .into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Css_t_T.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Css_t_T.
  
  Module  Impl_core_convert_From_T_for_axum_extra_response_Css_t_T.
  Section Impl_core_convert_From_T_for_axum_extra_response_Css_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum_extra.response.Css.t T.
    
    (*
                fn from(inner: T) -> Self {
                    Self(inner)
                }
    *)
    Definition from (inner : T) : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_T_for_axum_extra_response_Css_t_T.
  End Impl_core_convert_From_T_for_axum_extra_response_Css_t_T.
  
  Module  Wasm.
  Section Wasm.
    Context {T : Set}.
    
    Record t : Set := {
      x0 : T;
    }.
    
    Definition Get_0 :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  End Wasm.
  End Wasm.
  
  Module  Impl_core_clone_Clone_for_axum_extra_response_Wasm_t_T.
  Section Impl_core_clone_Clone_for_axum_extra_response_Wasm_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum_extra.response.Wasm.t T.
    
    (*
            Clone
    *)
    Definition clone (self : ref Self) : M (axum_extra.response.Wasm.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_extra_response_Wasm_t_T.
  End Impl_core_clone_Clone_for_axum_extra_response_Wasm_t_T.
  
  Module  Impl_core_marker_Copy_for_axum_extra_response_Wasm_t_T.
  Section Impl_core_marker_Copy_for_axum_extra_response_Wasm_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum_extra.response.Wasm.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_extra_response_Wasm_t_T.
  End Impl_core_marker_Copy_for_axum_extra_response_Wasm_t_T.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_response_Wasm_t_T.
  Section Impl_core_fmt_Debug_for_axum_extra_response_Wasm_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum_extra.response.Wasm.t T.
    
    (*
            Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_response_Wasm_t_T.
  End Impl_core_fmt_Debug_for_axum_extra_response_Wasm_t_T.
  
  Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Wasm_t_T.
  Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Wasm_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
    
    Definition Self : Set := axum_extra.response.Wasm.t T.
    
    (*
                fn into_response(self) -> axum::response::Response {
                    (
                        [(
                            http::header::CONTENT_TYPE,
                            http::HeaderValue::from_static($mime),
                        )],
                        self.0,
                    )
                        .into_response()
                }
    *)
    Definition into_response
        (self : Self)
        :
          M
            ltac:(axum_core.response.Response
              axum_core.response.Response.Default.T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_response :
      Notations.DoubleColon Self "into_response" := {
      Notations.double_colon := into_response;
    }.
    
    Global Instance ℐ :
      axum_core.response.into_response.IntoResponse.Trait Self := {
      axum_core.response.into_response.IntoResponse.into_response :=
        into_response;
    }.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Wasm_t_T.
  End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Wasm_t_T.
  
  Module  Impl_core_convert_From_T_for_axum_extra_response_Wasm_t_T.
  Section Impl_core_convert_From_T_for_axum_extra_response_Wasm_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum_extra.response.Wasm.t T.
    
    (*
                fn from(inner: T) -> Self {
                    Self(inner)
                }
    *)
    Definition from (inner : T) : M Self :=
      let* inner := M.alloc inner in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_T_for_axum_extra_response_Wasm_t_T.
  End Impl_core_convert_From_T_for_axum_extra_response_Wasm_t_T.
End response.

Module  Html.
Section Html.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Html.
End Html.

Module  Impl_core_clone_Clone_for_axum_extra_response_Html_t_T.
Section Impl_core_clone_Clone_for_axum_extra_response_Html_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum_extra.response.Html.t T.
  
  (*
          Clone
  *)
  Definition clone (self : ref Self) : M (axum_extra.response.Html.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_response_Html_t_T.
End Impl_core_clone_Clone_for_axum_extra_response_Html_t_T.

Module  Impl_core_marker_Copy_for_axum_extra_response_Html_t_T.
Section Impl_core_marker_Copy_for_axum_extra_response_Html_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum_extra.response.Html.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extra_response_Html_t_T.
End Impl_core_marker_Copy_for_axum_extra_response_Html_t_T.

Module  Impl_core_fmt_Debug_for_axum_extra_response_Html_t_T.
Section Impl_core_fmt_Debug_for_axum_extra_response_Html_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum_extra.response.Html.t T.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_response_Html_t_T.
End Impl_core_fmt_Debug_for_axum_extra_response_Html_t_T.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Html_t_T.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Html_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
  
  Definition Self : Set := axum_extra.response.Html.t T.
  
  (*
              fn into_response(self) -> axum::response::Response {
                  (
                      [(
                          http::header::CONTENT_TYPE,
                          http::HeaderValue::from_static($mime),
                      )],
                      self.0,
                  )
                      .into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Html_t_T.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Html_t_T.

Module  Impl_core_convert_From_T_for_axum_extra_response_Html_t_T.
Section Impl_core_convert_From_T_for_axum_extra_response_Html_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum_extra.response.Html.t T.
  
  (*
              fn from(inner: T) -> Self {
                  Self(inner)
              }
  *)
  Definition from (inner : T) : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_T_for_axum_extra_response_Html_t_T.
End Impl_core_convert_From_T_for_axum_extra_response_Html_t_T.

Module  JavaScript.
Section JavaScript.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End JavaScript.
End JavaScript.

Module  Impl_core_clone_Clone_for_axum_extra_response_JavaScript_t_T.
Section Impl_core_clone_Clone_for_axum_extra_response_JavaScript_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum_extra.response.JavaScript.t T.
  
  (*
          Clone
  *)
  Definition clone (self : ref Self) : M (axum_extra.response.JavaScript.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_response_JavaScript_t_T.
End Impl_core_clone_Clone_for_axum_extra_response_JavaScript_t_T.

Module  Impl_core_marker_Copy_for_axum_extra_response_JavaScript_t_T.
Section Impl_core_marker_Copy_for_axum_extra_response_JavaScript_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum_extra.response.JavaScript.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extra_response_JavaScript_t_T.
End Impl_core_marker_Copy_for_axum_extra_response_JavaScript_t_T.

Module  Impl_core_fmt_Debug_for_axum_extra_response_JavaScript_t_T.
Section Impl_core_fmt_Debug_for_axum_extra_response_JavaScript_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum_extra.response.JavaScript.t T.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_response_JavaScript_t_T.
End Impl_core_fmt_Debug_for_axum_extra_response_JavaScript_t_T.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_JavaScript_t_T.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_JavaScript_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
  
  Definition Self : Set := axum_extra.response.JavaScript.t T.
  
  (*
              fn into_response(self) -> axum::response::Response {
                  (
                      [(
                          http::header::CONTENT_TYPE,
                          http::HeaderValue::from_static($mime),
                      )],
                      self.0,
                  )
                      .into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_JavaScript_t_T.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_JavaScript_t_T.

Module  Impl_core_convert_From_T_for_axum_extra_response_JavaScript_t_T.
Section Impl_core_convert_From_T_for_axum_extra_response_JavaScript_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum_extra.response.JavaScript.t T.
  
  (*
              fn from(inner: T) -> Self {
                  Self(inner)
              }
  *)
  Definition from (inner : T) : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_T_for_axum_extra_response_JavaScript_t_T.
End Impl_core_convert_From_T_for_axum_extra_response_JavaScript_t_T.

Module  Css.
Section Css.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Css.
End Css.

Module  Impl_core_clone_Clone_for_axum_extra_response_Css_t_T.
Section Impl_core_clone_Clone_for_axum_extra_response_Css_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum_extra.response.Css.t T.
  
  (*
          Clone
  *)
  Definition clone (self : ref Self) : M (axum_extra.response.Css.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_response_Css_t_T.
End Impl_core_clone_Clone_for_axum_extra_response_Css_t_T.

Module  Impl_core_marker_Copy_for_axum_extra_response_Css_t_T.
Section Impl_core_marker_Copy_for_axum_extra_response_Css_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum_extra.response.Css.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extra_response_Css_t_T.
End Impl_core_marker_Copy_for_axum_extra_response_Css_t_T.

Module  Impl_core_fmt_Debug_for_axum_extra_response_Css_t_T.
Section Impl_core_fmt_Debug_for_axum_extra_response_Css_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum_extra.response.Css.t T.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_response_Css_t_T.
End Impl_core_fmt_Debug_for_axum_extra_response_Css_t_T.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Css_t_T.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Css_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
  
  Definition Self : Set := axum_extra.response.Css.t T.
  
  (*
              fn into_response(self) -> axum::response::Response {
                  (
                      [(
                          http::header::CONTENT_TYPE,
                          http::HeaderValue::from_static($mime),
                      )],
                      self.0,
                  )
                      .into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Css_t_T.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Css_t_T.

Module  Impl_core_convert_From_T_for_axum_extra_response_Css_t_T.
Section Impl_core_convert_From_T_for_axum_extra_response_Css_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum_extra.response.Css.t T.
  
  (*
              fn from(inner: T) -> Self {
                  Self(inner)
              }
  *)
  Definition from (inner : T) : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_T_for_axum_extra_response_Css_t_T.
End Impl_core_convert_From_T_for_axum_extra_response_Css_t_T.

Module  Wasm.
Section Wasm.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Wasm.
End Wasm.

Module  Impl_core_clone_Clone_for_axum_extra_response_Wasm_t_T.
Section Impl_core_clone_Clone_for_axum_extra_response_Wasm_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum_extra.response.Wasm.t T.
  
  (*
          Clone
  *)
  Definition clone (self : ref Self) : M (axum_extra.response.Wasm.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_extra_response_Wasm_t_T.
End Impl_core_clone_Clone_for_axum_extra_response_Wasm_t_T.

Module  Impl_core_marker_Copy_for_axum_extra_response_Wasm_t_T.
Section Impl_core_marker_Copy_for_axum_extra_response_Wasm_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum_extra.response.Wasm.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_extra_response_Wasm_t_T.
End Impl_core_marker_Copy_for_axum_extra_response_Wasm_t_T.

Module  Impl_core_fmt_Debug_for_axum_extra_response_Wasm_t_T.
Section Impl_core_fmt_Debug_for_axum_extra_response_Wasm_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum_extra.response.Wasm.t T.
  
  (*
          Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_response_Wasm_t_T.
End Impl_core_fmt_Debug_for_axum_extra_response_Wasm_t_T.

Module  Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Wasm_t_T.
Section Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Wasm_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : axum_core.response.into_response.IntoResponse.Trait T}.
  
  Definition Self : Set := axum_extra.response.Wasm.t T.
  
  (*
              fn into_response(self) -> axum::response::Response {
                  (
                      [(
                          http::header::CONTENT_TYPE,
                          http::HeaderValue::from_static($mime),
                      )],
                      self.0,
                  )
                      .into_response()
              }
  *)
  Definition into_response
      (self : Self)
      :
        M
          ltac:(axum_core.response.Response
            axum_core.response.Response.Default.T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_response :
    Notations.DoubleColon Self "into_response" := {
    Notations.double_colon := into_response;
  }.
  
  Global Instance ℐ :
    axum_core.response.into_response.IntoResponse.Trait Self := {
    axum_core.response.into_response.IntoResponse.into_response :=
      into_response;
  }.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Wasm_t_T.
End Impl_axum_core_response_into_response_IntoResponse_for_axum_extra_response_Wasm_t_T.

Module  Impl_core_convert_From_T_for_axum_extra_response_Wasm_t_T.
Section Impl_core_convert_From_T_for_axum_extra_response_Wasm_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum_extra.response.Wasm.t T.
  
  (*
              fn from(inner: T) -> Self {
                  Self(inner)
              }
  *)
  Definition from (inner : T) : M Self :=
    let* inner := M.alloc inner in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_T_for_axum_extra_response_Wasm_t_T.
End Impl_core_convert_From_T_for_axum_extra_response_Wasm_t_T.

Module routing.
  Module resource.
    Module  Resource.
    Section Resource.
      Context (S : Set).
      
      Record t : Set := {
        name : alloc.string.String.t;
        router : axum.routing.Router.t S;
      }.
      
      Definition Get_name :=
        Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>)).
      Definition Get_router :=
        Ref.map
          (fun α => Some α.(router))
          (fun β α => Some (α <| router := β |>)).
      Module Default.
        Definition S := unit.
      End Default.
    End Resource.
    End Resource.
    
    Module  Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.
    Section Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.
      Context {S : Set}.
      
      Context {ℋ_0 : core.fmt.Debug.Trait S}.
      
      Definition Self : Set := axum_extra.routing.resource.Resource.t S.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        M.read foo.
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.
    End Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.
    
    Module  Impl_axum_extra_routing_resource_Resource_t_S.
    Section Impl_axum_extra_routing_resource_Resource_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum_extra.routing.resource.Resource.t S.
      
      (*
          pub fn named(resource_name: &str) -> Self {
              Self {
                  name: resource_name.to_owned(),
                  router: Router::new(),
              }
          }
      *)
      Definition named (resource_name : ref str.t) : M Self :=
        let* resource_name := M.alloc resource_name in
        M.read foo.
      
      Global Instance AssociatedFunction_named :
        Notations.DoubleColon Self "named" := {
        Notations.double_colon := named;
      }.
      
      (*
          pub fn index<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
          {
              let path = self.index_create_path();
              self.route(&path, get(handler))
          }
      *)
      Definition index
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_index
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
        Notations.DoubleColon Self "index" := {
        Notations.double_colon := index (H := H) (T := T);
      }.
      
      (*
          pub fn create<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
          {
              let path = self.index_create_path();
              self.route(&path, post(handler))
          }
      *)
      Definition create
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_create
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
        Notations.DoubleColon Self "create" := {
        Notations.double_colon := create (H := H) (T := T);
      }.
      
      (*
          pub fn new<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
          {
              let path = format!("/{}/new", self.name);
              self.route(&path, get(handler))
          }
      *)
      Definition new
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_new
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new (H := H) (T := T);
      }.
      
      (*
          pub fn show<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
          {
              let path = self.show_update_destroy_path();
              self.route(&path, get(handler))
          }
      *)
      Definition show
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_show
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
        Notations.DoubleColon Self "show" := {
        Notations.double_colon := show (H := H) (T := T);
      }.
      
      (*
          pub fn edit<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
          {
              let path = format!("/{0}/:{0}_id/edit", self.name);
              self.route(&path, get(handler))
          }
      *)
      Definition edit
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_edit
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
        Notations.DoubleColon Self "edit" := {
        Notations.double_colon := edit (H := H) (T := T);
      }.
      
      (*
          pub fn update<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
          {
              let path = self.show_update_destroy_path();
              self.route(
                  &path,
                  on(MethodFilter::PUT.or(MethodFilter::PATCH), handler),
              )
          }
      *)
      Definition update
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_update
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
        Notations.DoubleColon Self "update" := {
        Notations.double_colon := update (H := H) (T := T);
      }.
      
      (*
          pub fn destroy<H, T>(self, handler: H) -> Self
          where
              H: Handler<T, S>,
              T: 'static,
          {
              let path = self.show_update_destroy_path();
              self.route(&path, delete(handler))
          }
      *)
      Definition destroy
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
          (self : Self)
          (handler : H)
          : M Self :=
        let* self := M.alloc self in
        let* handler := M.alloc handler in
        M.read foo.
      
      Global Instance AssociatedFunction_destroy
          {H T : Set}
          {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
        Notations.DoubleColon Self "destroy" := {
        Notations.double_colon := destroy (H := H) (T := T);
      }.
      
      (*
          fn index_create_path(&self) -> String {
              format!("/{}", self.name)
          }
      *)
      Definition index_create_path
          (self : ref Self)
          : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_index_create_path :
        Notations.DoubleColon Self "index_create_path" := {
        Notations.double_colon := index_create_path;
      }.
      
      (*
          fn show_update_destroy_path(&self) -> String {
              format!("/{0}/:{0}_id", self.name)
          }
      *)
      Definition show_update_destroy_path
          (self : ref Self)
          : M alloc.string.String.t :=
        let* self := M.alloc self in
        M.read foo.
      
      Global Instance AssociatedFunction_show_update_destroy_path :
        Notations.DoubleColon Self "show_update_destroy_path" := {
        Notations.double_colon := show_update_destroy_path;
      }.
      
      (*
          fn route(mut self, path: &str, method_router: MethodRouter<S>) -> Self {
              self.router = self.router.route(path, method_router);
              self
          }
      *)
      Definition route
          (self : Self)
          (path : ref str.t)
          (method_router
            :
            axum.routing.method_routing.MethodRouter.t
              S
              axum.routing.method_routing.MethodRouter.Default.E)
          : M Self :=
        let* self := M.alloc self in
        let* path := M.alloc path in
        let* method_router := M.alloc method_router in
        M.read foo.
      
      Global Instance AssociatedFunction_route :
        Notations.DoubleColon Self "route" := {
        Notations.double_colon := route;
      }.
    End Impl_axum_extra_routing_resource_Resource_t_S.
    End Impl_axum_extra_routing_resource_Resource_t_S.
    
    Module  Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.
    Section Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.routing.Router.t S.
      
      (*
          fn from(resource: Resource<S>) -> Self {
              resource.router
          }
      *)
      Definition from
          (resource : axum_extra.routing.resource.Resource.t S)
          : M Self :=
        let* resource := M.alloc resource in
        M.read foo.
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self
          (T := axum_extra.routing.resource.Resource.t S) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.
    End Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.
  End resource.
  
  Module  RouterExt.
  Section RouterExt.
    Class Trait (Self : Set) {S : Set} : Type := {
      ℒ_0 :: axum_extra.routing.sealed.Sealed.Trait Self;
      route_with_tsr :
        Self ->
          (ref str.t) ->
          (axum.routing.method_routing.MethodRouter.t
            S
            axum.routing.method_routing.MethodRouter.Default.E)
          ->
          M Self;
      route_service_with_tsr
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
        Self -> (ref str.t) -> T -> M Self;
    }.
    
  End RouterExt.
  End RouterExt.
  
  Module  Impl_axum_extra_routing_RouterExt_S_for_axum_routing_Router_t_S.
  Section Impl_axum_extra_routing_RouterExt_S_for_axum_routing_Router_t_S.
    Context {S : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait S}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}.
    
    Definition Self : Set := axum.routing.Router.t S.
    
    (*
        fn route_with_tsr(mut self, path: &str, method_router: MethodRouter<S>) -> Self
        where
            Self: Sized,
        {
            validate_tsr_path(path);
            self = self.route(path, method_router);
            add_tsr_redirect_route(self, path)
        }
    *)
    Definition route_with_tsr
        (self : Self)
        (path : ref str.t)
        (method_router
          :
          axum.routing.method_routing.MethodRouter.t
            S
            axum.routing.method_routing.MethodRouter.Default.E)
        : M Self :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* method_router := M.alloc method_router in
      M.read foo.
    
    Global Instance AssociatedFunction_route_with_tsr :
      Notations.DoubleColon Self "route_with_tsr" := {
      Notations.double_colon := route_with_tsr;
    }.
    
    (*
        fn route_service_with_tsr<T>(mut self, path: &str, service: T) -> Self
        where
            T: Service<Request, Error = Infallible> + Clone + Send + 'static,
            T::Response: IntoResponse,
            T::Future: Send + 'static,
            Self: Sized,
        {
            validate_tsr_path(path);
            self = self.route_service(path, service);
            add_tsr_redirect_route(self, path)
        }
    *)
    Definition route_service_with_tsr
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
        (self : Self)
        (path : ref str.t)
        (service : T)
        : M Self :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* service := M.alloc service in
      M.read foo.
    
    Global Instance AssociatedFunction_route_service_with_tsr
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Notations.DoubleColon Self "route_service_with_tsr" := {
      Notations.double_colon := route_service_with_tsr (T := T);
    }.
    
    Global Instance ℐ : axum_extra.routing.RouterExt.Trait Self (S := S) := {
      axum_extra.routing.RouterExt.route_with_tsr := route_with_tsr;
      axum_extra.routing.RouterExt.route_service_with_tsr
        {T : Set}
        {ℋ_0 :
          tower_service.Service.Trait T
            (Request := ltac:(axum_core.extract.Request
              axum_core.extract.Request.Default.T))}
        {ℋ_1 : core.clone.Clone.Trait T}
        {ℋ_2 : core.marker.Send.Trait T}
        {ℋ_3 :
          axum_core.response.into_response.IntoResponse.Trait
              T::type["Response"].t}
        {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :=
        route_service_with_tsr (T := T);
    }.
  End Impl_axum_extra_routing_RouterExt_S_for_axum_routing_Router_t_S.
  End Impl_axum_extra_routing_RouterExt_S_for_axum_routing_Router_t_S.
  
  (*
  fn validate_tsr_path(path: &str) {
      if path == "/" {
          panic!("Cannot add a trailing slash redirect route for `/`")
      }
  }
  *)
  Definition validate_tsr_path (path : ref str.t) : M unit :=
    let* path := M.alloc path in
    M.read foo.
  
  (*
  fn add_tsr_redirect_route<S>(router: Router<S>, path: &str) -> Router<S>
  where
      S: Clone + Send + Sync + 'static,
  {
      async fn redirect_handler(uri: Uri) -> Response {
          let new_uri = map_path(uri, |path| {
              path.strip_suffix('/')
                  .map(Cow::Borrowed)
                  .unwrap_or_else(|| Cow::Owned(format!("{path}/")))
          });
  
          if let Some(new_uri) = new_uri {
              Redirect::permanent(&new_uri.to_string()).into_response()
          } else {
              StatusCode::BAD_REQUEST.into_response()
          }
      }
  
      if let Some(path_without_trailing_slash) = path.strip_suffix('/') {
          router.route(path_without_trailing_slash, any(redirect_handler))
      } else {
          router.route(&format!("{path}/"), any(redirect_handler))
      }
  }
  *)
  Definition add_tsr_redirect_route
      {S : Set}
      {ℋ_0 : core.clone.Clone.Trait S}
      {ℋ_1 : core.marker.Send.Trait S}
      {ℋ_2 : core.marker.Sync.Trait S}
      (router : axum.routing.Router.t S)
      (path : ref str.t)
      : M (axum.routing.Router.t S) :=
    let* router := M.alloc router in
    let* path := M.alloc path in
    M.read foo.
  
  (*
  fn map_path<F>(original_uri: Uri, f: F) -> Option<Uri>
  where
      F: FnOnce(&str) -> Cow<'_, str>,
  {
      let mut parts = original_uri.into_parts();
      let path_and_query = parts.path_and_query.as_ref()?;
  
      let new_path = f(path_and_query.path());
  
      let new_path_and_query = if let Some(query) = &path_and_query.query() {
          format!("{new_path}?{query}").parse::<PathAndQuery>().ok()?
      } else {
          new_path.parse::<PathAndQuery>().ok()?
      };
      parts.path_and_query = Some(new_path_and_query);
  
      Uri::from_parts(parts).ok()
  }
  *)
  Definition map_path
      {F : Set}
      {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := ref str.t)}
      (original_uri : http.uri.Uri.t)
      (f : F)
      : M (core.option.Option.t http.uri.Uri.t) :=
    let* original_uri := M.alloc original_uri in
    let* f := M.alloc f in
    M.read foo.
  
  Module sealed.
    Module  Sealed.
    Section Sealed.
      Unset Primitive Projections.
      Class Trait (Self : Set) : Type := {
      }.
      Global Set Primitive Projections.
    End Sealed.
    End Sealed.
    
    Module  Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
    Section Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
      Context {S : Set}.
      
      Definition Self : Set := axum.routing.Router.t S.
      
      Global Instance ℐ : axum_extra.routing.sealed.Sealed.Trait Self := {
      }.
    End Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
    End Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
  End sealed.
End routing.

Module resource.
  Module  Resource.
  Section Resource.
    Context (S : Set).
    
    Record t : Set := {
      name : alloc.string.String.t;
      router : axum.routing.Router.t S;
    }.
    
    Definition Get_name :=
      Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>)).
    Definition Get_router :=
      Ref.map
        (fun α => Some α.(router))
        (fun β α => Some (α <| router := β |>)).
    Module Default.
      Definition S := unit.
    End Default.
  End Resource.
  End Resource.
  
  Module  Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.
  Section Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.
    Context {S : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait S}.
    
    Definition Self : Set := axum_extra.routing.resource.Resource.t S.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.
  End Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.
  
  Module  Impl_axum_extra_routing_resource_Resource_t_S_2.
  Section Impl_axum_extra_routing_resource_Resource_t_S_2.
    Context {S : Set}.
    
    Definition Self : Set := axum_extra.routing.resource.Resource.t S.
    
    (*
        pub fn named(resource_name: &str) -> Self {
            Self {
                name: resource_name.to_owned(),
                router: Router::new(),
            }
        }
    *)
    Definition named (resource_name : ref str.t) : M Self :=
      let* resource_name := M.alloc resource_name in
      M.read foo.
    
    Global Instance AssociatedFunction_named :
      Notations.DoubleColon Self "named" := {
      Notations.double_colon := named;
    }.
    
    (*
        pub fn index<H, T>(self, handler: H) -> Self
        where
            H: Handler<T, S>,
            T: 'static,
        {
            let path = self.index_create_path();
            self.route(&path, get(handler))
        }
    *)
    Definition index
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_index
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
      Notations.DoubleColon Self "index" := {
      Notations.double_colon := index (H := H) (T := T);
    }.
    
    (*
        pub fn create<H, T>(self, handler: H) -> Self
        where
            H: Handler<T, S>,
            T: 'static,
        {
            let path = self.index_create_path();
            self.route(&path, post(handler))
        }
    *)
    Definition create
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_create
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
      Notations.DoubleColon Self "create" := {
      Notations.double_colon := create (H := H) (T := T);
    }.
    
    (*
        pub fn new<H, T>(self, handler: H) -> Self
        where
            H: Handler<T, S>,
            T: 'static,
        {
            let path = format!("/{}/new", self.name);
            self.route(&path, get(handler))
        }
    *)
    Definition new
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_new
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon := new (H := H) (T := T);
    }.
    
    (*
        pub fn show<H, T>(self, handler: H) -> Self
        where
            H: Handler<T, S>,
            T: 'static,
        {
            let path = self.show_update_destroy_path();
            self.route(&path, get(handler))
        }
    *)
    Definition show
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_show
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
      Notations.DoubleColon Self "show" := {
      Notations.double_colon := show (H := H) (T := T);
    }.
    
    (*
        pub fn edit<H, T>(self, handler: H) -> Self
        where
            H: Handler<T, S>,
            T: 'static,
        {
            let path = format!("/{0}/:{0}_id/edit", self.name);
            self.route(&path, get(handler))
        }
    *)
    Definition edit
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_edit
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
      Notations.DoubleColon Self "edit" := {
      Notations.double_colon := edit (H := H) (T := T);
    }.
    
    (*
        pub fn update<H, T>(self, handler: H) -> Self
        where
            H: Handler<T, S>,
            T: 'static,
        {
            let path = self.show_update_destroy_path();
            self.route(
                &path,
                on(MethodFilter::PUT.or(MethodFilter::PATCH), handler),
            )
        }
    *)
    Definition update
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_update
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
      Notations.DoubleColon Self "update" := {
      Notations.double_colon := update (H := H) (T := T);
    }.
    
    (*
        pub fn destroy<H, T>(self, handler: H) -> Self
        where
            H: Handler<T, S>,
            T: 'static,
        {
            let path = self.show_update_destroy_path();
            self.route(&path, delete(handler))
        }
    *)
    Definition destroy
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
        (self : Self)
        (handler : H)
        : M Self :=
      let* self := M.alloc self in
      let* handler := M.alloc handler in
      M.read foo.
    
    Global Instance AssociatedFunction_destroy
        {H T : Set}
        {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
      Notations.DoubleColon Self "destroy" := {
      Notations.double_colon := destroy (H := H) (T := T);
    }.
    
    (*
        fn index_create_path(&self) -> String {
            format!("/{}", self.name)
        }
    *)
    Definition index_create_path (self : ref Self) : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_index_create_path :
      Notations.DoubleColon Self "index_create_path" := {
      Notations.double_colon := index_create_path;
    }.
    
    (*
        fn show_update_destroy_path(&self) -> String {
            format!("/{0}/:{0}_id", self.name)
        }
    *)
    Definition show_update_destroy_path
        (self : ref Self)
        : M alloc.string.String.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_show_update_destroy_path :
      Notations.DoubleColon Self "show_update_destroy_path" := {
      Notations.double_colon := show_update_destroy_path;
    }.
    
    (*
        fn route(mut self, path: &str, method_router: MethodRouter<S>) -> Self {
            self.router = self.router.route(path, method_router);
            self
        }
    *)
    Definition route
        (self : Self)
        (path : ref str.t)
        (method_router
          :
          axum.routing.method_routing.MethodRouter.t
            S
            axum.routing.method_routing.MethodRouter.Default.E)
        : M Self :=
      let* self := M.alloc self in
      let* path := M.alloc path in
      let* method_router := M.alloc method_router in
      M.read foo.
    
    Global Instance AssociatedFunction_route :
      Notations.DoubleColon Self "route" := {
      Notations.double_colon := route;
    }.
  End Impl_axum_extra_routing_resource_Resource_t_S_2.
  End Impl_axum_extra_routing_resource_Resource_t_S_2.
  
  Module  Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.
  Section Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.Router.t S.
    
    (*
        fn from(resource: Resource<S>) -> Self {
            resource.router
        }
    *)
    Definition from
        (resource : axum_extra.routing.resource.Resource.t S)
        : M Self :=
      let* resource := M.alloc resource in
      M.read foo.
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self
        (T := axum_extra.routing.resource.Resource.t S) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.
  End Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.
End resource.

Module  Resource.
Section Resource.
  Context (S : Set).
  
  Record t : Set := {
    name : alloc.string.String.t;
    router : axum.routing.Router.t S;
  }.
  
  Definition Get_name :=
    Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>)).
  Definition Get_router :=
    Ref.map (fun α => Some α.(router)) (fun β α => Some (α <| router := β |>)).
  Module Default.
    Definition S := unit.
  End Default.
End Resource.
End Resource.

Module  Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.
Section Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.
  Context {S : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait S}.
  
  Definition Self : Set := axum_extra.routing.resource.Resource.t S.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.
End Impl_core_fmt_Debug_for_axum_extra_routing_resource_Resource_t_S.

Module  Impl_axum_extra_routing_resource_Resource_t_S_3.
Section Impl_axum_extra_routing_resource_Resource_t_S_3.
  Context {S : Set}.
  
  Definition Self : Set := axum_extra.routing.resource.Resource.t S.
  
  (*
      pub fn named(resource_name: &str) -> Self {
          Self {
              name: resource_name.to_owned(),
              router: Router::new(),
          }
      }
  *)
  Definition named (resource_name : ref str.t) : M Self :=
    let* resource_name := M.alloc resource_name in
    M.read foo.
  
  Global Instance AssociatedFunction_named :
    Notations.DoubleColon Self "named" := {
    Notations.double_colon := named;
  }.
  
  (*
      pub fn index<H, T>(self, handler: H) -> Self
      where
          H: Handler<T, S>,
          T: 'static,
      {
          let path = self.index_create_path();
          self.route(&path, get(handler))
      }
  *)
  Definition index
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_index
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
    Notations.DoubleColon Self "index" := {
    Notations.double_colon := index (H := H) (T := T);
  }.
  
  (*
      pub fn create<H, T>(self, handler: H) -> Self
      where
          H: Handler<T, S>,
          T: 'static,
      {
          let path = self.index_create_path();
          self.route(&path, post(handler))
      }
  *)
  Definition create
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_create
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
    Notations.DoubleColon Self "create" := {
    Notations.double_colon := create (H := H) (T := T);
  }.
  
  (*
      pub fn new<H, T>(self, handler: H) -> Self
      where
          H: Handler<T, S>,
          T: 'static,
      {
          let path = format!("/{}/new", self.name);
          self.route(&path, get(handler))
      }
  *)
  Definition new
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_new
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
    Notations.DoubleColon Self "new" := {
    Notations.double_colon := new (H := H) (T := T);
  }.
  
  (*
      pub fn show<H, T>(self, handler: H) -> Self
      where
          H: Handler<T, S>,
          T: 'static,
      {
          let path = self.show_update_destroy_path();
          self.route(&path, get(handler))
      }
  *)
  Definition show
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_show
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
    Notations.DoubleColon Self "show" := {
    Notations.double_colon := show (H := H) (T := T);
  }.
  
  (*
      pub fn edit<H, T>(self, handler: H) -> Self
      where
          H: Handler<T, S>,
          T: 'static,
      {
          let path = format!("/{0}/:{0}_id/edit", self.name);
          self.route(&path, get(handler))
      }
  *)
  Definition edit
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_edit
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
    Notations.DoubleColon Self "edit" := {
    Notations.double_colon := edit (H := H) (T := T);
  }.
  
  (*
      pub fn update<H, T>(self, handler: H) -> Self
      where
          H: Handler<T, S>,
          T: 'static,
      {
          let path = self.show_update_destroy_path();
          self.route(
              &path,
              on(MethodFilter::PUT.or(MethodFilter::PATCH), handler),
          )
      }
  *)
  Definition update
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_update
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
    Notations.DoubleColon Self "update" := {
    Notations.double_colon := update (H := H) (T := T);
  }.
  
  (*
      pub fn destroy<H, T>(self, handler: H) -> Self
      where
          H: Handler<T, S>,
          T: 'static,
      {
          let path = self.show_update_destroy_path();
          self.route(&path, delete(handler))
      }
  *)
  Definition destroy
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)}
      (self : Self)
      (handler : H)
      : M Self :=
    let* self := M.alloc self in
    let* handler := M.alloc handler in
    M.read foo.
  
  Global Instance AssociatedFunction_destroy
      {H T : Set}
      {ℋ_0 : axum.handler.Handler.Trait H (T := T) (S := S)} :
    Notations.DoubleColon Self "destroy" := {
    Notations.double_colon := destroy (H := H) (T := T);
  }.
  
  (*
      fn index_create_path(&self) -> String {
          format!("/{}", self.name)
      }
  *)
  Definition index_create_path (self : ref Self) : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_index_create_path :
    Notations.DoubleColon Self "index_create_path" := {
    Notations.double_colon := index_create_path;
  }.
  
  (*
      fn show_update_destroy_path(&self) -> String {
          format!("/{0}/:{0}_id", self.name)
      }
  *)
  Definition show_update_destroy_path
      (self : ref Self)
      : M alloc.string.String.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_show_update_destroy_path :
    Notations.DoubleColon Self "show_update_destroy_path" := {
    Notations.double_colon := show_update_destroy_path;
  }.
  
  (*
      fn route(mut self, path: &str, method_router: MethodRouter<S>) -> Self {
          self.router = self.router.route(path, method_router);
          self
      }
  *)
  Definition route
      (self : Self)
      (path : ref str.t)
      (method_router
        :
        axum.routing.method_routing.MethodRouter.t
          S
          axum.routing.method_routing.MethodRouter.Default.E)
      : M Self :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* method_router := M.alloc method_router in
    M.read foo.
  
  Global Instance AssociatedFunction_route :
    Notations.DoubleColon Self "route" := {
    Notations.double_colon := route;
  }.
End Impl_axum_extra_routing_resource_Resource_t_S_3.
End Impl_axum_extra_routing_resource_Resource_t_S_3.

Module  Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.
Section Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.Router.t S.
  
  (*
      fn from(resource: Resource<S>) -> Self {
          resource.router
      }
  *)
  Definition from
      (resource : axum_extra.routing.resource.Resource.t S)
      : M Self :=
    let* resource := M.alloc resource in
    M.read foo.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self
      (T := axum_extra.routing.resource.Resource.t S) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.
End Impl_core_convert_From_axum_extra_routing_resource_Resource_t_S_for_axum_routing_Router_t_S.

Module  RouterExt.
Section RouterExt.
  Class Trait (Self : Set) {S : Set} : Type := {
    ℒ_0 :: axum_extra.routing.sealed.Sealed.Trait Self;
    route_with_tsr :
      Self ->
        (ref str.t) ->
        (axum.routing.method_routing.MethodRouter.t
          S
          axum.routing.method_routing.MethodRouter.Default.E)
        ->
        M Self;
    route_service_with_tsr
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
      Self -> (ref str.t) -> T -> M Self;
  }.
  
End RouterExt.
End RouterExt.

Module  Impl_axum_extra_routing_RouterExt_S_for_axum_routing_Router_t_S.
Section Impl_axum_extra_routing_RouterExt_S_for_axum_routing_Router_t_S.
  Context {S : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait S}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.marker.Sync.Trait S}.
  
  Definition Self : Set := axum.routing.Router.t S.
  
  (*
      fn route_with_tsr(mut self, path: &str, method_router: MethodRouter<S>) -> Self
      where
          Self: Sized,
      {
          validate_tsr_path(path);
          self = self.route(path, method_router);
          add_tsr_redirect_route(self, path)
      }
  *)
  Definition route_with_tsr
      (self : Self)
      (path : ref str.t)
      (method_router
        :
        axum.routing.method_routing.MethodRouter.t
          S
          axum.routing.method_routing.MethodRouter.Default.E)
      : M Self :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* method_router := M.alloc method_router in
    M.read foo.
  
  Global Instance AssociatedFunction_route_with_tsr :
    Notations.DoubleColon Self "route_with_tsr" := {
    Notations.double_colon := route_with_tsr;
  }.
  
  (*
      fn route_service_with_tsr<T>(mut self, path: &str, service: T) -> Self
      where
          T: Service<Request, Error = Infallible> + Clone + Send + 'static,
          T::Response: IntoResponse,
          T::Future: Send + 'static,
          Self: Sized,
      {
          validate_tsr_path(path);
          self = self.route_service(path, service);
          add_tsr_redirect_route(self, path)
      }
  *)
  Definition route_service_with_tsr
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t}
      (self : Self)
      (path : ref str.t)
      (service : T)
      : M Self :=
    let* self := M.alloc self in
    let* path := M.alloc path in
    let* service := M.alloc service in
    M.read foo.
  
  Global Instance AssociatedFunction_route_service_with_tsr
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :
    Notations.DoubleColon Self "route_service_with_tsr" := {
    Notations.double_colon := route_service_with_tsr (T := T);
  }.
  
  Global Instance ℐ : axum_extra.routing.RouterExt.Trait Self (S := S) := {
    axum_extra.routing.RouterExt.route_with_tsr := route_with_tsr;
    axum_extra.routing.RouterExt.route_service_with_tsr
      {T : Set}
      {ℋ_0 :
        tower_service.Service.Trait T
          (Request := ltac:(axum_core.extract.Request
            axum_core.extract.Request.Default.T))}
      {ℋ_1 : core.clone.Clone.Trait T}
      {ℋ_2 : core.marker.Send.Trait T}
      {ℋ_3 :
        axum_core.response.into_response.IntoResponse.Trait
            T::type["Response"].t}
      {ℋ_4 : core.marker.Send.Trait T::type["Future"].t} :=
      route_service_with_tsr (T := T);
  }.
End Impl_axum_extra_routing_RouterExt_S_for_axum_routing_Router_t_S.
End Impl_axum_extra_routing_RouterExt_S_for_axum_routing_Router_t_S.

(*
fn validate_tsr_path(path: &str) {
    if path == "/" {
        panic!("Cannot add a trailing slash redirect route for `/`")
    }
}
*)
Definition validate_tsr_path (path : ref str.t) : M unit :=
  let* path := M.alloc path in
  M.read foo.

(*
fn add_tsr_redirect_route<S>(router: Router<S>, path: &str) -> Router<S>
where
    S: Clone + Send + Sync + 'static,
{
    async fn redirect_handler(uri: Uri) -> Response {
        let new_uri = map_path(uri, |path| {
            path.strip_suffix('/')
                .map(Cow::Borrowed)
                .unwrap_or_else(|| Cow::Owned(format!("{path}/")))
        });

        if let Some(new_uri) = new_uri {
            Redirect::permanent(&new_uri.to_string()).into_response()
        } else {
            StatusCode::BAD_REQUEST.into_response()
        }
    }

    if let Some(path_without_trailing_slash) = path.strip_suffix('/') {
        router.route(path_without_trailing_slash, any(redirect_handler))
    } else {
        router.route(&format!("{path}/"), any(redirect_handler))
    }
}
*)
Definition add_tsr_redirect_route
    {S : Set}
    {ℋ_0 : core.clone.Clone.Trait S}
    {ℋ_1 : core.marker.Send.Trait S}
    {ℋ_2 : core.marker.Sync.Trait S}
    (router : axum.routing.Router.t S)
    (path : ref str.t)
    : M (axum.routing.Router.t S) :=
  let* router := M.alloc router in
  let* path := M.alloc path in
  M.read foo.

(*
    async fn redirect_handler(uri: Uri) -> Response {
        let new_uri = map_path(uri, |path| {
            path.strip_suffix('/')
                .map(Cow::Borrowed)
                .unwrap_or_else(|| Cow::Owned(format!("{path}/")))
        });

        if let Some(new_uri) = new_uri {
            Redirect::permanent(&new_uri.to_string()).into_response()
        } else {
            StatusCode::BAD_REQUEST.into_response()
        }
    }
*)
Definition redirect_handler (uri : http.uri.Uri.t) : M OpaqueDef :=
  let* uri := M.alloc uri in
  M.read foo.

Error OpaqueTy.

(*
fn map_path<F>(original_uri: Uri, f: F) -> Option<Uri>
where
    F: FnOnce(&str) -> Cow<'_, str>,
{
    let mut parts = original_uri.into_parts();
    let path_and_query = parts.path_and_query.as_ref()?;

    let new_path = f(path_and_query.path());

    let new_path_and_query = if let Some(query) = &path_and_query.query() {
        format!("{new_path}?{query}").parse::<PathAndQuery>().ok()?
    } else {
        new_path.parse::<PathAndQuery>().ok()?
    };
    parts.path_and_query = Some(new_path_and_query);

    Uri::from_parts(parts).ok()
}
*)
Definition map_path
    {F : Set}
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := ref str.t)}
    (original_uri : http.uri.Uri.t)
    (f : F)
    : M (core.option.Option.t http.uri.Uri.t) :=
  let* original_uri := M.alloc original_uri in
  let* f := M.alloc f in
  M.read foo.

Module sealed.
  Module  Sealed.
  Section Sealed.
    Unset Primitive Projections.
    Class Trait (Self : Set) : Type := {
    }.
    Global Set Primitive Projections.
  End Sealed.
  End Sealed.
  
  Module  Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
  Section Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
    Context {S : Set}.
    
    Definition Self : Set := axum.routing.Router.t S.
    
    Global Instance ℐ : axum_extra.routing.sealed.Sealed.Trait Self := {
    }.
  End Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
  End Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
End sealed.

Module  Sealed.
Section Sealed.
  Unset Primitive Projections.
  Class Trait (Self : Set) : Type := {
  }.
  Global Set Primitive Projections.
End Sealed.
End Sealed.

Module  Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
Section Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
  Context {S : Set}.
  
  Definition Self : Set := axum.routing.Router.t S.
  
  Global Instance ℐ : axum_extra.routing.sealed.Sealed.Trait Self := {
  }.
End Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
End Impl_axum_extra_routing_sealed_Sealed_for_axum_routing_Router_t_S.
