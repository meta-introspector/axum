(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module attr_parsing.
  (*
  pub(crate) fn parse_parenthesized_attribute<K, T>(
      input: ParseStream,
      out: &mut Option<(K, T)>,
  ) -> syn::Result<()>
  where
      K: Parse + ToTokens,
      T: Parse,
  {
      let kw = input.parse()?;
  
      let content;
      syn::parenthesized!(content in input);
      let inner = content.parse()?;
  
      if out.is_some() {
          let kw_name = std::any::type_name::<K>().split("::").last().unwrap();
          let msg = format!("`{kw_name}` specified more than once");
          return Err(syn::Error::new_spanned(kw, msg));
      }
  
      *out = Some((kw, inner));
  
      Ok(())
  }
  *)
  Definition parse_parenthesized_attribute
      {K T : Set}
      {ℋ_0 : syn.parse.Parse.Trait K}
      {ℋ_1 : quote.to_tokens.ToTokens.Trait K}
      {ℋ_2 : syn.parse.Parse.Trait T}
      (input : ltac:(syn.parse.ParseStream))
      (out : mut_ref (core.option.Option.t (K * T)))
      : M ltac:(syn.error.Result unit) :=
    let* input := M.alloc input in
    let* out := M.alloc out in
    M.read foo.
  
  (*
  pub(crate) fn parse_assignment_attribute<K, T>(
      input: ParseStream,
      out: &mut Option<(K, T)>,
  ) -> syn::Result<()>
  where
      K: Parse + ToTokens,
      T: Parse,
  {
      let kw = input.parse()?;
      input.parse::<Token![=]>()?;
      let inner = input.parse()?;
  
      if out.is_some() {
          let kw_name = std::any::type_name::<K>().split("::").last().unwrap();
          let msg = format!("`{kw_name}` specified more than once");
          return Err(syn::Error::new_spanned(kw, msg));
      }
  
      *out = Some((kw, inner));
  
      Ok(())
  }
  *)
  Definition parse_assignment_attribute
      {K T : Set}
      {ℋ_0 : syn.parse.Parse.Trait K}
      {ℋ_1 : quote.to_tokens.ToTokens.Trait K}
      {ℋ_2 : syn.parse.Parse.Trait T}
      (input : ltac:(syn.parse.ParseStream))
      (out : mut_ref (core.option.Option.t (K * T)))
      : M ltac:(syn.error.Result unit) :=
    let* input := M.alloc input in
    let* out := M.alloc out in
    M.read foo.
  
  Module  Combine.
  Section Combine.
    Class Trait (Self : Set) : Type := {
      combine : Self -> Self -> M ltac:(syn.error.Result Self);
    }.
    
  End Combine.
  End Combine.
  
  (*
  pub(crate) fn parse_attrs<T>(ident: &str, attrs: &[syn::Attribute]) -> syn::Result<T>
  where
      T: Combine + Default + Parse,
  {
      attrs
          .iter()
          .filter(|attr| attr.meta.path().is_ident(ident))
          .map(|attr| attr.parse_args::<T>())
          .try_fold(T::default(), |out, next| out.combine(next?))
  }
  *)
  Definition parse_attrs
      {T : Set}
      {ℋ_0 : axum_macros.attr_parsing.Combine.Trait T}
      {ℋ_1 : core.default.Default.Trait T}
      {ℋ_2 : syn.parse.Parse.Trait T}
      (ident : ref str.t)
      (attrs : ref (slice syn.attr.Attribute.t))
      : M ltac:(syn.error.Result T) :=
    let* ident := M.alloc ident in
    let* attrs := M.alloc attrs in
    M.read foo.
  
  (*
  pub(crate) fn combine_attribute<K, T>(a: &mut Option<(K, T)>, b: Option<(K, T)>) -> syn::Result<()>
  where
      K: ToTokens,
  {
      if let Some((kw, inner)) = b {
          if a.is_some() {
              let kw_name = std::any::type_name::<K>().split("::").last().unwrap();
              let msg = format!("`{kw_name}` specified more than once");
              return Err(syn::Error::new_spanned(kw, msg));
          }
          *a = Some((kw, inner));
      }
      Ok(())
  }
  *)
  Definition combine_attribute
      {K T : Set}
      {ℋ_0 : quote.to_tokens.ToTokens.Trait K}
      (a : mut_ref (core.option.Option.t (K * T)))
      (b : core.option.Option.t (K * T))
      : M ltac:(syn.error.Result unit) :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    M.read foo.
  
  (*
  pub(crate) fn combine_unary_attribute<K>(a: &mut Option<K>, b: Option<K>) -> syn::Result<()>
  where
      K: ToTokens,
  {
      if let Some(kw) = b {
          if a.is_some() {
              let kw_name = std::any::type_name::<K>().split("::").last().unwrap();
              let msg = format!("`{kw_name}` specified more than once");
              return Err(syn::Error::new_spanned(kw, msg));
          }
          *a = Some(kw);
      }
      Ok(())
  }
  *)
  Definition combine_unary_attribute
      {K : Set}
      {ℋ_0 : quote.to_tokens.ToTokens.Trait K}
      (a : mut_ref (core.option.Option.t K))
      (b : core.option.Option.t K)
      : M ltac:(syn.error.Result unit) :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    M.read foo.
  
  (*
  pub(crate) fn second<T, K>(tuple: (T, K)) -> K {
      tuple.1
  }
  *)
  Definition second {T K : Set} (tuple : T * K) : M K :=
    let* tuple := M.alloc tuple in
    M.read foo.
End attr_parsing.

(*
pub(crate) fn parse_parenthesized_attribute<K, T>(
    input: ParseStream,
    out: &mut Option<(K, T)>,
) -> syn::Result<()>
where
    K: Parse + ToTokens,
    T: Parse,
{
    let kw = input.parse()?;

    let content;
    syn::parenthesized!(content in input);
    let inner = content.parse()?;

    if out.is_some() {
        let kw_name = std::any::type_name::<K>().split("::").last().unwrap();
        let msg = format!("`{kw_name}` specified more than once");
        return Err(syn::Error::new_spanned(kw, msg));
    }

    *out = Some((kw, inner));

    Ok(())
}
*)
Definition parse_parenthesized_attribute
    {K T : Set}
    {ℋ_0 : syn.parse.Parse.Trait K}
    {ℋ_1 : quote.to_tokens.ToTokens.Trait K}
    {ℋ_2 : syn.parse.Parse.Trait T}
    (input : ltac:(syn.parse.ParseStream))
    (out : mut_ref (core.option.Option.t (K * T)))
    : M ltac:(syn.error.Result unit) :=
  let* input := M.alloc input in
  let* out := M.alloc out in
  M.read foo.

(*
pub(crate) fn parse_assignment_attribute<K, T>(
    input: ParseStream,
    out: &mut Option<(K, T)>,
) -> syn::Result<()>
where
    K: Parse + ToTokens,
    T: Parse,
{
    let kw = input.parse()?;
    input.parse::<Token![=]>()?;
    let inner = input.parse()?;

    if out.is_some() {
        let kw_name = std::any::type_name::<K>().split("::").last().unwrap();
        let msg = format!("`{kw_name}` specified more than once");
        return Err(syn::Error::new_spanned(kw, msg));
    }

    *out = Some((kw, inner));

    Ok(())
}
*)
Definition parse_assignment_attribute
    {K T : Set}
    {ℋ_0 : syn.parse.Parse.Trait K}
    {ℋ_1 : quote.to_tokens.ToTokens.Trait K}
    {ℋ_2 : syn.parse.Parse.Trait T}
    (input : ltac:(syn.parse.ParseStream))
    (out : mut_ref (core.option.Option.t (K * T)))
    : M ltac:(syn.error.Result unit) :=
  let* input := M.alloc input in
  let* out := M.alloc out in
  M.read foo.

Module  Combine.
Section Combine.
  Class Trait (Self : Set) : Type := {
    combine : Self -> Self -> M ltac:(syn.error.Result Self);
  }.
  
End Combine.
End Combine.

(*
pub(crate) fn parse_attrs<T>(ident: &str, attrs: &[syn::Attribute]) -> syn::Result<T>
where
    T: Combine + Default + Parse,
{
    attrs
        .iter()
        .filter(|attr| attr.meta.path().is_ident(ident))
        .map(|attr| attr.parse_args::<T>())
        .try_fold(T::default(), |out, next| out.combine(next?))
}
*)
Definition parse_attrs
    {T : Set}
    {ℋ_0 : axum_macros.attr_parsing.Combine.Trait T}
    {ℋ_1 : core.default.Default.Trait T}
    {ℋ_2 : syn.parse.Parse.Trait T}
    (ident : ref str.t)
    (attrs : ref (slice syn.attr.Attribute.t))
    : M ltac:(syn.error.Result T) :=
  let* ident := M.alloc ident in
  let* attrs := M.alloc attrs in
  M.read foo.

(*
pub(crate) fn combine_attribute<K, T>(a: &mut Option<(K, T)>, b: Option<(K, T)>) -> syn::Result<()>
where
    K: ToTokens,
{
    if let Some((kw, inner)) = b {
        if a.is_some() {
            let kw_name = std::any::type_name::<K>().split("::").last().unwrap();
            let msg = format!("`{kw_name}` specified more than once");
            return Err(syn::Error::new_spanned(kw, msg));
        }
        *a = Some((kw, inner));
    }
    Ok(())
}
*)
Definition combine_attribute
    {K T : Set}
    {ℋ_0 : quote.to_tokens.ToTokens.Trait K}
    (a : mut_ref (core.option.Option.t (K * T)))
    (b : core.option.Option.t (K * T))
    : M ltac:(syn.error.Result unit) :=
  let* a := M.alloc a in
  let* b := M.alloc b in
  M.read foo.

(*
pub(crate) fn combine_unary_attribute<K>(a: &mut Option<K>, b: Option<K>) -> syn::Result<()>
where
    K: ToTokens,
{
    if let Some(kw) = b {
        if a.is_some() {
            let kw_name = std::any::type_name::<K>().split("::").last().unwrap();
            let msg = format!("`{kw_name}` specified more than once");
            return Err(syn::Error::new_spanned(kw, msg));
        }
        *a = Some(kw);
    }
    Ok(())
}
*)
Definition combine_unary_attribute
    {K : Set}
    {ℋ_0 : quote.to_tokens.ToTokens.Trait K}
    (a : mut_ref (core.option.Option.t K))
    (b : core.option.Option.t K)
    : M ltac:(syn.error.Result unit) :=
  let* a := M.alloc a in
  let* b := M.alloc b in
  M.read foo.

(*
pub(crate) fn second<T, K>(tuple: (T, K)) -> K {
    tuple.1
}
*)
Definition second {T K : Set} (tuple : T * K) : M K :=
  let* tuple := M.alloc tuple in
  M.read foo.

Module debug_handler.
  (*
  pub(crate) fn expand(attr: Attrs, item_fn: ItemFn) -> TokenStream {
      let Attrs { state_ty } = attr;
  
      let mut state_ty = state_ty.map(second);
  
      let check_extractor_count = check_extractor_count(&item_fn);
      let check_path_extractor = check_path_extractor(&item_fn);
      let check_output_tuples = check_output_tuples(&item_fn);
      let check_output_impls_into_response = if check_output_tuples.is_empty() {
          check_output_impls_into_response(&item_fn)
      } else {
          check_output_tuples
      };
  
      // If the function is generic, we can't reliably check its inputs or whether the future it
      // returns is `Send`. Skip those checks to avoid unhelpful additional compiler errors.
      let check_inputs_and_future_send = if item_fn.sig.generics.params.is_empty() {
          let mut err = None;
  
          if state_ty.is_none() {
              let state_types_from_args = state_types_from_args(&item_fn);
  
              #[allow(clippy::comparison_chain)]
              if state_types_from_args.len() == 1 {
                  state_ty = state_types_from_args.into_iter().next();
              } else if state_types_from_args.len() > 1 {
                  err = Some(
                      syn::Error::new(
                          Span::call_site(),
                          "can't infer state type, please add set it explicitly, as in \
                           `#[debug_handler(state = MyStateType)]`",
                      )
                      .into_compile_error(),
                  );
              }
          }
  
          err.unwrap_or_else(|| {
              let state_ty = state_ty.unwrap_or_else(|| syn::parse_quote!(()));
  
              let check_future_send = check_future_send(&item_fn);
  
              if let Some(check_input_order) = check_input_order(&item_fn) {
                  quote! {
                      #check_input_order
                      #check_future_send
                  }
              } else {
                  let check_inputs_impls_from_request =
                      check_inputs_impls_from_request(&item_fn, state_ty);
  
                  quote! {
                      #check_inputs_impls_from_request
                      #check_future_send
                  }
              }
          })
      } else {
          syn::Error::new_spanned(
              &item_fn.sig.generics,
              "`#[axum_macros::debug_handler]` doesn't support generic functions",
          )
          .into_compile_error()
      };
  
      quote! {
          #item_fn
          #check_extractor_count
          #check_path_extractor
          #check_output_impls_into_response
          #check_inputs_and_future_send
      }
  }
  *)
  Definition expand
      (attr : axum_macros.debug_handler.Attrs.t)
      (item_fn : syn.item.ItemFn.t)
      : M proc_macro2.TokenStream.t :=
    let* attr := M.alloc attr in
    let* item_fn := M.alloc item_fn in
    M.read foo.
  
  Module kw.
    Module  body.
    Section body.
      Record t : Set := {
        span : ltac:(syn.__private.Span);
      }.
      
      Definition Get_span :=
        Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
    End body.
    End body.
    
    (*
            pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
                span: __S,
            ) -> $ident {
                $ident {
                    span: $crate::__private::IntoSpans::into_spans(span),
                }
            }
    *)
    (* #[allow(dead_code)] - function was ignored by the compiler *)
    Definition body
        {__S : Set}
        {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
        (span : __S)
        : M axum_macros.debug_handler.kw.body.t :=
      let* span := M.alloc span in
      M.read foo.
    
    Module  state.
    Section state.
      Record t : Set := {
        span : ltac:(syn.__private.Span);
      }.
      
      Definition Get_span :=
        Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
    End state.
    End state.
    
    (*
            pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
                span: __S,
            ) -> $ident {
                $ident {
                    span: $crate::__private::IntoSpans::into_spans(span),
                }
            }
    *)
    (* #[allow(dead_code)] - function was ignored by the compiler *)
    Definition state
        {__S : Set}
        {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
        (span : __S)
        : M axum_macros.debug_handler.kw.state.t :=
      let* span := M.alloc span in
      M.read foo.
  End kw.
  
  Module  Attrs.
  Section Attrs.
    Record t : Set := {
      state_ty :
        core.option.Option.t
          (axum_macros.debug_handler.kw.state.t * syn.ty.Type_.t);
    }.
    
    Definition Get_state_ty :=
      Ref.map
        (fun α => Some α.(state_ty))
        (fun β α => Some (α <| state_ty := β |>)).
  End Attrs.
  End Attrs.
  
  Module  Impl_syn_parse_Parse_for_axum_macros_debug_handler_Attrs_t.
  Section Impl_syn_parse_Parse_for_axum_macros_debug_handler_Attrs_t.
    Definition Self : Set := axum_macros.debug_handler.Attrs.t.
    
    (*
        fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
            let mut state_ty = None;
    
            while !input.is_empty() {
                let lh = input.lookahead1();
                if lh.peek(kw::state) {
                    parse_assignment_attribute(input, &mut state_ty)?;
                } else {
                    return Err(lh.error());
                }
    
                let _ = input.parse::<Token![,]>();
            }
    
            Ok(Self { state_ty })
        }
    *)
    Definition parse
        (input : ltac:(syn.parse.ParseStream))
        : M ltac:(syn.error.Result Self) :=
      let* input := M.alloc input in
      M.read foo.
    
    Global Instance AssociatedFunction_parse :
      Notations.DoubleColon Self "parse" := {
      Notations.double_colon := parse;
    }.
    
    Global Instance ℐ : syn.parse.Parse.Trait Self := {
      syn.parse.Parse.parse := parse;
    }.
  End Impl_syn_parse_Parse_for_axum_macros_debug_handler_Attrs_t.
  End Impl_syn_parse_Parse_for_axum_macros_debug_handler_Attrs_t.
  
  (*
  fn check_extractor_count(item_fn: &ItemFn) -> Option<TokenStream> {
      let max_extractors = 16;
      if item_fn.sig.inputs.len() <= max_extractors {
          None
      } else {
          let error_message = format!(
              "Handlers cannot take more than {max_extractors} arguments. \
              Use `(a, b): (ExtractorA, ExtractorA)` to further nest extractors",
          );
          let error = syn::Error::new_spanned(&item_fn.sig.inputs, error_message).to_compile_error();
          Some(error)
      }
  }
  *)
  Definition check_extractor_count
      (item_fn : ref syn.item.ItemFn.t)
      : M (core.option.Option.t proc_macro2.TokenStream.t) :=
    let* item_fn := M.alloc item_fn in
    M.read foo.
  
  (*
  fn extractor_idents(item_fn: &ItemFn) -> impl Iterator<Item = (usize, &syn::FnArg, &syn::Ident)> {
      item_fn
          .sig
          .inputs
          .iter()
          .enumerate()
          .filter_map(|(idx, fn_arg)| match fn_arg {
              FnArg::Receiver(_) => None,
              FnArg::Typed(pat_type) => {
                  if let Type::Path(type_path) = &*pat_type.ty {
                      type_path
                          .path
                          .segments
                          .last()
                          .map(|segment| (idx, fn_arg, &segment.ident))
                  } else {
                      None
                  }
              }
          })
  }
  *)
  Definition extractor_idents (item_fn : ref syn.item.ItemFn.t) : M OpaqueDef :=
    let* item_fn := M.alloc item_fn in
    M.read foo.
  
  (*
  fn check_path_extractor(item_fn: &ItemFn) -> TokenStream {
      let path_extractors = extractor_idents(item_fn)
          .filter(|(_, _, ident)| *ident == "Path")
          .collect::<Vec<_>>();
  
      if path_extractors.len() > 1 {
          path_extractors
              .into_iter()
              .map(|(_, arg, _)| {
                  syn::Error::new_spanned(
                      arg,
                      "Multiple parameters must be extracted with a tuple \
                      `Path<(_, _)>` or a struct `Path<YourParams>`, not by applying \
                      multiple `Path<_>` extractors",
                  )
                  .to_compile_error()
              })
              .collect()
      } else {
          quote! {}
      }
  }
  *)
  Definition check_path_extractor
      (item_fn : ref syn.item.ItemFn.t)
      : M proc_macro2.TokenStream.t :=
    let* item_fn := M.alloc item_fn in
    M.read foo.
  
  (*
  fn is_self_pat_type(typed: &syn::PatType) -> bool {
      let ident = if let syn::Pat::Ident(ident) = &*typed.pat {
          &ident.ident
      } else {
          return false;
      };
  
      ident == "self"
  }
  *)
  Definition is_self_pat_type (typed : ref syn.pat.PatType.t) : M bool.t :=
    let* typed := M.alloc typed in
    M.read foo.
  
  (*
  fn check_inputs_impls_from_request(item_fn: &ItemFn, state_ty: Type) -> TokenStream {
      let takes_self = item_fn.sig.inputs.first().map_or(false, |arg| match arg {
          FnArg::Receiver(_) => true,
          FnArg::Typed(typed) => is_self_pat_type(typed),
      });
  
      WithPosition::new(&item_fn.sig.inputs)
          .enumerate()
          .map(|(idx, arg)| {
              let must_impl_from_request_parts = match &arg {
                  Position::First(_) | Position::Middle(_) => true,
                  Position::Last(_) | Position::Only(_) => false,
              };
  
              let arg = arg.into_inner();
  
              let (span, ty) = match arg {
                  FnArg::Receiver(receiver) => {
                      if receiver.reference.is_some() {
                          return syn::Error::new_spanned(
                              receiver,
                              "Handlers must only take owned values",
                          )
                          .into_compile_error();
                      }
  
                      let span = receiver.span();
                      (span, syn::parse_quote!(Self))
                  }
                  FnArg::Typed(typed) => {
                      let ty = &typed.ty;
                      let span = ty.span();
  
                      if is_self_pat_type(typed) {
                          (span, syn::parse_quote!(Self))
                      } else {
                          (span, ty.clone())
                      }
                  }
              };
  
              let consumes_request = request_consuming_type_name(&ty).is_some();
  
              let check_fn = format_ident!(
                  "__axum_macros_check_{}_{}_from_request_check",
                  item_fn.sig.ident,
                  idx,
                  span = span,
              );
  
              let call_check_fn = format_ident!(
                  "__axum_macros_check_{}_{}_from_request_call_check",
                  item_fn.sig.ident,
                  idx,
                  span = span,
              );
  
              let call_check_fn_body = if takes_self {
                  quote_spanned! {span=>
                      Self::#check_fn();
                  }
              } else {
                  quote_spanned! {span=>
                      #check_fn();
                  }
              };
  
              let check_fn_generics = if must_impl_from_request_parts || consumes_request {
                  quote! {}
              } else {
                  quote! { <M> }
              };
  
              let from_request_bound = if must_impl_from_request_parts {
                  quote_spanned! {span=>
                      #ty: ::axum::extract::FromRequestParts<#state_ty> + Send
                  }
              } else if consumes_request {
                  quote_spanned! {span=>
                      #ty: ::axum::extract::FromRequest<#state_ty> + Send
                  }
              } else {
                  quote_spanned! {span=>
                      #ty: ::axum::extract::FromRequest<#state_ty, M> + Send
                  }
              };
  
              quote_spanned! {span=>
                  #[allow(warnings)]
                  #[allow(unreachable_code)]
                  #[doc(hidden)]
                  fn #check_fn #check_fn_generics()
                  where
                      #from_request_bound,
                  {}
  
                  // we have to call the function to actually trigger a compile error
                  // since the function is generic, just defining it is not enough
                  #[allow(warnings)]
                  #[allow(unreachable_code)]
                  #[doc(hidden)]
                  fn #call_check_fn() {
                      #call_check_fn_body
                  }
              }
          })
          .collect::<TokenStream>()
  }
  *)
  Definition check_inputs_impls_from_request
      (item_fn : ref syn.item.ItemFn.t)
      (state_ty : syn.ty.Type_.t)
      : M proc_macro2.TokenStream.t :=
    let* item_fn := M.alloc item_fn in
    let* state_ty := M.alloc state_ty in
    M.read foo.
  
  (*
  fn check_output_tuples(item_fn: &ItemFn) -> TokenStream {
      let elems = match &item_fn.sig.output {
          ReturnType::Type(_, ty) => match &**ty {
              Type::Tuple(tuple) => &tuple.elems,
              _ => return quote! {},
          },
          ReturnType::Default => return quote! {},
      };
  
      let handler_ident = &item_fn.sig.ident;
  
      match elems.len() {
          0 => quote! {},
          n if n > 17 => syn::Error::new_spanned(
              &item_fn.sig.output,
              "Cannot return tuples with more than 17 elements",
          )
          .to_compile_error(),
          _ => WithPosition::new(elems)
              .enumerate()
              .map(|(idx, arg)| match arg {
                  Position::First(ty) => match extract_clean_typename(ty).as_deref() {
                      Some("StatusCode" | "Response") => quote! {},
                      Some("Parts") => check_is_response_parts(ty, handler_ident, idx),
                      Some(_) | None => {
                          if let Some(tn) = well_known_last_response_type(ty) {
                              syn::Error::new_spanned(
                                  ty,
                                  format!(
                                      "`{tn}` must be the last element \
                                      in a response tuple"
                                  ),
                              )
                              .to_compile_error()
                          } else {
                              check_into_response_parts(ty, handler_ident, idx)
                          }
                      }
                  },
                  Position::Middle(ty) => {
                      if let Some(tn) = well_known_last_response_type(ty) {
                          syn::Error::new_spanned(
                              ty,
                              format!("`{tn}` must be the last element in a response tuple"),
                          )
                          .to_compile_error()
                      } else {
                          check_into_response_parts(ty, handler_ident, idx)
                      }
                  }
                  Position::Last(ty) | Position::Only(ty) => check_into_response(handler_ident, ty),
              })
              .collect::<TokenStream>(),
      }
  }
  *)
  Definition check_output_tuples
      (item_fn : ref syn.item.ItemFn.t)
      : M proc_macro2.TokenStream.t :=
    let* item_fn := M.alloc item_fn in
    M.read foo.
  
  (*
  fn check_into_response(handler: &Ident, ty: &Type) -> TokenStream {
      let (span, ty) = (ty.span(), ty.clone());
  
      let check_fn = format_ident!(
          "__axum_macros_check_{handler}_into_response_check",
          span = span,
      );
  
      let call_check_fn = format_ident!(
          "__axum_macros_check_{handler}_into_response_call_check",
          span = span,
      );
  
      let call_check_fn_body = quote_spanned! {span=>
          #check_fn();
      };
  
      let from_request_bound = quote_spanned! {span=>
          #ty: ::axum::response::IntoResponse
      };
      quote_spanned! {span=>
          #[allow(warnings)]
          #[allow(unreachable_code)]
          #[doc(hidden)]
          fn #check_fn()
          where
              #from_request_bound,
          {}
  
          // we have to call the function to actually trigger a compile error
          // since the function is generic, just defining it is not enough
          #[allow(warnings)]
          #[allow(unreachable_code)]
          #[doc(hidden)]
          fn #call_check_fn() {
              #call_check_fn_body
          }
      }
  }
  *)
  Definition check_into_response
      (handler : ref proc_macro2.Ident.t)
      (ty : ref syn.ty.Type_.t)
      : M proc_macro2.TokenStream.t :=
    let* handler := M.alloc handler in
    let* ty := M.alloc ty in
    M.read foo.
  
  (*
  fn check_is_response_parts(ty: &Type, ident: &Ident, index: usize) -> TokenStream {
      let (span, ty) = (ty.span(), ty.clone());
  
      let check_fn = format_ident!(
          "__axum_macros_check_{}_is_response_parts_{index}_check",
          ident,
          span = span,
      );
  
      quote_spanned! {span=>
          #[allow(warnings)]
          #[allow(unreachable_code)]
          #[doc(hidden)]
          fn #check_fn(parts: #ty) -> ::axum::http::response::Parts {
              parts
          }
      }
  }
  *)
  Definition check_is_response_parts
      (ty : ref syn.ty.Type_.t)
      (ident : ref proc_macro2.Ident.t)
      (index : usize.t)
      : M proc_macro2.TokenStream.t :=
    let* ty := M.alloc ty in
    let* ident := M.alloc ident in
    let* index := M.alloc index in
    M.read foo.
  
  (*
  fn check_into_response_parts(ty: &Type, ident: &Ident, index: usize) -> TokenStream {
      let (span, ty) = (ty.span(), ty.clone());
  
      let check_fn = format_ident!(
          "__axum_macros_check_{}_into_response_parts_{index}_check",
          ident,
          span = span,
      );
  
      let call_check_fn = format_ident!(
          "__axum_macros_check_{}_into_response_parts_{index}_call_check",
          ident,
          span = span,
      );
  
      let call_check_fn_body = quote_spanned! {span=>
          #check_fn();
      };
  
      let from_request_bound = quote_spanned! {span=>
          #ty: ::axum::response::IntoResponseParts
      };
      quote_spanned! {span=>
          #[allow(warnings)]
          #[allow(unreachable_code)]
          #[doc(hidden)]
          fn #check_fn()
          where
              #from_request_bound,
          {}
  
          // we have to call the function to actually trigger a compile error
          // since the function is generic, just defining it is not enough
          #[allow(warnings)]
          #[allow(unreachable_code)]
          #[doc(hidden)]
          fn #call_check_fn() {
              #call_check_fn_body
          }
      }
  }
  *)
  Definition check_into_response_parts
      (ty : ref syn.ty.Type_.t)
      (ident : ref proc_macro2.Ident.t)
      (index : usize.t)
      : M proc_macro2.TokenStream.t :=
    let* ty := M.alloc ty in
    let* ident := M.alloc ident in
    let* index := M.alloc index in
    M.read foo.
  
  (*
  fn check_input_order(item_fn: &ItemFn) -> Option<TokenStream> {
      let types_that_consume_the_request = item_fn
          .sig
          .inputs
          .iter()
          .enumerate()
          .filter_map(|(idx, arg)| {
              let ty = match arg {
                  FnArg::Typed(pat_type) => &*pat_type.ty,
                  FnArg::Receiver(_) => return None,
              };
              let type_name = request_consuming_type_name(ty)?;
  
              Some((idx, type_name, ty.span()))
          })
          .collect::<Vec<_>>();
  
      if types_that_consume_the_request.is_empty() {
          return None;
      };
  
      // exactly one type that consumes the request
      if types_that_consume_the_request.len() == 1 {
          // and that is not the last
          if types_that_consume_the_request[0].0 != item_fn.sig.inputs.len() - 1 {
              let (_idx, type_name, span) = &types_that_consume_the_request[0];
              let error = format!(
                  "`{type_name}` consumes the request body and thus must be \
                  the last argument to the handler function"
              );
              return Some(quote_spanned! {*span=>
                  compile_error!(#error);
              });
          } else {
              return None;
          }
      }
  
      if types_that_consume_the_request.len() == 2 {
          let (_, first, _) = &types_that_consume_the_request[0];
          let (_, second, _) = &types_that_consume_the_request[1];
          let error = format!(
              "Can't have two extractors that consume the request body. \
              `{first}` and `{second}` both do that.",
          );
          let span = item_fn.sig.inputs.span();
          Some(quote_spanned! {span=>
              compile_error!(#error);
          })
      } else {
          let types = WithPosition::new(types_that_consume_the_request)
              .map(|pos| match pos {
                  Position::First((_, type_name, _)) | Position::Middle((_, type_name, _)) => {
                      format!("`{type_name}`, ")
                  }
                  Position::Last((_, type_name, _)) => format!("and `{type_name}`"),
                  Position::Only(_) => unreachable!(),
              })
              .collect::<String>();
  
          let error = format!(
              "Can't have more than one extractor that consume the request body. \
              {types} all do that.",
          );
          let span = item_fn.sig.inputs.span();
          Some(quote_spanned! {span=>
              compile_error!(#error);
          })
      }
  }
  *)
  Definition check_input_order
      (item_fn : ref syn.item.ItemFn.t)
      : M (core.option.Option.t proc_macro2.TokenStream.t) :=
    let* item_fn := M.alloc item_fn in
    M.read foo.
  
  (*
  fn extract_clean_typename(ty: &Type) -> Option<String> {
      let path = match ty {
          Type::Path(type_path) => &type_path.path,
          _ => return None,
      };
      path.segments.last().map(|p| p.ident.to_string())
  }
  *)
  Definition extract_clean_typename
      (ty : ref syn.ty.Type_.t)
      : M (core.option.Option.t alloc.string.String.t) :=
    let* ty := M.alloc ty in
    M.read foo.
  
  (*
  fn request_consuming_type_name(ty: &Type) -> Option<&'static str> {
      let typename = extract_clean_typename(ty)?;
  
      let type_name = match &*typename {
          "Json" => "Json<_>",
          "RawBody" => "RawBody<_>",
          "RawForm" => "RawForm",
          "Multipart" => "Multipart",
          "Protobuf" => "Protobuf",
          "JsonLines" => "JsonLines<_>",
          "Form" => "Form<_>",
          "Request" => "Request<_>",
          "Bytes" => "Bytes",
          "String" => "String",
          "Parts" => "Parts",
          _ => return None,
      };
  
      Some(type_name)
  }
  *)
  Definition request_consuming_type_name
      (ty : ref syn.ty.Type_.t)
      : M (core.option.Option.t (ref str.t)) :=
    let* ty := M.alloc ty in
    M.read foo.
  
  (*
  fn well_known_last_response_type(ty: &Type) -> Option<&'static str> {
      let typename = match extract_clean_typename(ty) {
          Some(tn) => tn,
          None => return None,
      };
  
      let type_name = match &*typename {
          "Json" => "Json<_>",
          "Protobuf" => "Protobuf",
          "JsonLines" => "JsonLines<_>",
          "Form" => "Form<_>",
          "Bytes" => "Bytes",
          "String" => "String",
          _ => return None,
      };
  
      Some(type_name)
  }
  *)
  Definition well_known_last_response_type
      (ty : ref syn.ty.Type_.t)
      : M (core.option.Option.t (ref str.t)) :=
    let* ty := M.alloc ty in
    M.read foo.
  
  (*
  fn check_output_impls_into_response(item_fn: &ItemFn) -> TokenStream {
      let ty = match &item_fn.sig.output {
          syn::ReturnType::Default => return quote! {},
          syn::ReturnType::Type(_, ty) => ty,
      };
      let span = ty.span();
  
      let declare_inputs = item_fn
          .sig
          .inputs
          .iter()
          .filter_map(|arg| match arg {
              FnArg::Receiver(_) => None,
              FnArg::Typed(pat_ty) => {
                  let pat = &pat_ty.pat;
                  let ty = &pat_ty.ty;
                  Some(quote! {
                      let #pat: #ty = panic!();
                  })
              }
          })
          .collect::<TokenStream>();
  
      let block = &item_fn.block;
  
      let make_value_name = format_ident!(
          "__axum_macros_check_{}_into_response_make_value",
          item_fn.sig.ident
      );
  
      let make = if item_fn.sig.asyncness.is_some() {
          quote_spanned! {span=>
              #[allow(warnings)]
              #[allow(unreachable_code)]
              #[doc(hidden)]
              async fn #make_value_name() -> #ty {
                  #declare_inputs
                  #block
              }
          }
      } else {
          quote_spanned! {span=>
              #[allow(warnings)]
              #[allow(unreachable_code)]
              #[doc(hidden)]
              fn #make_value_name() -> #ty {
                  #declare_inputs
                  #block
              }
          }
      };
  
      let name = format_ident!("__axum_macros_check_{}_into_response", item_fn.sig.ident);
  
      if let Some(receiver) = self_receiver(item_fn) {
          quote_spanned! {span=>
              #make
  
              #[allow(warnings)]
              #[allow(unreachable_code)]
              #[doc(hidden)]
              async fn #name() {
                  let value = #receiver #make_value_name().await;
                  fn check<T>(_: T)
                      where T: ::axum::response::IntoResponse
                  {}
                  check(value);
              }
          }
      } else {
          quote_spanned! {span=>
              #[allow(warnings)]
              #[allow(unreachable_code)]
              #[doc(hidden)]
              async fn #name() {
                  #make
  
                  let value = #make_value_name().await;
  
                  fn check<T>(_: T)
                  where T: ::axum::response::IntoResponse
                  {}
  
                  check(value);
              }
          }
      }
  }
  *)
  Definition check_output_impls_into_response
      (item_fn : ref syn.item.ItemFn.t)
      : M proc_macro2.TokenStream.t :=
    let* item_fn := M.alloc item_fn in
    M.read foo.
  
  (*
  fn check_future_send(item_fn: &ItemFn) -> TokenStream {
      if item_fn.sig.asyncness.is_none() {
          match &item_fn.sig.output {
              syn::ReturnType::Default => {
                  return syn::Error::new_spanned(
                      item_fn.sig.fn_token,
                      "Handlers must be `async fn`s",
                  )
                  .into_compile_error();
              }
              syn::ReturnType::Type(_, ty) => ty,
          };
      }
  
      let span = item_fn.sig.ident.span();
  
      let handler_name = &item_fn.sig.ident;
  
      let args = item_fn.sig.inputs.iter().map(|_| {
          quote_spanned! {span=> panic!() }
      });
  
      let name = format_ident!("__axum_macros_check_{}_future", item_fn.sig.ident);
  
      let do_check = quote! {
          fn check<T>(_: T)
              where T: ::std::future::Future + Send
          {}
          check(future);
      };
  
      if let Some(receiver) = self_receiver(item_fn) {
          quote! {
              #[allow(warnings)]
              #[allow(unreachable_code)]
              #[doc(hidden)]
              fn #name() {
                  let future = #receiver #handler_name(#(#args),* );
                  #do_check
              }
          }
      } else {
          quote! {
              #[allow(warnings)]
              #[allow(unreachable_code)]
              #[doc(hidden)]
              fn #name() {
                  #item_fn
                  let future = #handler_name(#(#args),* );
                  #do_check
              }
          }
      }
  }
  *)
  Definition check_future_send
      (item_fn : ref syn.item.ItemFn.t)
      : M proc_macro2.TokenStream.t :=
    let* item_fn := M.alloc item_fn in
    M.read foo.
  
  (*
  fn self_receiver(item_fn: &ItemFn) -> Option<TokenStream> {
      let takes_self = item_fn.sig.inputs.iter().any(|arg| match arg {
          FnArg::Receiver(_) => true,
          FnArg::Typed(typed) => is_self_pat_type(typed),
      });
  
      if takes_self {
          return Some(quote! { Self:: });
      }
  
      if let syn::ReturnType::Type(_, ty) = &item_fn.sig.output {
          if let syn::Type::Path(path) = &**ty {
              let segments = &path.path.segments;
              if segments.len() == 1 {
                  if let Some(last) = segments.last() {
                      match &last.arguments {
                          syn::PathArguments::None if last.ident == "Self" => {
                              return Some(quote! { Self:: });
                          }
                          _ => {}
                      }
                  }
              }
          }
      }
  
      None
  }
  *)
  Definition self_receiver
      (item_fn : ref syn.item.ItemFn.t)
      : M (core.option.Option.t proc_macro2.TokenStream.t) :=
    let* item_fn := M.alloc item_fn in
    M.read foo.
  
  (*
  fn state_types_from_args(item_fn: &ItemFn) -> HashSet<Type> {
      let types = item_fn
          .sig
          .inputs
          .iter()
          .filter_map(|input| match input {
              FnArg::Receiver(_) => None,
              FnArg::Typed(pat_type) => Some(pat_type),
          })
          .map(|pat_type| &*pat_type.ty);
      crate::infer_state_types(types).collect()
  }
  *)
  Definition state_types_from_args
      (item_fn : ref syn.item.ItemFn.t)
      :
        M
          (std.collections.hash.set.HashSet.t
            syn.ty.Type_.t
            std.collections.hash.set.HashSet.Default.S) :=
    let* item_fn := M.alloc item_fn in
    M.read foo.
End debug_handler.

(*
pub(crate) fn expand(attr: Attrs, item_fn: ItemFn) -> TokenStream {
    let Attrs { state_ty } = attr;

    let mut state_ty = state_ty.map(second);

    let check_extractor_count = check_extractor_count(&item_fn);
    let check_path_extractor = check_path_extractor(&item_fn);
    let check_output_tuples = check_output_tuples(&item_fn);
    let check_output_impls_into_response = if check_output_tuples.is_empty() {
        check_output_impls_into_response(&item_fn)
    } else {
        check_output_tuples
    };

    // If the function is generic, we can't reliably check its inputs or whether the future it
    // returns is `Send`. Skip those checks to avoid unhelpful additional compiler errors.
    let check_inputs_and_future_send = if item_fn.sig.generics.params.is_empty() {
        let mut err = None;

        if state_ty.is_none() {
            let state_types_from_args = state_types_from_args(&item_fn);

            #[allow(clippy::comparison_chain)]
            if state_types_from_args.len() == 1 {
                state_ty = state_types_from_args.into_iter().next();
            } else if state_types_from_args.len() > 1 {
                err = Some(
                    syn::Error::new(
                        Span::call_site(),
                        "can't infer state type, please add set it explicitly, as in \
                         `#[debug_handler(state = MyStateType)]`",
                    )
                    .into_compile_error(),
                );
            }
        }

        err.unwrap_or_else(|| {
            let state_ty = state_ty.unwrap_or_else(|| syn::parse_quote!(()));

            let check_future_send = check_future_send(&item_fn);

            if let Some(check_input_order) = check_input_order(&item_fn) {
                quote! {
                    #check_input_order
                    #check_future_send
                }
            } else {
                let check_inputs_impls_from_request =
                    check_inputs_impls_from_request(&item_fn, state_ty);

                quote! {
                    #check_inputs_impls_from_request
                    #check_future_send
                }
            }
        })
    } else {
        syn::Error::new_spanned(
            &item_fn.sig.generics,
            "`#[axum_macros::debug_handler]` doesn't support generic functions",
        )
        .into_compile_error()
    };

    quote! {
        #item_fn
        #check_extractor_count
        #check_path_extractor
        #check_output_impls_into_response
        #check_inputs_and_future_send
    }
}
*)
Definition expand
    (attr : axum_macros.debug_handler.Attrs.t)
    (item_fn : syn.item.ItemFn.t)
    : M proc_macro2.TokenStream.t :=
  let* attr := M.alloc attr in
  let* item_fn := M.alloc item_fn in
  M.read foo.

Module kw.
  Module  body.
  Section body.
    Record t : Set := {
      span : ltac:(syn.__private.Span);
    }.
    
    Definition Get_span :=
      Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
  End body.
  End body.
  
  (*
          pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
              span: __S,
          ) -> $ident {
              $ident {
                  span: $crate::__private::IntoSpans::into_spans(span),
              }
          }
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition body
      {__S : Set}
      {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
      (span : __S)
      : M axum_macros.debug_handler.kw.body.t :=
    let* span := M.alloc span in
    M.read foo.
  
  Module  state.
  Section state.
    Record t : Set := {
      span : ltac:(syn.__private.Span);
    }.
    
    Definition Get_span :=
      Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
  End state.
  End state.
  
  (*
          pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
              span: __S,
          ) -> $ident {
              $ident {
                  span: $crate::__private::IntoSpans::into_spans(span),
              }
          }
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition state
      {__S : Set}
      {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
      (span : __S)
      : M axum_macros.debug_handler.kw.state.t :=
    let* span := M.alloc span in
    M.read foo.
End kw.

Module  body.
Section body.
  Record t : Set := {
    span : ltac:(syn.__private.Span);
  }.
  
  Definition Get_span :=
    Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
End body.
End body.

(*
        pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
            span: __S,
        ) -> $ident {
            $ident {
                span: $crate::__private::IntoSpans::into_spans(span),
            }
        }
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition body
    {__S : Set}
    {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
    (span : __S)
    : M axum_macros.debug_handler.kw.body.t :=
  let* span := M.alloc span in
  M.read foo.

Module  Impl_core_default_Default_for_axum_macros_debug_handler_kw_body_t.
Section Impl_core_default_Default_for_axum_macros_debug_handler_kw_body_t.
  Definition Self : Set := axum_macros.debug_handler.kw.body.t.
  
  (*
                  fn default() -> Self {
                      $ident {
                          span: $crate::__private::Span::call_site(),
                      }
                  }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_macros_debug_handler_kw_body_t.
End Impl_core_default_Default_for_axum_macros_debug_handler_kw_body_t.

Module  Impl_syn_token_private_CustomToken_for_axum_macros_debug_handler_kw_body_t.
Section Impl_syn_token_private_CustomToken_for_axum_macros_debug_handler_kw_body_t.
  Definition Self : Set := axum_macros.debug_handler.kw.body.t.
  
  (*
              fn peek(cursor: $crate::buffer::Cursor) -> $crate::__private::bool {
                  if let $crate::__private::Some((ident, _rest)) = cursor.ident() {
                      ident == $crate::__private::stringify!($ident)
                  } else {
                      false
                  }
              }
  *)
  Definition peek
      (cursor : syn.buffer.Cursor.t)
      : M ltac:(syn.__private.bool) :=
    let* cursor := M.alloc cursor in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
              fn display() -> &'static $crate::__private::str {
                  $crate::__private::concat!("`", $crate::__private::stringify!($ident), "`")
              }
  *)
  Definition display : M (ref ltac:(syn.__private.str)) := M.read foo.
  
  Global Instance AssociatedFunction_display :
    Notations.DoubleColon Self "display" := {
    Notations.double_colon := display;
  }.
  
  Global Instance ℐ : syn.token.private.CustomToken.Trait Self := {
    syn.token.private.CustomToken.peek := peek;
    syn.token.private.CustomToken.display := display;
  }.
End Impl_syn_token_private_CustomToken_for_axum_macros_debug_handler_kw_body_t.
End Impl_syn_token_private_CustomToken_for_axum_macros_debug_handler_kw_body_t.

Module  Impl_syn_parse_Parse_for_axum_macros_debug_handler_kw_body_t.
Section Impl_syn_parse_Parse_for_axum_macros_debug_handler_kw_body_t.
  Definition Self : Set := axum_macros.debug_handler.kw.body.t.
  
  (*
              fn parse(input: $crate::parse::ParseStream) -> $crate::parse::Result<$ident> {
                  input.step(|cursor| {
                      if let $crate::__private::Some((ident, rest)) = cursor.ident() {
                          if ident == $crate::__private::stringify!($ident) {
                              return $crate::__private::Ok(($ident { span: ident.span() }, rest));
                          }
                      }
                      $crate::__private::Err(cursor.error($crate::__private::concat!(
                          "expected `",
                          $crate::__private::stringify!($ident),
                          "`",
                      )))
                  })
              }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      : M ltac:(syn.error.Result axum_macros.debug_handler.kw.body.t) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_debug_handler_kw_body_t.
End Impl_syn_parse_Parse_for_axum_macros_debug_handler_kw_body_t.

Module  Impl_quote_to_tokens_ToTokens_for_axum_macros_debug_handler_kw_body_t.
Section Impl_quote_to_tokens_ToTokens_for_axum_macros_debug_handler_kw_body_t.
  Definition Self : Set := axum_macros.debug_handler.kw.body.t.
  
  (*
              fn to_tokens(&self, tokens: &mut $crate::__private::TokenStream2) {
                  let ident = $crate::Ident::new($crate::__private::stringify!($ident), self.span);
                  $crate::__private::TokenStreamExt::append(tokens, ident);
              }
  *)
  Definition to_tokens
      (self : ref Self)
      (tokens : mut_ref ltac:(syn.__private.TokenStream2))
      : M unit :=
    let* self := M.alloc self in
    let* tokens := M.alloc tokens in
    M.read foo.
  
  Global Instance AssociatedFunction_to_tokens :
    Notations.DoubleColon Self "to_tokens" := {
    Notations.double_colon := to_tokens;
  }.
  
  Global Instance ℐ : quote.to_tokens.ToTokens.Required.Trait Self := {
    quote.to_tokens.ToTokens.to_tokens := to_tokens;
    quote.to_tokens.ToTokens.to_token_stream := Datatypes.None;
    quote.to_tokens.ToTokens.into_token_stream := Datatypes.None;
  }.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_debug_handler_kw_body_t.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_debug_handler_kw_body_t.

Module  Impl_core_marker_Copy_for_axum_macros_debug_handler_kw_body_t.
Section Impl_core_marker_Copy_for_axum_macros_debug_handler_kw_body_t.
  Definition Self : Set := axum_macros.debug_handler.kw.body.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_macros_debug_handler_kw_body_t.
End Impl_core_marker_Copy_for_axum_macros_debug_handler_kw_body_t.

Module  Impl_core_clone_Clone_for_axum_macros_debug_handler_kw_body_t.
Section Impl_core_clone_Clone_for_axum_macros_debug_handler_kw_body_t.
  Definition Self : Set := axum_macros.debug_handler.kw.body.t.
  
  (*
              fn clone(&self) -> Self {
                  *self
              }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_macros_debug_handler_kw_body_t.
End Impl_core_clone_Clone_for_axum_macros_debug_handler_kw_body_t.

Module  Impl_core_fmt_Debug_for_axum_macros_debug_handler_kw_body_t.
Section Impl_core_fmt_Debug_for_axum_macros_debug_handler_kw_body_t.
  Definition Self : Set := axum_macros.debug_handler.kw.body.t.
  
  (*
              fn fmt(&self, f: &mut $crate::__private::Formatter) -> $crate::__private::FmtResult {
                  $crate::__private::Formatter::write_str(
                      f,
                      $crate::__private::concat!(
                          "Keyword [",
                          $crate::__private::stringify!($ident),
                          "]",
                      ),
                  )
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref ltac:(syn.__private.Formatter))
      : M ltac:(syn.__private.FmtResult) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_macros_debug_handler_kw_body_t.
End Impl_core_fmt_Debug_for_axum_macros_debug_handler_kw_body_t.

Module  Impl_core_cmp_Eq_for_axum_macros_debug_handler_kw_body_t.
Section Impl_core_cmp_Eq_for_axum_macros_debug_handler_kw_body_t.
  Definition Self : Set := axum_macros.debug_handler.kw.body.t.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq := Datatypes.None;
  }.
End Impl_core_cmp_Eq_for_axum_macros_debug_handler_kw_body_t.
End Impl_core_cmp_Eq_for_axum_macros_debug_handler_kw_body_t.

Module  Impl_core_cmp_PartialEq_for_axum_macros_debug_handler_kw_body_t.
Section Impl_core_cmp_PartialEq_for_axum_macros_debug_handler_kw_body_t.
  Definition Self : Set := axum_macros.debug_handler.kw.body.t.
  
  (*
              fn eq(&self, _other: &Self) -> $crate::__private::bool {
                  true
              }
  *)
  Definition eq
      (self : ref Self)
      (_other : ref Self)
      : M ltac:(syn.__private.bool) :=
    let* self := M.alloc self in
    let* _other := M.alloc _other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_macros_debug_handler_kw_body_t.
End Impl_core_cmp_PartialEq_for_axum_macros_debug_handler_kw_body_t.

Module  Impl_core_hash_Hash_for_axum_macros_debug_handler_kw_body_t.
Section Impl_core_hash_Hash_for_axum_macros_debug_handler_kw_body_t.
  Definition Self : Set := axum_macros.debug_handler.kw.body.t.
  
  (*
              fn hash<__H: $crate::__private::Hasher>(&self, _state: &mut __H) {}
  *)
  Definition hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H}
      (self : ref Self)
      (_state : mut_ref __H)
      : M unit :=
    let* self := M.alloc self in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
      hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_axum_macros_debug_handler_kw_body_t.
End Impl_core_hash_Hash_for_axum_macros_debug_handler_kw_body_t.

Module  state.
Section state.
  Record t : Set := {
    span : ltac:(syn.__private.Span);
  }.
  
  Definition Get_span :=
    Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
End state.
End state.

(*
        pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
            span: __S,
        ) -> $ident {
            $ident {
                span: $crate::__private::IntoSpans::into_spans(span),
            }
        }
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition state
    {__S : Set}
    {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
    (span : __S)
    : M axum_macros.debug_handler.kw.state.t :=
  let* span := M.alloc span in
  M.read foo.

Module  Impl_core_default_Default_for_axum_macros_debug_handler_kw_state_t.
Section Impl_core_default_Default_for_axum_macros_debug_handler_kw_state_t.
  Definition Self : Set := axum_macros.debug_handler.kw.state.t.
  
  (*
                  fn default() -> Self {
                      $ident {
                          span: $crate::__private::Span::call_site(),
                      }
                  }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_macros_debug_handler_kw_state_t.
End Impl_core_default_Default_for_axum_macros_debug_handler_kw_state_t.

Module  Impl_syn_token_private_CustomToken_for_axum_macros_debug_handler_kw_state_t.
Section Impl_syn_token_private_CustomToken_for_axum_macros_debug_handler_kw_state_t.
  Definition Self : Set := axum_macros.debug_handler.kw.state.t.
  
  (*
              fn peek(cursor: $crate::buffer::Cursor) -> $crate::__private::bool {
                  if let $crate::__private::Some((ident, _rest)) = cursor.ident() {
                      ident == $crate::__private::stringify!($ident)
                  } else {
                      false
                  }
              }
  *)
  Definition peek
      (cursor : syn.buffer.Cursor.t)
      : M ltac:(syn.__private.bool) :=
    let* cursor := M.alloc cursor in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
              fn display() -> &'static $crate::__private::str {
                  $crate::__private::concat!("`", $crate::__private::stringify!($ident), "`")
              }
  *)
  Definition display : M (ref ltac:(syn.__private.str)) := M.read foo.
  
  Global Instance AssociatedFunction_display :
    Notations.DoubleColon Self "display" := {
    Notations.double_colon := display;
  }.
  
  Global Instance ℐ : syn.token.private.CustomToken.Trait Self := {
    syn.token.private.CustomToken.peek := peek;
    syn.token.private.CustomToken.display := display;
  }.
End Impl_syn_token_private_CustomToken_for_axum_macros_debug_handler_kw_state_t.
End Impl_syn_token_private_CustomToken_for_axum_macros_debug_handler_kw_state_t.

Module  Impl_syn_parse_Parse_for_axum_macros_debug_handler_kw_state_t.
Section Impl_syn_parse_Parse_for_axum_macros_debug_handler_kw_state_t.
  Definition Self : Set := axum_macros.debug_handler.kw.state.t.
  
  (*
              fn parse(input: $crate::parse::ParseStream) -> $crate::parse::Result<$ident> {
                  input.step(|cursor| {
                      if let $crate::__private::Some((ident, rest)) = cursor.ident() {
                          if ident == $crate::__private::stringify!($ident) {
                              return $crate::__private::Ok(($ident { span: ident.span() }, rest));
                          }
                      }
                      $crate::__private::Err(cursor.error($crate::__private::concat!(
                          "expected `",
                          $crate::__private::stringify!($ident),
                          "`",
                      )))
                  })
              }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      : M ltac:(syn.error.Result axum_macros.debug_handler.kw.state.t) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_debug_handler_kw_state_t.
End Impl_syn_parse_Parse_for_axum_macros_debug_handler_kw_state_t.

Module  Impl_quote_to_tokens_ToTokens_for_axum_macros_debug_handler_kw_state_t.
Section Impl_quote_to_tokens_ToTokens_for_axum_macros_debug_handler_kw_state_t.
  Definition Self : Set := axum_macros.debug_handler.kw.state.t.
  
  (*
              fn to_tokens(&self, tokens: &mut $crate::__private::TokenStream2) {
                  let ident = $crate::Ident::new($crate::__private::stringify!($ident), self.span);
                  $crate::__private::TokenStreamExt::append(tokens, ident);
              }
  *)
  Definition to_tokens
      (self : ref Self)
      (tokens : mut_ref ltac:(syn.__private.TokenStream2))
      : M unit :=
    let* self := M.alloc self in
    let* tokens := M.alloc tokens in
    M.read foo.
  
  Global Instance AssociatedFunction_to_tokens :
    Notations.DoubleColon Self "to_tokens" := {
    Notations.double_colon := to_tokens;
  }.
  
  Global Instance ℐ : quote.to_tokens.ToTokens.Required.Trait Self := {
    quote.to_tokens.ToTokens.to_tokens := to_tokens;
    quote.to_tokens.ToTokens.to_token_stream := Datatypes.None;
    quote.to_tokens.ToTokens.into_token_stream := Datatypes.None;
  }.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_debug_handler_kw_state_t.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_debug_handler_kw_state_t.

Module  Impl_core_marker_Copy_for_axum_macros_debug_handler_kw_state_t.
Section Impl_core_marker_Copy_for_axum_macros_debug_handler_kw_state_t.
  Definition Self : Set := axum_macros.debug_handler.kw.state.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_macros_debug_handler_kw_state_t.
End Impl_core_marker_Copy_for_axum_macros_debug_handler_kw_state_t.

Module  Impl_core_clone_Clone_for_axum_macros_debug_handler_kw_state_t.
Section Impl_core_clone_Clone_for_axum_macros_debug_handler_kw_state_t.
  Definition Self : Set := axum_macros.debug_handler.kw.state.t.
  
  (*
              fn clone(&self) -> Self {
                  *self
              }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_macros_debug_handler_kw_state_t.
End Impl_core_clone_Clone_for_axum_macros_debug_handler_kw_state_t.

Module  Impl_core_fmt_Debug_for_axum_macros_debug_handler_kw_state_t.
Section Impl_core_fmt_Debug_for_axum_macros_debug_handler_kw_state_t.
  Definition Self : Set := axum_macros.debug_handler.kw.state.t.
  
  (*
              fn fmt(&self, f: &mut $crate::__private::Formatter) -> $crate::__private::FmtResult {
                  $crate::__private::Formatter::write_str(
                      f,
                      $crate::__private::concat!(
                          "Keyword [",
                          $crate::__private::stringify!($ident),
                          "]",
                      ),
                  )
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref ltac:(syn.__private.Formatter))
      : M ltac:(syn.__private.FmtResult) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_macros_debug_handler_kw_state_t.
End Impl_core_fmt_Debug_for_axum_macros_debug_handler_kw_state_t.

Module  Impl_core_cmp_Eq_for_axum_macros_debug_handler_kw_state_t.
Section Impl_core_cmp_Eq_for_axum_macros_debug_handler_kw_state_t.
  Definition Self : Set := axum_macros.debug_handler.kw.state.t.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq := Datatypes.None;
  }.
End Impl_core_cmp_Eq_for_axum_macros_debug_handler_kw_state_t.
End Impl_core_cmp_Eq_for_axum_macros_debug_handler_kw_state_t.

Module  Impl_core_cmp_PartialEq_for_axum_macros_debug_handler_kw_state_t.
Section Impl_core_cmp_PartialEq_for_axum_macros_debug_handler_kw_state_t.
  Definition Self : Set := axum_macros.debug_handler.kw.state.t.
  
  (*
              fn eq(&self, _other: &Self) -> $crate::__private::bool {
                  true
              }
  *)
  Definition eq
      (self : ref Self)
      (_other : ref Self)
      : M ltac:(syn.__private.bool) :=
    let* self := M.alloc self in
    let* _other := M.alloc _other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_macros_debug_handler_kw_state_t.
End Impl_core_cmp_PartialEq_for_axum_macros_debug_handler_kw_state_t.

Module  Impl_core_hash_Hash_for_axum_macros_debug_handler_kw_state_t.
Section Impl_core_hash_Hash_for_axum_macros_debug_handler_kw_state_t.
  Definition Self : Set := axum_macros.debug_handler.kw.state.t.
  
  (*
              fn hash<__H: $crate::__private::Hasher>(&self, _state: &mut __H) {}
  *)
  Definition hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H}
      (self : ref Self)
      (_state : mut_ref __H)
      : M unit :=
    let* self := M.alloc self in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
      hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_axum_macros_debug_handler_kw_state_t.
End Impl_core_hash_Hash_for_axum_macros_debug_handler_kw_state_t.

Module  Attrs.
Section Attrs.
  Record t : Set := {
    state_ty :
      core.option.Option.t
        (axum_macros.debug_handler.kw.state.t * syn.ty.Type_.t);
  }.
  
  Definition Get_state_ty :=
    Ref.map
      (fun α => Some α.(state_ty))
      (fun β α => Some (α <| state_ty := β |>)).
End Attrs.
End Attrs.

Module  Impl_syn_parse_Parse_for_axum_macros_debug_handler_Attrs_t.
Section Impl_syn_parse_Parse_for_axum_macros_debug_handler_Attrs_t.
  Definition Self : Set := axum_macros.debug_handler.Attrs.t.
  
  (*
      fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
          let mut state_ty = None;
  
          while !input.is_empty() {
              let lh = input.lookahead1();
              if lh.peek(kw::state) {
                  parse_assignment_attribute(input, &mut state_ty)?;
              } else {
                  return Err(lh.error());
              }
  
              let _ = input.parse::<Token![,]>();
          }
  
          Ok(Self { state_ty })
      }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      : M ltac:(syn.error.Result Self) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_debug_handler_Attrs_t.
End Impl_syn_parse_Parse_for_axum_macros_debug_handler_Attrs_t.

(*
fn check_extractor_count(item_fn: &ItemFn) -> Option<TokenStream> {
    let max_extractors = 16;
    if item_fn.sig.inputs.len() <= max_extractors {
        None
    } else {
        let error_message = format!(
            "Handlers cannot take more than {max_extractors} arguments. \
            Use `(a, b): (ExtractorA, ExtractorA)` to further nest extractors",
        );
        let error = syn::Error::new_spanned(&item_fn.sig.inputs, error_message).to_compile_error();
        Some(error)
    }
}
*)
Definition check_extractor_count
    (item_fn : ref syn.item.ItemFn.t)
    : M (core.option.Option.t proc_macro2.TokenStream.t) :=
  let* item_fn := M.alloc item_fn in
  M.read foo.

(*
fn extractor_idents(item_fn: &ItemFn) -> impl Iterator<Item = (usize, &syn::FnArg, &syn::Ident)> {
    item_fn
        .sig
        .inputs
        .iter()
        .enumerate()
        .filter_map(|(idx, fn_arg)| match fn_arg {
            FnArg::Receiver(_) => None,
            FnArg::Typed(pat_type) => {
                if let Type::Path(type_path) = &*pat_type.ty {
                    type_path
                        .path
                        .segments
                        .last()
                        .map(|segment| (idx, fn_arg, &segment.ident))
                } else {
                    None
                }
            }
        })
}
*)
Definition extractor_idents (item_fn : ref syn.item.ItemFn.t) : M OpaqueDef :=
  let* item_fn := M.alloc item_fn in
  M.read foo.

Error OpaqueTy.

(*
fn check_path_extractor(item_fn: &ItemFn) -> TokenStream {
    let path_extractors = extractor_idents(item_fn)
        .filter(|(_, _, ident)| *ident == "Path")
        .collect::<Vec<_>>();

    if path_extractors.len() > 1 {
        path_extractors
            .into_iter()
            .map(|(_, arg, _)| {
                syn::Error::new_spanned(
                    arg,
                    "Multiple parameters must be extracted with a tuple \
                    `Path<(_, _)>` or a struct `Path<YourParams>`, not by applying \
                    multiple `Path<_>` extractors",
                )
                .to_compile_error()
            })
            .collect()
    } else {
        quote! {}
    }
}
*)
Definition check_path_extractor
    (item_fn : ref syn.item.ItemFn.t)
    : M proc_macro2.TokenStream.t :=
  let* item_fn := M.alloc item_fn in
  M.read foo.

(*
fn is_self_pat_type(typed: &syn::PatType) -> bool {
    let ident = if let syn::Pat::Ident(ident) = &*typed.pat {
        &ident.ident
    } else {
        return false;
    };

    ident == "self"
}
*)
Definition is_self_pat_type (typed : ref syn.pat.PatType.t) : M bool.t :=
  let* typed := M.alloc typed in
  M.read foo.

(*
fn check_inputs_impls_from_request(item_fn: &ItemFn, state_ty: Type) -> TokenStream {
    let takes_self = item_fn.sig.inputs.first().map_or(false, |arg| match arg {
        FnArg::Receiver(_) => true,
        FnArg::Typed(typed) => is_self_pat_type(typed),
    });

    WithPosition::new(&item_fn.sig.inputs)
        .enumerate()
        .map(|(idx, arg)| {
            let must_impl_from_request_parts = match &arg {
                Position::First(_) | Position::Middle(_) => true,
                Position::Last(_) | Position::Only(_) => false,
            };

            let arg = arg.into_inner();

            let (span, ty) = match arg {
                FnArg::Receiver(receiver) => {
                    if receiver.reference.is_some() {
                        return syn::Error::new_spanned(
                            receiver,
                            "Handlers must only take owned values",
                        )
                        .into_compile_error();
                    }

                    let span = receiver.span();
                    (span, syn::parse_quote!(Self))
                }
                FnArg::Typed(typed) => {
                    let ty = &typed.ty;
                    let span = ty.span();

                    if is_self_pat_type(typed) {
                        (span, syn::parse_quote!(Self))
                    } else {
                        (span, ty.clone())
                    }
                }
            };

            let consumes_request = request_consuming_type_name(&ty).is_some();

            let check_fn = format_ident!(
                "__axum_macros_check_{}_{}_from_request_check",
                item_fn.sig.ident,
                idx,
                span = span,
            );

            let call_check_fn = format_ident!(
                "__axum_macros_check_{}_{}_from_request_call_check",
                item_fn.sig.ident,
                idx,
                span = span,
            );

            let call_check_fn_body = if takes_self {
                quote_spanned! {span=>
                    Self::#check_fn();
                }
            } else {
                quote_spanned! {span=>
                    #check_fn();
                }
            };

            let check_fn_generics = if must_impl_from_request_parts || consumes_request {
                quote! {}
            } else {
                quote! { <M> }
            };

            let from_request_bound = if must_impl_from_request_parts {
                quote_spanned! {span=>
                    #ty: ::axum::extract::FromRequestParts<#state_ty> + Send
                }
            } else if consumes_request {
                quote_spanned! {span=>
                    #ty: ::axum::extract::FromRequest<#state_ty> + Send
                }
            } else {
                quote_spanned! {span=>
                    #ty: ::axum::extract::FromRequest<#state_ty, M> + Send
                }
            };

            quote_spanned! {span=>
                #[allow(warnings)]
                #[allow(unreachable_code)]
                #[doc(hidden)]
                fn #check_fn #check_fn_generics()
                where
                    #from_request_bound,
                {}

                // we have to call the function to actually trigger a compile error
                // since the function is generic, just defining it is not enough
                #[allow(warnings)]
                #[allow(unreachable_code)]
                #[doc(hidden)]
                fn #call_check_fn() {
                    #call_check_fn_body
                }
            }
        })
        .collect::<TokenStream>()
}
*)
Definition check_inputs_impls_from_request
    (item_fn : ref syn.item.ItemFn.t)
    (state_ty : syn.ty.Type_.t)
    : M proc_macro2.TokenStream.t :=
  let* item_fn := M.alloc item_fn in
  let* state_ty := M.alloc state_ty in
  M.read foo.

(*
fn check_output_tuples(item_fn: &ItemFn) -> TokenStream {
    let elems = match &item_fn.sig.output {
        ReturnType::Type(_, ty) => match &**ty {
            Type::Tuple(tuple) => &tuple.elems,
            _ => return quote! {},
        },
        ReturnType::Default => return quote! {},
    };

    let handler_ident = &item_fn.sig.ident;

    match elems.len() {
        0 => quote! {},
        n if n > 17 => syn::Error::new_spanned(
            &item_fn.sig.output,
            "Cannot return tuples with more than 17 elements",
        )
        .to_compile_error(),
        _ => WithPosition::new(elems)
            .enumerate()
            .map(|(idx, arg)| match arg {
                Position::First(ty) => match extract_clean_typename(ty).as_deref() {
                    Some("StatusCode" | "Response") => quote! {},
                    Some("Parts") => check_is_response_parts(ty, handler_ident, idx),
                    Some(_) | None => {
                        if let Some(tn) = well_known_last_response_type(ty) {
                            syn::Error::new_spanned(
                                ty,
                                format!(
                                    "`{tn}` must be the last element \
                                    in a response tuple"
                                ),
                            )
                            .to_compile_error()
                        } else {
                            check_into_response_parts(ty, handler_ident, idx)
                        }
                    }
                },
                Position::Middle(ty) => {
                    if let Some(tn) = well_known_last_response_type(ty) {
                        syn::Error::new_spanned(
                            ty,
                            format!("`{tn}` must be the last element in a response tuple"),
                        )
                        .to_compile_error()
                    } else {
                        check_into_response_parts(ty, handler_ident, idx)
                    }
                }
                Position::Last(ty) | Position::Only(ty) => check_into_response(handler_ident, ty),
            })
            .collect::<TokenStream>(),
    }
}
*)
Definition check_output_tuples
    (item_fn : ref syn.item.ItemFn.t)
    : M proc_macro2.TokenStream.t :=
  let* item_fn := M.alloc item_fn in
  M.read foo.

(*
fn check_into_response(handler: &Ident, ty: &Type) -> TokenStream {
    let (span, ty) = (ty.span(), ty.clone());

    let check_fn = format_ident!(
        "__axum_macros_check_{handler}_into_response_check",
        span = span,
    );

    let call_check_fn = format_ident!(
        "__axum_macros_check_{handler}_into_response_call_check",
        span = span,
    );

    let call_check_fn_body = quote_spanned! {span=>
        #check_fn();
    };

    let from_request_bound = quote_spanned! {span=>
        #ty: ::axum::response::IntoResponse
    };
    quote_spanned! {span=>
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn #check_fn()
        where
            #from_request_bound,
        {}

        // we have to call the function to actually trigger a compile error
        // since the function is generic, just defining it is not enough
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn #call_check_fn() {
            #call_check_fn_body
        }
    }
}
*)
Definition check_into_response
    (handler : ref proc_macro2.Ident.t)
    (ty : ref syn.ty.Type_.t)
    : M proc_macro2.TokenStream.t :=
  let* handler := M.alloc handler in
  let* ty := M.alloc ty in
  M.read foo.

(*
fn check_is_response_parts(ty: &Type, ident: &Ident, index: usize) -> TokenStream {
    let (span, ty) = (ty.span(), ty.clone());

    let check_fn = format_ident!(
        "__axum_macros_check_{}_is_response_parts_{index}_check",
        ident,
        span = span,
    );

    quote_spanned! {span=>
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn #check_fn(parts: #ty) -> ::axum::http::response::Parts {
            parts
        }
    }
}
*)
Definition check_is_response_parts
    (ty : ref syn.ty.Type_.t)
    (ident : ref proc_macro2.Ident.t)
    (index : usize.t)
    : M proc_macro2.TokenStream.t :=
  let* ty := M.alloc ty in
  let* ident := M.alloc ident in
  let* index := M.alloc index in
  M.read foo.

(*
fn check_into_response_parts(ty: &Type, ident: &Ident, index: usize) -> TokenStream {
    let (span, ty) = (ty.span(), ty.clone());

    let check_fn = format_ident!(
        "__axum_macros_check_{}_into_response_parts_{index}_check",
        ident,
        span = span,
    );

    let call_check_fn = format_ident!(
        "__axum_macros_check_{}_into_response_parts_{index}_call_check",
        ident,
        span = span,
    );

    let call_check_fn_body = quote_spanned! {span=>
        #check_fn();
    };

    let from_request_bound = quote_spanned! {span=>
        #ty: ::axum::response::IntoResponseParts
    };
    quote_spanned! {span=>
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn #check_fn()
        where
            #from_request_bound,
        {}

        // we have to call the function to actually trigger a compile error
        // since the function is generic, just defining it is not enough
        #[allow(warnings)]
        #[allow(unreachable_code)]
        #[doc(hidden)]
        fn #call_check_fn() {
            #call_check_fn_body
        }
    }
}
*)
Definition check_into_response_parts
    (ty : ref syn.ty.Type_.t)
    (ident : ref proc_macro2.Ident.t)
    (index : usize.t)
    : M proc_macro2.TokenStream.t :=
  let* ty := M.alloc ty in
  let* ident := M.alloc ident in
  let* index := M.alloc index in
  M.read foo.

(*
fn check_input_order(item_fn: &ItemFn) -> Option<TokenStream> {
    let types_that_consume_the_request = item_fn
        .sig
        .inputs
        .iter()
        .enumerate()
        .filter_map(|(idx, arg)| {
            let ty = match arg {
                FnArg::Typed(pat_type) => &*pat_type.ty,
                FnArg::Receiver(_) => return None,
            };
            let type_name = request_consuming_type_name(ty)?;

            Some((idx, type_name, ty.span()))
        })
        .collect::<Vec<_>>();

    if types_that_consume_the_request.is_empty() {
        return None;
    };

    // exactly one type that consumes the request
    if types_that_consume_the_request.len() == 1 {
        // and that is not the last
        if types_that_consume_the_request[0].0 != item_fn.sig.inputs.len() - 1 {
            let (_idx, type_name, span) = &types_that_consume_the_request[0];
            let error = format!(
                "`{type_name}` consumes the request body and thus must be \
                the last argument to the handler function"
            );
            return Some(quote_spanned! {*span=>
                compile_error!(#error);
            });
        } else {
            return None;
        }
    }

    if types_that_consume_the_request.len() == 2 {
        let (_, first, _) = &types_that_consume_the_request[0];
        let (_, second, _) = &types_that_consume_the_request[1];
        let error = format!(
            "Can't have two extractors that consume the request body. \
            `{first}` and `{second}` both do that.",
        );
        let span = item_fn.sig.inputs.span();
        Some(quote_spanned! {span=>
            compile_error!(#error);
        })
    } else {
        let types = WithPosition::new(types_that_consume_the_request)
            .map(|pos| match pos {
                Position::First((_, type_name, _)) | Position::Middle((_, type_name, _)) => {
                    format!("`{type_name}`, ")
                }
                Position::Last((_, type_name, _)) => format!("and `{type_name}`"),
                Position::Only(_) => unreachable!(),
            })
            .collect::<String>();

        let error = format!(
            "Can't have more than one extractor that consume the request body. \
            {types} all do that.",
        );
        let span = item_fn.sig.inputs.span();
        Some(quote_spanned! {span=>
            compile_error!(#error);
        })
    }
}
*)
Definition check_input_order
    (item_fn : ref syn.item.ItemFn.t)
    : M (core.option.Option.t proc_macro2.TokenStream.t) :=
  let* item_fn := M.alloc item_fn in
  M.read foo.

(*
fn extract_clean_typename(ty: &Type) -> Option<String> {
    let path = match ty {
        Type::Path(type_path) => &type_path.path,
        _ => return None,
    };
    path.segments.last().map(|p| p.ident.to_string())
}
*)
Definition extract_clean_typename
    (ty : ref syn.ty.Type_.t)
    : M (core.option.Option.t alloc.string.String.t) :=
  let* ty := M.alloc ty in
  M.read foo.

(*
fn request_consuming_type_name(ty: &Type) -> Option<&'static str> {
    let typename = extract_clean_typename(ty)?;

    let type_name = match &*typename {
        "Json" => "Json<_>",
        "RawBody" => "RawBody<_>",
        "RawForm" => "RawForm",
        "Multipart" => "Multipart",
        "Protobuf" => "Protobuf",
        "JsonLines" => "JsonLines<_>",
        "Form" => "Form<_>",
        "Request" => "Request<_>",
        "Bytes" => "Bytes",
        "String" => "String",
        "Parts" => "Parts",
        _ => return None,
    };

    Some(type_name)
}
*)
Definition request_consuming_type_name
    (ty : ref syn.ty.Type_.t)
    : M (core.option.Option.t (ref str.t)) :=
  let* ty := M.alloc ty in
  M.read foo.

(*
fn well_known_last_response_type(ty: &Type) -> Option<&'static str> {
    let typename = match extract_clean_typename(ty) {
        Some(tn) => tn,
        None => return None,
    };

    let type_name = match &*typename {
        "Json" => "Json<_>",
        "Protobuf" => "Protobuf",
        "JsonLines" => "JsonLines<_>",
        "Form" => "Form<_>",
        "Bytes" => "Bytes",
        "String" => "String",
        _ => return None,
    };

    Some(type_name)
}
*)
Definition well_known_last_response_type
    (ty : ref syn.ty.Type_.t)
    : M (core.option.Option.t (ref str.t)) :=
  let* ty := M.alloc ty in
  M.read foo.

(*
fn check_output_impls_into_response(item_fn: &ItemFn) -> TokenStream {
    let ty = match &item_fn.sig.output {
        syn::ReturnType::Default => return quote! {},
        syn::ReturnType::Type(_, ty) => ty,
    };
    let span = ty.span();

    let declare_inputs = item_fn
        .sig
        .inputs
        .iter()
        .filter_map(|arg| match arg {
            FnArg::Receiver(_) => None,
            FnArg::Typed(pat_ty) => {
                let pat = &pat_ty.pat;
                let ty = &pat_ty.ty;
                Some(quote! {
                    let #pat: #ty = panic!();
                })
            }
        })
        .collect::<TokenStream>();

    let block = &item_fn.block;

    let make_value_name = format_ident!(
        "__axum_macros_check_{}_into_response_make_value",
        item_fn.sig.ident
    );

    let make = if item_fn.sig.asyncness.is_some() {
        quote_spanned! {span=>
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn #make_value_name() -> #ty {
                #declare_inputs
                #block
            }
        }
    } else {
        quote_spanned! {span=>
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            fn #make_value_name() -> #ty {
                #declare_inputs
                #block
            }
        }
    };

    let name = format_ident!("__axum_macros_check_{}_into_response", item_fn.sig.ident);

    if let Some(receiver) = self_receiver(item_fn) {
        quote_spanned! {span=>
            #make

            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn #name() {
                let value = #receiver #make_value_name().await;
                fn check<T>(_: T)
                    where T: ::axum::response::IntoResponse
                {}
                check(value);
            }
        }
    } else {
        quote_spanned! {span=>
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            async fn #name() {
                #make

                let value = #make_value_name().await;

                fn check<T>(_: T)
                where T: ::axum::response::IntoResponse
                {}

                check(value);
            }
        }
    }
}
*)
Definition check_output_impls_into_response
    (item_fn : ref syn.item.ItemFn.t)
    : M proc_macro2.TokenStream.t :=
  let* item_fn := M.alloc item_fn in
  M.read foo.

(*
fn check_future_send(item_fn: &ItemFn) -> TokenStream {
    if item_fn.sig.asyncness.is_none() {
        match &item_fn.sig.output {
            syn::ReturnType::Default => {
                return syn::Error::new_spanned(
                    item_fn.sig.fn_token,
                    "Handlers must be `async fn`s",
                )
                .into_compile_error();
            }
            syn::ReturnType::Type(_, ty) => ty,
        };
    }

    let span = item_fn.sig.ident.span();

    let handler_name = &item_fn.sig.ident;

    let args = item_fn.sig.inputs.iter().map(|_| {
        quote_spanned! {span=> panic!() }
    });

    let name = format_ident!("__axum_macros_check_{}_future", item_fn.sig.ident);

    let do_check = quote! {
        fn check<T>(_: T)
            where T: ::std::future::Future + Send
        {}
        check(future);
    };

    if let Some(receiver) = self_receiver(item_fn) {
        quote! {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            fn #name() {
                let future = #receiver #handler_name(#(#args),* );
                #do_check
            }
        }
    } else {
        quote! {
            #[allow(warnings)]
            #[allow(unreachable_code)]
            #[doc(hidden)]
            fn #name() {
                #item_fn
                let future = #handler_name(#(#args),* );
                #do_check
            }
        }
    }
}
*)
Definition check_future_send
    (item_fn : ref syn.item.ItemFn.t)
    : M proc_macro2.TokenStream.t :=
  let* item_fn := M.alloc item_fn in
  M.read foo.

(*
fn self_receiver(item_fn: &ItemFn) -> Option<TokenStream> {
    let takes_self = item_fn.sig.inputs.iter().any(|arg| match arg {
        FnArg::Receiver(_) => true,
        FnArg::Typed(typed) => is_self_pat_type(typed),
    });

    if takes_self {
        return Some(quote! { Self:: });
    }

    if let syn::ReturnType::Type(_, ty) = &item_fn.sig.output {
        if let syn::Type::Path(path) = &**ty {
            let segments = &path.path.segments;
            if segments.len() == 1 {
                if let Some(last) = segments.last() {
                    match &last.arguments {
                        syn::PathArguments::None if last.ident == "Self" => {
                            return Some(quote! { Self:: });
                        }
                        _ => {}
                    }
                }
            }
        }
    }

    None
}
*)
Definition self_receiver
    (item_fn : ref syn.item.ItemFn.t)
    : M (core.option.Option.t proc_macro2.TokenStream.t) :=
  let* item_fn := M.alloc item_fn in
  M.read foo.

(*
fn state_types_from_args(item_fn: &ItemFn) -> HashSet<Type> {
    let types = item_fn
        .sig
        .inputs
        .iter()
        .filter_map(|input| match input {
            FnArg::Receiver(_) => None,
            FnArg::Typed(pat_type) => Some(pat_type),
        })
        .map(|pat_type| &*pat_type.ty);
    crate::infer_state_types(types).collect()
}
*)
Definition state_types_from_args
    (item_fn : ref syn.item.ItemFn.t)
    :
      M
        (std.collections.hash.set.HashSet.t
          syn.ty.Type_.t
          std.collections.hash.set.HashSet.Default.S) :=
  let* item_fn := M.alloc item_fn in
  M.read foo.

Module from_ref.
  (*
  pub(crate) fn expand(item: ItemStruct) -> syn::Result<TokenStream> {
      if !item.generics.params.is_empty() {
          return Err(syn::Error::new_spanned(
              item.generics,
              "`#[derive(FromRef)]` doesn't support generics",
          ));
      }
  
      let tokens = item
          .fields
          .iter()
          .enumerate()
          .map(|(idx, field)| expand_field(&item.ident, idx, field))
          .collect();
  
      Ok(tokens)
  }
  *)
  Definition expand
      (item : syn.item.ItemStruct.t)
      : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
    let* item := M.alloc item in
    M.read foo.
  
  (*
  fn expand_field(state: &Ident, idx: usize, field: &Field) -> TokenStream {
      let FieldAttrs { skip } = match parse_attrs("from_ref", &field.attrs) {
          Ok(attrs) => attrs,
          Err(err) => return err.into_compile_error(),
      };
  
      if skip.is_some() {
          return TokenStream::default();
      }
  
      let field_ty = &field.ty;
      let span = field.ty.span();
  
      let body = if let Some(field_ident) = &field.ident {
          if matches!(field_ty, Type::Reference(_)) {
              quote_spanned! {span=> state.#field_ident }
          } else {
              quote_spanned! {span=> state.#field_ident.clone() }
          }
      } else {
          let idx = syn::Index {
              index: idx as _,
              span: field.span(),
          };
          quote_spanned! {span=> state.#idx.clone() }
      };
  
      quote_spanned! {span=>
          #[allow(clippy::clone_on_copy)]
          impl ::axum::extract::FromRef<#state> for #field_ty {
              fn from_ref(state: &#state) -> Self {
                  #body
              }
          }
      }
  }
  *)
  Definition expand_field
      (state : ref proc_macro2.Ident.t)
      (idx : usize.t)
      (field : ref syn.data.Field.t)
      : M proc_macro2.TokenStream.t :=
    let* state := M.alloc state in
    let* idx := M.alloc idx in
    let* field := M.alloc field in
    M.read foo.
  
  Module kw.
    Module  skip.
    Section skip.
      Record t : Set := {
        span : ltac:(syn.__private.Span);
      }.
      
      Definition Get_span :=
        Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
    End skip.
    End skip.
    
    (*
            pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
                span: __S,
            ) -> $ident {
                $ident {
                    span: $crate::__private::IntoSpans::into_spans(span),
                }
            }
    *)
    (* #[allow(dead_code)] - function was ignored by the compiler *)
    Definition skip
        {__S : Set}
        {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
        (span : __S)
        : M axum_macros.from_ref.kw.skip.t :=
      let* span := M.alloc span in
      M.read foo.
  End kw.
  
  Module  FieldAttrs.
  Section FieldAttrs.
    Record t : Set := {
      skip : core.option.Option.t axum_macros.from_ref.kw.skip.t;
    }.
    
    Definition Get_skip :=
      Ref.map (fun α => Some α.(skip)) (fun β α => Some (α <| skip := β |>)).
  End FieldAttrs.
  End FieldAttrs.
  
  Module  Impl_core_default_Default_for_axum_macros_from_ref_FieldAttrs_t.
  Section Impl_core_default_Default_for_axum_macros_from_ref_FieldAttrs_t.
    Definition Self : Set := axum_macros.from_ref.FieldAttrs.t.
    
    (*
    Default
    *)
    Definition default : M axum_macros.from_ref.FieldAttrs.t := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_macros_from_ref_FieldAttrs_t.
  End Impl_core_default_Default_for_axum_macros_from_ref_FieldAttrs_t.
  
  Module  Impl_syn_parse_Parse_for_axum_macros_from_ref_FieldAttrs_t.
  Section Impl_syn_parse_Parse_for_axum_macros_from_ref_FieldAttrs_t.
    Definition Self : Set := axum_macros.from_ref.FieldAttrs.t.
    
    (*
        fn parse(input: ParseStream) -> syn::Result<Self> {
            let mut skip = None;
    
            while !input.is_empty() {
                let lh = input.lookahead1();
                if lh.peek(kw::skip) {
                    skip = Some(input.parse()?);
                } else {
                    return Err(lh.error());
                }
    
                let _ = input.parse::<Token![,]>();
            }
    
            Ok(Self { skip })
        }
    *)
    Definition parse
        (input : ltac:(syn.parse.ParseStream))
        : M ltac:(syn.error.Result Self) :=
      let* input := M.alloc input in
      M.read foo.
    
    Global Instance AssociatedFunction_parse :
      Notations.DoubleColon Self "parse" := {
      Notations.double_colon := parse;
    }.
    
    Global Instance ℐ : syn.parse.Parse.Trait Self := {
      syn.parse.Parse.parse := parse;
    }.
  End Impl_syn_parse_Parse_for_axum_macros_from_ref_FieldAttrs_t.
  End Impl_syn_parse_Parse_for_axum_macros_from_ref_FieldAttrs_t.
  
  Module  Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_ref_FieldAttrs_t.
  Section Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_ref_FieldAttrs_t.
    Definition Self : Set := axum_macros.from_ref.FieldAttrs.t.
    
    (*
        fn combine(mut self, other: Self) -> syn::Result<Self> {
            let Self { skip } = other;
            combine_unary_attribute(&mut self.skip, skip)?;
            Ok(self)
        }
    *)
    Definition combine
        (self : Self)
        (other : Self)
        : M ltac:(syn.error.Result Self) :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_combine :
      Notations.DoubleColon Self "combine" := {
      Notations.double_colon := combine;
    }.
    
    Global Instance ℐ : axum_macros.attr_parsing.Combine.Trait Self := {
      axum_macros.attr_parsing.Combine.combine := combine;
    }.
  End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_ref_FieldAttrs_t.
  End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_ref_FieldAttrs_t.
End from_ref.

(*
pub(crate) fn expand(item: ItemStruct) -> syn::Result<TokenStream> {
    if !item.generics.params.is_empty() {
        return Err(syn::Error::new_spanned(
            item.generics,
            "`#[derive(FromRef)]` doesn't support generics",
        ));
    }

    let tokens = item
        .fields
        .iter()
        .enumerate()
        .map(|(idx, field)| expand_field(&item.ident, idx, field))
        .collect();

    Ok(tokens)
}
*)
Definition expand
    (item : syn.item.ItemStruct.t)
    : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
  let* item := M.alloc item in
  M.read foo.

(*
fn expand_field(state: &Ident, idx: usize, field: &Field) -> TokenStream {
    let FieldAttrs { skip } = match parse_attrs("from_ref", &field.attrs) {
        Ok(attrs) => attrs,
        Err(err) => return err.into_compile_error(),
    };

    if skip.is_some() {
        return TokenStream::default();
    }

    let field_ty = &field.ty;
    let span = field.ty.span();

    let body = if let Some(field_ident) = &field.ident {
        if matches!(field_ty, Type::Reference(_)) {
            quote_spanned! {span=> state.#field_ident }
        } else {
            quote_spanned! {span=> state.#field_ident.clone() }
        }
    } else {
        let idx = syn::Index {
            index: idx as _,
            span: field.span(),
        };
        quote_spanned! {span=> state.#idx.clone() }
    };

    quote_spanned! {span=>
        #[allow(clippy::clone_on_copy)]
        impl ::axum::extract::FromRef<#state> for #field_ty {
            fn from_ref(state: &#state) -> Self {
                #body
            }
        }
    }
}
*)
Definition expand_field
    (state : ref proc_macro2.Ident.t)
    (idx : usize.t)
    (field : ref syn.data.Field.t)
    : M proc_macro2.TokenStream.t :=
  let* state := M.alloc state in
  let* idx := M.alloc idx in
  let* field := M.alloc field in
  M.read foo.

Module Wrap_kw_1.
Module kw.
  Module  skip.
  Section skip.
    Record t : Set := {
      span : ltac:(syn.__private.Span);
    }.
    
    Definition Get_span :=
      Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
  End skip.
  End skip.
  
  (*
          pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
              span: __S,
          ) -> $ident {
              $ident {
                  span: $crate::__private::IntoSpans::into_spans(span),
              }
          }
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition skip
      {__S : Set}
      {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
      (span : __S)
      : M axum_macros.from_ref.kw.skip.t :=
    let* span := M.alloc span in
    M.read foo.
End kw.
End Wrap_kw_1.
Import Wrap_kw_1.

Module  skip.
Section skip.
  Record t : Set := {
    span : ltac:(syn.__private.Span);
  }.
  
  Definition Get_span :=
    Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
End skip.
End skip.

(*
        pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
            span: __S,
        ) -> $ident {
            $ident {
                span: $crate::__private::IntoSpans::into_spans(span),
            }
        }
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition skip
    {__S : Set}
    {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
    (span : __S)
    : M axum_macros.from_ref.kw.skip.t :=
  let* span := M.alloc span in
  M.read foo.

Module  Impl_core_default_Default_for_axum_macros_from_ref_kw_skip_t.
Section Impl_core_default_Default_for_axum_macros_from_ref_kw_skip_t.
  Definition Self : Set := axum_macros.from_ref.kw.skip.t.
  
  (*
                  fn default() -> Self {
                      $ident {
                          span: $crate::__private::Span::call_site(),
                      }
                  }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_macros_from_ref_kw_skip_t.
End Impl_core_default_Default_for_axum_macros_from_ref_kw_skip_t.

Module  Impl_syn_token_private_CustomToken_for_axum_macros_from_ref_kw_skip_t.
Section Impl_syn_token_private_CustomToken_for_axum_macros_from_ref_kw_skip_t.
  Definition Self : Set := axum_macros.from_ref.kw.skip.t.
  
  (*
              fn peek(cursor: $crate::buffer::Cursor) -> $crate::__private::bool {
                  if let $crate::__private::Some((ident, _rest)) = cursor.ident() {
                      ident == $crate::__private::stringify!($ident)
                  } else {
                      false
                  }
              }
  *)
  Definition peek
      (cursor : syn.buffer.Cursor.t)
      : M ltac:(syn.__private.bool) :=
    let* cursor := M.alloc cursor in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
              fn display() -> &'static $crate::__private::str {
                  $crate::__private::concat!("`", $crate::__private::stringify!($ident), "`")
              }
  *)
  Definition display : M (ref ltac:(syn.__private.str)) := M.read foo.
  
  Global Instance AssociatedFunction_display :
    Notations.DoubleColon Self "display" := {
    Notations.double_colon := display;
  }.
  
  Global Instance ℐ : syn.token.private.CustomToken.Trait Self := {
    syn.token.private.CustomToken.peek := peek;
    syn.token.private.CustomToken.display := display;
  }.
End Impl_syn_token_private_CustomToken_for_axum_macros_from_ref_kw_skip_t.
End Impl_syn_token_private_CustomToken_for_axum_macros_from_ref_kw_skip_t.

Module  Impl_syn_parse_Parse_for_axum_macros_from_ref_kw_skip_t.
Section Impl_syn_parse_Parse_for_axum_macros_from_ref_kw_skip_t.
  Definition Self : Set := axum_macros.from_ref.kw.skip.t.
  
  (*
              fn parse(input: $crate::parse::ParseStream) -> $crate::parse::Result<$ident> {
                  input.step(|cursor| {
                      if let $crate::__private::Some((ident, rest)) = cursor.ident() {
                          if ident == $crate::__private::stringify!($ident) {
                              return $crate::__private::Ok(($ident { span: ident.span() }, rest));
                          }
                      }
                      $crate::__private::Err(cursor.error($crate::__private::concat!(
                          "expected `",
                          $crate::__private::stringify!($ident),
                          "`",
                      )))
                  })
              }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      : M ltac:(syn.error.Result axum_macros.from_ref.kw.skip.t) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_from_ref_kw_skip_t.
End Impl_syn_parse_Parse_for_axum_macros_from_ref_kw_skip_t.

Module  Impl_quote_to_tokens_ToTokens_for_axum_macros_from_ref_kw_skip_t.
Section Impl_quote_to_tokens_ToTokens_for_axum_macros_from_ref_kw_skip_t.
  Definition Self : Set := axum_macros.from_ref.kw.skip.t.
  
  (*
              fn to_tokens(&self, tokens: &mut $crate::__private::TokenStream2) {
                  let ident = $crate::Ident::new($crate::__private::stringify!($ident), self.span);
                  $crate::__private::TokenStreamExt::append(tokens, ident);
              }
  *)
  Definition to_tokens
      (self : ref Self)
      (tokens : mut_ref ltac:(syn.__private.TokenStream2))
      : M unit :=
    let* self := M.alloc self in
    let* tokens := M.alloc tokens in
    M.read foo.
  
  Global Instance AssociatedFunction_to_tokens :
    Notations.DoubleColon Self "to_tokens" := {
    Notations.double_colon := to_tokens;
  }.
  
  Global Instance ℐ : quote.to_tokens.ToTokens.Required.Trait Self := {
    quote.to_tokens.ToTokens.to_tokens := to_tokens;
    quote.to_tokens.ToTokens.to_token_stream := Datatypes.None;
    quote.to_tokens.ToTokens.into_token_stream := Datatypes.None;
  }.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_ref_kw_skip_t.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_ref_kw_skip_t.

Module  Impl_core_marker_Copy_for_axum_macros_from_ref_kw_skip_t.
Section Impl_core_marker_Copy_for_axum_macros_from_ref_kw_skip_t.
  Definition Self : Set := axum_macros.from_ref.kw.skip.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_macros_from_ref_kw_skip_t.
End Impl_core_marker_Copy_for_axum_macros_from_ref_kw_skip_t.

Module  Impl_core_clone_Clone_for_axum_macros_from_ref_kw_skip_t.
Section Impl_core_clone_Clone_for_axum_macros_from_ref_kw_skip_t.
  Definition Self : Set := axum_macros.from_ref.kw.skip.t.
  
  (*
              fn clone(&self) -> Self {
                  *self
              }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_macros_from_ref_kw_skip_t.
End Impl_core_clone_Clone_for_axum_macros_from_ref_kw_skip_t.

Module  Impl_core_fmt_Debug_for_axum_macros_from_ref_kw_skip_t.
Section Impl_core_fmt_Debug_for_axum_macros_from_ref_kw_skip_t.
  Definition Self : Set := axum_macros.from_ref.kw.skip.t.
  
  (*
              fn fmt(&self, f: &mut $crate::__private::Formatter) -> $crate::__private::FmtResult {
                  $crate::__private::Formatter::write_str(
                      f,
                      $crate::__private::concat!(
                          "Keyword [",
                          $crate::__private::stringify!($ident),
                          "]",
                      ),
                  )
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref ltac:(syn.__private.Formatter))
      : M ltac:(syn.__private.FmtResult) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_macros_from_ref_kw_skip_t.
End Impl_core_fmt_Debug_for_axum_macros_from_ref_kw_skip_t.

Module  Impl_core_cmp_Eq_for_axum_macros_from_ref_kw_skip_t.
Section Impl_core_cmp_Eq_for_axum_macros_from_ref_kw_skip_t.
  Definition Self : Set := axum_macros.from_ref.kw.skip.t.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq := Datatypes.None;
  }.
End Impl_core_cmp_Eq_for_axum_macros_from_ref_kw_skip_t.
End Impl_core_cmp_Eq_for_axum_macros_from_ref_kw_skip_t.

Module  Impl_core_cmp_PartialEq_for_axum_macros_from_ref_kw_skip_t.
Section Impl_core_cmp_PartialEq_for_axum_macros_from_ref_kw_skip_t.
  Definition Self : Set := axum_macros.from_ref.kw.skip.t.
  
  (*
              fn eq(&self, _other: &Self) -> $crate::__private::bool {
                  true
              }
  *)
  Definition eq
      (self : ref Self)
      (_other : ref Self)
      : M ltac:(syn.__private.bool) :=
    let* self := M.alloc self in
    let* _other := M.alloc _other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_macros_from_ref_kw_skip_t.
End Impl_core_cmp_PartialEq_for_axum_macros_from_ref_kw_skip_t.

Module  Impl_core_hash_Hash_for_axum_macros_from_ref_kw_skip_t.
Section Impl_core_hash_Hash_for_axum_macros_from_ref_kw_skip_t.
  Definition Self : Set := axum_macros.from_ref.kw.skip.t.
  
  (*
              fn hash<__H: $crate::__private::Hasher>(&self, _state: &mut __H) {}
  *)
  Definition hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H}
      (self : ref Self)
      (_state : mut_ref __H)
      : M unit :=
    let* self := M.alloc self in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
      hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_axum_macros_from_ref_kw_skip_t.
End Impl_core_hash_Hash_for_axum_macros_from_ref_kw_skip_t.

Module  FieldAttrs.
Section FieldAttrs.
  Record t : Set := {
    skip : core.option.Option.t axum_macros.from_ref.kw.skip.t;
  }.
  
  Definition Get_skip :=
    Ref.map (fun α => Some α.(skip)) (fun β α => Some (α <| skip := β |>)).
End FieldAttrs.
End FieldAttrs.

Module  Impl_core_default_Default_for_axum_macros_from_ref_FieldAttrs_t.
Section Impl_core_default_Default_for_axum_macros_from_ref_FieldAttrs_t.
  Definition Self : Set := axum_macros.from_ref.FieldAttrs.t.
  
  (*
  Default
  *)
  Definition default : M axum_macros.from_ref.FieldAttrs.t := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_macros_from_ref_FieldAttrs_t.
End Impl_core_default_Default_for_axum_macros_from_ref_FieldAttrs_t.

Module  Impl_syn_parse_Parse_for_axum_macros_from_ref_FieldAttrs_t.
Section Impl_syn_parse_Parse_for_axum_macros_from_ref_FieldAttrs_t.
  Definition Self : Set := axum_macros.from_ref.FieldAttrs.t.
  
  (*
      fn parse(input: ParseStream) -> syn::Result<Self> {
          let mut skip = None;
  
          while !input.is_empty() {
              let lh = input.lookahead1();
              if lh.peek(kw::skip) {
                  skip = Some(input.parse()?);
              } else {
                  return Err(lh.error());
              }
  
              let _ = input.parse::<Token![,]>();
          }
  
          Ok(Self { skip })
      }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      : M ltac:(syn.error.Result Self) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_from_ref_FieldAttrs_t.
End Impl_syn_parse_Parse_for_axum_macros_from_ref_FieldAttrs_t.

Module  Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_ref_FieldAttrs_t.
Section Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_ref_FieldAttrs_t.
  Definition Self : Set := axum_macros.from_ref.FieldAttrs.t.
  
  (*
      fn combine(mut self, other: Self) -> syn::Result<Self> {
          let Self { skip } = other;
          combine_unary_attribute(&mut self.skip, skip)?;
          Ok(self)
      }
  *)
  Definition combine
      (self : Self)
      (other : Self)
      : M ltac:(syn.error.Result Self) :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_combine :
    Notations.DoubleColon Self "combine" := {
    Notations.double_colon := combine;
  }.
  
  Global Instance ℐ : axum_macros.attr_parsing.Combine.Trait Self := {
    axum_macros.attr_parsing.Combine.combine := combine;
  }.
End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_ref_FieldAttrs_t.
End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_ref_FieldAttrs_t.

Module from_request.
  Module attr.
    Module kw.
      Module  via.
      Section via.
        Record t : Set := {
          span : ltac:(syn.__private.Span);
        }.
        
        Definition Get_span :=
          Ref.map
            (fun α => Some α.(span))
            (fun β α => Some (α <| span := β |>)).
      End via.
      End via.
      
      (*
              pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
                  span: __S,
              ) -> $ident {
                  $ident {
                      span: $crate::__private::IntoSpans::into_spans(span),
                  }
              }
      *)
      (* #[allow(dead_code)] - function was ignored by the compiler *)
      Definition via
          {__S : Set}
          {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
          (span : __S)
          : M axum_macros.from_request.attr.kw.via.t :=
        let* span := M.alloc span in
        M.read foo.
      
      Module  rejection.
      Section rejection.
        Record t : Set := {
          span : ltac:(syn.__private.Span);
        }.
        
        Definition Get_span :=
          Ref.map
            (fun α => Some α.(span))
            (fun β α => Some (α <| span := β |>)).
      End rejection.
      End rejection.
      
      (*
              pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
                  span: __S,
              ) -> $ident {
                  $ident {
                      span: $crate::__private::IntoSpans::into_spans(span),
                  }
              }
      *)
      (* #[allow(dead_code)] - function was ignored by the compiler *)
      Definition rejection
          {__S : Set}
          {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
          (span : __S)
          : M axum_macros.from_request.attr.kw.rejection.t :=
        let* span := M.alloc span in
        M.read foo.
      
      Module  state.
      Section state.
        Record t : Set := {
          span : ltac:(syn.__private.Span);
        }.
        
        Definition Get_span :=
          Ref.map
            (fun α => Some α.(span))
            (fun β α => Some (α <| span := β |>)).
      End state.
      End state.
      
      (*
              pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
                  span: __S,
              ) -> $ident {
                  $ident {
                      span: $crate::__private::IntoSpans::into_spans(span),
                  }
              }
      *)
      (* #[allow(dead_code)] - function was ignored by the compiler *)
      Definition state
          {__S : Set}
          {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
          (span : __S)
          : M axum_macros.from_request.attr.kw.state.t :=
        let* span := M.alloc span in
        M.read foo.
    End kw.
    
    Module  FromRequestContainerAttrs.
    Section FromRequestContainerAttrs.
      Record t : Set := {
        via :
          core.option.Option.t
            (axum_macros.from_request.attr.kw.via.t * syn.path.Path.t);
        rejection :
          core.option.Option.t
            (axum_macros.from_request.attr.kw.rejection.t * syn.path.Path.t);
        state :
          core.option.Option.t
            (axum_macros.from_request.attr.kw.state.t * syn.ty.Type_.t);
      }.
      
      Definition Get_via :=
        Ref.map (fun α => Some α.(via)) (fun β α => Some (α <| via := β |>)).
      Definition Get_rejection :=
        Ref.map
          (fun α => Some α.(rejection))
          (fun β α => Some (α <| rejection := β |>)).
      Definition Get_state :=
        Ref.map
          (fun α => Some α.(state))
          (fun β α => Some (α <| state := β |>)).
    End FromRequestContainerAttrs.
    End FromRequestContainerAttrs.
    
    Module  Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    Section Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
      Definition Self : Set :=
        axum_macros.from_request.attr.FromRequestContainerAttrs.t.
      
      (*
      Default
      *)
      Definition default
          : M axum_macros.from_request.attr.FromRequestContainerAttrs.t :=
        M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    
    Module  Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    Section Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
      Definition Self : Set :=
        axum_macros.from_request.attr.FromRequestContainerAttrs.t.
      
      (*
          fn parse(input: ParseStream) -> syn::Result<Self> {
              let mut via = None;
              let mut rejection = None;
              let mut state = None;
      
              while !input.is_empty() {
                  let lh = input.lookahead1();
                  if lh.peek(kw::via) {
                      parse_parenthesized_attribute(input, &mut via)?;
                  } else if lh.peek(kw::rejection) {
                      parse_parenthesized_attribute(input, &mut rejection)?;
                  } else if lh.peek(kw::state) {
                      parse_parenthesized_attribute(input, &mut state)?;
                  } else {
                      return Err(lh.error());
                  }
      
                  let _ = input.parse::<Token![,]>();
              }
      
              Ok(Self {
                  via,
                  rejection,
                  state,
              })
          }
      *)
      Definition parse
          (input : ltac:(syn.parse.ParseStream))
          : M ltac:(syn.error.Result Self) :=
        let* input := M.alloc input in
        M.read foo.
      
      Global Instance AssociatedFunction_parse :
        Notations.DoubleColon Self "parse" := {
        Notations.double_colon := parse;
      }.
      
      Global Instance ℐ : syn.parse.Parse.Trait Self := {
        syn.parse.Parse.parse := parse;
      }.
    End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    
    Module  Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    Section Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
      Definition Self : Set :=
        axum_macros.from_request.attr.FromRequestContainerAttrs.t.
      
      (*
          fn combine(mut self, other: Self) -> syn::Result<Self> {
              let Self {
                  via,
                  rejection,
                  state,
              } = other;
              combine_attribute(&mut self.via, via)?;
              combine_attribute(&mut self.rejection, rejection)?;
              combine_attribute(&mut self.state, state)?;
              Ok(self)
          }
      *)
      Definition combine
          (self : Self)
          (other : Self)
          : M ltac:(syn.error.Result Self) :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_combine :
        Notations.DoubleColon Self "combine" := {
        Notations.double_colon := combine;
      }.
      
      Global Instance ℐ : axum_macros.attr_parsing.Combine.Trait Self := {
        axum_macros.attr_parsing.Combine.combine := combine;
      }.
    End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    
    Module  FromRequestFieldAttrs.
    Section FromRequestFieldAttrs.
      Record t : Set := {
        via :
          core.option.Option.t
            (axum_macros.from_request.attr.kw.via.t * syn.path.Path.t);
      }.
      
      Definition Get_via :=
        Ref.map (fun α => Some α.(via)) (fun β α => Some (α <| via := β |>)).
    End FromRequestFieldAttrs.
    End FromRequestFieldAttrs.
    
    Module  Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
    Section Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
      Definition Self : Set :=
        axum_macros.from_request.attr.FromRequestFieldAttrs.t.
      
      (*
      Default
      *)
      Definition default
          : M axum_macros.from_request.attr.FromRequestFieldAttrs.t :=
        M.read foo.
      
      Global Instance AssociatedFunction_default :
        Notations.DoubleColon Self "default" := {
        Notations.double_colon := default;
      }.
      
      Global Instance ℐ : core.default.Default.Trait Self := {
        core.default.Default.default := default;
      }.
    End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
    End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
    
    Module  Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
    Section Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
      Definition Self : Set :=
        axum_macros.from_request.attr.FromRequestFieldAttrs.t.
      
      (*
          fn parse(input: ParseStream) -> syn::Result<Self> {
              let mut via = None;
      
              while !input.is_empty() {
                  let lh = input.lookahead1();
                  if lh.peek(kw::via) {
                      parse_parenthesized_attribute(input, &mut via)?;
                  } else {
                      return Err(lh.error());
                  }
      
                  let _ = input.parse::<Token![,]>();
              }
      
              Ok(Self { via })
          }
      *)
      Definition parse
          (input : ltac:(syn.parse.ParseStream))
          : M ltac:(syn.error.Result Self) :=
        let* input := M.alloc input in
        M.read foo.
      
      Global Instance AssociatedFunction_parse :
        Notations.DoubleColon Self "parse" := {
        Notations.double_colon := parse;
      }.
      
      Global Instance ℐ : syn.parse.Parse.Trait Self := {
        syn.parse.Parse.parse := parse;
      }.
    End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
    End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
    
    Module  Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
    Section Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
      Definition Self : Set :=
        axum_macros.from_request.attr.FromRequestFieldAttrs.t.
      
      (*
          fn combine(mut self, other: Self) -> syn::Result<Self> {
              let Self { via } = other;
              combine_attribute(&mut self.via, via)?;
              Ok(self)
          }
      *)
      Definition combine
          (self : Self)
          (other : Self)
          : M ltac:(syn.error.Result Self) :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        M.read foo.
      
      Global Instance AssociatedFunction_combine :
        Notations.DoubleColon Self "combine" := {
        Notations.double_colon := combine;
      }.
      
      Global Instance ℐ : axum_macros.attr_parsing.Combine.Trait Self := {
        axum_macros.attr_parsing.Combine.combine := combine;
      }.
    End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
    End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  End attr.
  
  Module Trait.
    Inductive t : Set :=
    | FromRequest
    | FromRequestParts.
  End Trait.
  
  Module  Impl_core_clone_Clone_for_axum_macros_from_request_Trait_t.
  Section Impl_core_clone_Clone_for_axum_macros_from_request_Trait_t.
    Definition Self : Set := axum_macros.from_request.Trait.t.
    
    (*
    Clone
    *)
    Definition clone (self : ref Self) : M axum_macros.from_request.Trait.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_macros_from_request_Trait_t.
  End Impl_core_clone_Clone_for_axum_macros_from_request_Trait_t.
  
  Module  Impl_core_marker_Copy_for_axum_macros_from_request_Trait_t.
  Section Impl_core_marker_Copy_for_axum_macros_from_request_Trait_t.
    Definition Self : Set := axum_macros.from_request.Trait.t.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_macros_from_request_Trait_t.
  End Impl_core_marker_Copy_for_axum_macros_from_request_Trait_t.
  
  Module  Impl_axum_macros_from_request_Trait_t.
  Section Impl_axum_macros_from_request_Trait_t.
    Definition Self : Set := axum_macros.from_request.Trait.t.
    
    (*
        fn via_marker_type(&self) -> Option<Type> {
            match self {
                Trait::FromRequest => Some(parse_quote!(M)),
                Trait::FromRequestParts => None,
            }
        }
    *)
    Definition via_marker_type
        (self : ref Self)
        : M (core.option.Option.t syn.ty.Type_.t) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_via_marker_type :
      Notations.DoubleColon Self "via_marker_type" := {
      Notations.double_colon := via_marker_type;
    }.
  End Impl_axum_macros_from_request_Trait_t.
  End Impl_axum_macros_from_request_Trait_t.
  
  Module  Impl_core_fmt_Display_for_axum_macros_from_request_Trait_t.
  Section Impl_core_fmt_Display_for_axum_macros_from_request_Trait_t.
    Definition Self : Set := axum_macros.from_request.Trait.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Trait::FromRequest => f.write_str("FromRequest"),
                Trait::FromRequestParts => f.write_str("FromRequestParts"),
            }
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_axum_macros_from_request_Trait_t.
  End Impl_core_fmt_Display_for_axum_macros_from_request_Trait_t.
  
  Module State.
    Inductive t : Set :=
    | Custom (_ : syn.ty.Type_.t)
    | Default (_ : syn.ty.Type_.t)
    | CannotInfer.
    
    Definition Get_Custom_0 :=
      Ref.map
        (fun α => match α with | Custom α0 => Some α0 | _ => None end)
        (fun β α => match α with | Custom _ => Some (Custom β) | _ => None end).
    
    Definition Get_Default_0 :=
      Ref.map
        (fun α => match α with | Default α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with | Default _ => Some (Default β) | _ => None end).
  End State.
  
  Module  Impl_core_fmt_Debug_for_axum_macros_from_request_State_t.
  Section Impl_core_fmt_Debug_for_axum_macros_from_request_State_t.
    Definition Self : Set := axum_macros.from_request.State.t.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_macros_from_request_State_t.
  End Impl_core_fmt_Debug_for_axum_macros_from_request_State_t.
  
  Module  Impl_axum_macros_from_request_State_t.
  Section Impl_axum_macros_from_request_State_t.
    Definition Self : Set := axum_macros.from_request.State.t.
    
    (*
        fn impl_generics(&self) -> impl Iterator<Item = Type> {
            match self {
                State::Default(inner) => Some(inner.clone()),
                State::Custom(_) => None,
                State::CannotInfer => Some(parse_quote!(S)),
            }
            .into_iter()
        }
    *)
    Definition impl_generics (self : ref Self) : M _ (* OpaqueTy *) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_impl_generics :
      Notations.DoubleColon Self "impl_generics" := {
      Notations.double_colon := impl_generics;
    }.
    
    (*
        fn trait_generics(&self) -> impl Iterator<Item = Type> {
            match self {
                State::Default(inner) | State::Custom(inner) => iter::once(inner.clone()),
                State::CannotInfer => iter::once(parse_quote!(S)),
            }
        }
    *)
    Definition trait_generics (self : ref Self) : M _ (* OpaqueTy *) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_trait_generics :
      Notations.DoubleColon Self "trait_generics" := {
      Notations.double_colon := trait_generics;
    }.
    
    (*
        fn bounds(&self) -> TokenStream {
            match self {
                State::Custom(_) => quote! {},
                State::Default(inner) => quote! {
                    #inner: ::std::marker::Send + ::std::marker::Sync,
                },
                State::CannotInfer => quote! {
                    S: ::std::marker::Send + ::std::marker::Sync,
                },
            }
        }
    *)
    Definition bounds (self : ref Self) : M proc_macro2.TokenStream.t :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_bounds :
      Notations.DoubleColon Self "bounds" := {
      Notations.double_colon := bounds;
    }.
  End Impl_axum_macros_from_request_State_t.
  End Impl_axum_macros_from_request_State_t.
  
  Module  Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_State_t.
  Section Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_State_t.
    Definition Self : Set := axum_macros.from_request.State.t.
    
    (*
        fn to_tokens(&self, tokens: &mut TokenStream) {
            match self {
                State::Custom(inner) | State::Default(inner) => inner.to_tokens(tokens),
                State::CannotInfer => quote! { S }.to_tokens(tokens),
            }
        }
    *)
    Definition to_tokens
        (self : ref Self)
        (tokens : mut_ref proc_macro2.TokenStream.t)
        : M unit :=
      let* self := M.alloc self in
      let* tokens := M.alloc tokens in
      M.read foo.
    
    Global Instance AssociatedFunction_to_tokens :
      Notations.DoubleColon Self "to_tokens" := {
      Notations.double_colon := to_tokens;
    }.
    
    Global Instance ℐ : quote.to_tokens.ToTokens.Required.Trait Self := {
      quote.to_tokens.ToTokens.to_tokens := to_tokens;
      quote.to_tokens.ToTokens.to_token_stream := Datatypes.None;
      quote.to_tokens.ToTokens.into_token_stream := Datatypes.None;
    }.
  End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_State_t.
  End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_State_t.
  
  (*
  pub(crate) fn expand(item: syn::Item, tr: Trait) -> syn::Result<TokenStream> {
      match item {
          syn::Item::Struct(item) => {
              let syn::ItemStruct {
                  attrs,
                  ident,
                  generics,
                  fields,
                  semi_token: _,
                  vis: _,
                  struct_token: _,
              } = item;
  
              let generic_ident = parse_single_generic_type_on_struct(generics, &fields, tr)?;
  
              let FromRequestContainerAttrs {
                  via,
                  rejection,
                  state,
              } = parse_attrs("from_request", &attrs)?;
  
              let state = match state {
                  Some((_, state)) => State::Custom(state),
                  None => {
                      let mut inferred_state_types: HashSet<_> =
                          infer_state_type_from_field_types(&fields)
                              .chain(infer_state_type_from_field_attributes(&fields))
                              .collect();
  
                      if let Some((_, via)) = &via {
                          inferred_state_types.extend(state_from_via(&ident, via));
                      }
  
                      match inferred_state_types.len() {
                          0 => State::Default(syn::parse_quote!(S)),
                          1 => State::Custom(inferred_state_types.iter().next().unwrap().to_owned()),
                          _ => State::CannotInfer,
                      }
                  }
              };
  
              let trait_impl = match (via.map(second), rejection.map(second)) {
                  (Some(via), rejection) => impl_struct_by_extracting_all_at_once(
                      ident,
                      fields,
                      via,
                      rejection,
                      generic_ident,
                      &state,
                      tr,
                  )?,
                  (None, rejection) => {
                      error_on_generic_ident(generic_ident, tr)?;
                      impl_struct_by_extracting_each_field(ident, fields, rejection, &state, tr)?
                  }
              };
  
              if let State::CannotInfer = state {
                  let attr_name = match tr {
                      Trait::FromRequest => "from_request",
                      Trait::FromRequestParts => "from_request_parts",
                  };
                  let compile_error = syn::Error::new(
                      Span::call_site(),
                      format_args!(
                          "can't infer state type, please add \
                           `#[{attr_name}(state = MyStateType)]` attribute",
                      ),
                  )
                  .into_compile_error();
  
                  Ok(quote! {
                      #trait_impl
                      #compile_error
                  })
              } else {
                  Ok(trait_impl)
              }
          }
          syn::Item::Enum(item) => {
              let syn::ItemEnum {
                  attrs,
                  vis: _,
                  enum_token: _,
                  ident,
                  generics,
                  brace_token: _,
                  variants,
              } = item;
  
              let generics_error = format!("`#[derive({tr})] on enums don't support generics");
  
              if !generics.params.is_empty() {
                  return Err(syn::Error::new_spanned(generics, generics_error));
              }
  
              if let Some(where_clause) = generics.where_clause {
                  return Err(syn::Error::new_spanned(where_clause, generics_error));
              }
  
              let FromRequestContainerAttrs {
                  via,
                  rejection,
                  state,
              } = parse_attrs("from_request", &attrs)?;
  
              let state = match state {
                  Some((_, state)) => State::Custom(state),
                  None => (|| {
                      let via = via.as_ref().map(|(_, via)| via)?;
                      state_from_via(&ident, via).map(State::Custom)
                  })()
                  .unwrap_or_else(|| State::Default(syn::parse_quote!(S))),
              };
  
              match (via.map(second), rejection) {
                  (Some(via), rejection) => impl_enum_by_extracting_all_at_once(
                      ident,
                      variants,
                      via,
                      rejection.map(second),
                      state,
                      tr,
                  ),
                  (None, Some((rejection_kw, _))) => Err(syn::Error::new_spanned(
                      rejection_kw,
                      "cannot use `rejection` without `via`",
                  )),
                  (None, _) => Err(syn::Error::new(
                      Span::call_site(),
                      "missing `#[from_request(via(...))]`",
                  )),
              }
          }
          _ => Err(syn::Error::new_spanned(item, "expected `struct` or `enum`")),
      }
  }
  *)
  Definition expand
      (item : syn.item.Item.t)
      (tr : axum_macros.from_request.Trait.t)
      : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
    let* item := M.alloc item in
    let* tr := M.alloc tr in
    M.read foo.
  
  (*
  fn parse_single_generic_type_on_struct(
      generics: syn::Generics,
      fields: &syn::Fields,
      tr: Trait,
  ) -> syn::Result<Option<Ident>> {
      if let Some(where_clause) = generics.where_clause {
          return Err(syn::Error::new_spanned(
              where_clause,
              format_args!("#[derive({tr})] doesn't support structs with `where` clauses"),
          ));
      }
  
      match generics.params.len() {
          0 => Ok(None),
          1 => {
              let param = generics.params.first().unwrap();
              let ty_ident = match param {
                  syn::GenericParam::Type(ty) => &ty.ident,
                  syn::GenericParam::Lifetime(lifetime) => {
                      return Err(syn::Error::new_spanned(
                          lifetime,
                          format_args!(
                              "#[derive({tr})] doesn't support structs \
                               that are generic over lifetimes"
                          ),
                      ));
                  }
                  syn::GenericParam::Const(konst) => {
                      return Err(syn::Error::new_spanned(
                          konst,
                          format_args!(
                              "#[derive({tr})] doesn't support structs \
                               that have const generics"
                          ),
                      ));
                  }
              };
  
              match fields {
                  syn::Fields::Named(fields_named) => {
                      return Err(syn::Error::new_spanned(
                          fields_named,
                          format_args!(
                              "#[derive({tr})] doesn't support named fields \
                               for generic structs. Use a tuple struct instead"
                          ),
                      ));
                  }
                  syn::Fields::Unnamed(fields_unnamed) => {
                      if fields_unnamed.unnamed.len() != 1 {
                          return Err(syn::Error::new_spanned(
                              fields_unnamed,
                              format_args!(
                                  "#[derive({tr})] only supports generics on \
                                   tuple structs that have exactly one field"
                              ),
                          ));
                      }
  
                      let field = fields_unnamed.unnamed.first().unwrap();
  
                      if let syn::Type::Path(type_path) = &field.ty {
                          if type_path
                              .path
                              .get_ident()
                              .map_or(true, |field_type_ident| field_type_ident != ty_ident)
                          {
                              return Err(syn::Error::new_spanned(
                                  type_path,
                                  format_args!(
                                      "#[derive({tr})] only supports generics on \
                                       tuple structs that have exactly one field of the generic type"
                                  ),
                              ));
                          }
                      } else {
                          return Err(syn::Error::new_spanned(&field.ty, "Expected type path"));
                      }
                  }
                  syn::Fields::Unit => return Ok(None),
              }
  
              Ok(Some(ty_ident.clone()))
          }
          _ => Err(syn::Error::new_spanned(
              generics,
              format_args!("#[derive({tr})] only supports 0 or 1 generic type parameters"),
          )),
      }
  }
  *)
  Definition parse_single_generic_type_on_struct
      (generics : syn.generics.Generics.t)
      (fields : ref syn.data.Fields.t)
      (tr : axum_macros.from_request.Trait.t)
      : M ltac:(syn.error.Result (core.option.Option.t proc_macro2.Ident.t)) :=
    let* generics := M.alloc generics in
    let* fields := M.alloc fields in
    let* tr := M.alloc tr in
    M.read foo.
  
  (*
  fn error_on_generic_ident(generic_ident: Option<Ident>, tr: Trait) -> syn::Result<()> {
      if let Some(generic_ident) = generic_ident {
          Err(syn::Error::new_spanned(
              generic_ident,
              format_args!(
                  "#[derive({tr})] only supports generics when used with #[from_request(via)]"
              ),
          ))
      } else {
          Ok(())
      }
  }
  *)
  Definition error_on_generic_ident
      (generic_ident : core.option.Option.t proc_macro2.Ident.t)
      (tr : axum_macros.from_request.Trait.t)
      : M ltac:(syn.error.Result unit) :=
    let* generic_ident := M.alloc generic_ident in
    let* tr := M.alloc tr in
    M.read foo.
  
  (*
  fn impl_struct_by_extracting_each_field(
      ident: syn::Ident,
      fields: syn::Fields,
      rejection: Option<syn::Path>,
      state: &State,
      tr: Trait,
  ) -> syn::Result<TokenStream> {
      let trait_fn_body = match state {
          State::CannotInfer => quote! {
              ::std::unimplemented!()
          },
          _ => {
              let extract_fields = extract_fields(&fields, &rejection, tr)?;
              quote! {
                  ::std::result::Result::Ok(Self {
                      #(#extract_fields)*
                  })
              }
          }
      };
  
      let rejection_ident = if let Some(rejection) = rejection {
          quote!(#rejection)
      } else if has_no_fields(&fields) {
          quote!(::std::convert::Infallible)
      } else {
          quote!(::axum::response::Response)
      };
  
      let impl_generics = state
          .impl_generics()
          .collect::<Punctuated<Type, Token![,]>>();
  
      let trait_generics = state
          .trait_generics()
          .collect::<Punctuated<Type, Token![,]>>();
  
      let state_bounds = state.bounds();
  
      Ok(match tr {
          Trait::FromRequest => quote! {
              #[::axum::async_trait]
              #[automatically_derived]
              impl<#impl_generics> ::axum::extract::FromRequest<#trait_generics> for #ident
              where
                  #state_bounds
              {
                  type Rejection = #rejection_ident;
  
                  async fn from_request(
                      mut req: ::axum::http::Request<::axum::body::Body>,
                      state: &#state,
                  ) -> ::std::result::Result<Self, Self::Rejection> {
                      #trait_fn_body
                  }
              }
          },
          Trait::FromRequestParts => quote! {
              #[::axum::async_trait]
              #[automatically_derived]
              impl<#impl_generics> ::axum::extract::FromRequestParts<#trait_generics> for #ident
              where
                  #state_bounds
              {
                  type Rejection = #rejection_ident;
  
                  async fn from_request_parts(
                      parts: &mut ::axum::http::request::Parts,
                      state: &#state,
                  ) -> ::std::result::Result<Self, Self::Rejection> {
                      #trait_fn_body
                  }
              }
          },
      })
  }
  *)
  Definition impl_struct_by_extracting_each_field
      (ident : proc_macro2.Ident.t)
      (fields : syn.data.Fields.t)
      (rejection : core.option.Option.t syn.path.Path.t)
      (state : ref axum_macros.from_request.State.t)
      (tr : axum_macros.from_request.Trait.t)
      : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
    let* ident := M.alloc ident in
    let* fields := M.alloc fields in
    let* rejection := M.alloc rejection in
    let* state := M.alloc state in
    let* tr := M.alloc tr in
    M.read foo.
  
  (*
  fn has_no_fields(fields: &syn::Fields) -> bool {
      match fields {
          syn::Fields::Named(fields) => fields.named.is_empty(),
          syn::Fields::Unnamed(fields) => fields.unnamed.is_empty(),
          syn::Fields::Unit => true,
      }
  }
  *)
  Definition has_no_fields (fields : ref syn.data.Fields.t) : M bool.t :=
    let* fields := M.alloc fields in
    M.read foo.
  
  (*
  fn extract_fields(
      fields: &syn::Fields,
      rejection: &Option<syn::Path>,
      tr: Trait,
  ) -> syn::Result<Vec<TokenStream>> {
      fn member(field: &syn::Field, index: usize) -> TokenStream {
          match &field.ident {
              Some(ident) => quote! { #ident },
              _ => {
                  let member = syn::Member::Unnamed(syn::Index {
                      index: index as u32,
                      span: field.span(),
                  });
                  quote! { #member }
              }
          }
      }
  
      fn into_inner(via: Option<(attr::kw::via, syn::Path)>, ty_span: Span) -> TokenStream {
          if let Some((_, path)) = via {
              let span = path.span();
              quote_spanned! {span=>
                  |#path(inner)| inner
              }
          } else {
              quote_spanned! {ty_span=>
                  ::std::convert::identity
              }
          }
      }
  
      let mut fields_iter = fields.iter();
  
      let last = match tr {
          // Use FromRequestParts for all elements except the last
          Trait::FromRequest => fields_iter.next_back(),
          // Use FromRequestParts for all elements
          Trait::FromRequestParts => None,
      };
  
      let mut res: Vec<_> = fields_iter
          .enumerate()
          .map(|(index, field)| {
              let FromRequestFieldAttrs { via } = parse_attrs("from_request", &field.attrs)?;
  
              let member = member(field, index);
              let ty_span = field.ty.span();
              let into_inner = into_inner(via, ty_span);
  
              if peel_option(&field.ty).is_some() {
                  let tokens = match tr {
                      Trait::FromRequest => {
                          quote_spanned! {ty_span=>
                              #member: {
                                  let (mut parts, body) = req.into_parts();
                                  let value =
                                      ::axum::extract::FromRequestParts::from_request_parts(
                                          &mut parts,
                                          state,
                                      )
                                      .await
                                      .ok()
                                      .map(#into_inner);
                                  req = ::axum::http::Request::from_parts(parts, body);
                                  value
                              },
                          }
                      }
                      Trait::FromRequestParts => {
                          quote_spanned! {ty_span=>
                              #member: {
                                  ::axum::extract::FromRequestParts::from_request_parts(
                                      parts,
                                      state,
                                  )
                                  .await
                                  .ok()
                                  .map(#into_inner)
                              },
                          }
                      }
                  };
                  Ok(tokens)
              } else if peel_result_ok(&field.ty).is_some() {
                  let tokens = match tr {
                      Trait::FromRequest => {
                          quote_spanned! {ty_span=>
                              #member: {
                                  let (mut parts, body) = req.into_parts();
                                  let value =
                                      ::axum::extract::FromRequestParts::from_request_parts(
                                          &mut parts,
                                          state,
                                      )
                                      .await
                                      .map(#into_inner);
                                  req = ::axum::http::Request::from_parts(parts, body);
                                  value
                              },
                          }
                      }
                      Trait::FromRequestParts => {
                          quote_spanned! {ty_span=>
                              #member: {
                                  ::axum::extract::FromRequestParts::from_request_parts(
                                      parts,
                                      state,
                                  )
                                  .await
                                  .map(#into_inner)
                              },
                          }
                      }
                  };
                  Ok(tokens)
              } else {
                  let map_err = if let Some(rejection) = rejection {
                      quote! { <#rejection as ::std::convert::From<_>>::from }
                  } else {
                      quote! { ::axum::response::IntoResponse::into_response }
                  };
  
                  let tokens = match tr {
                      Trait::FromRequest => {
                          quote_spanned! {ty_span=>
                              #member: {
                                  let (mut parts, body) = req.into_parts();
                                  let value =
                                      ::axum::extract::FromRequestParts::from_request_parts(
                                          &mut parts,
                                          state,
                                      )
                                      .await
                                      .map(#into_inner)
                                      .map_err(#map_err)?;
                                  req = ::axum::http::Request::from_parts(parts, body);
                                  value
                              },
                          }
                      }
                      Trait::FromRequestParts => {
                          quote_spanned! {ty_span=>
                              #member: {
                                  ::axum::extract::FromRequestParts::from_request_parts(
                                      parts,
                                      state,
                                  )
                                  .await
                                  .map(#into_inner)
                                  .map_err(#map_err)?
                              },
                          }
                      }
                  };
                  Ok(tokens)
              }
          })
          .collect::<syn::Result<_>>()?;
  
      // Handle the last element, if deriving FromRequest
      if let Some(field) = last {
          let FromRequestFieldAttrs { via } = parse_attrs("from_request", &field.attrs)?;
  
          let member = member(field, fields.len() - 1);
          let ty_span = field.ty.span();
          let into_inner = into_inner(via, ty_span);
  
          let item = if peel_option(&field.ty).is_some() {
              quote_spanned! {ty_span=>
                  #member: {
                      ::axum::extract::FromRequest::from_request(req, state)
                          .await
                          .ok()
                          .map(#into_inner)
                  },
              }
          } else if peel_result_ok(&field.ty).is_some() {
              quote_spanned! {ty_span=>
                  #member: {
                      ::axum::extract::FromRequest::from_request(req, state)
                          .await
                          .map(#into_inner)
                  },
              }
          } else {
              let map_err = if let Some(rejection) = rejection {
                  quote! { <#rejection as ::std::convert::From<_>>::from }
              } else {
                  quote! { ::axum::response::IntoResponse::into_response }
              };
  
              quote_spanned! {ty_span=>
                  #member: {
                      ::axum::extract::FromRequest::from_request(req, state)
                          .await
                          .map(#into_inner)
                          .map_err(#map_err)?
                  },
              }
          };
  
          res.push(item);
      }
  
      Ok(res)
  }
  *)
  Definition extract_fields
      (fields : ref syn.data.Fields.t)
      (rejection : ref (core.option.Option.t syn.path.Path.t))
      (tr : axum_macros.from_request.Trait.t)
      :
        M
          ltac:(syn.error.Result
            (alloc.vec.Vec.t
              proc_macro2.TokenStream.t
              alloc.vec.Vec.Default.A)) :=
    let* fields := M.alloc fields in
    let* rejection := M.alloc rejection in
    let* tr := M.alloc tr in
    M.read foo.
  
  (*
  fn peel_option(ty: &syn::Type) -> Option<&syn::Type> {
      let type_path = if let syn::Type::Path(type_path) = ty {
          type_path
      } else {
          return None;
      };
  
      let segment = type_path.path.segments.last()?;
  
      if segment.ident != "Option" {
          return None;
      }
  
      let args = match &segment.arguments {
          syn::PathArguments::AngleBracketed(args) => args,
          syn::PathArguments::Parenthesized(_) | syn::PathArguments::None => return None,
      };
  
      let ty = if args.args.len() == 1 {
          args.args.last().unwrap()
      } else {
          return None;
      };
  
      if let syn::GenericArgument::Type(ty) = ty {
          Some(ty)
      } else {
          None
      }
  }
  *)
  Definition peel_option
      (ty : ref syn.ty.Type_.t)
      : M (core.option.Option.t (ref syn.ty.Type_.t)) :=
    let* ty := M.alloc ty in
    M.read foo.
  
  (*
  fn peel_result_ok(ty: &syn::Type) -> Option<&syn::Type> {
      let type_path = if let syn::Type::Path(type_path) = ty {
          type_path
      } else {
          return None;
      };
  
      let segment = type_path.path.segments.last()?;
  
      if segment.ident != "Result" {
          return None;
      }
  
      let args = match &segment.arguments {
          syn::PathArguments::AngleBracketed(args) => args,
          syn::PathArguments::Parenthesized(_) | syn::PathArguments::None => return None,
      };
  
      let ty = if args.args.len() == 2 {
          args.args.first().unwrap()
      } else {
          return None;
      };
  
      if let syn::GenericArgument::Type(ty) = ty {
          Some(ty)
      } else {
          None
      }
  }
  *)
  Definition peel_result_ok
      (ty : ref syn.ty.Type_.t)
      : M (core.option.Option.t (ref syn.ty.Type_.t)) :=
    let* ty := M.alloc ty in
    M.read foo.
  
  (*
  fn impl_struct_by_extracting_all_at_once(
      ident: syn::Ident,
      fields: syn::Fields,
      via_path: syn::Path,
      rejection: Option<syn::Path>,
      generic_ident: Option<Ident>,
      state: &State,
      tr: Trait,
  ) -> syn::Result<TokenStream> {
      let fields = match fields {
          syn::Fields::Named(fields) => fields.named.into_iter(),
          syn::Fields::Unnamed(fields) => fields.unnamed.into_iter(),
          syn::Fields::Unit => Punctuated::<_, Token![,]>::new().into_iter(),
      };
  
      for field in fields {
          let FromRequestFieldAttrs { via } = parse_attrs("from_request", &field.attrs)?;
  
          if let Some((via, _)) = via {
              return Err(syn::Error::new_spanned(
                  via,
                  "`#[from_request(via(...))]` on a field cannot be used \
                  together with `#[from_request(...)]` on the container",
              ));
          }
      }
  
      let path_span = via_path.span();
  
      let (associated_rejection_type, map_err) = if let Some(rejection) = &rejection {
          let rejection = quote! { #rejection };
          let map_err = quote! { ::std::convert::From::from };
          (rejection, map_err)
      } else {
          let rejection = quote! {
              ::axum::response::Response
          };
          let map_err = quote! { ::axum::response::IntoResponse::into_response };
          (rejection, map_err)
      };
  
      // for something like
      //
      // ```
      // #[derive(Clone, Default, FromRequest)]
      // #[from_request(via(State))]
      // struct AppState {}
      // ```
      //
      // we need to implement `impl<M> FromRequest<AppState, M>` but only for
      // - `#[derive(FromRequest)]`, not `#[derive(FromRequestParts)]`
      // - `State`, not other extractors
      //
      // honestly not sure why but the tests all pass
      let via_marker_type = if path_ident_is_state(&via_path) {
          tr.via_marker_type()
      } else {
          None
      };
  
      let impl_generics = via_marker_type
          .iter()
          .cloned()
          .chain(state.impl_generics())
          .chain(generic_ident.is_some().then(|| parse_quote!(T)))
          .collect::<Punctuated<Type, Token![,]>>();
  
      let trait_generics = state
          .trait_generics()
          .chain(via_marker_type)
          .collect::<Punctuated<Type, Token![,]>>();
  
      let ident_generics = generic_ident
          .is_some()
          .then(|| quote! { <T> })
          .unwrap_or_default();
  
      let rejection_bound = rejection.as_ref().map(|rejection| {
          match (tr, generic_ident.is_some()) {
              (Trait::FromRequest, true) => {
                  quote! {
                      #rejection: ::std::convert::From<<#via_path<T> as ::axum::extract::FromRequest<#trait_generics>>::Rejection>,
                  }
              },
              (Trait::FromRequest, false) => {
                  quote! {
                      #rejection: ::std::convert::From<<#via_path<Self> as ::axum::extract::FromRequest<#trait_generics>>::Rejection>,
                  }
              },
              (Trait::FromRequestParts, true) => {
                  quote! {
                      #rejection: ::std::convert::From<<#via_path<T> as ::axum::extract::FromRequestParts<#trait_generics>>::Rejection>,
                  }
              },
              (Trait::FromRequestParts, false) => {
                  quote! {
                      #rejection: ::std::convert::From<<#via_path<Self> as ::axum::extract::FromRequestParts<#trait_generics>>::Rejection>,
                  }
              }
          }
      }).unwrap_or_default();
  
      let via_type_generics = if generic_ident.is_some() {
          quote! { T }
      } else {
          quote! { Self }
      };
  
      let value_to_self = if generic_ident.is_some() {
          quote! {
              #ident(value)
          }
      } else {
          quote! { value }
      };
  
      let state_bounds = state.bounds();
  
      let tokens = match tr {
          Trait::FromRequest => {
              quote_spanned! {path_span=>
                  #[::axum::async_trait]
                  #[automatically_derived]
                  impl<#impl_generics> ::axum::extract::FromRequest<#trait_generics> for #ident #ident_generics
                  where
                      #via_path<#via_type_generics>: ::axum::extract::FromRequest<#trait_generics>,
                      #rejection_bound
                      #state_bounds
                  {
                      type Rejection = #associated_rejection_type;
  
                      async fn from_request(
                          req: ::axum::http::Request<::axum::body::Body>,
                          state: &#state,
                      ) -> ::std::result::Result<Self, Self::Rejection> {
                          ::axum::extract::FromRequest::from_request(req, state)
                              .await
                              .map(|#via_path(value)| #value_to_self)
                              .map_err(#map_err)
                      }
                  }
              }
          }
          Trait::FromRequestParts => {
              quote_spanned! {path_span=>
                  #[::axum::async_trait]
                  #[automatically_derived]
                  impl<#impl_generics> ::axum::extract::FromRequestParts<#trait_generics> for #ident #ident_generics
                  where
                      #via_path<#via_type_generics>: ::axum::extract::FromRequestParts<#trait_generics>,
                      #rejection_bound
                      #state_bounds
                  {
                      type Rejection = #associated_rejection_type;
  
                      async fn from_request_parts(
                          parts: &mut ::axum::http::request::Parts,
                          state: &#state,
                      ) -> ::std::result::Result<Self, Self::Rejection> {
                          ::axum::extract::FromRequestParts::from_request_parts(parts, state)
                              .await
                              .map(|#via_path(value)| #value_to_self)
                              .map_err(#map_err)
                      }
                  }
              }
          }
      };
  
      Ok(tokens)
  }
  *)
  Definition impl_struct_by_extracting_all_at_once
      (ident : proc_macro2.Ident.t)
      (fields : syn.data.Fields.t)
      (via_path : syn.path.Path.t)
      (rejection : core.option.Option.t syn.path.Path.t)
      (generic_ident : core.option.Option.t proc_macro2.Ident.t)
      (state : ref axum_macros.from_request.State.t)
      (tr : axum_macros.from_request.Trait.t)
      : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
    let* ident := M.alloc ident in
    let* fields := M.alloc fields in
    let* via_path := M.alloc via_path in
    let* rejection := M.alloc rejection in
    let* generic_ident := M.alloc generic_ident in
    let* state := M.alloc state in
    let* tr := M.alloc tr in
    M.read foo.
  
  (*
  fn impl_enum_by_extracting_all_at_once(
      ident: syn::Ident,
      variants: Punctuated<syn::Variant, Token![,]>,
      path: syn::Path,
      rejection: Option<syn::Path>,
      state: State,
      tr: Trait,
  ) -> syn::Result<TokenStream> {
      for variant in variants {
          let FromRequestFieldAttrs { via } = parse_attrs("from_request", &variant.attrs)?;
  
          if let Some((via, _)) = via {
              return Err(syn::Error::new_spanned(
                  via,
                  "`#[from_request(via(...))]` cannot be used on variants",
              ));
          }
  
          let fields = match variant.fields {
              syn::Fields::Named(fields) => fields.named.into_iter(),
              syn::Fields::Unnamed(fields) => fields.unnamed.into_iter(),
              syn::Fields::Unit => Punctuated::<_, Token![,]>::new().into_iter(),
          };
  
          for field in fields {
              let FromRequestFieldAttrs { via } = parse_attrs("from_request", &field.attrs)?;
              if let Some((via, _)) = via {
                  return Err(syn::Error::new_spanned(
                      via,
                      "`#[from_request(via(...))]` cannot be used inside variants",
                  ));
              }
          }
      }
  
      let (associated_rejection_type, map_err) = if let Some(rejection) = &rejection {
          let rejection = quote! { #rejection };
          let map_err = quote! { ::std::convert::From::from };
          (rejection, map_err)
      } else {
          let rejection = quote! {
              ::axum::response::Response
          };
          let map_err = quote! { ::axum::response::IntoResponse::into_response };
          (rejection, map_err)
      };
  
      let path_span = path.span();
  
      let impl_generics = state
          .impl_generics()
          .collect::<Punctuated<Type, Token![,]>>();
  
      let trait_generics = state
          .trait_generics()
          .collect::<Punctuated<Type, Token![,]>>();
  
      let state_bounds = state.bounds();
  
      let tokens = match tr {
          Trait::FromRequest => {
              quote_spanned! {path_span=>
                  #[::axum::async_trait]
                  #[automatically_derived]
                  impl<#impl_generics> ::axum::extract::FromRequest<#trait_generics> for #ident
                  where
                      #state_bounds
                  {
                      type Rejection = #associated_rejection_type;
  
                      async fn from_request(
                          req: ::axum::http::Request<::axum::body::Body>,
                          state: &#state,
                      ) -> ::std::result::Result<Self, Self::Rejection> {
                          ::axum::extract::FromRequest::from_request(req, state)
                              .await
                              .map(|#path(inner)| inner)
                              .map_err(#map_err)
                      }
                  }
              }
          }
          Trait::FromRequestParts => {
              quote_spanned! {path_span=>
                  #[::axum::async_trait]
                  #[automatically_derived]
                  impl<#impl_generics> ::axum::extract::FromRequestParts<#trait_generics> for #ident
                  where
                      #state_bounds
                  {
                      type Rejection = #associated_rejection_type;
  
                      async fn from_request_parts(
                          parts: &mut ::axum::http::request::Parts,
                          state: &#state,
                      ) -> ::std::result::Result<Self, Self::Rejection> {
                          ::axum::extract::FromRequestParts::from_request_parts(parts, state)
                              .await
                              .map(|#path(inner)| inner)
                              .map_err(#map_err)
                      }
                  }
              }
          }
      };
  
      Ok(tokens)
  }
  *)
  Definition impl_enum_by_extracting_all_at_once
      (ident : proc_macro2.Ident.t)
      (variants
        :
        syn.punctuated.Punctuated.t syn.data.Variant.t syn.token.Comma.t)
      (path : syn.path.Path.t)
      (rejection : core.option.Option.t syn.path.Path.t)
      (state : axum_macros.from_request.State.t)
      (tr : axum_macros.from_request.Trait.t)
      : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
    let* ident := M.alloc ident in
    let* variants := M.alloc variants in
    let* path := M.alloc path in
    let* rejection := M.alloc rejection in
    let* state := M.alloc state in
    let* tr := M.alloc tr in
    M.read foo.
  
  (*
  fn infer_state_type_from_field_types(fields: &Fields) -> impl Iterator<Item = Type> + '_ {
      match fields {
          Fields::Named(fields_named) => Box::new(crate::infer_state_types(
              fields_named.named.iter().map(|field| &field.ty),
          )) as Box<dyn Iterator<Item = Type>>,
          Fields::Unnamed(fields_unnamed) => Box::new(crate::infer_state_types(
              fields_unnamed.unnamed.iter().map(|field| &field.ty),
          )),
          Fields::Unit => Box::new(iter::empty()),
      }
  }
  *)
  Definition infer_state_type_from_field_types
      (fields : ref syn.data.Fields.t)
      : M OpaqueDef :=
    let* fields := M.alloc fields in
    M.read foo.
  
  (*
  fn infer_state_type_from_field_attributes(fields: &Fields) -> impl Iterator<Item = Type> + '_ {
      match fields {
          Fields::Named(fields_named) => {
              Box::new(fields_named.named.iter().filter_map(|field| {
                  // TODO(david): it's a little wasteful to parse the attributes again here
                  // ideally we should parse things once and pass the data down
                  let FromRequestFieldAttrs { via } =
                      parse_attrs("from_request", &field.attrs).ok()?;
                  let (_, via_path) = via?;
                  path_ident_is_state(&via_path).then(|| field.ty.clone())
              })) as Box<dyn Iterator<Item = Type>>
          }
          Fields::Unnamed(fields_unnamed) => {
              Box::new(fields_unnamed.unnamed.iter().filter_map(|field| {
                  // TODO(david): it's a little wasteful to parse the attributes again here
                  // ideally we should parse things once and pass the data down
                  let FromRequestFieldAttrs { via } =
                      parse_attrs("from_request", &field.attrs).ok()?;
                  let (_, via_path) = via?;
                  path_ident_is_state(&via_path).then(|| field.ty.clone())
              }))
          }
          Fields::Unit => Box::new(iter::empty()),
      }
  }
  *)
  Definition infer_state_type_from_field_attributes
      (fields : ref syn.data.Fields.t)
      : M OpaqueDef :=
    let* fields := M.alloc fields in
    M.read foo.
  
  (*
  fn path_ident_is_state(path: &Path) -> bool {
      if let Some(last_segment) = path.segments.last() {
          last_segment.ident == "State"
      } else {
          false
      }
  }
  *)
  Definition path_ident_is_state (path : ref syn.path.Path.t) : M bool.t :=
    let* path := M.alloc path in
    M.read foo.
  
  (*
  fn state_from_via(ident: &Ident, via: &Path) -> Option<Type> {
      path_ident_is_state(via).then(|| parse_quote!(#ident))
  }
  *)
  Definition state_from_via
      (ident : ref proc_macro2.Ident.t)
      (via : ref syn.path.Path.t)
      : M (core.option.Option.t syn.ty.Type_.t) :=
    let* ident := M.alloc ident in
    let* via := M.alloc via in
    M.read foo.
  
  (*
  fn test_field_doesnt_impl_from_request() {}
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition test_field_doesnt_impl_from_request : M unit := M.read foo.
End from_request.

Module attr.
  Module kw.
    Module  via.
    Section via.
      Record t : Set := {
        span : ltac:(syn.__private.Span);
      }.
      
      Definition Get_span :=
        Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
    End via.
    End via.
    
    (*
            pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
                span: __S,
            ) -> $ident {
                $ident {
                    span: $crate::__private::IntoSpans::into_spans(span),
                }
            }
    *)
    (* #[allow(dead_code)] - function was ignored by the compiler *)
    Definition via
        {__S : Set}
        {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
        (span : __S)
        : M axum_macros.from_request.attr.kw.via.t :=
      let* span := M.alloc span in
      M.read foo.
    
    Module  rejection.
    Section rejection.
      Record t : Set := {
        span : ltac:(syn.__private.Span);
      }.
      
      Definition Get_span :=
        Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
    End rejection.
    End rejection.
    
    (*
            pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
                span: __S,
            ) -> $ident {
                $ident {
                    span: $crate::__private::IntoSpans::into_spans(span),
                }
            }
    *)
    (* #[allow(dead_code)] - function was ignored by the compiler *)
    Definition rejection
        {__S : Set}
        {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
        (span : __S)
        : M axum_macros.from_request.attr.kw.rejection.t :=
      let* span := M.alloc span in
      M.read foo.
    
    Module  state.
    Section state.
      Record t : Set := {
        span : ltac:(syn.__private.Span);
      }.
      
      Definition Get_span :=
        Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
    End state.
    End state.
    
    (*
            pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
                span: __S,
            ) -> $ident {
                $ident {
                    span: $crate::__private::IntoSpans::into_spans(span),
                }
            }
    *)
    (* #[allow(dead_code)] - function was ignored by the compiler *)
    Definition state
        {__S : Set}
        {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
        (span : __S)
        : M axum_macros.from_request.attr.kw.state.t :=
      let* span := M.alloc span in
      M.read foo.
  End kw.
  
  Module  FromRequestContainerAttrs.
  Section FromRequestContainerAttrs.
    Record t : Set := {
      via :
        core.option.Option.t
          (axum_macros.from_request.attr.kw.via.t * syn.path.Path.t);
      rejection :
        core.option.Option.t
          (axum_macros.from_request.attr.kw.rejection.t * syn.path.Path.t);
      state :
        core.option.Option.t
          (axum_macros.from_request.attr.kw.state.t * syn.ty.Type_.t);
    }.
    
    Definition Get_via :=
      Ref.map (fun α => Some α.(via)) (fun β α => Some (α <| via := β |>)).
    Definition Get_rejection :=
      Ref.map
        (fun α => Some α.(rejection))
        (fun β α => Some (α <| rejection := β |>)).
    Definition Get_state :=
      Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
  End FromRequestContainerAttrs.
  End FromRequestContainerAttrs.
  
  Module  Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  Section Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    Definition Self : Set :=
      axum_macros.from_request.attr.FromRequestContainerAttrs.t.
    
    (*
    Default
    *)
    Definition default
        : M axum_macros.from_request.attr.FromRequestContainerAttrs.t :=
      M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  
  Module  Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  Section Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    Definition Self : Set :=
      axum_macros.from_request.attr.FromRequestContainerAttrs.t.
    
    (*
        fn parse(input: ParseStream) -> syn::Result<Self> {
            let mut via = None;
            let mut rejection = None;
            let mut state = None;
    
            while !input.is_empty() {
                let lh = input.lookahead1();
                if lh.peek(kw::via) {
                    parse_parenthesized_attribute(input, &mut via)?;
                } else if lh.peek(kw::rejection) {
                    parse_parenthesized_attribute(input, &mut rejection)?;
                } else if lh.peek(kw::state) {
                    parse_parenthesized_attribute(input, &mut state)?;
                } else {
                    return Err(lh.error());
                }
    
                let _ = input.parse::<Token![,]>();
            }
    
            Ok(Self {
                via,
                rejection,
                state,
            })
        }
    *)
    Definition parse
        (input : ltac:(syn.parse.ParseStream))
        : M ltac:(syn.error.Result Self) :=
      let* input := M.alloc input in
      M.read foo.
    
    Global Instance AssociatedFunction_parse :
      Notations.DoubleColon Self "parse" := {
      Notations.double_colon := parse;
    }.
    
    Global Instance ℐ : syn.parse.Parse.Trait Self := {
      syn.parse.Parse.parse := parse;
    }.
  End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  
  Module  Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  Section Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
    Definition Self : Set :=
      axum_macros.from_request.attr.FromRequestContainerAttrs.t.
    
    (*
        fn combine(mut self, other: Self) -> syn::Result<Self> {
            let Self {
                via,
                rejection,
                state,
            } = other;
            combine_attribute(&mut self.via, via)?;
            combine_attribute(&mut self.rejection, rejection)?;
            combine_attribute(&mut self.state, state)?;
            Ok(self)
        }
    *)
    Definition combine
        (self : Self)
        (other : Self)
        : M ltac:(syn.error.Result Self) :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_combine :
      Notations.DoubleColon Self "combine" := {
      Notations.double_colon := combine;
    }.
    
    Global Instance ℐ : axum_macros.attr_parsing.Combine.Trait Self := {
      axum_macros.attr_parsing.Combine.combine := combine;
    }.
  End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  
  Module  FromRequestFieldAttrs.
  Section FromRequestFieldAttrs.
    Record t : Set := {
      via :
        core.option.Option.t
          (axum_macros.from_request.attr.kw.via.t * syn.path.Path.t);
    }.
    
    Definition Get_via :=
      Ref.map (fun α => Some α.(via)) (fun β α => Some (α <| via := β |>)).
  End FromRequestFieldAttrs.
  End FromRequestFieldAttrs.
  
  Module  Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  Section Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
    Definition Self : Set :=
      axum_macros.from_request.attr.FromRequestFieldAttrs.t.
    
    (*
    Default
    *)
    Definition default
        : M axum_macros.from_request.attr.FromRequestFieldAttrs.t :=
      M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  
  Module  Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  Section Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
    Definition Self : Set :=
      axum_macros.from_request.attr.FromRequestFieldAttrs.t.
    
    (*
        fn parse(input: ParseStream) -> syn::Result<Self> {
            let mut via = None;
    
            while !input.is_empty() {
                let lh = input.lookahead1();
                if lh.peek(kw::via) {
                    parse_parenthesized_attribute(input, &mut via)?;
                } else {
                    return Err(lh.error());
                }
    
                let _ = input.parse::<Token![,]>();
            }
    
            Ok(Self { via })
        }
    *)
    Definition parse
        (input : ltac:(syn.parse.ParseStream))
        : M ltac:(syn.error.Result Self) :=
      let* input := M.alloc input in
      M.read foo.
    
    Global Instance AssociatedFunction_parse :
      Notations.DoubleColon Self "parse" := {
      Notations.double_colon := parse;
    }.
    
    Global Instance ℐ : syn.parse.Parse.Trait Self := {
      syn.parse.Parse.parse := parse;
    }.
  End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  
  Module  Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  Section Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
    Definition Self : Set :=
      axum_macros.from_request.attr.FromRequestFieldAttrs.t.
    
    (*
        fn combine(mut self, other: Self) -> syn::Result<Self> {
            let Self { via } = other;
            combine_attribute(&mut self.via, via)?;
            Ok(self)
        }
    *)
    Definition combine
        (self : Self)
        (other : Self)
        : M ltac:(syn.error.Result Self) :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_combine :
      Notations.DoubleColon Self "combine" := {
      Notations.double_colon := combine;
    }.
    
    Global Instance ℐ : axum_macros.attr_parsing.Combine.Trait Self := {
      axum_macros.attr_parsing.Combine.combine := combine;
    }.
  End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
End attr.

Module Wrap_kw_2.
Module kw.
  Module  via.
  Section via.
    Record t : Set := {
      span : ltac:(syn.__private.Span);
    }.
    
    Definition Get_span :=
      Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
  End via.
  End via.
  
  (*
          pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
              span: __S,
          ) -> $ident {
              $ident {
                  span: $crate::__private::IntoSpans::into_spans(span),
              }
          }
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition via
      {__S : Set}
      {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
      (span : __S)
      : M axum_macros.from_request.attr.kw.via.t :=
    let* span := M.alloc span in
    M.read foo.
  
  Module  rejection.
  Section rejection.
    Record t : Set := {
      span : ltac:(syn.__private.Span);
    }.
    
    Definition Get_span :=
      Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
  End rejection.
  End rejection.
  
  (*
          pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
              span: __S,
          ) -> $ident {
              $ident {
                  span: $crate::__private::IntoSpans::into_spans(span),
              }
          }
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition rejection
      {__S : Set}
      {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
      (span : __S)
      : M axum_macros.from_request.attr.kw.rejection.t :=
    let* span := M.alloc span in
    M.read foo.
  
  Module  state.
  Section state.
    Record t : Set := {
      span : ltac:(syn.__private.Span);
    }.
    
    Definition Get_span :=
      Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
  End state.
  End state.
  
  (*
          pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
              span: __S,
          ) -> $ident {
              $ident {
                  span: $crate::__private::IntoSpans::into_spans(span),
              }
          }
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition state
      {__S : Set}
      {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
      (span : __S)
      : M axum_macros.from_request.attr.kw.state.t :=
    let* span := M.alloc span in
    M.read foo.
End kw.
End Wrap_kw_2.
Import Wrap_kw_2.

Module  via.
Section via.
  Record t : Set := {
    span : ltac:(syn.__private.Span);
  }.
  
  Definition Get_span :=
    Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
End via.
End via.

(*
        pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
            span: __S,
        ) -> $ident {
            $ident {
                span: $crate::__private::IntoSpans::into_spans(span),
            }
        }
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition via
    {__S : Set}
    {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
    (span : __S)
    : M axum_macros.from_request.attr.kw.via.t :=
  let* span := M.alloc span in
  M.read foo.

Module  Impl_core_default_Default_for_axum_macros_from_request_attr_kw_via_t.
Section Impl_core_default_Default_for_axum_macros_from_request_attr_kw_via_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.via.t.
  
  (*
                  fn default() -> Self {
                      $ident {
                          span: $crate::__private::Span::call_site(),
                      }
                  }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_macros_from_request_attr_kw_via_t.
End Impl_core_default_Default_for_axum_macros_from_request_attr_kw_via_t.

Module  Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_via_t.
Section Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_via_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.via.t.
  
  (*
              fn peek(cursor: $crate::buffer::Cursor) -> $crate::__private::bool {
                  if let $crate::__private::Some((ident, _rest)) = cursor.ident() {
                      ident == $crate::__private::stringify!($ident)
                  } else {
                      false
                  }
              }
  *)
  Definition peek
      (cursor : syn.buffer.Cursor.t)
      : M ltac:(syn.__private.bool) :=
    let* cursor := M.alloc cursor in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
              fn display() -> &'static $crate::__private::str {
                  $crate::__private::concat!("`", $crate::__private::stringify!($ident), "`")
              }
  *)
  Definition display : M (ref ltac:(syn.__private.str)) := M.read foo.
  
  Global Instance AssociatedFunction_display :
    Notations.DoubleColon Self "display" := {
    Notations.double_colon := display;
  }.
  
  Global Instance ℐ : syn.token.private.CustomToken.Trait Self := {
    syn.token.private.CustomToken.peek := peek;
    syn.token.private.CustomToken.display := display;
  }.
End Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_via_t.
End Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_via_t.

Module  Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_via_t.
Section Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_via_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.via.t.
  
  (*
              fn parse(input: $crate::parse::ParseStream) -> $crate::parse::Result<$ident> {
                  input.step(|cursor| {
                      if let $crate::__private::Some((ident, rest)) = cursor.ident() {
                          if ident == $crate::__private::stringify!($ident) {
                              return $crate::__private::Ok(($ident { span: ident.span() }, rest));
                          }
                      }
                      $crate::__private::Err(cursor.error($crate::__private::concat!(
                          "expected `",
                          $crate::__private::stringify!($ident),
                          "`",
                      )))
                  })
              }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      : M ltac:(syn.error.Result axum_macros.from_request.attr.kw.via.t) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_via_t.
End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_via_t.

Module  Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_via_t.
Section Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_via_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.via.t.
  
  (*
              fn to_tokens(&self, tokens: &mut $crate::__private::TokenStream2) {
                  let ident = $crate::Ident::new($crate::__private::stringify!($ident), self.span);
                  $crate::__private::TokenStreamExt::append(tokens, ident);
              }
  *)
  Definition to_tokens
      (self : ref Self)
      (tokens : mut_ref ltac:(syn.__private.TokenStream2))
      : M unit :=
    let* self := M.alloc self in
    let* tokens := M.alloc tokens in
    M.read foo.
  
  Global Instance AssociatedFunction_to_tokens :
    Notations.DoubleColon Self "to_tokens" := {
    Notations.double_colon := to_tokens;
  }.
  
  Global Instance ℐ : quote.to_tokens.ToTokens.Required.Trait Self := {
    quote.to_tokens.ToTokens.to_tokens := to_tokens;
    quote.to_tokens.ToTokens.to_token_stream := Datatypes.None;
    quote.to_tokens.ToTokens.into_token_stream := Datatypes.None;
  }.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_via_t.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_via_t.

Module  Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_via_t.
Section Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_via_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.via.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_via_t.
End Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_via_t.

Module  Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_via_t.
Section Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_via_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.via.t.
  
  (*
              fn clone(&self) -> Self {
                  *self
              }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_via_t.
End Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_via_t.

Module  Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_via_t.
Section Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_via_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.via.t.
  
  (*
              fn fmt(&self, f: &mut $crate::__private::Formatter) -> $crate::__private::FmtResult {
                  $crate::__private::Formatter::write_str(
                      f,
                      $crate::__private::concat!(
                          "Keyword [",
                          $crate::__private::stringify!($ident),
                          "]",
                      ),
                  )
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref ltac:(syn.__private.Formatter))
      : M ltac:(syn.__private.FmtResult) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_via_t.
End Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_via_t.

Module  Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_via_t.
Section Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_via_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.via.t.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq := Datatypes.None;
  }.
End Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_via_t.
End Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_via_t.

Module  Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_via_t.
Section Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_via_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.via.t.
  
  (*
              fn eq(&self, _other: &Self) -> $crate::__private::bool {
                  true
              }
  *)
  Definition eq
      (self : ref Self)
      (_other : ref Self)
      : M ltac:(syn.__private.bool) :=
    let* self := M.alloc self in
    let* _other := M.alloc _other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_via_t.
End Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_via_t.

Module  Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_via_t.
Section Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_via_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.via.t.
  
  (*
              fn hash<__H: $crate::__private::Hasher>(&self, _state: &mut __H) {}
  *)
  Definition hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H}
      (self : ref Self)
      (_state : mut_ref __H)
      : M unit :=
    let* self := M.alloc self in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
      hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_via_t.
End Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_via_t.

Module  rejection.
Section rejection.
  Record t : Set := {
    span : ltac:(syn.__private.Span);
  }.
  
  Definition Get_span :=
    Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
End rejection.
End rejection.

(*
        pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
            span: __S,
        ) -> $ident {
            $ident {
                span: $crate::__private::IntoSpans::into_spans(span),
            }
        }
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition rejection
    {__S : Set}
    {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
    (span : __S)
    : M axum_macros.from_request.attr.kw.rejection.t :=
  let* span := M.alloc span in
  M.read foo.

Module  Impl_core_default_Default_for_axum_macros_from_request_attr_kw_rejection_t.
Section Impl_core_default_Default_for_axum_macros_from_request_attr_kw_rejection_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.rejection.t.
  
  (*
                  fn default() -> Self {
                      $ident {
                          span: $crate::__private::Span::call_site(),
                      }
                  }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_macros_from_request_attr_kw_rejection_t.
End Impl_core_default_Default_for_axum_macros_from_request_attr_kw_rejection_t.

Module  Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_rejection_t.
Section Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_rejection_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.rejection.t.
  
  (*
              fn peek(cursor: $crate::buffer::Cursor) -> $crate::__private::bool {
                  if let $crate::__private::Some((ident, _rest)) = cursor.ident() {
                      ident == $crate::__private::stringify!($ident)
                  } else {
                      false
                  }
              }
  *)
  Definition peek
      (cursor : syn.buffer.Cursor.t)
      : M ltac:(syn.__private.bool) :=
    let* cursor := M.alloc cursor in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
              fn display() -> &'static $crate::__private::str {
                  $crate::__private::concat!("`", $crate::__private::stringify!($ident), "`")
              }
  *)
  Definition display : M (ref ltac:(syn.__private.str)) := M.read foo.
  
  Global Instance AssociatedFunction_display :
    Notations.DoubleColon Self "display" := {
    Notations.double_colon := display;
  }.
  
  Global Instance ℐ : syn.token.private.CustomToken.Trait Self := {
    syn.token.private.CustomToken.peek := peek;
    syn.token.private.CustomToken.display := display;
  }.
End Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_rejection_t.
End Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_rejection_t.

Module  Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_rejection_t.
Section Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_rejection_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.rejection.t.
  
  (*
              fn parse(input: $crate::parse::ParseStream) -> $crate::parse::Result<$ident> {
                  input.step(|cursor| {
                      if let $crate::__private::Some((ident, rest)) = cursor.ident() {
                          if ident == $crate::__private::stringify!($ident) {
                              return $crate::__private::Ok(($ident { span: ident.span() }, rest));
                          }
                      }
                      $crate::__private::Err(cursor.error($crate::__private::concat!(
                          "expected `",
                          $crate::__private::stringify!($ident),
                          "`",
                      )))
                  })
              }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      :
        M
          ltac:(syn.error.Result
            axum_macros.from_request.attr.kw.rejection.t) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_rejection_t.
End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_rejection_t.

Module  Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_rejection_t.
Section Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_rejection_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.rejection.t.
  
  (*
              fn to_tokens(&self, tokens: &mut $crate::__private::TokenStream2) {
                  let ident = $crate::Ident::new($crate::__private::stringify!($ident), self.span);
                  $crate::__private::TokenStreamExt::append(tokens, ident);
              }
  *)
  Definition to_tokens
      (self : ref Self)
      (tokens : mut_ref ltac:(syn.__private.TokenStream2))
      : M unit :=
    let* self := M.alloc self in
    let* tokens := M.alloc tokens in
    M.read foo.
  
  Global Instance AssociatedFunction_to_tokens :
    Notations.DoubleColon Self "to_tokens" := {
    Notations.double_colon := to_tokens;
  }.
  
  Global Instance ℐ : quote.to_tokens.ToTokens.Required.Trait Self := {
    quote.to_tokens.ToTokens.to_tokens := to_tokens;
    quote.to_tokens.ToTokens.to_token_stream := Datatypes.None;
    quote.to_tokens.ToTokens.into_token_stream := Datatypes.None;
  }.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_rejection_t.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_rejection_t.

Module  Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_rejection_t.
Section Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_rejection_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.rejection.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_rejection_t.
End Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_rejection_t.

Module  Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_rejection_t.
Section Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_rejection_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.rejection.t.
  
  (*
              fn clone(&self) -> Self {
                  *self
              }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_rejection_t.
End Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_rejection_t.

Module  Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_rejection_t.
Section Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_rejection_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.rejection.t.
  
  (*
              fn fmt(&self, f: &mut $crate::__private::Formatter) -> $crate::__private::FmtResult {
                  $crate::__private::Formatter::write_str(
                      f,
                      $crate::__private::concat!(
                          "Keyword [",
                          $crate::__private::stringify!($ident),
                          "]",
                      ),
                  )
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref ltac:(syn.__private.Formatter))
      : M ltac:(syn.__private.FmtResult) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_rejection_t.
End Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_rejection_t.

Module  Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_rejection_t.
Section Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_rejection_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.rejection.t.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq := Datatypes.None;
  }.
End Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_rejection_t.
End Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_rejection_t.

Module  Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_rejection_t.
Section Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_rejection_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.rejection.t.
  
  (*
              fn eq(&self, _other: &Self) -> $crate::__private::bool {
                  true
              }
  *)
  Definition eq
      (self : ref Self)
      (_other : ref Self)
      : M ltac:(syn.__private.bool) :=
    let* self := M.alloc self in
    let* _other := M.alloc _other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_rejection_t.
End Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_rejection_t.

Module  Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_rejection_t.
Section Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_rejection_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.rejection.t.
  
  (*
              fn hash<__H: $crate::__private::Hasher>(&self, _state: &mut __H) {}
  *)
  Definition hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H}
      (self : ref Self)
      (_state : mut_ref __H)
      : M unit :=
    let* self := M.alloc self in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
      hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_rejection_t.
End Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_rejection_t.

(*
        pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
            span: __S,
        ) -> $ident {
            $ident {
                span: $crate::__private::IntoSpans::into_spans(span),
            }
        }
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition state
    {__S : Set}
    {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
    (span : __S)
    : M axum_macros.from_request.attr.kw.state.t :=
  let* span := M.alloc span in
  M.read foo.

Module  Impl_core_default_Default_for_axum_macros_from_request_attr_kw_state_t.
Section Impl_core_default_Default_for_axum_macros_from_request_attr_kw_state_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.state.t.
  
  (*
                  fn default() -> Self {
                      $ident {
                          span: $crate::__private::Span::call_site(),
                      }
                  }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_macros_from_request_attr_kw_state_t.
End Impl_core_default_Default_for_axum_macros_from_request_attr_kw_state_t.

Module  Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_state_t.
Section Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_state_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.state.t.
  
  (*
              fn peek(cursor: $crate::buffer::Cursor) -> $crate::__private::bool {
                  if let $crate::__private::Some((ident, _rest)) = cursor.ident() {
                      ident == $crate::__private::stringify!($ident)
                  } else {
                      false
                  }
              }
  *)
  Definition peek
      (cursor : syn.buffer.Cursor.t)
      : M ltac:(syn.__private.bool) :=
    let* cursor := M.alloc cursor in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
              fn display() -> &'static $crate::__private::str {
                  $crate::__private::concat!("`", $crate::__private::stringify!($ident), "`")
              }
  *)
  Definition display : M (ref ltac:(syn.__private.str)) := M.read foo.
  
  Global Instance AssociatedFunction_display :
    Notations.DoubleColon Self "display" := {
    Notations.double_colon := display;
  }.
  
  Global Instance ℐ : syn.token.private.CustomToken.Trait Self := {
    syn.token.private.CustomToken.peek := peek;
    syn.token.private.CustomToken.display := display;
  }.
End Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_state_t.
End Impl_syn_token_private_CustomToken_for_axum_macros_from_request_attr_kw_state_t.

Module  Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_state_t.
Section Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_state_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.state.t.
  
  (*
              fn parse(input: $crate::parse::ParseStream) -> $crate::parse::Result<$ident> {
                  input.step(|cursor| {
                      if let $crate::__private::Some((ident, rest)) = cursor.ident() {
                          if ident == $crate::__private::stringify!($ident) {
                              return $crate::__private::Ok(($ident { span: ident.span() }, rest));
                          }
                      }
                      $crate::__private::Err(cursor.error($crate::__private::concat!(
                          "expected `",
                          $crate::__private::stringify!($ident),
                          "`",
                      )))
                  })
              }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      : M ltac:(syn.error.Result axum_macros.from_request.attr.kw.state.t) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_state_t.
End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_kw_state_t.

Module  Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_state_t.
Section Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_state_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.state.t.
  
  (*
              fn to_tokens(&self, tokens: &mut $crate::__private::TokenStream2) {
                  let ident = $crate::Ident::new($crate::__private::stringify!($ident), self.span);
                  $crate::__private::TokenStreamExt::append(tokens, ident);
              }
  *)
  Definition to_tokens
      (self : ref Self)
      (tokens : mut_ref ltac:(syn.__private.TokenStream2))
      : M unit :=
    let* self := M.alloc self in
    let* tokens := M.alloc tokens in
    M.read foo.
  
  Global Instance AssociatedFunction_to_tokens :
    Notations.DoubleColon Self "to_tokens" := {
    Notations.double_colon := to_tokens;
  }.
  
  Global Instance ℐ : quote.to_tokens.ToTokens.Required.Trait Self := {
    quote.to_tokens.ToTokens.to_tokens := to_tokens;
    quote.to_tokens.ToTokens.to_token_stream := Datatypes.None;
    quote.to_tokens.ToTokens.into_token_stream := Datatypes.None;
  }.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_state_t.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_attr_kw_state_t.

Module  Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_state_t.
Section Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_state_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.state.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_state_t.
End Impl_core_marker_Copy_for_axum_macros_from_request_attr_kw_state_t.

Module  Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_state_t.
Section Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_state_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.state.t.
  
  (*
              fn clone(&self) -> Self {
                  *self
              }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_state_t.
End Impl_core_clone_Clone_for_axum_macros_from_request_attr_kw_state_t.

Module  Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_state_t.
Section Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_state_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.state.t.
  
  (*
              fn fmt(&self, f: &mut $crate::__private::Formatter) -> $crate::__private::FmtResult {
                  $crate::__private::Formatter::write_str(
                      f,
                      $crate::__private::concat!(
                          "Keyword [",
                          $crate::__private::stringify!($ident),
                          "]",
                      ),
                  )
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref ltac:(syn.__private.Formatter))
      : M ltac:(syn.__private.FmtResult) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_state_t.
End Impl_core_fmt_Debug_for_axum_macros_from_request_attr_kw_state_t.

Module  Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_state_t.
Section Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_state_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.state.t.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq := Datatypes.None;
  }.
End Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_state_t.
End Impl_core_cmp_Eq_for_axum_macros_from_request_attr_kw_state_t.

Module  Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_state_t.
Section Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_state_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.state.t.
  
  (*
              fn eq(&self, _other: &Self) -> $crate::__private::bool {
                  true
              }
  *)
  Definition eq
      (self : ref Self)
      (_other : ref Self)
      : M ltac:(syn.__private.bool) :=
    let* self := M.alloc self in
    let* _other := M.alloc _other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_state_t.
End Impl_core_cmp_PartialEq_for_axum_macros_from_request_attr_kw_state_t.

Module  Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_state_t.
Section Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_state_t.
  Definition Self : Set := axum_macros.from_request.attr.kw.state.t.
  
  (*
              fn hash<__H: $crate::__private::Hasher>(&self, _state: &mut __H) {}
  *)
  Definition hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H}
      (self : ref Self)
      (_state : mut_ref __H)
      : M unit :=
    let* self := M.alloc self in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
      hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_state_t.
End Impl_core_hash_Hash_for_axum_macros_from_request_attr_kw_state_t.

Module  FromRequestContainerAttrs.
Section FromRequestContainerAttrs.
  Record t : Set := {
    via :
      core.option.Option.t
        (axum_macros.from_request.attr.kw.via.t * syn.path.Path.t);
    rejection :
      core.option.Option.t
        (axum_macros.from_request.attr.kw.rejection.t * syn.path.Path.t);
    state :
      core.option.Option.t
        (axum_macros.from_request.attr.kw.state.t * syn.ty.Type_.t);
  }.
  
  Definition Get_via :=
    Ref.map (fun α => Some α.(via)) (fun β α => Some (α <| via := β |>)).
  Definition Get_rejection :=
    Ref.map
      (fun α => Some α.(rejection))
      (fun β α => Some (α <| rejection := β |>)).
  Definition Get_state :=
    Ref.map (fun α => Some α.(state)) (fun β α => Some (α <| state := β |>)).
End FromRequestContainerAttrs.
End FromRequestContainerAttrs.

Module  Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
Section Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  Definition Self : Set :=
    axum_macros.from_request.attr.FromRequestContainerAttrs.t.
  
  (*
  Default
  *)
  Definition default
      : M axum_macros.from_request.attr.FromRequestContainerAttrs.t :=
    M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.

Module  Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
Section Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  Definition Self : Set :=
    axum_macros.from_request.attr.FromRequestContainerAttrs.t.
  
  (*
      fn parse(input: ParseStream) -> syn::Result<Self> {
          let mut via = None;
          let mut rejection = None;
          let mut state = None;
  
          while !input.is_empty() {
              let lh = input.lookahead1();
              if lh.peek(kw::via) {
                  parse_parenthesized_attribute(input, &mut via)?;
              } else if lh.peek(kw::rejection) {
                  parse_parenthesized_attribute(input, &mut rejection)?;
              } else if lh.peek(kw::state) {
                  parse_parenthesized_attribute(input, &mut state)?;
              } else {
                  return Err(lh.error());
              }
  
              let _ = input.parse::<Token![,]>();
          }
  
          Ok(Self {
              via,
              rejection,
              state,
          })
      }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      : M ltac:(syn.error.Result Self) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.

Module  Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
Section Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
  Definition Self : Set :=
    axum_macros.from_request.attr.FromRequestContainerAttrs.t.
  
  (*
      fn combine(mut self, other: Self) -> syn::Result<Self> {
          let Self {
              via,
              rejection,
              state,
          } = other;
          combine_attribute(&mut self.via, via)?;
          combine_attribute(&mut self.rejection, rejection)?;
          combine_attribute(&mut self.state, state)?;
          Ok(self)
      }
  *)
  Definition combine
      (self : Self)
      (other : Self)
      : M ltac:(syn.error.Result Self) :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_combine :
    Notations.DoubleColon Self "combine" := {
    Notations.double_colon := combine;
  }.
  
  Global Instance ℐ : axum_macros.attr_parsing.Combine.Trait Self := {
    axum_macros.attr_parsing.Combine.combine := combine;
  }.
End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.
End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestContainerAttrs_t.

Module  FromRequestFieldAttrs.
Section FromRequestFieldAttrs.
  Record t : Set := {
    via :
      core.option.Option.t
        (axum_macros.from_request.attr.kw.via.t * syn.path.Path.t);
  }.
  
  Definition Get_via :=
    Ref.map (fun α => Some α.(via)) (fun β α => Some (α <| via := β |>)).
End FromRequestFieldAttrs.
End FromRequestFieldAttrs.

Module  Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
Section Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  Definition Self : Set :=
    axum_macros.from_request.attr.FromRequestFieldAttrs.t.
  
  (*
  Default
  *)
  Definition default
      : M axum_macros.from_request.attr.FromRequestFieldAttrs.t :=
    M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
End Impl_core_default_Default_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.

Module  Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
Section Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  Definition Self : Set :=
    axum_macros.from_request.attr.FromRequestFieldAttrs.t.
  
  (*
      fn parse(input: ParseStream) -> syn::Result<Self> {
          let mut via = None;
  
          while !input.is_empty() {
              let lh = input.lookahead1();
              if lh.peek(kw::via) {
                  parse_parenthesized_attribute(input, &mut via)?;
              } else {
                  return Err(lh.error());
              }
  
              let _ = input.parse::<Token![,]>();
          }
  
          Ok(Self { via })
      }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      : M ltac:(syn.error.Result Self) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
End Impl_syn_parse_Parse_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.

Module  Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
Section Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
  Definition Self : Set :=
    axum_macros.from_request.attr.FromRequestFieldAttrs.t.
  
  (*
      fn combine(mut self, other: Self) -> syn::Result<Self> {
          let Self { via } = other;
          combine_attribute(&mut self.via, via)?;
          Ok(self)
      }
  *)
  Definition combine
      (self : Self)
      (other : Self)
      : M ltac:(syn.error.Result Self) :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_combine :
    Notations.DoubleColon Self "combine" := {
    Notations.double_colon := combine;
  }.
  
  Global Instance ℐ : axum_macros.attr_parsing.Combine.Trait Self := {
    axum_macros.attr_parsing.Combine.combine := combine;
  }.
End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.
End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_from_request_attr_FromRequestFieldAttrs_t.

Module Trait.
  Inductive t : Set :=
  | FromRequest
  | FromRequestParts.
End Trait.

Module  Impl_core_clone_Clone_for_axum_macros_from_request_Trait_t.
Section Impl_core_clone_Clone_for_axum_macros_from_request_Trait_t.
  Definition Self : Set := axum_macros.from_request.Trait.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M axum_macros.from_request.Trait.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_macros_from_request_Trait_t.
End Impl_core_clone_Clone_for_axum_macros_from_request_Trait_t.

Module  Impl_core_marker_Copy_for_axum_macros_from_request_Trait_t.
Section Impl_core_marker_Copy_for_axum_macros_from_request_Trait_t.
  Definition Self : Set := axum_macros.from_request.Trait.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_macros_from_request_Trait_t.
End Impl_core_marker_Copy_for_axum_macros_from_request_Trait_t.

Module  Impl_axum_macros_from_request_Trait_t_2.
Section Impl_axum_macros_from_request_Trait_t_2.
  Definition Self : Set := axum_macros.from_request.Trait.t.
  
  (*
      fn via_marker_type(&self) -> Option<Type> {
          match self {
              Trait::FromRequest => Some(parse_quote!(M)),
              Trait::FromRequestParts => None,
          }
      }
  *)
  Definition via_marker_type
      (self : ref Self)
      : M (core.option.Option.t syn.ty.Type_.t) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_via_marker_type :
    Notations.DoubleColon Self "via_marker_type" := {
    Notations.double_colon := via_marker_type;
  }.
End Impl_axum_macros_from_request_Trait_t_2.
End Impl_axum_macros_from_request_Trait_t_2.

Module  Impl_core_fmt_Display_for_axum_macros_from_request_Trait_t.
Section Impl_core_fmt_Display_for_axum_macros_from_request_Trait_t.
  Definition Self : Set := axum_macros.from_request.Trait.t.
  
  (*
      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
          match self {
              Trait::FromRequest => f.write_str("FromRequest"),
              Trait::FromRequestParts => f.write_str("FromRequestParts"),
          }
      }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Display.Trait Self := {
    core.fmt.Display.fmt := fmt;
  }.
End Impl_core_fmt_Display_for_axum_macros_from_request_Trait_t.
End Impl_core_fmt_Display_for_axum_macros_from_request_Trait_t.

Module State.
  Inductive t : Set :=
  | Custom (_ : syn.ty.Type_.t)
  | Default (_ : syn.ty.Type_.t)
  | CannotInfer.
  
  Definition Get_Custom_0 :=
    Ref.map
      (fun α => match α with | Custom α0 => Some α0 | _ => None end)
      (fun β α => match α with | Custom _ => Some (Custom β) | _ => None end).
  
  Definition Get_Default_0 :=
    Ref.map
      (fun α => match α with | Default α0 => Some α0 | _ => None end)
      (fun β α => match α with | Default _ => Some (Default β) | _ => None end).
End State.

Module  Impl_core_fmt_Debug_for_axum_macros_from_request_State_t.
Section Impl_core_fmt_Debug_for_axum_macros_from_request_State_t.
  Definition Self : Set := axum_macros.from_request.State.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_macros_from_request_State_t.
End Impl_core_fmt_Debug_for_axum_macros_from_request_State_t.

Module  Impl_axum_macros_from_request_State_t_2.
Section Impl_axum_macros_from_request_State_t_2.
  Definition Self : Set := axum_macros.from_request.State.t.
  
  (*
      fn impl_generics(&self) -> impl Iterator<Item = Type> {
          match self {
              State::Default(inner) => Some(inner.clone()),
              State::Custom(_) => None,
              State::CannotInfer => Some(parse_quote!(S)),
          }
          .into_iter()
      }
  *)
  Definition impl_generics (self : ref Self) : M _ (* OpaqueTy *) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_impl_generics :
    Notations.DoubleColon Self "impl_generics" := {
    Notations.double_colon := impl_generics;
  }.
  
  (*
      fn trait_generics(&self) -> impl Iterator<Item = Type> {
          match self {
              State::Default(inner) | State::Custom(inner) => iter::once(inner.clone()),
              State::CannotInfer => iter::once(parse_quote!(S)),
          }
      }
  *)
  Definition trait_generics (self : ref Self) : M _ (* OpaqueTy *) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_trait_generics :
    Notations.DoubleColon Self "trait_generics" := {
    Notations.double_colon := trait_generics;
  }.
  
  (*
      fn bounds(&self) -> TokenStream {
          match self {
              State::Custom(_) => quote! {},
              State::Default(inner) => quote! {
                  #inner: ::std::marker::Send + ::std::marker::Sync,
              },
              State::CannotInfer => quote! {
                  S: ::std::marker::Send + ::std::marker::Sync,
              },
          }
      }
  *)
  Definition bounds (self : ref Self) : M proc_macro2.TokenStream.t :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_bounds :
    Notations.DoubleColon Self "bounds" := {
    Notations.double_colon := bounds;
  }.
End Impl_axum_macros_from_request_State_t_2.
End Impl_axum_macros_from_request_State_t_2.

Module  Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_State_t.
Section Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_State_t.
  Definition Self : Set := axum_macros.from_request.State.t.
  
  (*
      fn to_tokens(&self, tokens: &mut TokenStream) {
          match self {
              State::Custom(inner) | State::Default(inner) => inner.to_tokens(tokens),
              State::CannotInfer => quote! { S }.to_tokens(tokens),
          }
      }
  *)
  Definition to_tokens
      (self : ref Self)
      (tokens : mut_ref proc_macro2.TokenStream.t)
      : M unit :=
    let* self := M.alloc self in
    let* tokens := M.alloc tokens in
    M.read foo.
  
  Global Instance AssociatedFunction_to_tokens :
    Notations.DoubleColon Self "to_tokens" := {
    Notations.double_colon := to_tokens;
  }.
  
  Global Instance ℐ : quote.to_tokens.ToTokens.Required.Trait Self := {
    quote.to_tokens.ToTokens.to_tokens := to_tokens;
    quote.to_tokens.ToTokens.to_token_stream := Datatypes.None;
    quote.to_tokens.ToTokens.into_token_stream := Datatypes.None;
  }.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_State_t.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_from_request_State_t.

(*
pub(crate) fn expand(item: syn::Item, tr: Trait) -> syn::Result<TokenStream> {
    match item {
        syn::Item::Struct(item) => {
            let syn::ItemStruct {
                attrs,
                ident,
                generics,
                fields,
                semi_token: _,
                vis: _,
                struct_token: _,
            } = item;

            let generic_ident = parse_single_generic_type_on_struct(generics, &fields, tr)?;

            let FromRequestContainerAttrs {
                via,
                rejection,
                state,
            } = parse_attrs("from_request", &attrs)?;

            let state = match state {
                Some((_, state)) => State::Custom(state),
                None => {
                    let mut inferred_state_types: HashSet<_> =
                        infer_state_type_from_field_types(&fields)
                            .chain(infer_state_type_from_field_attributes(&fields))
                            .collect();

                    if let Some((_, via)) = &via {
                        inferred_state_types.extend(state_from_via(&ident, via));
                    }

                    match inferred_state_types.len() {
                        0 => State::Default(syn::parse_quote!(S)),
                        1 => State::Custom(inferred_state_types.iter().next().unwrap().to_owned()),
                        _ => State::CannotInfer,
                    }
                }
            };

            let trait_impl = match (via.map(second), rejection.map(second)) {
                (Some(via), rejection) => impl_struct_by_extracting_all_at_once(
                    ident,
                    fields,
                    via,
                    rejection,
                    generic_ident,
                    &state,
                    tr,
                )?,
                (None, rejection) => {
                    error_on_generic_ident(generic_ident, tr)?;
                    impl_struct_by_extracting_each_field(ident, fields, rejection, &state, tr)?
                }
            };

            if let State::CannotInfer = state {
                let attr_name = match tr {
                    Trait::FromRequest => "from_request",
                    Trait::FromRequestParts => "from_request_parts",
                };
                let compile_error = syn::Error::new(
                    Span::call_site(),
                    format_args!(
                        "can't infer state type, please add \
                         `#[{attr_name}(state = MyStateType)]` attribute",
                    ),
                )
                .into_compile_error();

                Ok(quote! {
                    #trait_impl
                    #compile_error
                })
            } else {
                Ok(trait_impl)
            }
        }
        syn::Item::Enum(item) => {
            let syn::ItemEnum {
                attrs,
                vis: _,
                enum_token: _,
                ident,
                generics,
                brace_token: _,
                variants,
            } = item;

            let generics_error = format!("`#[derive({tr})] on enums don't support generics");

            if !generics.params.is_empty() {
                return Err(syn::Error::new_spanned(generics, generics_error));
            }

            if let Some(where_clause) = generics.where_clause {
                return Err(syn::Error::new_spanned(where_clause, generics_error));
            }

            let FromRequestContainerAttrs {
                via,
                rejection,
                state,
            } = parse_attrs("from_request", &attrs)?;

            let state = match state {
                Some((_, state)) => State::Custom(state),
                None => (|| {
                    let via = via.as_ref().map(|(_, via)| via)?;
                    state_from_via(&ident, via).map(State::Custom)
                })()
                .unwrap_or_else(|| State::Default(syn::parse_quote!(S))),
            };

            match (via.map(second), rejection) {
                (Some(via), rejection) => impl_enum_by_extracting_all_at_once(
                    ident,
                    variants,
                    via,
                    rejection.map(second),
                    state,
                    tr,
                ),
                (None, Some((rejection_kw, _))) => Err(syn::Error::new_spanned(
                    rejection_kw,
                    "cannot use `rejection` without `via`",
                )),
                (None, _) => Err(syn::Error::new(
                    Span::call_site(),
                    "missing `#[from_request(via(...))]`",
                )),
            }
        }
        _ => Err(syn::Error::new_spanned(item, "expected `struct` or `enum`")),
    }
}
*)
Definition expand
    (item : syn.item.Item.t)
    (tr : axum_macros.from_request.Trait.t)
    : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
  let* item := M.alloc item in
  let* tr := M.alloc tr in
  M.read foo.

(*
fn parse_single_generic_type_on_struct(
    generics: syn::Generics,
    fields: &syn::Fields,
    tr: Trait,
) -> syn::Result<Option<Ident>> {
    if let Some(where_clause) = generics.where_clause {
        return Err(syn::Error::new_spanned(
            where_clause,
            format_args!("#[derive({tr})] doesn't support structs with `where` clauses"),
        ));
    }

    match generics.params.len() {
        0 => Ok(None),
        1 => {
            let param = generics.params.first().unwrap();
            let ty_ident = match param {
                syn::GenericParam::Type(ty) => &ty.ident,
                syn::GenericParam::Lifetime(lifetime) => {
                    return Err(syn::Error::new_spanned(
                        lifetime,
                        format_args!(
                            "#[derive({tr})] doesn't support structs \
                             that are generic over lifetimes"
                        ),
                    ));
                }
                syn::GenericParam::Const(konst) => {
                    return Err(syn::Error::new_spanned(
                        konst,
                        format_args!(
                            "#[derive({tr})] doesn't support structs \
                             that have const generics"
                        ),
                    ));
                }
            };

            match fields {
                syn::Fields::Named(fields_named) => {
                    return Err(syn::Error::new_spanned(
                        fields_named,
                        format_args!(
                            "#[derive({tr})] doesn't support named fields \
                             for generic structs. Use a tuple struct instead"
                        ),
                    ));
                }
                syn::Fields::Unnamed(fields_unnamed) => {
                    if fields_unnamed.unnamed.len() != 1 {
                        return Err(syn::Error::new_spanned(
                            fields_unnamed,
                            format_args!(
                                "#[derive({tr})] only supports generics on \
                                 tuple structs that have exactly one field"
                            ),
                        ));
                    }

                    let field = fields_unnamed.unnamed.first().unwrap();

                    if let syn::Type::Path(type_path) = &field.ty {
                        if type_path
                            .path
                            .get_ident()
                            .map_or(true, |field_type_ident| field_type_ident != ty_ident)
                        {
                            return Err(syn::Error::new_spanned(
                                type_path,
                                format_args!(
                                    "#[derive({tr})] only supports generics on \
                                     tuple structs that have exactly one field of the generic type"
                                ),
                            ));
                        }
                    } else {
                        return Err(syn::Error::new_spanned(&field.ty, "Expected type path"));
                    }
                }
                syn::Fields::Unit => return Ok(None),
            }

            Ok(Some(ty_ident.clone()))
        }
        _ => Err(syn::Error::new_spanned(
            generics,
            format_args!("#[derive({tr})] only supports 0 or 1 generic type parameters"),
        )),
    }
}
*)
Definition parse_single_generic_type_on_struct
    (generics : syn.generics.Generics.t)
    (fields : ref syn.data.Fields.t)
    (tr : axum_macros.from_request.Trait.t)
    : M ltac:(syn.error.Result (core.option.Option.t proc_macro2.Ident.t)) :=
  let* generics := M.alloc generics in
  let* fields := M.alloc fields in
  let* tr := M.alloc tr in
  M.read foo.

(*
fn error_on_generic_ident(generic_ident: Option<Ident>, tr: Trait) -> syn::Result<()> {
    if let Some(generic_ident) = generic_ident {
        Err(syn::Error::new_spanned(
            generic_ident,
            format_args!(
                "#[derive({tr})] only supports generics when used with #[from_request(via)]"
            ),
        ))
    } else {
        Ok(())
    }
}
*)
Definition error_on_generic_ident
    (generic_ident : core.option.Option.t proc_macro2.Ident.t)
    (tr : axum_macros.from_request.Trait.t)
    : M ltac:(syn.error.Result unit) :=
  let* generic_ident := M.alloc generic_ident in
  let* tr := M.alloc tr in
  M.read foo.

(*
fn impl_struct_by_extracting_each_field(
    ident: syn::Ident,
    fields: syn::Fields,
    rejection: Option<syn::Path>,
    state: &State,
    tr: Trait,
) -> syn::Result<TokenStream> {
    let trait_fn_body = match state {
        State::CannotInfer => quote! {
            ::std::unimplemented!()
        },
        _ => {
            let extract_fields = extract_fields(&fields, &rejection, tr)?;
            quote! {
                ::std::result::Result::Ok(Self {
                    #(#extract_fields)*
                })
            }
        }
    };

    let rejection_ident = if let Some(rejection) = rejection {
        quote!(#rejection)
    } else if has_no_fields(&fields) {
        quote!(::std::convert::Infallible)
    } else {
        quote!(::axum::response::Response)
    };

    let impl_generics = state
        .impl_generics()
        .collect::<Punctuated<Type, Token![,]>>();

    let trait_generics = state
        .trait_generics()
        .collect::<Punctuated<Type, Token![,]>>();

    let state_bounds = state.bounds();

    Ok(match tr {
        Trait::FromRequest => quote! {
            #[::axum::async_trait]
            #[automatically_derived]
            impl<#impl_generics> ::axum::extract::FromRequest<#trait_generics> for #ident
            where
                #state_bounds
            {
                type Rejection = #rejection_ident;

                async fn from_request(
                    mut req: ::axum::http::Request<::axum::body::Body>,
                    state: &#state,
                ) -> ::std::result::Result<Self, Self::Rejection> {
                    #trait_fn_body
                }
            }
        },
        Trait::FromRequestParts => quote! {
            #[::axum::async_trait]
            #[automatically_derived]
            impl<#impl_generics> ::axum::extract::FromRequestParts<#trait_generics> for #ident
            where
                #state_bounds
            {
                type Rejection = #rejection_ident;

                async fn from_request_parts(
                    parts: &mut ::axum::http::request::Parts,
                    state: &#state,
                ) -> ::std::result::Result<Self, Self::Rejection> {
                    #trait_fn_body
                }
            }
        },
    })
}
*)
Definition impl_struct_by_extracting_each_field
    (ident : proc_macro2.Ident.t)
    (fields : syn.data.Fields.t)
    (rejection : core.option.Option.t syn.path.Path.t)
    (state : ref axum_macros.from_request.State.t)
    (tr : axum_macros.from_request.Trait.t)
    : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
  let* ident := M.alloc ident in
  let* fields := M.alloc fields in
  let* rejection := M.alloc rejection in
  let* state := M.alloc state in
  let* tr := M.alloc tr in
  M.read foo.

(*
fn has_no_fields(fields: &syn::Fields) -> bool {
    match fields {
        syn::Fields::Named(fields) => fields.named.is_empty(),
        syn::Fields::Unnamed(fields) => fields.unnamed.is_empty(),
        syn::Fields::Unit => true,
    }
}
*)
Definition has_no_fields (fields : ref syn.data.Fields.t) : M bool.t :=
  let* fields := M.alloc fields in
  M.read foo.

(*
fn extract_fields(
    fields: &syn::Fields,
    rejection: &Option<syn::Path>,
    tr: Trait,
) -> syn::Result<Vec<TokenStream>> {
    fn member(field: &syn::Field, index: usize) -> TokenStream {
        match &field.ident {
            Some(ident) => quote! { #ident },
            _ => {
                let member = syn::Member::Unnamed(syn::Index {
                    index: index as u32,
                    span: field.span(),
                });
                quote! { #member }
            }
        }
    }

    fn into_inner(via: Option<(attr::kw::via, syn::Path)>, ty_span: Span) -> TokenStream {
        if let Some((_, path)) = via {
            let span = path.span();
            quote_spanned! {span=>
                |#path(inner)| inner
            }
        } else {
            quote_spanned! {ty_span=>
                ::std::convert::identity
            }
        }
    }

    let mut fields_iter = fields.iter();

    let last = match tr {
        // Use FromRequestParts for all elements except the last
        Trait::FromRequest => fields_iter.next_back(),
        // Use FromRequestParts for all elements
        Trait::FromRequestParts => None,
    };

    let mut res: Vec<_> = fields_iter
        .enumerate()
        .map(|(index, field)| {
            let FromRequestFieldAttrs { via } = parse_attrs("from_request", &field.attrs)?;

            let member = member(field, index);
            let ty_span = field.ty.span();
            let into_inner = into_inner(via, ty_span);

            if peel_option(&field.ty).is_some() {
                let tokens = match tr {
                    Trait::FromRequest => {
                        quote_spanned! {ty_span=>
                            #member: {
                                let (mut parts, body) = req.into_parts();
                                let value =
                                    ::axum::extract::FromRequestParts::from_request_parts(
                                        &mut parts,
                                        state,
                                    )
                                    .await
                                    .ok()
                                    .map(#into_inner);
                                req = ::axum::http::Request::from_parts(parts, body);
                                value
                            },
                        }
                    }
                    Trait::FromRequestParts => {
                        quote_spanned! {ty_span=>
                            #member: {
                                ::axum::extract::FromRequestParts::from_request_parts(
                                    parts,
                                    state,
                                )
                                .await
                                .ok()
                                .map(#into_inner)
                            },
                        }
                    }
                };
                Ok(tokens)
            } else if peel_result_ok(&field.ty).is_some() {
                let tokens = match tr {
                    Trait::FromRequest => {
                        quote_spanned! {ty_span=>
                            #member: {
                                let (mut parts, body) = req.into_parts();
                                let value =
                                    ::axum::extract::FromRequestParts::from_request_parts(
                                        &mut parts,
                                        state,
                                    )
                                    .await
                                    .map(#into_inner);
                                req = ::axum::http::Request::from_parts(parts, body);
                                value
                            },
                        }
                    }
                    Trait::FromRequestParts => {
                        quote_spanned! {ty_span=>
                            #member: {
                                ::axum::extract::FromRequestParts::from_request_parts(
                                    parts,
                                    state,
                                )
                                .await
                                .map(#into_inner)
                            },
                        }
                    }
                };
                Ok(tokens)
            } else {
                let map_err = if let Some(rejection) = rejection {
                    quote! { <#rejection as ::std::convert::From<_>>::from }
                } else {
                    quote! { ::axum::response::IntoResponse::into_response }
                };

                let tokens = match tr {
                    Trait::FromRequest => {
                        quote_spanned! {ty_span=>
                            #member: {
                                let (mut parts, body) = req.into_parts();
                                let value =
                                    ::axum::extract::FromRequestParts::from_request_parts(
                                        &mut parts,
                                        state,
                                    )
                                    .await
                                    .map(#into_inner)
                                    .map_err(#map_err)?;
                                req = ::axum::http::Request::from_parts(parts, body);
                                value
                            },
                        }
                    }
                    Trait::FromRequestParts => {
                        quote_spanned! {ty_span=>
                            #member: {
                                ::axum::extract::FromRequestParts::from_request_parts(
                                    parts,
                                    state,
                                )
                                .await
                                .map(#into_inner)
                                .map_err(#map_err)?
                            },
                        }
                    }
                };
                Ok(tokens)
            }
        })
        .collect::<syn::Result<_>>()?;

    // Handle the last element, if deriving FromRequest
    if let Some(field) = last {
        let FromRequestFieldAttrs { via } = parse_attrs("from_request", &field.attrs)?;

        let member = member(field, fields.len() - 1);
        let ty_span = field.ty.span();
        let into_inner = into_inner(via, ty_span);

        let item = if peel_option(&field.ty).is_some() {
            quote_spanned! {ty_span=>
                #member: {
                    ::axum::extract::FromRequest::from_request(req, state)
                        .await
                        .ok()
                        .map(#into_inner)
                },
            }
        } else if peel_result_ok(&field.ty).is_some() {
            quote_spanned! {ty_span=>
                #member: {
                    ::axum::extract::FromRequest::from_request(req, state)
                        .await
                        .map(#into_inner)
                },
            }
        } else {
            let map_err = if let Some(rejection) = rejection {
                quote! { <#rejection as ::std::convert::From<_>>::from }
            } else {
                quote! { ::axum::response::IntoResponse::into_response }
            };

            quote_spanned! {ty_span=>
                #member: {
                    ::axum::extract::FromRequest::from_request(req, state)
                        .await
                        .map(#into_inner)
                        .map_err(#map_err)?
                },
            }
        };

        res.push(item);
    }

    Ok(res)
}
*)
Definition extract_fields
    (fields : ref syn.data.Fields.t)
    (rejection : ref (core.option.Option.t syn.path.Path.t))
    (tr : axum_macros.from_request.Trait.t)
    :
      M
        ltac:(syn.error.Result
          (alloc.vec.Vec.t
            proc_macro2.TokenStream.t
            alloc.vec.Vec.Default.A)) :=
  let* fields := M.alloc fields in
  let* rejection := M.alloc rejection in
  let* tr := M.alloc tr in
  M.read foo.

(*
    fn member(field: &syn::Field, index: usize) -> TokenStream {
        match &field.ident {
            Some(ident) => quote! { #ident },
            _ => {
                let member = syn::Member::Unnamed(syn::Index {
                    index: index as u32,
                    span: field.span(),
                });
                quote! { #member }
            }
        }
    }
*)
Definition member
    (field : ref syn.data.Field.t)
    (index : usize.t)
    : M proc_macro2.TokenStream.t :=
  let* field := M.alloc field in
  let* index := M.alloc index in
  M.read foo.

(*
    fn into_inner(via: Option<(attr::kw::via, syn::Path)>, ty_span: Span) -> TokenStream {
        if let Some((_, path)) = via {
            let span = path.span();
            quote_spanned! {span=>
                |#path(inner)| inner
            }
        } else {
            quote_spanned! {ty_span=>
                ::std::convert::identity
            }
        }
    }
*)
Definition into_inner
    (via
      :
      core.option.Option.t
        (axum_macros.from_request.attr.kw.via.t * syn.path.Path.t))
    (ty_span : proc_macro2.Span.t)
    : M proc_macro2.TokenStream.t :=
  let* via := M.alloc via in
  let* ty_span := M.alloc ty_span in
  M.read foo.

(*
fn peel_option(ty: &syn::Type) -> Option<&syn::Type> {
    let type_path = if let syn::Type::Path(type_path) = ty {
        type_path
    } else {
        return None;
    };

    let segment = type_path.path.segments.last()?;

    if segment.ident != "Option" {
        return None;
    }

    let args = match &segment.arguments {
        syn::PathArguments::AngleBracketed(args) => args,
        syn::PathArguments::Parenthesized(_) | syn::PathArguments::None => return None,
    };

    let ty = if args.args.len() == 1 {
        args.args.last().unwrap()
    } else {
        return None;
    };

    if let syn::GenericArgument::Type(ty) = ty {
        Some(ty)
    } else {
        None
    }
}
*)
Definition peel_option
    (ty : ref syn.ty.Type_.t)
    : M (core.option.Option.t (ref syn.ty.Type_.t)) :=
  let* ty := M.alloc ty in
  M.read foo.

(*
fn peel_result_ok(ty: &syn::Type) -> Option<&syn::Type> {
    let type_path = if let syn::Type::Path(type_path) = ty {
        type_path
    } else {
        return None;
    };

    let segment = type_path.path.segments.last()?;

    if segment.ident != "Result" {
        return None;
    }

    let args = match &segment.arguments {
        syn::PathArguments::AngleBracketed(args) => args,
        syn::PathArguments::Parenthesized(_) | syn::PathArguments::None => return None,
    };

    let ty = if args.args.len() == 2 {
        args.args.first().unwrap()
    } else {
        return None;
    };

    if let syn::GenericArgument::Type(ty) = ty {
        Some(ty)
    } else {
        None
    }
}
*)
Definition peel_result_ok
    (ty : ref syn.ty.Type_.t)
    : M (core.option.Option.t (ref syn.ty.Type_.t)) :=
  let* ty := M.alloc ty in
  M.read foo.

(*
fn impl_struct_by_extracting_all_at_once(
    ident: syn::Ident,
    fields: syn::Fields,
    via_path: syn::Path,
    rejection: Option<syn::Path>,
    generic_ident: Option<Ident>,
    state: &State,
    tr: Trait,
) -> syn::Result<TokenStream> {
    let fields = match fields {
        syn::Fields::Named(fields) => fields.named.into_iter(),
        syn::Fields::Unnamed(fields) => fields.unnamed.into_iter(),
        syn::Fields::Unit => Punctuated::<_, Token![,]>::new().into_iter(),
    };

    for field in fields {
        let FromRequestFieldAttrs { via } = parse_attrs("from_request", &field.attrs)?;

        if let Some((via, _)) = via {
            return Err(syn::Error::new_spanned(
                via,
                "`#[from_request(via(...))]` on a field cannot be used \
                together with `#[from_request(...)]` on the container",
            ));
        }
    }

    let path_span = via_path.span();

    let (associated_rejection_type, map_err) = if let Some(rejection) = &rejection {
        let rejection = quote! { #rejection };
        let map_err = quote! { ::std::convert::From::from };
        (rejection, map_err)
    } else {
        let rejection = quote! {
            ::axum::response::Response
        };
        let map_err = quote! { ::axum::response::IntoResponse::into_response };
        (rejection, map_err)
    };

    // for something like
    //
    // ```
    // #[derive(Clone, Default, FromRequest)]
    // #[from_request(via(State))]
    // struct AppState {}
    // ```
    //
    // we need to implement `impl<M> FromRequest<AppState, M>` but only for
    // - `#[derive(FromRequest)]`, not `#[derive(FromRequestParts)]`
    // - `State`, not other extractors
    //
    // honestly not sure why but the tests all pass
    let via_marker_type = if path_ident_is_state(&via_path) {
        tr.via_marker_type()
    } else {
        None
    };

    let impl_generics = via_marker_type
        .iter()
        .cloned()
        .chain(state.impl_generics())
        .chain(generic_ident.is_some().then(|| parse_quote!(T)))
        .collect::<Punctuated<Type, Token![,]>>();

    let trait_generics = state
        .trait_generics()
        .chain(via_marker_type)
        .collect::<Punctuated<Type, Token![,]>>();

    let ident_generics = generic_ident
        .is_some()
        .then(|| quote! { <T> })
        .unwrap_or_default();

    let rejection_bound = rejection.as_ref().map(|rejection| {
        match (tr, generic_ident.is_some()) {
            (Trait::FromRequest, true) => {
                quote! {
                    #rejection: ::std::convert::From<<#via_path<T> as ::axum::extract::FromRequest<#trait_generics>>::Rejection>,
                }
            },
            (Trait::FromRequest, false) => {
                quote! {
                    #rejection: ::std::convert::From<<#via_path<Self> as ::axum::extract::FromRequest<#trait_generics>>::Rejection>,
                }
            },
            (Trait::FromRequestParts, true) => {
                quote! {
                    #rejection: ::std::convert::From<<#via_path<T> as ::axum::extract::FromRequestParts<#trait_generics>>::Rejection>,
                }
            },
            (Trait::FromRequestParts, false) => {
                quote! {
                    #rejection: ::std::convert::From<<#via_path<Self> as ::axum::extract::FromRequestParts<#trait_generics>>::Rejection>,
                }
            }
        }
    }).unwrap_or_default();

    let via_type_generics = if generic_ident.is_some() {
        quote! { T }
    } else {
        quote! { Self }
    };

    let value_to_self = if generic_ident.is_some() {
        quote! {
            #ident(value)
        }
    } else {
        quote! { value }
    };

    let state_bounds = state.bounds();

    let tokens = match tr {
        Trait::FromRequest => {
            quote_spanned! {path_span=>
                #[::axum::async_trait]
                #[automatically_derived]
                impl<#impl_generics> ::axum::extract::FromRequest<#trait_generics> for #ident #ident_generics
                where
                    #via_path<#via_type_generics>: ::axum::extract::FromRequest<#trait_generics>,
                    #rejection_bound
                    #state_bounds
                {
                    type Rejection = #associated_rejection_type;

                    async fn from_request(
                        req: ::axum::http::Request<::axum::body::Body>,
                        state: &#state,
                    ) -> ::std::result::Result<Self, Self::Rejection> {
                        ::axum::extract::FromRequest::from_request(req, state)
                            .await
                            .map(|#via_path(value)| #value_to_self)
                            .map_err(#map_err)
                    }
                }
            }
        }
        Trait::FromRequestParts => {
            quote_spanned! {path_span=>
                #[::axum::async_trait]
                #[automatically_derived]
                impl<#impl_generics> ::axum::extract::FromRequestParts<#trait_generics> for #ident #ident_generics
                where
                    #via_path<#via_type_generics>: ::axum::extract::FromRequestParts<#trait_generics>,
                    #rejection_bound
                    #state_bounds
                {
                    type Rejection = #associated_rejection_type;

                    async fn from_request_parts(
                        parts: &mut ::axum::http::request::Parts,
                        state: &#state,
                    ) -> ::std::result::Result<Self, Self::Rejection> {
                        ::axum::extract::FromRequestParts::from_request_parts(parts, state)
                            .await
                            .map(|#via_path(value)| #value_to_self)
                            .map_err(#map_err)
                    }
                }
            }
        }
    };

    Ok(tokens)
}
*)
Definition impl_struct_by_extracting_all_at_once
    (ident : proc_macro2.Ident.t)
    (fields : syn.data.Fields.t)
    (via_path : syn.path.Path.t)
    (rejection : core.option.Option.t syn.path.Path.t)
    (generic_ident : core.option.Option.t proc_macro2.Ident.t)
    (state : ref axum_macros.from_request.State.t)
    (tr : axum_macros.from_request.Trait.t)
    : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
  let* ident := M.alloc ident in
  let* fields := M.alloc fields in
  let* via_path := M.alloc via_path in
  let* rejection := M.alloc rejection in
  let* generic_ident := M.alloc generic_ident in
  let* state := M.alloc state in
  let* tr := M.alloc tr in
  M.read foo.

(*
fn impl_enum_by_extracting_all_at_once(
    ident: syn::Ident,
    variants: Punctuated<syn::Variant, Token![,]>,
    path: syn::Path,
    rejection: Option<syn::Path>,
    state: State,
    tr: Trait,
) -> syn::Result<TokenStream> {
    for variant in variants {
        let FromRequestFieldAttrs { via } = parse_attrs("from_request", &variant.attrs)?;

        if let Some((via, _)) = via {
            return Err(syn::Error::new_spanned(
                via,
                "`#[from_request(via(...))]` cannot be used on variants",
            ));
        }

        let fields = match variant.fields {
            syn::Fields::Named(fields) => fields.named.into_iter(),
            syn::Fields::Unnamed(fields) => fields.unnamed.into_iter(),
            syn::Fields::Unit => Punctuated::<_, Token![,]>::new().into_iter(),
        };

        for field in fields {
            let FromRequestFieldAttrs { via } = parse_attrs("from_request", &field.attrs)?;
            if let Some((via, _)) = via {
                return Err(syn::Error::new_spanned(
                    via,
                    "`#[from_request(via(...))]` cannot be used inside variants",
                ));
            }
        }
    }

    let (associated_rejection_type, map_err) = if let Some(rejection) = &rejection {
        let rejection = quote! { #rejection };
        let map_err = quote! { ::std::convert::From::from };
        (rejection, map_err)
    } else {
        let rejection = quote! {
            ::axum::response::Response
        };
        let map_err = quote! { ::axum::response::IntoResponse::into_response };
        (rejection, map_err)
    };

    let path_span = path.span();

    let impl_generics = state
        .impl_generics()
        .collect::<Punctuated<Type, Token![,]>>();

    let trait_generics = state
        .trait_generics()
        .collect::<Punctuated<Type, Token![,]>>();

    let state_bounds = state.bounds();

    let tokens = match tr {
        Trait::FromRequest => {
            quote_spanned! {path_span=>
                #[::axum::async_trait]
                #[automatically_derived]
                impl<#impl_generics> ::axum::extract::FromRequest<#trait_generics> for #ident
                where
                    #state_bounds
                {
                    type Rejection = #associated_rejection_type;

                    async fn from_request(
                        req: ::axum::http::Request<::axum::body::Body>,
                        state: &#state,
                    ) -> ::std::result::Result<Self, Self::Rejection> {
                        ::axum::extract::FromRequest::from_request(req, state)
                            .await
                            .map(|#path(inner)| inner)
                            .map_err(#map_err)
                    }
                }
            }
        }
        Trait::FromRequestParts => {
            quote_spanned! {path_span=>
                #[::axum::async_trait]
                #[automatically_derived]
                impl<#impl_generics> ::axum::extract::FromRequestParts<#trait_generics> for #ident
                where
                    #state_bounds
                {
                    type Rejection = #associated_rejection_type;

                    async fn from_request_parts(
                        parts: &mut ::axum::http::request::Parts,
                        state: &#state,
                    ) -> ::std::result::Result<Self, Self::Rejection> {
                        ::axum::extract::FromRequestParts::from_request_parts(parts, state)
                            .await
                            .map(|#path(inner)| inner)
                            .map_err(#map_err)
                    }
                }
            }
        }
    };

    Ok(tokens)
}
*)
Definition impl_enum_by_extracting_all_at_once
    (ident : proc_macro2.Ident.t)
    (variants
      :
      syn.punctuated.Punctuated.t syn.data.Variant.t syn.token.Comma.t)
    (path : syn.path.Path.t)
    (rejection : core.option.Option.t syn.path.Path.t)
    (state : axum_macros.from_request.State.t)
    (tr : axum_macros.from_request.Trait.t)
    : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
  let* ident := M.alloc ident in
  let* variants := M.alloc variants in
  let* path := M.alloc path in
  let* rejection := M.alloc rejection in
  let* state := M.alloc state in
  let* tr := M.alloc tr in
  M.read foo.

(*
fn infer_state_type_from_field_types(fields: &Fields) -> impl Iterator<Item = Type> + '_ {
    match fields {
        Fields::Named(fields_named) => Box::new(crate::infer_state_types(
            fields_named.named.iter().map(|field| &field.ty),
        )) as Box<dyn Iterator<Item = Type>>,
        Fields::Unnamed(fields_unnamed) => Box::new(crate::infer_state_types(
            fields_unnamed.unnamed.iter().map(|field| &field.ty),
        )),
        Fields::Unit => Box::new(iter::empty()),
    }
}
*)
Definition infer_state_type_from_field_types
    (fields : ref syn.data.Fields.t)
    : M OpaqueDef :=
  let* fields := M.alloc fields in
  M.read foo.

(*
fn infer_state_type_from_field_attributes(fields: &Fields) -> impl Iterator<Item = Type> + '_ {
    match fields {
        Fields::Named(fields_named) => {
            Box::new(fields_named.named.iter().filter_map(|field| {
                // TODO(david): it's a little wasteful to parse the attributes again here
                // ideally we should parse things once and pass the data down
                let FromRequestFieldAttrs { via } =
                    parse_attrs("from_request", &field.attrs).ok()?;
                let (_, via_path) = via?;
                path_ident_is_state(&via_path).then(|| field.ty.clone())
            })) as Box<dyn Iterator<Item = Type>>
        }
        Fields::Unnamed(fields_unnamed) => {
            Box::new(fields_unnamed.unnamed.iter().filter_map(|field| {
                // TODO(david): it's a little wasteful to parse the attributes again here
                // ideally we should parse things once and pass the data down
                let FromRequestFieldAttrs { via } =
                    parse_attrs("from_request", &field.attrs).ok()?;
                let (_, via_path) = via?;
                path_ident_is_state(&via_path).then(|| field.ty.clone())
            }))
        }
        Fields::Unit => Box::new(iter::empty()),
    }
}
*)
Definition infer_state_type_from_field_attributes
    (fields : ref syn.data.Fields.t)
    : M OpaqueDef :=
  let* fields := M.alloc fields in
  M.read foo.

(*
fn path_ident_is_state(path: &Path) -> bool {
    if let Some(last_segment) = path.segments.last() {
        last_segment.ident == "State"
    } else {
        false
    }
}
*)
Definition path_ident_is_state (path : ref syn.path.Path.t) : M bool.t :=
  let* path := M.alloc path in
  M.read foo.

(*
fn state_from_via(ident: &Ident, via: &Path) -> Option<Type> {
    path_ident_is_state(via).then(|| parse_quote!(#ident))
}
*)
Definition state_from_via
    (ident : ref proc_macro2.Ident.t)
    (via : ref syn.path.Path.t)
    : M (core.option.Option.t syn.ty.Type_.t) :=
  let* ident := M.alloc ident in
  let* via := M.alloc via in
  M.read foo.

(*
fn test_field_doesnt_impl_from_request() {}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition test_field_doesnt_impl_from_request : M unit := M.read foo.

Module typed_path.
  (*
  pub(crate) fn expand(item_struct: ItemStruct) -> syn::Result<TokenStream> {
      let ItemStruct {
          attrs,
          ident,
          generics,
          fields,
          ..
      } = &item_struct;
  
      if !generics.params.is_empty() || generics.where_clause.is_some() {
          return Err(syn::Error::new_spanned(
              generics,
              "`#[derive(TypedPath)]` doesn't support generics",
          ));
      }
  
      let Attrs { path, rejection } = crate::attr_parsing::parse_attrs("typed_path", attrs)?;
  
      let path = path.ok_or_else(|| {
          syn::Error::new(
              Span::call_site(),
              "Missing path: `#[typed_path(\"/foo/bar\")]`",
          )
      })?;
  
      let rejection = rejection.map(second);
  
      match fields {
          syn::Fields::Named(_) => {
              let segments = parse_path(&path)?;
              Ok(expand_named_fields(ident, path, &segments, rejection))
          }
          syn::Fields::Unnamed(fields) => {
              let segments = parse_path(&path)?;
              expand_unnamed_fields(fields, ident, path, &segments, rejection)
          }
          syn::Fields::Unit => expand_unit_fields(ident, path, rejection),
      }
  }
  *)
  Definition expand
      (item_struct : syn.item.ItemStruct.t)
      : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
    let* item_struct := M.alloc item_struct in
    M.read foo.
  
  Module kw.
    Module  rejection.
    Section rejection.
      Record t : Set := {
        span : ltac:(syn.__private.Span);
      }.
      
      Definition Get_span :=
        Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
    End rejection.
    End rejection.
    
    (*
            pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
                span: __S,
            ) -> $ident {
                $ident {
                    span: $crate::__private::IntoSpans::into_spans(span),
                }
            }
    *)
    (* #[allow(dead_code)] - function was ignored by the compiler *)
    Definition rejection
        {__S : Set}
        {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
        (span : __S)
        : M axum_macros.typed_path.kw.rejection.t :=
      let* span := M.alloc span in
      M.read foo.
  End kw.
  
  Module  Attrs.
  Section Attrs.
    Record t : Set := {
      path : core.option.Option.t syn.lit.LitStr.t;
      rejection :
        core.option.Option.t
          (axum_macros.typed_path.kw.rejection.t * syn.path.Path.t);
    }.
    
    Definition Get_path :=
      Ref.map (fun α => Some α.(path)) (fun β α => Some (α <| path := β |>)).
    Definition Get_rejection :=
      Ref.map
        (fun α => Some α.(rejection))
        (fun β α => Some (α <| rejection := β |>)).
  End Attrs.
  End Attrs.
  
  Module  Impl_core_default_Default_for_axum_macros_typed_path_Attrs_t.
  Section Impl_core_default_Default_for_axum_macros_typed_path_Attrs_t.
    Definition Self : Set := axum_macros.typed_path.Attrs.t.
    
    (*
    Default
    *)
    Definition default : M axum_macros.typed_path.Attrs.t := M.read foo.
    
    Global Instance AssociatedFunction_default :
      Notations.DoubleColon Self "default" := {
      Notations.double_colon := default;
    }.
    
    Global Instance ℐ : core.default.Default.Trait Self := {
      core.default.Default.default := default;
    }.
  End Impl_core_default_Default_for_axum_macros_typed_path_Attrs_t.
  End Impl_core_default_Default_for_axum_macros_typed_path_Attrs_t.
  
  Module  Impl_syn_parse_Parse_for_axum_macros_typed_path_Attrs_t.
  Section Impl_syn_parse_Parse_for_axum_macros_typed_path_Attrs_t.
    Definition Self : Set := axum_macros.typed_path.Attrs.t.
    
    (*
        fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
            let mut path = None;
            let mut rejection = None;
    
            while !input.is_empty() {
                let lh = input.lookahead1();
                if lh.peek(LitStr) {
                    path = Some(input.parse()?);
                } else if lh.peek(kw::rejection) {
                    parse_parenthesized_attribute(input, &mut rejection)?;
                } else {
                    return Err(lh.error());
                }
    
                let _ = input.parse::<Token![,]>();
            }
    
            Ok(Self { path, rejection })
        }
    *)
    Definition parse
        (input : ltac:(syn.parse.ParseStream))
        : M ltac:(syn.error.Result Self) :=
      let* input := M.alloc input in
      M.read foo.
    
    Global Instance AssociatedFunction_parse :
      Notations.DoubleColon Self "parse" := {
      Notations.double_colon := parse;
    }.
    
    Global Instance ℐ : syn.parse.Parse.Trait Self := {
      syn.parse.Parse.parse := parse;
    }.
  End Impl_syn_parse_Parse_for_axum_macros_typed_path_Attrs_t.
  End Impl_syn_parse_Parse_for_axum_macros_typed_path_Attrs_t.
  
  Module  Impl_axum_macros_attr_parsing_Combine_for_axum_macros_typed_path_Attrs_t.
  Section Impl_axum_macros_attr_parsing_Combine_for_axum_macros_typed_path_Attrs_t.
    Definition Self : Set := axum_macros.typed_path.Attrs.t.
    
    (*
        fn combine(mut self, other: Self) -> syn::Result<Self> {
            let Self { path, rejection } = other;
            if let Some(path) = path {
                if self.path.is_some() {
                    return Err(syn::Error::new_spanned(
                        path,
                        "path specified more than once",
                    ));
                }
                self.path = Some(path);
            }
            combine_attribute(&mut self.rejection, rejection)?;
            Ok(self)
        }
    *)
    Definition combine
        (self : Self)
        (other : Self)
        : M ltac:(syn.error.Result Self) :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_combine :
      Notations.DoubleColon Self "combine" := {
      Notations.double_colon := combine;
    }.
    
    Global Instance ℐ : axum_macros.attr_parsing.Combine.Trait Self := {
      axum_macros.attr_parsing.Combine.combine := combine;
    }.
  End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_typed_path_Attrs_t.
  End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_typed_path_Attrs_t.
  
  (*
  fn expand_named_fields(
      ident: &syn::Ident,
      path: LitStr,
      segments: &[Segment],
      rejection: Option<syn::Path>,
  ) -> TokenStream {
      let format_str = format_str_from_path(segments);
      let captures = captures_from_path(segments);
  
      let typed_path_impl = quote_spanned! {path.span()=>
          #[automatically_derived]
          impl ::axum_extra::routing::TypedPath for #ident {
              const PATH: &'static str = #path;
          }
      };
  
      let display_impl = quote_spanned! {path.span()=>
          #[automatically_derived]
          impl ::std::fmt::Display for #ident {
              #[allow(clippy::unnecessary_to_owned)]
              fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                  let Self { #(#captures,)* } = self;
                  write!(
                      f,
                      #format_str,
                      #(
                          #captures = ::axum_extra::__private::utf8_percent_encode(
                              &#captures.to_string(),
                              ::axum_extra::__private::PATH_SEGMENT,
                          )
                      ),*
                  )
              }
          }
      };
  
      let rejection_assoc_type = rejection_assoc_type(&rejection);
      let map_err_rejection = map_err_rejection(&rejection);
  
      let from_request_impl = quote! {
          #[::axum::async_trait]
          #[automatically_derived]
          impl<S> ::axum::extract::FromRequestParts<S> for #ident
          where
              S: Send + Sync,
          {
              type Rejection = #rejection_assoc_type;
  
              async fn from_request_parts(
                  parts: &mut ::axum::http::request::Parts,
                  state: &S,
              ) -> ::std::result::Result<Self, Self::Rejection> {
                  ::axum::extract::Path::from_request_parts(parts, state)
                      .await
                      .map(|path| path.0)
                      #map_err_rejection
              }
          }
      };
  
      quote! {
          #typed_path_impl
          #display_impl
          #from_request_impl
      }
  }
  *)
  Definition expand_named_fields
      (ident : ref proc_macro2.Ident.t)
      (path : syn.lit.LitStr.t)
      (segments : ref (slice axum_macros.typed_path.Segment.t))
      (rejection : core.option.Option.t syn.path.Path.t)
      : M proc_macro2.TokenStream.t :=
    let* ident := M.alloc ident in
    let* path := M.alloc path in
    let* segments := M.alloc segments in
    let* rejection := M.alloc rejection in
    M.read foo.
  
  (*
  fn expand_unnamed_fields(
      fields: &syn::FieldsUnnamed,
      ident: &syn::Ident,
      path: LitStr,
      segments: &[Segment],
      rejection: Option<syn::Path>,
  ) -> syn::Result<TokenStream> {
      let num_captures = segments
          .iter()
          .filter(|segment| match segment {
              Segment::Capture(_, _) => true,
              Segment::Static(_) => false,
          })
          .count();
      let num_fields = fields.unnamed.len();
      if num_fields != num_captures {
          return Err(syn::Error::new_spanned(
              fields,
              format!(
                  "Mismatch in number of captures and fields. Path has {} but struct has {}",
                  simple_pluralize(num_captures, "capture"),
                  simple_pluralize(num_fields, "field"),
              ),
          ));
      }
  
      let destructure_self = segments
          .iter()
          .filter_map(|segment| match segment {
              Segment::Capture(capture, _) => Some(capture),
              Segment::Static(_) => None,
          })
          .enumerate()
          .map(|(idx, capture)| {
              let idx = syn::Index {
                  index: idx as _,
                  span: Span::call_site(),
              };
              let capture = format_ident!("{}", capture, span = path.span());
              quote_spanned! {path.span()=>
                  #idx: #capture,
              }
          });
  
      let format_str = format_str_from_path(segments);
      let captures = captures_from_path(segments);
  
      let typed_path_impl = quote_spanned! {path.span()=>
          #[automatically_derived]
          impl ::axum_extra::routing::TypedPath for #ident {
              const PATH: &'static str = #path;
          }
      };
  
      let display_impl = quote_spanned! {path.span()=>
          #[automatically_derived]
          impl ::std::fmt::Display for #ident {
              #[allow(clippy::unnecessary_to_owned)]
              fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                  let Self { #(#destructure_self)* } = self;
                  write!(
                      f,
                      #format_str,
                      #(
                          #captures = ::axum_extra::__private::utf8_percent_encode(
                              &#captures.to_string(),
                              ::axum_extra::__private::PATH_SEGMENT,
                          )
                      ),*
                  )
              }
          }
      };
  
      let rejection_assoc_type = rejection_assoc_type(&rejection);
      let map_err_rejection = map_err_rejection(&rejection);
  
      let from_request_impl = quote! {
          #[::axum::async_trait]
          #[automatically_derived]
          impl<S> ::axum::extract::FromRequestParts<S> for #ident
          where
              S: Send + Sync,
          {
              type Rejection = #rejection_assoc_type;
  
              async fn from_request_parts(
                  parts: &mut ::axum::http::request::Parts,
                  state: &S,
              ) -> ::std::result::Result<Self, Self::Rejection> {
                  ::axum::extract::Path::from_request_parts(parts, state)
                      .await
                      .map(|path| path.0)
                      #map_err_rejection
              }
          }
      };
  
      Ok(quote! {
          #typed_path_impl
          #display_impl
          #from_request_impl
      })
  }
  *)
  Definition expand_unnamed_fields
      (fields : ref syn.data.FieldsUnnamed.t)
      (ident : ref proc_macro2.Ident.t)
      (path : syn.lit.LitStr.t)
      (segments : ref (slice axum_macros.typed_path.Segment.t))
      (rejection : core.option.Option.t syn.path.Path.t)
      : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
    let* fields := M.alloc fields in
    let* ident := M.alloc ident in
    let* path := M.alloc path in
    let* segments := M.alloc segments in
    let* rejection := M.alloc rejection in
    M.read foo.
  
  (*
  fn simple_pluralize(count: usize, word: &str) -> String {
      if count == 1 {
          format!("{count} {word}")
      } else {
          format!("{count} {word}s")
      }
  }
  *)
  Definition simple_pluralize
      (count : usize.t)
      (word : ref str.t)
      : M alloc.string.String.t :=
    let* count := M.alloc count in
    let* word := M.alloc word in
    M.read foo.
  
  (*
  fn expand_unit_fields(
      ident: &syn::Ident,
      path: LitStr,
      rejection: Option<syn::Path>,
  ) -> syn::Result<TokenStream> {
      for segment in parse_path(&path)? {
          match segment {
              Segment::Capture(_, span) => {
                  return Err(syn::Error::new(
                      span,
                      "Typed paths for unit structs cannot contain captures",
                  ));
              }
              Segment::Static(_) => {}
          }
      }
  
      let typed_path_impl = quote_spanned! {path.span()=>
          #[automatically_derived]
          impl ::axum_extra::routing::TypedPath for #ident {
              const PATH: &'static str = #path;
          }
      };
  
      let display_impl = quote_spanned! {path.span()=>
          #[automatically_derived]
          impl ::std::fmt::Display for #ident {
              fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                  write!(f, #path)
              }
          }
      };
  
      let rejection_assoc_type = if let Some(rejection) = &rejection {
          quote! { #rejection }
      } else {
          quote! { ::axum::http::StatusCode }
      };
      let create_rejection = if let Some(rejection) = &rejection {
          quote! {
              Err(<#rejection as ::std::default::Default>::default())
          }
      } else {
          quote! {
              Err(::axum::http::StatusCode::NOT_FOUND)
          }
      };
  
      let from_request_impl = quote! {
          #[::axum::async_trait]
          #[automatically_derived]
          impl<S> ::axum::extract::FromRequestParts<S> for #ident
          where
              S: Send + Sync,
          {
              type Rejection = #rejection_assoc_type;
  
              async fn from_request_parts(
                  parts: &mut ::axum::http::request::Parts,
                  _state: &S,
              ) -> ::std::result::Result<Self, Self::Rejection> {
                  if parts.uri.path() == <Self as ::axum_extra::routing::TypedPath>::PATH {
                      Ok(Self)
                  } else {
                      #create_rejection
                  }
              }
          }
      };
  
      Ok(quote! {
          #typed_path_impl
          #display_impl
          #from_request_impl
      })
  }
  *)
  Definition expand_unit_fields
      (ident : ref proc_macro2.Ident.t)
      (path : syn.lit.LitStr.t)
      (rejection : core.option.Option.t syn.path.Path.t)
      : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
    let* ident := M.alloc ident in
    let* path := M.alloc path in
    let* rejection := M.alloc rejection in
    M.read foo.
  
  (*
  fn format_str_from_path(segments: &[Segment]) -> String {
      segments
          .iter()
          .map(|segment| match segment {
              Segment::Capture(capture, _) => format!("{{{capture}}}"),
              Segment::Static(segment) => segment.to_owned(),
          })
          .collect::<Vec<_>>()
          .join("/")
  }
  *)
  Definition format_str_from_path
      (segments : ref (slice axum_macros.typed_path.Segment.t))
      : M alloc.string.String.t :=
    let* segments := M.alloc segments in
    M.read foo.
  
  (*
  fn captures_from_path(segments: &[Segment]) -> Vec<syn::Ident> {
      segments
          .iter()
          .filter_map(|segment| match segment {
              Segment::Capture(capture, span) => Some(format_ident!("{}", capture, span = *span)),
              Segment::Static(_) => None,
          })
          .collect::<Vec<_>>()
  }
  *)
  Definition captures_from_path
      (segments : ref (slice axum_macros.typed_path.Segment.t))
      : M (alloc.vec.Vec.t proc_macro2.Ident.t alloc.vec.Vec.Default.A) :=
    let* segments := M.alloc segments in
    M.read foo.
  
  (*
  fn parse_path(path: &LitStr) -> syn::Result<Vec<Segment>> {
      let value = path.value();
      if value.is_empty() {
          return Err(syn::Error::new_spanned(
              path,
              "paths must start with a `/`. Use \"/\" for root routes",
          ));
      } else if !path.value().starts_with('/') {
          return Err(syn::Error::new_spanned(path, "paths must start with a `/`"));
      }
  
      path.value()
          .split('/')
          .map(|segment| {
              if let Some(capture) = segment
                  .strip_prefix(':')
                  .or_else(|| segment.strip_prefix('*'))
              {
                  Ok(Segment::Capture(capture.to_owned(), path.span()))
              } else {
                  Ok(Segment::Static(segment.to_owned()))
              }
          })
          .collect()
  }
  *)
  Definition parse_path
      (path : ref syn.lit.LitStr.t)
      :
        M
          ltac:(syn.error.Result
            (alloc.vec.Vec.t
              axum_macros.typed_path.Segment.t
              alloc.vec.Vec.Default.A)) :=
    let* path := M.alloc path in
    M.read foo.
  
  Module Segment.
    Inductive t : Set :=
    | Capture (_ : alloc.string.String.t) (_ : proc_macro2.Span.t)
    | Static (_ : alloc.string.String.t).
    
    Definition Get_Capture_0 :=
      Ref.map
        (fun α => match α with | Capture α0 _ => Some α0 | _ => None end)
        (fun β α =>
          match α with | Capture _ α1 => Some (Capture β α1) | _ => None end).
    
    Definition Get_Capture_1 :=
      Ref.map
        (fun α => match α with | Capture _ α1 => Some α1 | _ => None end)
        (fun β α =>
          match α with | Capture α0 _ => Some (Capture α0 β) | _ => None end).
    
    Definition Get_Static_0 :=
      Ref.map
        (fun α => match α with | Static α0 => Some α0 | _ => None end)
        (fun β α => match α with | Static _ => Some (Static β) | _ => None end).
  End Segment.
  
  (*
  fn path_rejection() -> TokenStream {
      quote! {
          <::axum::extract::Path<Self> as ::axum::extract::FromRequestParts<S>>::Rejection
      }
  }
  *)
  Definition path_rejection : M proc_macro2.TokenStream.t := M.read foo.
  
  (*
  fn rejection_assoc_type(rejection: &Option<syn::Path>) -> TokenStream {
      match rejection {
          Some(rejection) => quote! { #rejection },
          None => path_rejection(),
      }
  }
  *)
  Definition rejection_assoc_type
      (rejection : ref (core.option.Option.t syn.path.Path.t))
      : M proc_macro2.TokenStream.t :=
    let* rejection := M.alloc rejection in
    M.read foo.
  
  (*
  fn map_err_rejection(rejection: &Option<syn::Path>) -> TokenStream {
      rejection
          .as_ref()
          .map(|rejection| {
              let path_rejection = path_rejection();
              quote! {
                  .map_err(|rejection| {
                      <#rejection as ::std::convert::From<#path_rejection>>::from(rejection)
                  })
              }
          })
          .unwrap_or_default()
  }
  *)
  Definition map_err_rejection
      (rejection : ref (core.option.Option.t syn.path.Path.t))
      : M proc_macro2.TokenStream.t :=
    let* rejection := M.alloc rejection in
    M.read foo.
End typed_path.

(*
pub(crate) fn expand(item_struct: ItemStruct) -> syn::Result<TokenStream> {
    let ItemStruct {
        attrs,
        ident,
        generics,
        fields,
        ..
    } = &item_struct;

    if !generics.params.is_empty() || generics.where_clause.is_some() {
        return Err(syn::Error::new_spanned(
            generics,
            "`#[derive(TypedPath)]` doesn't support generics",
        ));
    }

    let Attrs { path, rejection } = crate::attr_parsing::parse_attrs("typed_path", attrs)?;

    let path = path.ok_or_else(|| {
        syn::Error::new(
            Span::call_site(),
            "Missing path: `#[typed_path(\"/foo/bar\")]`",
        )
    })?;

    let rejection = rejection.map(second);

    match fields {
        syn::Fields::Named(_) => {
            let segments = parse_path(&path)?;
            Ok(expand_named_fields(ident, path, &segments, rejection))
        }
        syn::Fields::Unnamed(fields) => {
            let segments = parse_path(&path)?;
            expand_unnamed_fields(fields, ident, path, &segments, rejection)
        }
        syn::Fields::Unit => expand_unit_fields(ident, path, rejection),
    }
}
*)
Definition expand
    (item_struct : syn.item.ItemStruct.t)
    : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
  let* item_struct := M.alloc item_struct in
  M.read foo.

Module Wrap_kw_3.
Module kw.
  Module  rejection.
  Section rejection.
    Record t : Set := {
      span : ltac:(syn.__private.Span);
    }.
    
    Definition Get_span :=
      Ref.map (fun α => Some α.(span)) (fun β α => Some (α <| span := β |>)).
  End rejection.
  End rejection.
  
  (*
          pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
              span: __S,
          ) -> $ident {
              $ident {
                  span: $crate::__private::IntoSpans::into_spans(span),
              }
          }
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition rejection
      {__S : Set}
      {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
      (span : __S)
      : M axum_macros.typed_path.kw.rejection.t :=
    let* span := M.alloc span in
    M.read foo.
End kw.
End Wrap_kw_3.
Import Wrap_kw_3.

(*
        pub fn $ident<__S: $crate::__private::IntoSpans<$crate::__private::Span>>(
            span: __S,
        ) -> $ident {
            $ident {
                span: $crate::__private::IntoSpans::into_spans(span),
            }
        }
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition rejection
    {__S : Set}
    {ℋ_0 : syn.span.IntoSpans.Trait __S (S := ltac:(syn.__private.Span))}
    (span : __S)
    : M axum_macros.typed_path.kw.rejection.t :=
  let* span := M.alloc span in
  M.read foo.

Module  Impl_core_default_Default_for_axum_macros_typed_path_kw_rejection_t.
Section Impl_core_default_Default_for_axum_macros_typed_path_kw_rejection_t.
  Definition Self : Set := axum_macros.typed_path.kw.rejection.t.
  
  (*
                  fn default() -> Self {
                      $ident {
                          span: $crate::__private::Span::call_site(),
                      }
                  }
  *)
  Definition default : M Self := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_macros_typed_path_kw_rejection_t.
End Impl_core_default_Default_for_axum_macros_typed_path_kw_rejection_t.

Module  Impl_syn_token_private_CustomToken_for_axum_macros_typed_path_kw_rejection_t.
Section Impl_syn_token_private_CustomToken_for_axum_macros_typed_path_kw_rejection_t.
  Definition Self : Set := axum_macros.typed_path.kw.rejection.t.
  
  (*
              fn peek(cursor: $crate::buffer::Cursor) -> $crate::__private::bool {
                  if let $crate::__private::Some((ident, _rest)) = cursor.ident() {
                      ident == $crate::__private::stringify!($ident)
                  } else {
                      false
                  }
              }
  *)
  Definition peek
      (cursor : syn.buffer.Cursor.t)
      : M ltac:(syn.__private.bool) :=
    let* cursor := M.alloc cursor in
    M.read foo.
  
  Global Instance AssociatedFunction_peek :
    Notations.DoubleColon Self "peek" := {
    Notations.double_colon := peek;
  }.
  
  (*
              fn display() -> &'static $crate::__private::str {
                  $crate::__private::concat!("`", $crate::__private::stringify!($ident), "`")
              }
  *)
  Definition display : M (ref ltac:(syn.__private.str)) := M.read foo.
  
  Global Instance AssociatedFunction_display :
    Notations.DoubleColon Self "display" := {
    Notations.double_colon := display;
  }.
  
  Global Instance ℐ : syn.token.private.CustomToken.Trait Self := {
    syn.token.private.CustomToken.peek := peek;
    syn.token.private.CustomToken.display := display;
  }.
End Impl_syn_token_private_CustomToken_for_axum_macros_typed_path_kw_rejection_t.
End Impl_syn_token_private_CustomToken_for_axum_macros_typed_path_kw_rejection_t.

Module  Impl_syn_parse_Parse_for_axum_macros_typed_path_kw_rejection_t.
Section Impl_syn_parse_Parse_for_axum_macros_typed_path_kw_rejection_t.
  Definition Self : Set := axum_macros.typed_path.kw.rejection.t.
  
  (*
              fn parse(input: $crate::parse::ParseStream) -> $crate::parse::Result<$ident> {
                  input.step(|cursor| {
                      if let $crate::__private::Some((ident, rest)) = cursor.ident() {
                          if ident == $crate::__private::stringify!($ident) {
                              return $crate::__private::Ok(($ident { span: ident.span() }, rest));
                          }
                      }
                      $crate::__private::Err(cursor.error($crate::__private::concat!(
                          "expected `",
                          $crate::__private::stringify!($ident),
                          "`",
                      )))
                  })
              }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      : M ltac:(syn.error.Result axum_macros.typed_path.kw.rejection.t) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_typed_path_kw_rejection_t.
End Impl_syn_parse_Parse_for_axum_macros_typed_path_kw_rejection_t.

Module  Impl_quote_to_tokens_ToTokens_for_axum_macros_typed_path_kw_rejection_t.
Section Impl_quote_to_tokens_ToTokens_for_axum_macros_typed_path_kw_rejection_t.
  Definition Self : Set := axum_macros.typed_path.kw.rejection.t.
  
  (*
              fn to_tokens(&self, tokens: &mut $crate::__private::TokenStream2) {
                  let ident = $crate::Ident::new($crate::__private::stringify!($ident), self.span);
                  $crate::__private::TokenStreamExt::append(tokens, ident);
              }
  *)
  Definition to_tokens
      (self : ref Self)
      (tokens : mut_ref ltac:(syn.__private.TokenStream2))
      : M unit :=
    let* self := M.alloc self in
    let* tokens := M.alloc tokens in
    M.read foo.
  
  Global Instance AssociatedFunction_to_tokens :
    Notations.DoubleColon Self "to_tokens" := {
    Notations.double_colon := to_tokens;
  }.
  
  Global Instance ℐ : quote.to_tokens.ToTokens.Required.Trait Self := {
    quote.to_tokens.ToTokens.to_tokens := to_tokens;
    quote.to_tokens.ToTokens.to_token_stream := Datatypes.None;
    quote.to_tokens.ToTokens.into_token_stream := Datatypes.None;
  }.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_typed_path_kw_rejection_t.
End Impl_quote_to_tokens_ToTokens_for_axum_macros_typed_path_kw_rejection_t.

Module  Impl_core_marker_Copy_for_axum_macros_typed_path_kw_rejection_t.
Section Impl_core_marker_Copy_for_axum_macros_typed_path_kw_rejection_t.
  Definition Self : Set := axum_macros.typed_path.kw.rejection.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_macros_typed_path_kw_rejection_t.
End Impl_core_marker_Copy_for_axum_macros_typed_path_kw_rejection_t.

Module  Impl_core_clone_Clone_for_axum_macros_typed_path_kw_rejection_t.
Section Impl_core_clone_Clone_for_axum_macros_typed_path_kw_rejection_t.
  Definition Self : Set := axum_macros.typed_path.kw.rejection.t.
  
  (*
              fn clone(&self) -> Self {
                  *self
              }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_macros_typed_path_kw_rejection_t.
End Impl_core_clone_Clone_for_axum_macros_typed_path_kw_rejection_t.

Module  Impl_core_fmt_Debug_for_axum_macros_typed_path_kw_rejection_t.
Section Impl_core_fmt_Debug_for_axum_macros_typed_path_kw_rejection_t.
  Definition Self : Set := axum_macros.typed_path.kw.rejection.t.
  
  (*
              fn fmt(&self, f: &mut $crate::__private::Formatter) -> $crate::__private::FmtResult {
                  $crate::__private::Formatter::write_str(
                      f,
                      $crate::__private::concat!(
                          "Keyword [",
                          $crate::__private::stringify!($ident),
                          "]",
                      ),
                  )
              }
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref ltac:(syn.__private.Formatter))
      : M ltac:(syn.__private.FmtResult) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_macros_typed_path_kw_rejection_t.
End Impl_core_fmt_Debug_for_axum_macros_typed_path_kw_rejection_t.

Module  Impl_core_cmp_Eq_for_axum_macros_typed_path_kw_rejection_t.
Section Impl_core_cmp_Eq_for_axum_macros_typed_path_kw_rejection_t.
  Definition Self : Set := axum_macros.typed_path.kw.rejection.t.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq := Datatypes.None;
  }.
End Impl_core_cmp_Eq_for_axum_macros_typed_path_kw_rejection_t.
End Impl_core_cmp_Eq_for_axum_macros_typed_path_kw_rejection_t.

Module  Impl_core_cmp_PartialEq_for_axum_macros_typed_path_kw_rejection_t.
Section Impl_core_cmp_PartialEq_for_axum_macros_typed_path_kw_rejection_t.
  Definition Self : Set := axum_macros.typed_path.kw.rejection.t.
  
  (*
              fn eq(&self, _other: &Self) -> $crate::__private::bool {
                  true
              }
  *)
  Definition eq
      (self : ref Self)
      (_other : ref Self)
      : M ltac:(syn.__private.bool) :=
    let* self := M.alloc self in
    let* _other := M.alloc _other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_macros_typed_path_kw_rejection_t.
End Impl_core_cmp_PartialEq_for_axum_macros_typed_path_kw_rejection_t.

Module  Impl_core_hash_Hash_for_axum_macros_typed_path_kw_rejection_t.
Section Impl_core_hash_Hash_for_axum_macros_typed_path_kw_rejection_t.
  Definition Self : Set := axum_macros.typed_path.kw.rejection.t.
  
  (*
              fn hash<__H: $crate::__private::Hasher>(&self, _state: &mut __H) {}
  *)
  Definition hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H}
      (self : ref Self)
      (_state : mut_ref __H)
      : M unit :=
    let* self := M.alloc self in
    let* _state := M.alloc _state in
    M.read foo.
  
  Global Instance AssociatedFunction_hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
      hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_axum_macros_typed_path_kw_rejection_t.
End Impl_core_hash_Hash_for_axum_macros_typed_path_kw_rejection_t.

Module  Attrs.
Section Attrs.
  Record t : Set := {
    path : core.option.Option.t syn.lit.LitStr.t;
    rejection :
      core.option.Option.t
        (axum_macros.typed_path.kw.rejection.t * syn.path.Path.t);
  }.
  
  Definition Get_path :=
    Ref.map (fun α => Some α.(path)) (fun β α => Some (α <| path := β |>)).
  Definition Get_rejection :=
    Ref.map
      (fun α => Some α.(rejection))
      (fun β α => Some (α <| rejection := β |>)).
End Attrs.
End Attrs.

Module  Impl_core_default_Default_for_axum_macros_typed_path_Attrs_t.
Section Impl_core_default_Default_for_axum_macros_typed_path_Attrs_t.
  Definition Self : Set := axum_macros.typed_path.Attrs.t.
  
  (*
  Default
  *)
  Definition default : M axum_macros.typed_path.Attrs.t := M.read foo.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_axum_macros_typed_path_Attrs_t.
End Impl_core_default_Default_for_axum_macros_typed_path_Attrs_t.

Module  Impl_syn_parse_Parse_for_axum_macros_typed_path_Attrs_t.
Section Impl_syn_parse_Parse_for_axum_macros_typed_path_Attrs_t.
  Definition Self : Set := axum_macros.typed_path.Attrs.t.
  
  (*
      fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
          let mut path = None;
          let mut rejection = None;
  
          while !input.is_empty() {
              let lh = input.lookahead1();
              if lh.peek(LitStr) {
                  path = Some(input.parse()?);
              } else if lh.peek(kw::rejection) {
                  parse_parenthesized_attribute(input, &mut rejection)?;
              } else {
                  return Err(lh.error());
              }
  
              let _ = input.parse::<Token![,]>();
          }
  
          Ok(Self { path, rejection })
      }
  *)
  Definition parse
      (input : ltac:(syn.parse.ParseStream))
      : M ltac:(syn.error.Result Self) :=
    let* input := M.alloc input in
    M.read foo.
  
  Global Instance AssociatedFunction_parse :
    Notations.DoubleColon Self "parse" := {
    Notations.double_colon := parse;
  }.
  
  Global Instance ℐ : syn.parse.Parse.Trait Self := {
    syn.parse.Parse.parse := parse;
  }.
End Impl_syn_parse_Parse_for_axum_macros_typed_path_Attrs_t.
End Impl_syn_parse_Parse_for_axum_macros_typed_path_Attrs_t.

Module  Impl_axum_macros_attr_parsing_Combine_for_axum_macros_typed_path_Attrs_t.
Section Impl_axum_macros_attr_parsing_Combine_for_axum_macros_typed_path_Attrs_t.
  Definition Self : Set := axum_macros.typed_path.Attrs.t.
  
  (*
      fn combine(mut self, other: Self) -> syn::Result<Self> {
          let Self { path, rejection } = other;
          if let Some(path) = path {
              if self.path.is_some() {
                  return Err(syn::Error::new_spanned(
                      path,
                      "path specified more than once",
                  ));
              }
              self.path = Some(path);
          }
          combine_attribute(&mut self.rejection, rejection)?;
          Ok(self)
      }
  *)
  Definition combine
      (self : Self)
      (other : Self)
      : M ltac:(syn.error.Result Self) :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_combine :
    Notations.DoubleColon Self "combine" := {
    Notations.double_colon := combine;
  }.
  
  Global Instance ℐ : axum_macros.attr_parsing.Combine.Trait Self := {
    axum_macros.attr_parsing.Combine.combine := combine;
  }.
End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_typed_path_Attrs_t.
End Impl_axum_macros_attr_parsing_Combine_for_axum_macros_typed_path_Attrs_t.

(*
fn expand_named_fields(
    ident: &syn::Ident,
    path: LitStr,
    segments: &[Segment],
    rejection: Option<syn::Path>,
) -> TokenStream {
    let format_str = format_str_from_path(segments);
    let captures = captures_from_path(segments);

    let typed_path_impl = quote_spanned! {path.span()=>
        #[automatically_derived]
        impl ::axum_extra::routing::TypedPath for #ident {
            const PATH: &'static str = #path;
        }
    };

    let display_impl = quote_spanned! {path.span()=>
        #[automatically_derived]
        impl ::std::fmt::Display for #ident {
            #[allow(clippy::unnecessary_to_owned)]
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                let Self { #(#captures,)* } = self;
                write!(
                    f,
                    #format_str,
                    #(
                        #captures = ::axum_extra::__private::utf8_percent_encode(
                            &#captures.to_string(),
                            ::axum_extra::__private::PATH_SEGMENT,
                        )
                    ),*
                )
            }
        }
    };

    let rejection_assoc_type = rejection_assoc_type(&rejection);
    let map_err_rejection = map_err_rejection(&rejection);

    let from_request_impl = quote! {
        #[::axum::async_trait]
        #[automatically_derived]
        impl<S> ::axum::extract::FromRequestParts<S> for #ident
        where
            S: Send + Sync,
        {
            type Rejection = #rejection_assoc_type;

            async fn from_request_parts(
                parts: &mut ::axum::http::request::Parts,
                state: &S,
            ) -> ::std::result::Result<Self, Self::Rejection> {
                ::axum::extract::Path::from_request_parts(parts, state)
                    .await
                    .map(|path| path.0)
                    #map_err_rejection
            }
        }
    };

    quote! {
        #typed_path_impl
        #display_impl
        #from_request_impl
    }
}
*)
Definition expand_named_fields
    (ident : ref proc_macro2.Ident.t)
    (path : syn.lit.LitStr.t)
    (segments : ref (slice axum_macros.typed_path.Segment.t))
    (rejection : core.option.Option.t syn.path.Path.t)
    : M proc_macro2.TokenStream.t :=
  let* ident := M.alloc ident in
  let* path := M.alloc path in
  let* segments := M.alloc segments in
  let* rejection := M.alloc rejection in
  M.read foo.

(*
fn expand_unnamed_fields(
    fields: &syn::FieldsUnnamed,
    ident: &syn::Ident,
    path: LitStr,
    segments: &[Segment],
    rejection: Option<syn::Path>,
) -> syn::Result<TokenStream> {
    let num_captures = segments
        .iter()
        .filter(|segment| match segment {
            Segment::Capture(_, _) => true,
            Segment::Static(_) => false,
        })
        .count();
    let num_fields = fields.unnamed.len();
    if num_fields != num_captures {
        return Err(syn::Error::new_spanned(
            fields,
            format!(
                "Mismatch in number of captures and fields. Path has {} but struct has {}",
                simple_pluralize(num_captures, "capture"),
                simple_pluralize(num_fields, "field"),
            ),
        ));
    }

    let destructure_self = segments
        .iter()
        .filter_map(|segment| match segment {
            Segment::Capture(capture, _) => Some(capture),
            Segment::Static(_) => None,
        })
        .enumerate()
        .map(|(idx, capture)| {
            let idx = syn::Index {
                index: idx as _,
                span: Span::call_site(),
            };
            let capture = format_ident!("{}", capture, span = path.span());
            quote_spanned! {path.span()=>
                #idx: #capture,
            }
        });

    let format_str = format_str_from_path(segments);
    let captures = captures_from_path(segments);

    let typed_path_impl = quote_spanned! {path.span()=>
        #[automatically_derived]
        impl ::axum_extra::routing::TypedPath for #ident {
            const PATH: &'static str = #path;
        }
    };

    let display_impl = quote_spanned! {path.span()=>
        #[automatically_derived]
        impl ::std::fmt::Display for #ident {
            #[allow(clippy::unnecessary_to_owned)]
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                let Self { #(#destructure_self)* } = self;
                write!(
                    f,
                    #format_str,
                    #(
                        #captures = ::axum_extra::__private::utf8_percent_encode(
                            &#captures.to_string(),
                            ::axum_extra::__private::PATH_SEGMENT,
                        )
                    ),*
                )
            }
        }
    };

    let rejection_assoc_type = rejection_assoc_type(&rejection);
    let map_err_rejection = map_err_rejection(&rejection);

    let from_request_impl = quote! {
        #[::axum::async_trait]
        #[automatically_derived]
        impl<S> ::axum::extract::FromRequestParts<S> for #ident
        where
            S: Send + Sync,
        {
            type Rejection = #rejection_assoc_type;

            async fn from_request_parts(
                parts: &mut ::axum::http::request::Parts,
                state: &S,
            ) -> ::std::result::Result<Self, Self::Rejection> {
                ::axum::extract::Path::from_request_parts(parts, state)
                    .await
                    .map(|path| path.0)
                    #map_err_rejection
            }
        }
    };

    Ok(quote! {
        #typed_path_impl
        #display_impl
        #from_request_impl
    })
}
*)
Definition expand_unnamed_fields
    (fields : ref syn.data.FieldsUnnamed.t)
    (ident : ref proc_macro2.Ident.t)
    (path : syn.lit.LitStr.t)
    (segments : ref (slice axum_macros.typed_path.Segment.t))
    (rejection : core.option.Option.t syn.path.Path.t)
    : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
  let* fields := M.alloc fields in
  let* ident := M.alloc ident in
  let* path := M.alloc path in
  let* segments := M.alloc segments in
  let* rejection := M.alloc rejection in
  M.read foo.

(*
fn simple_pluralize(count: usize, word: &str) -> String {
    if count == 1 {
        format!("{count} {word}")
    } else {
        format!("{count} {word}s")
    }
}
*)
Definition simple_pluralize
    (count : usize.t)
    (word : ref str.t)
    : M alloc.string.String.t :=
  let* count := M.alloc count in
  let* word := M.alloc word in
  M.read foo.

(*
fn expand_unit_fields(
    ident: &syn::Ident,
    path: LitStr,
    rejection: Option<syn::Path>,
) -> syn::Result<TokenStream> {
    for segment in parse_path(&path)? {
        match segment {
            Segment::Capture(_, span) => {
                return Err(syn::Error::new(
                    span,
                    "Typed paths for unit structs cannot contain captures",
                ));
            }
            Segment::Static(_) => {}
        }
    }

    let typed_path_impl = quote_spanned! {path.span()=>
        #[automatically_derived]
        impl ::axum_extra::routing::TypedPath for #ident {
            const PATH: &'static str = #path;
        }
    };

    let display_impl = quote_spanned! {path.span()=>
        #[automatically_derived]
        impl ::std::fmt::Display for #ident {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, #path)
            }
        }
    };

    let rejection_assoc_type = if let Some(rejection) = &rejection {
        quote! { #rejection }
    } else {
        quote! { ::axum::http::StatusCode }
    };
    let create_rejection = if let Some(rejection) = &rejection {
        quote! {
            Err(<#rejection as ::std::default::Default>::default())
        }
    } else {
        quote! {
            Err(::axum::http::StatusCode::NOT_FOUND)
        }
    };

    let from_request_impl = quote! {
        #[::axum::async_trait]
        #[automatically_derived]
        impl<S> ::axum::extract::FromRequestParts<S> for #ident
        where
            S: Send + Sync,
        {
            type Rejection = #rejection_assoc_type;

            async fn from_request_parts(
                parts: &mut ::axum::http::request::Parts,
                _state: &S,
            ) -> ::std::result::Result<Self, Self::Rejection> {
                if parts.uri.path() == <Self as ::axum_extra::routing::TypedPath>::PATH {
                    Ok(Self)
                } else {
                    #create_rejection
                }
            }
        }
    };

    Ok(quote! {
        #typed_path_impl
        #display_impl
        #from_request_impl
    })
}
*)
Definition expand_unit_fields
    (ident : ref proc_macro2.Ident.t)
    (path : syn.lit.LitStr.t)
    (rejection : core.option.Option.t syn.path.Path.t)
    : M ltac:(syn.error.Result proc_macro2.TokenStream.t) :=
  let* ident := M.alloc ident in
  let* path := M.alloc path in
  let* rejection := M.alloc rejection in
  M.read foo.

(*
fn format_str_from_path(segments: &[Segment]) -> String {
    segments
        .iter()
        .map(|segment| match segment {
            Segment::Capture(capture, _) => format!("{{{capture}}}"),
            Segment::Static(segment) => segment.to_owned(),
        })
        .collect::<Vec<_>>()
        .join("/")
}
*)
Definition format_str_from_path
    (segments : ref (slice axum_macros.typed_path.Segment.t))
    : M alloc.string.String.t :=
  let* segments := M.alloc segments in
  M.read foo.

(*
fn captures_from_path(segments: &[Segment]) -> Vec<syn::Ident> {
    segments
        .iter()
        .filter_map(|segment| match segment {
            Segment::Capture(capture, span) => Some(format_ident!("{}", capture, span = *span)),
            Segment::Static(_) => None,
        })
        .collect::<Vec<_>>()
}
*)
Definition captures_from_path
    (segments : ref (slice axum_macros.typed_path.Segment.t))
    : M (alloc.vec.Vec.t proc_macro2.Ident.t alloc.vec.Vec.Default.A) :=
  let* segments := M.alloc segments in
  M.read foo.

(*
fn parse_path(path: &LitStr) -> syn::Result<Vec<Segment>> {
    let value = path.value();
    if value.is_empty() {
        return Err(syn::Error::new_spanned(
            path,
            "paths must start with a `/`. Use \"/\" for root routes",
        ));
    } else if !path.value().starts_with('/') {
        return Err(syn::Error::new_spanned(path, "paths must start with a `/`"));
    }

    path.value()
        .split('/')
        .map(|segment| {
            if let Some(capture) = segment
                .strip_prefix(':')
                .or_else(|| segment.strip_prefix('*'))
            {
                Ok(Segment::Capture(capture.to_owned(), path.span()))
            } else {
                Ok(Segment::Static(segment.to_owned()))
            }
        })
        .collect()
}
*)
Definition parse_path
    (path : ref syn.lit.LitStr.t)
    :
      M
        ltac:(syn.error.Result
          (alloc.vec.Vec.t
            axum_macros.typed_path.Segment.t
            alloc.vec.Vec.Default.A)) :=
  let* path := M.alloc path in
  M.read foo.

Module Segment.
  Inductive t : Set :=
  | Capture (_ : alloc.string.String.t) (_ : proc_macro2.Span.t)
  | Static (_ : alloc.string.String.t).
  
  Definition Get_Capture_0 :=
    Ref.map
      (fun α => match α with | Capture α0 _ => Some α0 | _ => None end)
      (fun β α =>
        match α with | Capture _ α1 => Some (Capture β α1) | _ => None end).
  
  Definition Get_Capture_1 :=
    Ref.map
      (fun α => match α with | Capture _ α1 => Some α1 | _ => None end)
      (fun β α =>
        match α with | Capture α0 _ => Some (Capture α0 β) | _ => None end).
  
  Definition Get_Static_0 :=
    Ref.map
      (fun α => match α with | Static α0 => Some α0 | _ => None end)
      (fun β α => match α with | Static _ => Some (Static β) | _ => None end).
End Segment.

(*
fn path_rejection() -> TokenStream {
    quote! {
        <::axum::extract::Path<Self> as ::axum::extract::FromRequestParts<S>>::Rejection
    }
}
*)
Definition path_rejection : M proc_macro2.TokenStream.t := M.read foo.

(*
fn rejection_assoc_type(rejection: &Option<syn::Path>) -> TokenStream {
    match rejection {
        Some(rejection) => quote! { #rejection },
        None => path_rejection(),
    }
}
*)
Definition rejection_assoc_type
    (rejection : ref (core.option.Option.t syn.path.Path.t))
    : M proc_macro2.TokenStream.t :=
  let* rejection := M.alloc rejection in
  M.read foo.

(*
fn map_err_rejection(rejection: &Option<syn::Path>) -> TokenStream {
    rejection
        .as_ref()
        .map(|rejection| {
            let path_rejection = path_rejection();
            quote! {
                .map_err(|rejection| {
                    <#rejection as ::std::convert::From<#path_rejection>>::from(rejection)
                })
            }
        })
        .unwrap_or_default()
}
*)
Definition map_err_rejection
    (rejection : ref (core.option.Option.t syn.path.Path.t))
    : M proc_macro2.TokenStream.t :=
  let* rejection := M.alloc rejection in
  M.read foo.

Module with_position.
  Module  WithPosition.
  Section WithPosition.
    Context (I : Set).
    
    Context {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}.
    Record t : Set := {
      handled_first : bool.t;
      peekable :
        core.iter.adapters.peekable.Peekable.t
          (core.iter.adapters.fuse.Fuse.t I);
    }.
    
    Definition Get_handled_first :=
      Ref.map
        (fun α => Some α.(handled_first))
        (fun β α => Some (α <| handled_first := β |>)).
    Definition Get_peekable :=
      Ref.map
        (fun α => Some α.(peekable))
        (fun β α => Some (α <| peekable := β |>)).
  End WithPosition.
  End WithPosition.
  
  Module  Impl_axum_macros_with_position_WithPosition_t_I.
  Section Impl_axum_macros_with_position_WithPosition_t_I.
    Context {I : Set}.
    
    Definition Self : Set := axum_macros.with_position.WithPosition.t I.
    
    (*
        pub(crate) fn new(iter: impl IntoIterator<IntoIter = I>) -> WithPosition<I> {
            WithPosition {
                handled_first: false,
                peekable: iter.into_iter().fuse().peekable(),
            }
        }
    *)
    Definition new
        {impl IntoIterator<IntoIter = I> : Set}
        {ℋ_0 :
          core.iter.traits.collect.IntoIterator.Trait
              impl IntoIterator<IntoIter = I>}
        (iter : impl IntoIterator<IntoIter = I>)
        : M (axum_macros.with_position.WithPosition.t I) :=
      let* iter := M.alloc iter in
      M.read foo.
    
    Global Instance AssociatedFunction_new
        {impl IntoIterator<IntoIter = I> : Set}
        {ℋ_0 :
          core.iter.traits.collect.IntoIterator.Trait
              impl IntoIterator<IntoIter = I>} :
      Notations.DoubleColon Self "new" := {
      Notations.double_colon :=
        new
          (impl IntoIterator<IntoIter = I> := impl IntoIterator<IntoIter = I>);
    }.
  End Impl_axum_macros_with_position_WithPosition_t_I.
  End Impl_axum_macros_with_position_WithPosition_t_I.
  
  Module  Impl_core_clone_Clone_for_axum_macros_with_position_WithPosition_t_I.
  Section Impl_core_clone_Clone_for_axum_macros_with_position_WithPosition_t_I.
    Context {I : Set}.
    
    Context
      {ℋ_0 : core.clone.Clone.Trait I}
      {ℋ_1 : core.iter.traits.iterator.Iterator.Trait I}
      {ℋ_2 : core.clone.Clone.Trait I::type["Item"].t}.
    
    Definition Self : Set := axum_macros.with_position.WithPosition.t I.
    
    (*
        fn clone(&self) -> Self {
            Self {
                handled_first: self.handled_first,
                peekable: self.peekable.clone(),
            }
        }
    *)
    Definition clone (self : ref Self) : M Self :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_macros_with_position_WithPosition_t_I.
  End Impl_core_clone_Clone_for_axum_macros_with_position_WithPosition_t_I.
  
  Module Position.
    Inductive t (T : Set) : Set :=
    | First (_ : T)
    | Middle (_ : T)
    | Last (_ : T)
    | Only (_ : T).
    
    Definition Get_First_0 :=
      Ref.map
        (fun α => match α with | First α0 => Some α0 | _ => None end)
        (fun β α => match α with | First _ => Some (First β) | _ => None end).
    
    Definition Get_Middle_0 :=
      Ref.map
        (fun α => match α with | Middle α0 => Some α0 | _ => None end)
        (fun β α => match α with | Middle _ => Some (Middle β) | _ => None end).
    
    Definition Get_Last_0 :=
      Ref.map
        (fun α => match α with | Last α0 => Some α0 | _ => None end)
        (fun β α => match α with | Last _ => Some (Last β) | _ => None end).
    
    Definition Get_Only_0 :=
      Ref.map
        (fun α => match α with | Only α0 => Some α0 | _ => None end)
        (fun β α => match α with | Only _ => Some (Only β) | _ => None end).
  End Position.
  
  Module  Impl_core_marker_Copy_for_axum_macros_with_position_Position_t_T.
  Section Impl_core_marker_Copy_for_axum_macros_with_position_Position_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    
    Definition Self : Set := axum_macros.with_position.Position.t T.
    
    Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_axum_macros_with_position_Position_t_T.
  End Impl_core_marker_Copy_for_axum_macros_with_position_Position_t_T.
  
  Module  Impl_core_clone_Clone_for_axum_macros_with_position_Position_t_T.
  Section Impl_core_clone_Clone_for_axum_macros_with_position_Position_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    
    Definition Self : Set := axum_macros.with_position.Position.t T.
    
    (*
    Clone
    *)
    Definition clone
        (self : ref Self)
        : M (axum_macros.with_position.Position.t T) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_clone :
      Notations.DoubleColon Self "clone" := {
      Notations.double_colon := clone;
    }.
    
    Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
      core.clone.Clone.clone := clone;
      core.clone.Clone.clone_from := Datatypes.None;
    }.
  End Impl_core_clone_Clone_for_axum_macros_with_position_Position_t_T.
  End Impl_core_clone_Clone_for_axum_macros_with_position_Position_t_T.
  
  Module  Impl_core_fmt_Debug_for_axum_macros_with_position_Position_t_T.
  Section Impl_core_fmt_Debug_for_axum_macros_with_position_Position_t_T.
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    
    Definition Self : Set := axum_macros.with_position.Position.t T.
    
    (*
    Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      M.read foo.
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_axum_macros_with_position_Position_t_T.
  End Impl_core_fmt_Debug_for_axum_macros_with_position_Position_t_T.
  
  Module  Impl_core_marker_StructuralPartialEq_for_axum_macros_with_position_Position_t_T.
  Section Impl_core_marker_StructuralPartialEq_for_axum_macros_with_position_Position_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum_macros.with_position.Position.t T.
    
    Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
    }.
  End Impl_core_marker_StructuralPartialEq_for_axum_macros_with_position_Position_t_T.
  End Impl_core_marker_StructuralPartialEq_for_axum_macros_with_position_Position_t_T.
  
  Module  Impl_core_cmp_PartialEq_for_axum_macros_with_position_Position_t_T.
  Section Impl_core_cmp_PartialEq_for_axum_macros_with_position_Position_t_T.
    Context {T : Set}.
    
    Context
      {ℋ_0 :
        core.cmp.PartialEq.Trait T (Rhs := core.cmp.PartialEq.Default.Rhs T)}.
    
    Definition Self : Set := axum_macros.with_position.Position.t T.
    
    (*
    PartialEq
    *)
    Definition eq
        (self : ref Self)
        (other : ref (axum_macros.with_position.Position.t T))
        : M bool.t :=
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.read foo.
    
    Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
      Notations.double_colon := eq;
    }.
    
    Global Instance ℐ :
      core.cmp.PartialEq.Required.Trait Self
        (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
      core.cmp.PartialEq.eq := eq;
      core.cmp.PartialEq.ne := Datatypes.None;
    }.
  End Impl_core_cmp_PartialEq_for_axum_macros_with_position_Position_t_T.
  End Impl_core_cmp_PartialEq_for_axum_macros_with_position_Position_t_T.
  
  Module  Impl_axum_macros_with_position_Position_t_T.
  Section Impl_axum_macros_with_position_Position_t_T.
    Context {T : Set}.
    
    Definition Self : Set := axum_macros.with_position.Position.t T.
    
    (*
        pub(crate) fn into_inner(self) -> T {
            match self {
                Position::First(x) | Position::Middle(x) | Position::Last(x) | Position::Only(x) => x,
            }
        }
    *)
    Definition into_inner (self : Self) : M T :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_into_inner :
      Notations.DoubleColon Self "into_inner" := {
      Notations.double_colon := into_inner;
    }.
  End Impl_axum_macros_with_position_Position_t_T.
  End Impl_axum_macros_with_position_Position_t_T.
  
  Module  Impl_core_iter_traits_iterator_Iterator_for_axum_macros_with_position_WithPosition_t_I.
  Section Impl_core_iter_traits_iterator_Iterator_for_axum_macros_with_position_WithPosition_t_I.
    Context {I : Set}.
    
    Context {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}.
    
    Definition Self : Set := axum_macros.with_position.WithPosition.t I.
    
    (*
        type Item = Position<I::Item>;
    *)
    Definition Item : Set :=
      axum_macros.with_position.Position.t I::type["Item"].t.
    
    (*
        fn next(&mut self) -> Option<Self::Item> {
            match self.peekable.next() {
                Some(item) => {
                    if !self.handled_first {
                        // Haven't seen the first item yet, and there is one to give.
                        self.handled_first = true;
                        // Peek to see if this is also the last item,
                        // in which case tag it as `Only`.
                        match self.peekable.peek() {
                            Some(_) => Some(Position::First(item)),
                            None => Some(Position::Only(item)),
                        }
                    } else {
                        // Have seen the first item, and there's something left.
                        // Peek to see if this is the last item.
                        match self.peekable.peek() {
                            Some(_) => Some(Position::Middle(item)),
                            None => Some(Position::Last(item)),
                        }
                    }
                }
                // Iterator is finished.
                None => None,
            }
        }
    *)
    Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_next :
      Notations.DoubleColon Self "next" := {
      Notations.double_colon := next;
    }.
    
    (*
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.peekable.size_hint()
        }
    *)
    Definition size_hint
        (self : ref Self)
        : M (usize.t * (core.option.Option.t usize.t)) :=
      let* self := M.alloc self in
      M.read foo.
    
    Global Instance AssociatedFunction_size_hint :
      Notations.DoubleColon Self "size_hint" := {
      Notations.double_colon := size_hint;
    }.
    
    Global Instance ℐ :
      core.iter.traits.iterator.Iterator.Required.Trait Self := {
      core.iter.traits.iterator.Iterator.Item := Item;
      core.iter.traits.iterator.Iterator.next := next;
      core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
      core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
      core.iter.traits.iterator.Iterator.count := Datatypes.None;
      core.iter.traits.iterator.Iterator.last := Datatypes.None;
      core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.nth := Datatypes.None;
      core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.chain := Datatypes.None;
      core.iter.traits.iterator.Iterator.zip := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
      core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
      core.iter.traits.iterator.Iterator.map := Datatypes.None;
      core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter := Datatypes.None;
      core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
      core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
      core.iter.traits.iterator.Iterator.skip := Datatypes.None;
      core.iter.traits.iterator.Iterator.take := Datatypes.None;
      core.iter.traits.iterator.Iterator.scan := Datatypes.None;
      core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
      core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
      core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
      core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
      core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
      core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition := Datatypes.None;
      core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
      core.iter.traits.iterator.Iterator.fold := Datatypes.None;
      core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
      core.iter.traits.iterator.Iterator.all := Datatypes.None;
      core.iter.traits.iterator.Iterator.any := Datatypes.None;
      core.iter.traits.iterator.Iterator.find := Datatypes.None;
      core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
      core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
      core.iter.traits.iterator.Iterator.position := Datatypes.None;
      core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
      core.iter.traits.iterator.Iterator.max := Datatypes.None;
      core.iter.traits.iterator.Iterator.min := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.rev := Datatypes.None;
      core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
      core.iter.traits.iterator.Iterator.copied := Datatypes.None;
      core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
      core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
      core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
      core.iter.traits.iterator.Iterator.sum := Datatypes.None;
      core.iter.traits.iterator.Iterator.product := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
      core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq := Datatypes.None;
      core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.ne := Datatypes.None;
      core.iter.traits.iterator.Iterator.lt := Datatypes.None;
      core.iter.traits.iterator.Iterator.le := Datatypes.None;
      core.iter.traits.iterator.Iterator.gt := Datatypes.None;
      core.iter.traits.iterator.Iterator.ge := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
      core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
      core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
        Datatypes.None;
    }.
  End Impl_core_iter_traits_iterator_Iterator_for_axum_macros_with_position_WithPosition_t_I.
  End Impl_core_iter_traits_iterator_Iterator_for_axum_macros_with_position_WithPosition_t_I.
  
  Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_axum_macros_with_position_WithPosition_t_I.
  Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_axum_macros_with_position_WithPosition_t_I.
    Context {I : Set}.
    
    Context {ℋ_0 : core.iter.traits.exact_size.ExactSizeIterator.Trait I}.
    
    Definition Self : Set := axum_macros.with_position.WithPosition.t I.
    
    Global Instance ℐ :
      core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
      core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.None;
      core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
    }.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_axum_macros_with_position_WithPosition_t_I.
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_axum_macros_with_position_WithPosition_t_I.
  
  Module  Impl_core_iter_traits_marker_FusedIterator_for_axum_macros_with_position_WithPosition_t_I.
  Section Impl_core_iter_traits_marker_FusedIterator_for_axum_macros_with_position_WithPosition_t_I.
    Context {I : Set}.
    
    Context {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}.
    
    Definition Self : Set := axum_macros.with_position.WithPosition.t I.
    
    Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
    }.
  End Impl_core_iter_traits_marker_FusedIterator_for_axum_macros_with_position_WithPosition_t_I.
  End Impl_core_iter_traits_marker_FusedIterator_for_axum_macros_with_position_WithPosition_t_I.
End with_position.

Module  WithPosition.
Section WithPosition.
  Context (I : Set).
  
  Context {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}.
  Record t : Set := {
    handled_first : bool.t;
    peekable :
      core.iter.adapters.peekable.Peekable.t (core.iter.adapters.fuse.Fuse.t I);
  }.
  
  Definition Get_handled_first :=
    Ref.map
      (fun α => Some α.(handled_first))
      (fun β α => Some (α <| handled_first := β |>)).
  Definition Get_peekable :=
    Ref.map
      (fun α => Some α.(peekable))
      (fun β α => Some (α <| peekable := β |>)).
End WithPosition.
End WithPosition.

Module  Impl_axum_macros_with_position_WithPosition_t_I_2.
Section Impl_axum_macros_with_position_WithPosition_t_I_2.
  Context {I : Set}.
  
  Definition Self : Set := axum_macros.with_position.WithPosition.t I.
  
  (*
      pub(crate) fn new(iter: impl IntoIterator<IntoIter = I>) -> WithPosition<I> {
          WithPosition {
              handled_first: false,
              peekable: iter.into_iter().fuse().peekable(),
          }
      }
  *)
  Definition new
      {impl IntoIterator<IntoIter = I> : Set}
      {ℋ_0 :
        core.iter.traits.collect.IntoIterator.Trait
            impl IntoIterator<IntoIter = I>}
      (iter : impl IntoIterator<IntoIter = I>)
      : M (axum_macros.with_position.WithPosition.t I) :=
    let* iter := M.alloc iter in
    M.read foo.
  
  Global Instance AssociatedFunction_new
      {impl IntoIterator<IntoIter = I> : Set}
      {ℋ_0 :
        core.iter.traits.collect.IntoIterator.Trait
            impl IntoIterator<IntoIter = I>} :
    Notations.DoubleColon Self "new" := {
    Notations.double_colon :=
      new (impl IntoIterator<IntoIter = I> := impl IntoIterator<IntoIter = I>);
  }.
End Impl_axum_macros_with_position_WithPosition_t_I_2.
End Impl_axum_macros_with_position_WithPosition_t_I_2.

Module  Impl_core_clone_Clone_for_axum_macros_with_position_WithPosition_t_I.
Section Impl_core_clone_Clone_for_axum_macros_with_position_WithPosition_t_I.
  Context {I : Set}.
  
  Context
    {ℋ_0 : core.clone.Clone.Trait I}
    {ℋ_1 : core.iter.traits.iterator.Iterator.Trait I}
    {ℋ_2 : core.clone.Clone.Trait I::type["Item"].t}.
  
  Definition Self : Set := axum_macros.with_position.WithPosition.t I.
  
  (*
      fn clone(&self) -> Self {
          Self {
              handled_first: self.handled_first,
              peekable: self.peekable.clone(),
          }
      }
  *)
  Definition clone (self : ref Self) : M Self :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_macros_with_position_WithPosition_t_I.
End Impl_core_clone_Clone_for_axum_macros_with_position_WithPosition_t_I.

Module Position.
  Inductive t (T : Set) : Set :=
  | First (_ : T)
  | Middle (_ : T)
  | Last (_ : T)
  | Only (_ : T).
  
  Definition Get_First_0 :=
    Ref.map
      (fun α => match α with | First α0 => Some α0 | _ => None end)
      (fun β α => match α with | First _ => Some (First β) | _ => None end).
  
  Definition Get_Middle_0 :=
    Ref.map
      (fun α => match α with | Middle α0 => Some α0 | _ => None end)
      (fun β α => match α with | Middle _ => Some (Middle β) | _ => None end).
  
  Definition Get_Last_0 :=
    Ref.map
      (fun α => match α with | Last α0 => Some α0 | _ => None end)
      (fun β α => match α with | Last _ => Some (Last β) | _ => None end).
  
  Definition Get_Only_0 :=
    Ref.map
      (fun α => match α with | Only α0 => Some α0 | _ => None end)
      (fun β α => match α with | Only _ => Some (Only β) | _ => None end).
End Position.

Module  Impl_core_marker_Copy_for_axum_macros_with_position_Position_t_T.
Section Impl_core_marker_Copy_for_axum_macros_with_position_Position_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := axum_macros.with_position.Position.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_axum_macros_with_position_Position_t_T.
End Impl_core_marker_Copy_for_axum_macros_with_position_Position_t_T.

Module  Impl_core_clone_Clone_for_axum_macros_with_position_Position_t_T.
Section Impl_core_clone_Clone_for_axum_macros_with_position_Position_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := axum_macros.with_position.Position.t T.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M (axum_macros.with_position.Position.t T) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_axum_macros_with_position_Position_t_T.
End Impl_core_clone_Clone_for_axum_macros_with_position_Position_t_T.

Module  Impl_core_fmt_Debug_for_axum_macros_with_position_Position_t_T.
Section Impl_core_fmt_Debug_for_axum_macros_with_position_Position_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := axum_macros.with_position.Position.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    M.read foo.
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_axum_macros_with_position_Position_t_T.
End Impl_core_fmt_Debug_for_axum_macros_with_position_Position_t_T.

Module  Impl_core_marker_StructuralPartialEq_for_axum_macros_with_position_Position_t_T.
Section Impl_core_marker_StructuralPartialEq_for_axum_macros_with_position_Position_t_T.
  Context {T : Set}.
  
  Definition Self : Set := axum_macros.with_position.Position.t T.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_axum_macros_with_position_Position_t_T.
End Impl_core_marker_StructuralPartialEq_for_axum_macros_with_position_Position_t_T.

Module  Impl_core_cmp_PartialEq_for_axum_macros_with_position_Position_t_T.
Section Impl_core_cmp_PartialEq_for_axum_macros_with_position_Position_t_T.
  Context {T : Set}.
  
  Context
    {ℋ_0 :
      core.cmp.PartialEq.Trait T (Rhs := core.cmp.PartialEq.Default.Rhs T)}.
  
  Definition Self : Set := axum_macros.with_position.Position.t T.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref (axum_macros.with_position.Position.t T))
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.read foo.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_axum_macros_with_position_Position_t_T.
End Impl_core_cmp_PartialEq_for_axum_macros_with_position_Position_t_T.

Module  Impl_axum_macros_with_position_Position_t_T_2.
Section Impl_axum_macros_with_position_Position_t_T_2.
  Context {T : Set}.
  
  Definition Self : Set := axum_macros.with_position.Position.t T.
  
  (*
      pub(crate) fn into_inner(self) -> T {
          match self {
              Position::First(x) | Position::Middle(x) | Position::Last(x) | Position::Only(x) => x,
          }
      }
  *)
  Definition into_inner (self : Self) : M T :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_into_inner :
    Notations.DoubleColon Self "into_inner" := {
    Notations.double_colon := into_inner;
  }.
End Impl_axum_macros_with_position_Position_t_T_2.
End Impl_axum_macros_with_position_Position_t_T_2.

Module  Impl_core_iter_traits_iterator_Iterator_for_axum_macros_with_position_WithPosition_t_I.
Section Impl_core_iter_traits_iterator_Iterator_for_axum_macros_with_position_WithPosition_t_I.
  Context {I : Set}.
  
  Context {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}.
  
  Definition Self : Set := axum_macros.with_position.WithPosition.t I.
  
  (*
      type Item = Position<I::Item>;
  *)
  Definition Item : Set :=
    axum_macros.with_position.Position.t I::type["Item"].t.
  
  (*
      fn next(&mut self) -> Option<Self::Item> {
          match self.peekable.next() {
              Some(item) => {
                  if !self.handled_first {
                      // Haven't seen the first item yet, and there is one to give.
                      self.handled_first = true;
                      // Peek to see if this is also the last item,
                      // in which case tag it as `Only`.
                      match self.peekable.peek() {
                          Some(_) => Some(Position::First(item)),
                          None => Some(Position::Only(item)),
                      }
                  } else {
                      // Have seen the first item, and there's something left.
                      // Peek to see if this is the last item.
                      match self.peekable.peek() {
                          Some(_) => Some(Position::Middle(item)),
                          None => Some(Position::Last(item)),
                      }
                  }
              }
              // Iterator is finished.
              None => None,
          }
      }
  *)
  Definition next (self : mut_ref Self) : M (core.option.Option.t Item) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_next :
    Notations.DoubleColon Self "next" := {
    Notations.double_colon := next;
  }.
  
  (*
      fn size_hint(&self) -> (usize, Option<usize>) {
          self.peekable.size_hint()
      }
  *)
  Definition size_hint
      (self : ref Self)
      : M (usize.t * (core.option.Option.t usize.t)) :=
    let* self := M.alloc self in
    M.read foo.
  
  Global Instance AssociatedFunction_size_hint :
    Notations.DoubleColon Self "size_hint" := {
    Notations.double_colon := size_hint;
  }.
  
  Global Instance ℐ :
    core.iter.traits.iterator.Iterator.Required.Trait Self := {
    core.iter.traits.iterator.Iterator.Item := Item;
    core.iter.traits.iterator.Iterator.next := next;
    core.iter.traits.iterator.Iterator.size_hint := Datatypes.Some size_hint;
    core.iter.traits.iterator.Iterator.next_chunk := Datatypes.None;
    core.iter.traits.iterator.Iterator.count := Datatypes.None;
    core.iter.traits.iterator.Iterator.last := Datatypes.None;
    core.iter.traits.iterator.Iterator.advance_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.nth := Datatypes.None;
    core.iter.traits.iterator.Iterator.step_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.chain := Datatypes.None;
    core.iter.traits.iterator.Iterator.zip := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse := Datatypes.None;
    core.iter.traits.iterator.Iterator.intersperse_with := Datatypes.None;
    core.iter.traits.iterator.Iterator.map := Datatypes.None;
    core.iter.traits.iterator.Iterator.for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter := Datatypes.None;
    core.iter.traits.iterator.Iterator.filter_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.enumerate := Datatypes.None;
    core.iter.traits.iterator.Iterator.peekable := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.take_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_while := Datatypes.None;
    core.iter.traits.iterator.Iterator.skip := Datatypes.None;
    core.iter.traits.iterator.Iterator.take := Datatypes.None;
    core.iter.traits.iterator.Iterator.scan := Datatypes.None;
    core.iter.traits.iterator.Iterator.flat_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.flatten := Datatypes.None;
    core.iter.traits.iterator.Iterator.map_windows := Datatypes.None;
    core.iter.traits.iterator.Iterator.fuse := Datatypes.None;
    core.iter.traits.iterator.Iterator.inspect := Datatypes.None;
    core.iter.traits.iterator.Iterator.by_ref := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_collect := Datatypes.None;
    core.iter.traits.iterator.Iterator.collect_into := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition := Datatypes.None;
    core.iter.traits.iterator.Iterator.partition_in_place := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_partitioned := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_for_each := Datatypes.None;
    core.iter.traits.iterator.Iterator.fold := Datatypes.None;
    core.iter.traits.iterator.Iterator.reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_reduce := Datatypes.None;
    core.iter.traits.iterator.Iterator.all := Datatypes.None;
    core.iter.traits.iterator.Iterator.any := Datatypes.None;
    core.iter.traits.iterator.Iterator.find := Datatypes.None;
    core.iter.traits.iterator.Iterator.find_map := Datatypes.None;
    core.iter.traits.iterator.Iterator.try_find := Datatypes.None;
    core.iter.traits.iterator.Iterator.position := Datatypes.None;
    core.iter.traits.iterator.Iterator.rposition := Datatypes.None;
    core.iter.traits.iterator.Iterator.max := Datatypes.None;
    core.iter.traits.iterator.Iterator.min := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.max_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.min_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.rev := Datatypes.None;
    core.iter.traits.iterator.Iterator.unzip := Datatypes.None;
    core.iter.traits.iterator.Iterator.copied := Datatypes.None;
    core.iter.traits.iterator.Iterator.cloned := Datatypes.None;
    core.iter.traits.iterator.Iterator.cycle := Datatypes.None;
    core.iter.traits.iterator.Iterator.array_chunks := Datatypes.None;
    core.iter.traits.iterator.Iterator.sum := Datatypes.None;
    core.iter.traits.iterator.Iterator.product := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp := Datatypes.None;
    core.iter.traits.iterator.Iterator.partial_cmp_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq := Datatypes.None;
    core.iter.traits.iterator.Iterator.eq_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.ne := Datatypes.None;
    core.iter.traits.iterator.Iterator.lt := Datatypes.None;
    core.iter.traits.iterator.Iterator.le := Datatypes.None;
    core.iter.traits.iterator.Iterator.gt := Datatypes.None;
    core.iter.traits.iterator.Iterator.ge := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by := Datatypes.None;
    core.iter.traits.iterator.Iterator.is_sorted_by_key := Datatypes.None;
    core.iter.traits.iterator.Iterator.__iterator_get_unchecked :=
      Datatypes.None;
  }.
End Impl_core_iter_traits_iterator_Iterator_for_axum_macros_with_position_WithPosition_t_I.
End Impl_core_iter_traits_iterator_Iterator_for_axum_macros_with_position_WithPosition_t_I.

Module  Impl_core_iter_traits_exact_size_ExactSizeIterator_for_axum_macros_with_position_WithPosition_t_I.
Section Impl_core_iter_traits_exact_size_ExactSizeIterator_for_axum_macros_with_position_WithPosition_t_I.
  Context {I : Set}.
  
  Context {ℋ_0 : core.iter.traits.exact_size.ExactSizeIterator.Trait I}.
  
  Definition Self : Set := axum_macros.with_position.WithPosition.t I.
  
  Global Instance ℐ :
    core.iter.traits.exact_size.ExactSizeIterator.Required.Trait Self := {
    core.iter.traits.exact_size.ExactSizeIterator.len := Datatypes.None;
    core.iter.traits.exact_size.ExactSizeIterator.is_empty := Datatypes.None;
  }.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_axum_macros_with_position_WithPosition_t_I.
End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_axum_macros_with_position_WithPosition_t_I.

Module  Impl_core_iter_traits_marker_FusedIterator_for_axum_macros_with_position_WithPosition_t_I.
Section Impl_core_iter_traits_marker_FusedIterator_for_axum_macros_with_position_WithPosition_t_I.
  Context {I : Set}.
  
  Context {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}.
  
  Definition Self : Set := axum_macros.with_position.WithPosition.t I.
  
  Global Instance ℐ : core.iter.traits.marker.FusedIterator.Trait Self := {
  }.
End Impl_core_iter_traits_marker_FusedIterator_for_axum_macros_with_position_WithPosition_t_I.
End Impl_core_iter_traits_marker_FusedIterator_for_axum_macros_with_position_WithPosition_t_I.

(*
pub fn derive_from_request(item: TokenStream) -> TokenStream {
    expand_with(item, |item| from_request::expand(item, FromRequest))
}
*)
Definition derive_from_request
    (item : proc_macro.TokenStream.t)
    : M proc_macro.TokenStream.t :=
  let* item := M.alloc item in
  M.read foo.

(*
pub fn derive_from_request_parts(item: TokenStream) -> TokenStream {
    expand_with(item, |item| from_request::expand(item, FromRequestParts))
}
*)
Definition derive_from_request_parts
    (item : proc_macro.TokenStream.t)
    : M proc_macro.TokenStream.t :=
  let* item := M.alloc item in
  M.read foo.

(*
pub fn debug_handler(_attr: TokenStream, input: TokenStream) -> TokenStream {
    #[cfg(not(debug_assertions))]
    return input;

    #[cfg(debug_assertions)]
    return expand_attr_with(_attr, input, debug_handler::expand);
}
*)
Definition debug_handler
    (_attr : proc_macro.TokenStream.t)
    (input : proc_macro.TokenStream.t)
    : M proc_macro.TokenStream.t :=
  let* _attr := M.alloc _attr in
  let* input := M.alloc input in
  M.read foo.

(*
pub fn derive_typed_path(input: TokenStream) -> TokenStream {
    expand_with(input, typed_path::expand)
}
*)
Definition derive_typed_path
    (input : proc_macro.TokenStream.t)
    : M proc_macro.TokenStream.t :=
  let* input := M.alloc input in
  M.read foo.

(*
pub fn derive_from_ref(item: TokenStream) -> TokenStream {
    expand_with(item, from_ref::expand)
}
*)
Definition derive_from_ref
    (item : proc_macro.TokenStream.t)
    : M proc_macro.TokenStream.t :=
  let* item := M.alloc item in
  M.read foo.

(*
fn expand_with<F, I, K>(input: TokenStream, f: F) -> TokenStream
where
    F: FnOnce(I) -> syn::Result<K>,
    I: Parse,
    K: ToTokens,
{
    expand(syn::parse(input).and_then(f))
}
*)
Definition expand_with
    {F I K : Set}
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := I)}
    {ℋ_1 : syn.parse.Parse.Trait I}
    {ℋ_2 : quote.to_tokens.ToTokens.Trait K}
    (input : proc_macro.TokenStream.t)
    (f : F)
    : M proc_macro.TokenStream.t :=
  let* input := M.alloc input in
  let* f := M.alloc f in
  M.read foo.

(*
fn expand_attr_with<F, A, I, K>(attr: TokenStream, input: TokenStream, f: F) -> TokenStream
where
    F: FnOnce(A, I) -> K,
    A: Parse,
    I: Parse,
    K: ToTokens,
{
    let expand_result = (|| {
        let attr = syn::parse(attr)?;
        let input = syn::parse(input)?;
        Ok(f(attr, input))
    })();
    expand(expand_result)
}
*)
Definition expand_attr_with
    {F A I K : Set}
    {ℋ_0 : core.ops.function.FnOnce.Trait F (Args := A * I)}
    {ℋ_1 : syn.parse.Parse.Trait A}
    {ℋ_2 : syn.parse.Parse.Trait I}
    {ℋ_3 : quote.to_tokens.ToTokens.Trait K}
    (attr : proc_macro.TokenStream.t)
    (input : proc_macro.TokenStream.t)
    (f : F)
    : M proc_macro.TokenStream.t :=
  let* attr := M.alloc attr in
  let* input := M.alloc input in
  let* f := M.alloc f in
  M.read foo.

(*
fn expand<T>(result: syn::Result<T>) -> TokenStream
where
    T: ToTokens,
{
    match result {
        Ok(tokens) => {
            let tokens = (quote! { #tokens }).into();
            if std::env::var_os("AXUM_MACROS_DEBUG").is_some() {
                eprintln!("{tokens}");
            }
            tokens
        }
        Err(err) => err.into_compile_error().into(),
    }
}
*)
Definition expand
    {T : Set}
    {ℋ_0 : quote.to_tokens.ToTokens.Trait T}
    (result : ltac:(syn.error.Result T))
    : M proc_macro.TokenStream.t :=
  let* result := M.alloc result in
  M.read foo.

(*
fn infer_state_types<'a, I>(types: I) -> impl Iterator<Item = Type> + 'a
where
    I: Iterator<Item = &'a Type> + 'a,
{
    types
        .filter_map(|ty| {
            if let Type::Path(path) = ty {
                Some(&path.path)
            } else {
                None
            }
        })
        .filter_map(|path| {
            if let Some(last_segment) = path.segments.last() {
                if last_segment.ident != "State" {
                    return None;
                }

                match &last_segment.arguments {
                    syn::PathArguments::AngleBracketed(args) if args.args.len() == 1 => {
                        Some(args.args.first().unwrap())
                    }
                    _ => None,
                }
            } else {
                None
            }
        })
        .filter_map(|generic_arg| {
            if let syn::GenericArgument::Type(ty) = generic_arg {
                Some(ty)
            } else {
                None
            }
        })
        .cloned()
}
*)
Definition infer_state_types
    {I : Set}
    {ℋ_0 : core.iter.traits.iterator.Iterator.Trait I}
    (types : I)
    : M OpaqueDef :=
  let* types := M.alloc types in
  M.read foo.

Definition _DECLS
    : M.Val (ref (ref (slice proc_macro.bridge.client.ProcMacro.t))) :=
  M.run (M.alloc foo).
